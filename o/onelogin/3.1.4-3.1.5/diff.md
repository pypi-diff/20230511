# Comparing `tmp/onelogin-3.1.4.tar.gz` & `tmp/onelogin-3.1.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "onelogin-3.1.4.tar", last modified: Tue Apr 25 18:47:19 2023, max compression
+gzip compressed data, was "onelogin-3.1.5.tar", last modified: Thu May 11 21:26:38 2023, max compression
```

## Comparing `onelogin-3.1.4.tar` & `onelogin-3.1.5.tar`

### file list

```diff
@@ -1,385 +1,388 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.926764 onelogin-3.1.4/
--rw-r--r--   0 runner    (1001) docker     (123)      287 2023-04-25 18:47:19.926764 onelogin-3.1.4/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    37574 2023-04-25 18:47:03.000000 onelogin-3.1.4/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.878764 onelogin-3.1.4/onelogin/
--rw-r--r--   0 runner    (1001) docker     (123)    13582 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.882763 onelogin-3.1.4/onelogin/api/
--rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    28065 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/api_auth_claims_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    28994 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/api_auth_client_apps_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27857 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/api_auth_scopes_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    32408 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/api_authorization_server_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    78521 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/app_rules_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    48468 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/apps_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    37271 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/branding_service_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18383 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/branding_service_smtp_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    57369 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/branding_service_templates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    22024 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    12257 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/groups_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    14022 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/invite_links_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    74224 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/multi_factor_authentication_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    48940 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/multi_factor_authentication_v1_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    20361 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/o_auth2_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    70143 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/privileges_api.py
--rw-r--r--   0 runner    (1001) docker     (123)   109464 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/roles_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27804 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/saml_assertions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    75866 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/smart_hooks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    78033 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/user_mappings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)   116500 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/users_v1_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    54709 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/users_v2_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    50915 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api/vigilance_ai_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    29552 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/api_client.py
--rw-r--r--   0 runner    (1001) docker     (123)    15236 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     5093 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.902764 onelogin-3.1.4/onelogin/models/
--rw-r--r--   0 runner    (1001) docker     (123)    11745 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     2112 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/action_obj.py
--rw-r--r--   0 runner    (1001) docker     (123)     2986 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/activate_mfa_factors_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2016 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/add_client_app201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2161 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/add_client_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1960 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/add_privilege_to_role201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1942 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/add_privilege_to_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2026 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/add_roles_to_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2178 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/alt_err.py
--rw-r--r--   0 runner    (1001) docker     (123)     3738 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/app_parameters.py
--rw-r--r--   0 runner    (1001) docker     (123)     3927 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/app_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     1974 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/assign_users_to_privilege_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2542 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_claim.py
--rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_id.py
--rw-r--r--   0 runner    (1001) docker     (123)      763 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     2222 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_scope.py
--rw-r--r--   0 runner    (1001) docker     (123)     2681 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_server.py
--rw-r--r--   0 runner    (1001) docker     (123)     2884 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/auth_server_configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     5225 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand.py
--rw-r--r--   0 runner    (1001) docker     (123)     2548 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     2401 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_background.py
--rw-r--r--   0 runner    (1001) docker     (123)     2006 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_background_urls.py
--rw-r--r--   0 runner    (1001) docker     (123)     2329 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_logo.py
--rw-r--r--   0 runner    (1001) docker     (123)     1966 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_logo_urls.py
--rw-r--r--   0 runner    (1001) docker     (123)     2177 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/brand_req.py
--rw-r--r--   0 runner    (1001) docker     (123)     2718 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/client_app_full.py
--rw-r--r--   0 runner    (1001) docker     (123)     2011 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/clock_counter.py
--rw-r--r--   0 runner    (1001) docker     (123)     2226 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/condition.py
--rw-r--r--   0 runner    (1001) docker     (123)     3559 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/configuration_oidc.py
--rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/configuration_saml.py
--rw-r--r--   0 runner    (1001) docker     (123)     2559 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/connector.py
--rw-r--r--   0 runner    (1001) docker     (123)     4776 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_app200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4691 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3677 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_device_verification201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3216 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_device_verification_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3121 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_factor_registration201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3887 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_factor_registration_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_privilege200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1914 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/create_role201_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2122 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/device.py
--rw-r--r--   0 runner    (1001) docker     (123)     2902 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/email_config.py
--rw-r--r--   0 runner    (1001) docker     (123)     7549 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/enforcement_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     3000 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/enforcement_point_resources_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2869 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/enroll_mfa_factor200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2018 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/error.py
--rw-r--r--   0 runner    (1001) docker     (123)    14635 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/event.py
--rw-r--r--   0 runner    (1001) docker     (123)     2577 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_mf_atoken200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2423 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_mf_atoken_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2790 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_otp201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2383 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_otp_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2322 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_saml_assert200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1979 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generate_token_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6098 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generic_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     1932 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/generic_app_provisioning.py
--rw-r--r--   0 runner    (1001) docker     (123)     3509 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_assigned_user200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2386 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_auth_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3098 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_authentication_devices200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2670 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_custom_attributes200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4579 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_email_settings200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1970 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_email_settings200_response_one_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2645 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2641 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     4341 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response_data_otp_devices_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2481 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_event_by_id200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2791 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_event_types200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2173 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_event_types200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     3128 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_events200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2324 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_events200_response_pagination.py
--rw-r--r--   0 runner    (1001) docker     (123)     2642 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_groups200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2335 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_invite_link200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1994 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_invite_link_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2585 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_mfa_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2594 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_mfa_factors200_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     2377 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_mfa_factors200_response_data_auth_factors_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2498 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_rate_limit200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2263 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_risk_score200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3621 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_risk_score_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2361 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_risk_scores200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2318 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_risk_scores200_response_scores.py
--rw-r--r--   0 runner    (1001) docker     (123)     2214 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_apps200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2768 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_by_id200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2137 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_by_id200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     3296 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_by_name200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2132 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_by_name200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2356 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_role_by_name200_response_pagination.py
--rw-r--r--   0 runner    (1001) docker     (123)     4724 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_user_apps200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2345 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_user_roles200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2453 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/get_user_verification200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2109 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/group.py
--rw-r--r--   0 runner    (1001) docker     (123)     5798 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/hook.py
--rw-r--r--   0 runner    (1001) docker     (123)     2635 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/hook_envvar.py
--rw-r--r--   0 runner    (1001) docker     (123)     2136 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/hook_log.py
--rw-r--r--   0 runner    (1001) docker     (123)     2207 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/hook_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/hook_status.py
--rw-r--r--   0 runner    (1001) docker     (123)     2215 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_conditions200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2280 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_mapping_action_values200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2229 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_mapping_conditions200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2328 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_mapping_conditions_operators200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_mapping_contion_values200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2249 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_mappings_actions200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2337 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_message_templates200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     3533 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/list_privelege_roles200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1995 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/locale.py
--rw-r--r--   0 runner    (1001) docker     (123)     2322 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/lock_account_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3920 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/mapping.py
--rw-r--r--   0 runner    (1001) docker     (123)     4580 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/message_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     4737 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/message_template_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     2219 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/message_template_template_one_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2028 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/message_template_template_one_of1.py
--rw-r--r--   0 runner    (1001) docker     (123)     3077 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/oauth_token.py
--rw-r--r--   0 runner    (1001) docker     (123)     6265 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/oidc_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     2494 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/oidc_app_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2689 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/otp_device.py
--rw-r--r--   0 runner    (1001) docker     (123)     2375 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/privilege.py
--rw-r--r--   0 runner    (1001) docker     (123)     2597 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/privilege_privilege.py
--rw-r--r--   0 runner    (1001) docker     (123)     5465 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/privilege_privilege_statement_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2341 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/rate_limit.py
--rw-r--r--   0 runner    (1001) docker     (123)     1926 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/remove_role_users_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2498 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/remove_user_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2022 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/remove_user_role_request_role_id_array_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     5098 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/request_brand.py
--rw-r--r--   0 runner    (1001) docker     (123)     2052 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/revoke_tokens_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1877 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/risk_device.py
--rw-r--r--   0 runner    (1001) docker     (123)     3535 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/risk_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     2273 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/risk_user.py
--rw-r--r--   0 runner    (1001) docker     (123)     2449 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/role.py
--rw-r--r--   0 runner    (1001) docker     (123)     2049 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/rule_action.py
--rw-r--r--   0 runner    (1001) docker     (123)     2045 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/rule_condition.py
--rw-r--r--   0 runner    (1001) docker     (123)     6370 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     2960 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_app_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_app_all_of_parameters.py
--rw-r--r--   0 runner    (1001) docker     (123)     2024 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_app_all_of_parameters_saml_username.py
--rw-r--r--   0 runner    (1001) docker     (123)     2976 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_assert.py
--rw-r--r--   0 runner    (1001) docker     (123)     3227 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/saml_factor.py
--rw-r--r--   0 runner    (1001) docker     (123)     2085 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/scope.py
--rw-r--r--   0 runner    (1001) docker     (123)     2168 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/send_invite_link200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2291 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/send_invite_link_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1994 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/session.py
--rw-r--r--   0 runner    (1001) docker     (123)     2175 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/set_user_state_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2060 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/source.py
--rw-r--r--   0 runner    (1001) docker     (123)     1919 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/sso_oidc.py
--rw-r--r--   0 runner    (1001) docker     (123)     2526 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/sso_saml.py
--rw-r--r--   0 runner    (1001) docker     (123)     2181 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/sso_saml_certificate.py
--rw-r--r--   0 runner    (1001) docker     (123)     3514 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/token_claim.py
--rw-r--r--   0 runner    (1001) docker     (123)     4051 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/track_risk_event_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2004 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_client_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2068 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_environment_variable_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2756 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_password_insecure_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3245 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_password_secure_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_privilege200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1932 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_risk_rule_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1874 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/update_role200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     7678 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/user.py
--rw-r--r--   0 runner    (1001) docker     (123)     2143 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/ver_factor_saml200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/verb.py
--rw-r--r--   0 runner    (1001) docker     (123)     2640 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/verify_mfa_factor_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2413 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/verify_user_registration200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2104 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/verify_user_registration_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2274 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/models/verify_user_verification_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    12607 2023-04-25 18:47:03.000000 onelogin-3.1.4/onelogin/rest.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.878764 onelogin-3.1.4/onelogin.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)      287 2023-04-25 18:47:19.000000 onelogin-3.1.4/onelogin.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    14352 2023-04-25 18:47:19.000000 onelogin-3.1.4/onelogin.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-25 18:47:19.000000 onelogin-3.1.4/onelogin.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       47 2023-04-25 18:47:19.000000 onelogin-3.1.4/onelogin.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        9 2023-04-25 18:47:19.000000 onelogin-3.1.4/onelogin.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)      581 2023-04-25 18:47:03.000000 onelogin-3.1.4/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)       69 2023-04-25 18:47:19.926764 onelogin-3.1.4/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-04-25 18:47:03.000000 onelogin-3.1.4/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-25 18:47:19.926764 onelogin-3.1.4/test/
--rw-r--r--   0 runner    (1001) docker     (123)     1437 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_action_obj.py
--rw-r--r--   0 runner    (1001) docker     (123)     1739 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_activate_mfa_factors_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1579 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_add_client_app201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1527 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_add_client_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1612 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_add_privilege_to_role201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1604 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_add_privilege_to_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1644 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_add_roles_to_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_alt_err.py
--rw-r--r--   0 runner    (1001) docker     (123)     1303 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_api_auth_claims_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_api_auth_client_apps_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1275 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_api_auth_scopes_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_api_authorization_server_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1553 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_app_parameters.py
--rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_app_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     2181 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_app_rules_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_apps_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1652 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_assign_users_to_privilege_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1511 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_claim.py
--rw-r--r--   0 runner    (1001) docker     (123)     1327 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_id.py
--rw-r--r--   0 runner    (1001) docker     (123)      695 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_method.py
--rw-r--r--   0 runner    (1001) docker     (123)     1453 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_scope.py
--rw-r--r--   0 runner    (1001) docker     (123)     2337 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_server.py
--rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_auth_server_configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     4468 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand.py
--rw-r--r--   0 runner    (1001) docker     (123)     2120 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     1991 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_background.py
--rw-r--r--   0 runner    (1001) docker     (123)     1638 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_background_urls.py
--rw-r--r--   0 runner    (1001) docker     (123)     1899 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_logo.py
--rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_logo_urls.py
--rw-r--r--   0 runner    (1001) docker     (123)     1413 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_brand_req.py
--rw-r--r--   0 runner    (1001) docker     (123)     1495 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_branding_service_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1199 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_branding_service_smtp_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2102 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_branding_service_templates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1743 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_client_app_full.py
--rw-r--r--   0 runner    (1001) docker     (123)     1426 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_clock_counter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1435 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_condition.py
--rw-r--r--   0 runner    (1001) docker     (123)     2027 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_configuration_oidc.py
--rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_configuration_saml.py
--rw-r--r--   0 runner    (1001) docker     (123)     1637 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_connector.py
--rw-r--r--   0 runner    (1001) docker     (123)     4395 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_app200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     4347 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2048 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_device_verification201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1827 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_device_verification_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1982 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_factor_registration201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_factor_registration_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1601 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_privilege200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1567 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_create_role201_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1387 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_device.py
--rw-r--r--   0 runner    (1001) docker     (123)     1774 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_email_config.py
--rw-r--r--   0 runner    (1001) docker     (123)     2115 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_enforcement_point.py
--rw-r--r--   0 runner    (1001) docker     (123)     1769 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_enforcement_point_resources_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2435 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_enroll_mfa_factor200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1482 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_error.py
--rw-r--r--   0 runner    (1001) docker     (123)     2886 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_event.py
--rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_mf_atoken200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_mf_atoken_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_otp201_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_otp_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_saml_assert200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generate_token_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2967 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generic_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_generic_app_provisioning.py
--rw-r--r--   0 runner    (1001) docker     (123)     1786 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_assigned_user200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_auth_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_authentication_devices200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1842 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_custom_attributes200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2012 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_email_settings200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1659 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_email_settings200_response_one_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     2645 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_enrolled_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2321 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_enrolled_factors200_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     2229 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_enrolled_factors200_response_data_otp_devices_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     3552 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_event_by_id200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2056 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_event_types200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1772 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_event_types200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     4183 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_events200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1902 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_events200_response_pagination.py
--rw-r--r--   0 runner    (1001) docker     (123)     1921 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_groups200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1796 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_invite_link200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_invite_link_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2144 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_mfa_factors200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_mfa_factors200_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1841 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_mfa_factors200_response_data_auth_factors_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1924 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_rate_limit200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_risk_score200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2248 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_risk_score_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1830 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_risk_scores200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1740 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_risk_scores200_response_scores.py
--rw-r--r--   0 runner    (1001) docker     (123)     1641 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_apps200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1946 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_by_id200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1673 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_by_id200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2330 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_by_name200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_by_name200_response_data_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_role_by_name200_response_pagination.py
--rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_user_apps200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1784 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_user_roles200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1727 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_get_user_verification200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1407 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_group.py
--rw-r--r--   0 runner    (1001) docker     (123)      908 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_groups_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2579 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_hook.py
--rw-r--r--   0 runner    (1001) docker     (123)     1551 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_hook_envvar.py
--rw-r--r--   0 runner    (1001) docker     (123)     1489 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_hook_log.py
--rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_hook_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     1411 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_hook_status.py
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_invite_links_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1663 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_conditions200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1769 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_mapping_action_values200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1687 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_mapping_conditions200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1849 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_mapping_conditions_operators200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1781 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_mapping_contion_values200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1724 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_mappings_actions200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1755 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_message_templates200_response_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1822 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_list_privelege_roles200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1363 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_locale.py
--rw-r--r--   0 runner    (1001) docker     (123)     1564 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_lock_account_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2555 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_mapping.py
--rw-r--r--   0 runner    (1001) docker     (123)     1841 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_message_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     2071 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_message_template_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     2014 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_message_template_template_one_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     1700 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_message_template_template_one_of1.py
--rw-r--r--   0 runner    (1001) docker     (123)     2377 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_multi_factor_authentication_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1836 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_multi_factor_authentication_v1_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_o_auth2_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_oauth_token.py
--rw-r--r--   0 runner    (1001) docker     (123)     4076 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_oidc_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     2342 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_oidc_app_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_otp_device.py
--rw-r--r--   0 runner    (1001) docker     (123)     2680 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_privilege.py
--rw-r--r--   0 runner    (1001) docker     (123)     1888 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_privilege_privilege.py
--rw-r--r--   0 runner    (1001) docker     (123)     2014 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_privilege_privilege_statement_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2413 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_privileges_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1468 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_rate_limit.py
--rw-r--r--   0 runner    (1001) docker     (123)     1568 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_remove_role_users_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1926 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_remove_user_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1712 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_remove_user_role_request_role_id_array_inner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2372 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_request_brand.py
--rw-r--r--   0 runner    (1001) docker     (123)     1654 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_revoke_tokens_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1371 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_risk_device.py
--rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_risk_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_risk_user.py
--rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_role.py
--rw-r--r--   0 runner    (1001) docker     (123)     2716 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_roles_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1418 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_rule_action.py
--rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_rule_condition.py
--rw-r--r--   0 runner    (1001) docker     (123)     4131 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_app.py
--rw-r--r--   0 runner    (1001) docker     (123)     2608 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_app_all_of.py
--rw-r--r--   0 runner    (1001) docker     (123)     1862 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_app_all_of_parameters.py
--rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_app_all_of_parameters_saml_username.py
--rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_assert.py
--rw-r--r--   0 runner    (1001) docker     (123)     1303 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_assertions_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1735 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_saml_factor.py
--rw-r--r--   0 runner    (1001) docker     (123)     1404 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_scope.py
--rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_send_invite_link200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1605 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_send_invite_link_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1333 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_session.py
--rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_set_user_state_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2365 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_smart_hooks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1349 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_source.py
--rw-r--r--   0 runner    (1001) docker     (123)     1383 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_sso_oidc.py
--rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_sso_saml.py
--rw-r--r--   0 runner    (1001) docker     (123)     1588 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_sso_saml_certificate.py
--rw-r--r--   0 runner    (1001) docker     (123)     1720 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_token_claim.py
--rw-r--r--   0 runner    (1001) docker     (123)     2360 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_track_risk_event_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1530 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_client_app_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1670 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_environment_variable_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_password_insecure_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2098 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_password_secure_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1565 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_privilege200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1507 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_risk_rule_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1505 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_update_role200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     2578 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_user.py
--rw-r--r--   0 runner    (1001) docker     (123)     2330 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_user_mappings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2841 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_users_v1_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1433 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_users_v2_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1901 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_ver_factor_saml200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)      652 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_verb.py
--rw-r--r--   0 runner    (1001) docker     (123)     1607 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_verify_mfa_factor_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1765 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_verify_user_registration200_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1604 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_verify_user_registration_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1646 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_verify_user_verification_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1792 2023-04-25 18:47:03.000000 onelogin-3.1.4/test/test_vigilance_ai_api.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.762802 onelogin-3.1.5/
+-rw-r--r--   0 runner    (1001) docker     (123)      287 2023-05-11 21:26:38.762802 onelogin-3.1.5/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)   100299 2023-05-11 21:26:26.000000 onelogin-3.1.5/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.698801 onelogin-3.1.5/onelogin/
+-rw-r--r--   0 runner    (1001) docker     (123)    13544 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.706801 onelogin-3.1.5/onelogin/api/
+-rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28353 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/api_auth_claims_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29286 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/api_auth_client_apps_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28131 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/api_auth_scopes_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32755 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/api_authorization_server_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    79163 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/app_rules_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48923 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/apps_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    37636 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/branding_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18627 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/branding_service_smtp_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    57905 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/branding_service_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22235 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/events_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12420 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/groups_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14215 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/invite_links_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    74904 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/multi_factor_authentication_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    49416 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/multi_factor_authentication_v1_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20597 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/o_auth2_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    70685 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/privileges_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)   110315 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/roles_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28128 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/saml_assertions_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    76539 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/smart_hooks_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    78713 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/user_mappings_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)   117402 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/users_v1_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55073 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/users_v2_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    51421 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api/vigilance_ai_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29944 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api_client.py
+-rw-r--r--   0 runner    (1001) docker     (123)      844 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/api_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15394 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5093 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.738801 onelogin-3.1.5/onelogin/models/
+-rw-r--r--   0 runner    (1001) docker     (123)    11661 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2118 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/action_obj.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2992 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/activate_mfa_factors_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2022 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/add_client_app201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2167 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/add_client_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1966 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/add_privilege_to_role201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/add_privilege_to_role_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2032 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/add_roles_to_user_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2184 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/alt_err.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3744 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/app_parameters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3987 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/app_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1980 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/assign_users_to_privilege_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2548 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_claim.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1813 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_id.py
+-rw-r--r--   0 runner    (1001) docker     (123)      926 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_method.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2228 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_scope.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2687 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_server.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2890 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/auth_server_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5231 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2554 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2407 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_background.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2012 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_background_urls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2335 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_logo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1972 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_logo_urls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2183 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/brand_req.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2724 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/client_app_full.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2017 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/clock_counter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2232 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3655 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/configuration_oidc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2304 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/configuration_saml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2565 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5604 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_app200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5511 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3683 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_device_verification201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3222 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_device_verification_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3127 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_factor_registration201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3893 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_factor_registration_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_privilege200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1920 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/create_role201_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2128 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/email_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7609 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/enforcement_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3060 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/enforcement_point_resources_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2877 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/enroll_mfa_factor200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2026 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/error.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14697 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/event.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2585 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_mf_atoken200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2431 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_mf_atoken_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2796 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_otp201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2390 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_otp_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2328 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_saml_assert200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1985 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generate_token_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6104 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generic_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1938 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/generic_app_provisioning.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3515 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_assigned_user200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2392 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_auth_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3104 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_authentication_devices200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2676 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_custom_attributes200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5404 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_email_settings200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1976 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_email_settings200_response_one_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2651 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2647 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4347 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response_data_otp_devices_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2487 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_event_by_id200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2797 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_event_types200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2179 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_event_types200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3134 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_events200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2330 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_events200_response_pagination.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2648 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_groups200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2341 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_invite_link200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2000 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_invite_link_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2591 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_mfa_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2600 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_mfa_factors200_response_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2383 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_mfa_factors200_response_data_auth_factors_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2505 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_rate_limit200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2270 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_risk_score200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3627 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_risk_score_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2367 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_risk_scores200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2325 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_risk_scores200_response_scores.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2220 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_apps200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2774 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_by_id200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2143 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_by_id200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3302 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_by_name200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2138 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_by_name200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2362 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_role_by_name200_response_pagination.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4838 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_user_apps200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2351 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_user_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2459 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/get_user_verification200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2115 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5858 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/hook.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2641 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/hook_envvar.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2142 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/hook_log.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2213 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/hook_options.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1996 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/hook_status.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2221 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_conditions200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2286 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_mapping_action_values200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2235 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_mapping_conditions200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2334 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_mapping_conditions_operators200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2297 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_mapping_contion_values200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2255 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_mappings_actions200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2343 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_message_templates200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3533 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_privelege_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3539 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/list_privilege_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2001 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/locale.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2328 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/lock_account_user_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3971 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/mapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4690 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/message_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5554 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/message_template_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2225 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/message_template_template_one_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2034 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/message_template_template_one_of1.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3084 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/oauth_token.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6271 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/oidc_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2500 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/oidc_app_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2695 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/otp_device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2381 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/privilege.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2603 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/privilege_privilege.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5517 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/privilege_privilege_statement_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2347 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/rate_limit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1932 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/remove_role_users_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2504 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/remove_user_role_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2028 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/remove_user_role_request_role_id_array_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5104 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/request_brand.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2059 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/revoke_tokens_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1883 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/risk_device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3649 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/risk_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2280 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/risk_user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2455 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/role.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2055 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/rule_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2051 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/rule_condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6376 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2966 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_app_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2297 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_app_all_of_parameters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_app_all_of_parameters_saml_username.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2982 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_assert.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3233 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/saml_factor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2092 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/scope.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2174 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/send_invite_link200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2297 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/send_invite_link_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2000 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/session.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2226 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/set_user_state_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2066 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/source.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1925 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/sso_oidc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2532 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/sso_saml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2187 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/sso_saml_certificate.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3520 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/token_claim.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4057 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/track_risk_event_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2010 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_client_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2074 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_environment_variable_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2762 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_password_insecure_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3251 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_password_secure_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1963 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_privilege200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1938 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_risk_rule_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1880 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/update_role200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7792 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2151 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/ver_factor_saml200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/verb.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2646 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/verify_mfa_factor_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2419 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/verify_user_registration200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2110 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/verify_user_registration_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2280 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/models/verify_user_verification_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12733 2023-05-11 21:26:26.000000 onelogin-3.1.5/onelogin/rest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.698801 onelogin-3.1.5/onelogin.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)      287 2023-05-11 21:26:38.000000 onelogin-3.1.5/onelogin.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    14475 2023-05-11 21:26:38.000000 onelogin-3.1.5/onelogin.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-11 21:26:38.000000 onelogin-3.1.5/onelogin.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       91 2023-05-11 21:26:38.000000 onelogin-3.1.5/onelogin.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        9 2023-05-11 21:26:38.000000 onelogin-3.1.5/onelogin.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      665 2023-05-11 21:26:26.000000 onelogin-3.1.5/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       69 2023-05-11 21:26:38.762802 onelogin-3.1.5/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1069 2023-05-11 21:26:26.000000 onelogin-3.1.5/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 21:26:38.762802 onelogin-3.1.5/test/
+-rw-r--r--   0 runner    (1001) docker     (123)     1437 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_action_obj.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1739 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_activate_mfa_factors_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1579 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_add_client_app201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1527 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_add_client_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1612 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_add_privilege_to_role201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1604 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_add_privilege_to_role_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1644 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_add_roles_to_user_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_alt_err.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1303 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_api_auth_claims_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_api_auth_client_apps_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1275 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_api_auth_scopes_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_api_authorization_server_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1553 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_app_parameters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1969 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_app_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2181 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_app_rules_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_apps_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1652 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_assign_users_to_privilege_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1511 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_claim.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1327 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_id.py
+-rw-r--r--   0 runner    (1001) docker     (123)      695 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_method.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1453 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_scope.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2337 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_server.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_auth_server_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4468 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2120 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1991 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_background.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1638 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_background_urls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1899 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_logo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_logo_urls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1413 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_brand_req.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1495 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_branding_service_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1199 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_branding_service_smtp_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2102 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_branding_service_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1743 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_client_app_full.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1426 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_clock_counter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1435 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2027 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_configuration_oidc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_configuration_saml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1637 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_connector.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4395 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_app200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4347 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2048 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_device_verification201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1827 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_device_verification_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1982 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_factor_registration201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_factor_registration_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1601 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_privilege200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1567 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_create_role201_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1387 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1774 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_email_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2115 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_enforcement_point.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1769 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_enforcement_point_resources_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2435 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_enroll_mfa_factor200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1482 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_error.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2886 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_event.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_events_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1686 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_mf_atoken200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_mf_atoken_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_otp201_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_otp_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_saml_assert200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generate_token_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2967 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generic_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1524 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_generic_app_provisioning.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1786 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_assigned_user200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_auth_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1948 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_authentication_devices200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1842 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_custom_attributes200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2012 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_email_settings200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1659 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_email_settings200_response_one_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2645 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_enrolled_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2321 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_enrolled_factors200_response_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2229 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_enrolled_factors200_response_data_otp_devices_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3552 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_event_by_id200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2056 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_event_types200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1772 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_event_types200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4183 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_events200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1902 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_events200_response_pagination.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1921 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_groups200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1796 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_invite_link200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_invite_link_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2144 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_mfa_factors200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_mfa_factors200_response_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1841 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_mfa_factors200_response_data_auth_factors_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1924 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_rate_limit200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_risk_score200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2248 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_risk_score_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1830 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_risk_scores200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1740 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_risk_scores200_response_scores.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1641 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_apps200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1946 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_by_id200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1673 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_by_id200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2330 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_by_name200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_by_name200_response_data_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_role_by_name200_response_pagination.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_user_apps200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1784 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_user_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1727 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_get_user_verification200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1407 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)      908 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_groups_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2579 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_hook.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1551 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_hook_envvar.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1489 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_hook_log.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_hook_options.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1411 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_hook_status.py
+-rw-r--r--   0 runner    (1001) docker     (123)      964 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_invite_links_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1663 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_conditions200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1769 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_mapping_action_values200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1687 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_mapping_conditions200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1849 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_mapping_conditions_operators200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1781 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_mapping_contion_values200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1724 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_mappings_actions200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1755 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_message_templates200_response_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1822 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_privelege_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1822 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_list_privilege_roles200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1363 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_locale.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1564 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_lock_account_user_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2555 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_mapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1841 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_message_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2071 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_message_template_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2014 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_message_template_template_one_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1700 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_message_template_template_one_of1.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2377 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_multi_factor_authentication_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1836 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_multi_factor_authentication_v1_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_o_auth2_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_oauth_token.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4076 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_oidc_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2342 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_oidc_app_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_otp_device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2680 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_privilege.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1888 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_privilege_privilege.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2014 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_privilege_privilege_statement_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2413 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_privileges_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1468 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_rate_limit.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1568 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_remove_role_users_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1926 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_remove_user_role_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1712 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_remove_user_role_request_role_id_array_inner.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2372 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_request_brand.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1654 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_revoke_tokens_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1371 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_risk_device.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_risk_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1439 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_risk_user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_role.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2716 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_roles_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1418 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_rule_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1458 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_rule_condition.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4131 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2608 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_app_all_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1862 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_app_all_of_parameters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_app_all_of_parameters_saml_username.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_assert.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1303 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_assertions_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1735 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_saml_factor.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1404 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_scope.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1736 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_send_invite_link200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1605 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_send_invite_link_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1333 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_session.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_set_user_state_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2365 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_smart_hooks_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1349 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_source.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1383 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_sso_oidc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_sso_saml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1588 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_sso_saml_certificate.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1720 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_token_claim.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2360 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_track_risk_event_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1530 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_client_app_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1670 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_environment_variable_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1837 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_password_insecure_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2098 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_password_secure_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1565 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_privilege200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1507 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_risk_rule_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1505 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_update_role200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2578 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2330 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_user_mappings_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2841 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_users_v1_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1433 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_users_v2_api.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1901 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_ver_factor_saml200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)      652 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_verb.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1607 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_verify_mfa_factor_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1765 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_verify_user_registration200_response.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1604 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_verify_user_registration_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1646 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_verify_user_verification_request.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1792 2023-05-11 21:26:26.000000 onelogin-3.1.5/test/test_vigilance_ai_api.py
```

### Comparing `onelogin-3.1.4/onelogin/__init__.py` & `onelogin-3.1.5/onelogin/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     The version of the OpenAPI document: 3.1.1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
-__version__ = "3.1.4"
+__version__ = "3.1.5"
 
 # import apis into sdk package
 from onelogin.api.api_auth_claims_api import APIAuthClaimsApi
 from onelogin.api.api_auth_client_apps_api import APIAuthClientAppsApi
 from onelogin.api.api_auth_scopes_api import APIAuthScopesApi
 from onelogin.api.api_authorization_server_api import APIAuthorizationServerApi
 from onelogin.api.app_rules_api import AppRulesApi
@@ -38,14 +38,15 @@
 from onelogin.api.smart_hooks_api import SmartHooksApi
 from onelogin.api.user_mappings_api import UserMappingsApi
 from onelogin.api.users_v1_api import UsersV1Api
 from onelogin.api.users_v2_api import UsersV2Api
 from onelogin.api.vigilance_ai_api import VigilanceAIApi
 
 # import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.api_client import ApiClient
 from onelogin.configuration import Configuration
 from onelogin.exceptions import OpenApiException
 from onelogin.exceptions import ApiTypeError
 from onelogin.exceptions import ApiValueError
 from onelogin.exceptions import ApiKeyError
 from onelogin.exceptions import ApiAttributeError
@@ -83,15 +84,14 @@
 from onelogin.models.connector import Connector
 from onelogin.models.create_app200_response import CreateApp200Response
 from onelogin.models.create_app_request import CreateAppRequest
 from onelogin.models.create_device_verification201_response import CreateDeviceVerification201Response
 from onelogin.models.create_device_verification_request import CreateDeviceVerificationRequest
 from onelogin.models.create_factor_registration201_response import CreateFactorRegistration201Response
 from onelogin.models.create_factor_registration_request import CreateFactorRegistrationRequest
-from onelogin.models.create_privilege200_response import CreatePrivilege200Response
 from onelogin.models.create_role201_response_inner import CreateRole201ResponseInner
 from onelogin.models.device import Device
 from onelogin.models.email_config import EmailConfig
 from onelogin.models.enforcement_point import EnforcementPoint
 from onelogin.models.enforcement_point_resources_inner import EnforcementPointResourcesInner
 from onelogin.models.enroll_mfa_factor200_response import EnrollMfaFactor200Response
 from onelogin.models.error import Error
@@ -147,15 +147,15 @@
 from onelogin.models.list_conditions200_response_inner import ListConditions200ResponseInner
 from onelogin.models.list_mapping_action_values200_response_inner import ListMappingActionValues200ResponseInner
 from onelogin.models.list_mapping_conditions200_response import ListMappingConditions200Response
 from onelogin.models.list_mapping_conditions_operators200_response_inner import ListMappingConditionsOperators200ResponseInner
 from onelogin.models.list_mapping_contion_values200_response_inner import ListMappingContionValues200ResponseInner
 from onelogin.models.list_mappings_actions200_response_inner import ListMappingsActions200ResponseInner
 from onelogin.models.list_message_templates200_response_inner import ListMessageTemplates200ResponseInner
-from onelogin.models.list_privelege_roles200_response import ListPrivelegeRoles200Response
+from onelogin.models.list_privilege_roles200_response import ListPrivilegeRoles200Response
 from onelogin.models.locale import Locale
 from onelogin.models.lock_account_user_request import LockAccountUserRequest
 from onelogin.models.mapping import Mapping
 from onelogin.models.message_template import MessageTemplate
 from onelogin.models.message_template_template import MessageTemplateTemplate
 from onelogin.models.message_template_template_one_of import MessageTemplateTemplateOneOf
 from onelogin.models.message_template_template_one_of1 import MessageTemplateTemplateOneOf1
```

### Comparing `onelogin-3.1.4/onelogin/api/__init__.py` & `onelogin-3.1.5/onelogin/api/__init__.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/onelogin/api/api_auth_claims_api.py` & `onelogin-3.1.5/onelogin/api/api_auth_claims_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,27 +9,30 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictInt, StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.auth_claim import AuthClaim
 from onelogin.models.auth_id import AuthId
 from onelogin.models.token_claim import TokenClaim
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class APIAuthClaimsApi(object):
@@ -59,32 +62,30 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_claim:
         :type auth_claim: AuthClaim
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: int
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_auth_claim_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_auth_claim_with_http_info(api_auth_id, content_type, auth_claim, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_auth_claim_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_claim : Optional[AuthClaim] = None, **kwargs):  # noqa: E501
+    def create_auth_claim_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_claim : Optional[AuthClaim] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Api Auth Server Claim  # noqa: E501
 
         Create Authorization Claim  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_auth_claim_with_http_info(api_auth_id, content_type, auth_claim, async_req=True)
@@ -94,21 +95,22 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_claim:
         :type auth_claim: AuthClaim
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -165,15 +167,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_claim']:
+        if _params['auth_claim'] is not None:
             _body_params = _params['auth_claim']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -225,32 +227,30 @@
         :type api_auth_id: str
         :param claim_id: (required)
         :type claim_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_auth_claim_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_auth_claim_with_http_info(api_auth_id, claim_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_auth_claim_with_http_info(self, api_auth_id : StrictStr, claim_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def delete_auth_claim_with_http_info(self, api_auth_id : StrictStr, claim_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Api Auth Server Claim  # noqa: E501
 
         Delete Authorization Claim  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_auth_claim_with_http_info(api_auth_id, claim_id, content_type, async_req=True)
@@ -260,21 +260,22 @@
         :type api_auth_id: str
         :param claim_id: (required)
         :type claim_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -377,32 +378,30 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[TokenClaim]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_authclaims_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_authclaims_with_http_info(api_auth_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_authclaims_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def get_authclaims_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Api Auth Server claims  # noqa: E501
 
         Get Authorization claims  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_authclaims_with_http_info(api_auth_id, content_type, async_req=True)
@@ -410,21 +409,22 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -531,32 +531,30 @@
         :type claim_id: int
         :param content_type:
         :type content_type: str
         :param auth_claim:
         :type auth_claim: AuthClaim
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthId
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_claim_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_claim_with_http_info(api_auth_id, claim_id, content_type, auth_claim, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_claim_with_http_info(self, api_auth_id : StrictStr, claim_id : StrictInt, content_type : Optional[StrictStr] = None, auth_claim : Optional[AuthClaim] = None, **kwargs):  # noqa: E501
+    def update_claim_with_http_info(self, api_auth_id : StrictStr, claim_id : StrictInt, content_type : Optional[StrictStr] = None, auth_claim : Optional[AuthClaim] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Api Auth Server Claim  # noqa: E501
 
         Update Authorization Server Claim  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_claim_with_http_info(api_auth_id, claim_id, content_type, auth_claim, async_req=True)
@@ -568,21 +566,22 @@
         :type claim_id: int
         :param content_type:
         :type content_type: str
         :param auth_claim:
         :type auth_claim: AuthClaim
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -643,15 +642,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_claim']:
+        if _params['auth_claim'] is not None:
             _body_params = _params['auth_claim']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/api_auth_client_apps_api.py` & `onelogin-3.1.5/onelogin/api/api_auth_client_apps_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,28 +9,31 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictInt, StrictStr
 
 from typing import Optional
 
 from onelogin.models.add_client_app201_response import AddClientApp201Response
 from onelogin.models.add_client_app_request import AddClientAppRequest
 from onelogin.models.client_app_full import ClientAppFull
 from onelogin.models.update_client_app_request import UpdateClientAppRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class APIAuthClientAppsApi(object):
@@ -60,32 +63,30 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param add_client_app_request:
         :type add_client_app_request: AddClientAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AddClientApp201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the add_client_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.add_client_app_with_http_info(api_auth_id, content_type, add_client_app_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def add_client_app_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, add_client_app_request : Optional[AddClientAppRequest] = None, **kwargs):  # noqa: E501
+    def add_client_app_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, add_client_app_request : Optional[AddClientAppRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Add Client App  # noqa: E501
 
         Add Client App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.add_client_app_with_http_info(api_auth_id, content_type, add_client_app_request, async_req=True)
@@ -95,21 +96,22 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param add_client_app_request:
         :type add_client_app_request: AddClientAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -166,15 +168,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['add_client_app_request']:
+        if _params['add_client_app_request'] is not None:
             _body_params = _params['add_client_app_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -226,32 +228,30 @@
         :type api_auth_id: str
         :param client_app_id: (required)
         :type client_app_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AddClientApp201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_client_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_client_app_with_http_info(api_auth_id, client_app_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_client_app_with_http_info(self, api_auth_id : StrictStr, client_app_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def delete_client_app_with_http_info(self, api_auth_id : StrictStr, client_app_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Remove Client App  # noqa: E501
 
         Delete Client App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_client_app_with_http_info(api_auth_id, client_app_id, content_type, async_req=True)
@@ -261,21 +261,22 @@
         :type api_auth_id: str
         :param client_app_id: (required)
         :type client_app_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -383,32 +384,30 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ClientAppFull
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_client_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_client_apps_with_http_info(api_auth_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_client_apps_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def list_client_apps_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Clients Apps  # noqa: E501
 
         List Client Apps  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_client_apps_with_http_info(api_auth_id, content_type, async_req=True)
@@ -416,21 +415,22 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -537,32 +537,30 @@
         :type client_app_id: int
         :param content_type:
         :type content_type: str
         :param update_client_app_request:
         :type update_client_app_request: UpdateClientAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AddClientApp201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_client_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_client_app_with_http_info(api_auth_id, client_app_id, content_type, update_client_app_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_client_app_with_http_info(self, api_auth_id : StrictStr, client_app_id : StrictInt, content_type : Optional[StrictStr] = None, update_client_app_request : Optional[UpdateClientAppRequest] = None, **kwargs):  # noqa: E501
+    def update_client_app_with_http_info(self, api_auth_id : StrictStr, client_app_id : StrictInt, content_type : Optional[StrictStr] = None, update_client_app_request : Optional[UpdateClientAppRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Client App  # noqa: E501
 
         Update Client App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_client_app_with_http_info(api_auth_id, client_app_id, content_type, update_client_app_request, async_req=True)
@@ -574,21 +572,22 @@
         :type client_app_id: int
         :param content_type:
         :type content_type: str
         :param update_client_app_request:
         :type update_client_app_request: UpdateClientAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -649,15 +648,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['update_client_app_request']:
+        if _params['update_client_app_request'] is not None:
             _body_params = _params['update_client_app_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/api_auth_scopes_api.py` & `onelogin-3.1.5/onelogin/api/api_auth_scopes_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,26 +9,29 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictInt, StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.auth_id import AuthId
 from onelogin.models.auth_scope import AuthScope
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class APIAuthScopesApi(object):
@@ -58,32 +61,30 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_scope:
         :type auth_scope: AuthScope
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthScope
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_scope_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_scope_with_http_info(api_auth_id, content_type, auth_scope, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_scope_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_scope : Optional[AuthScope] = None, **kwargs):  # noqa: E501
+    def create_scope_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_scope : Optional[AuthScope] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Api Auth Server Scope  # noqa: E501
 
         Create API Auth Server Scope  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_scope_with_http_info(api_auth_id, content_type, auth_scope, async_req=True)
@@ -93,21 +94,22 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_scope:
         :type auth_scope: AuthScope
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -164,15 +166,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_scope']:
+        if _params['auth_scope'] is not None:
             _body_params = _params['auth_scope']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -224,32 +226,30 @@
         :type api_auth_id: str
         :param scope_id: (required)
         :type scope_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_scope_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_scope_with_http_info(api_auth_id, scope_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_scope_with_http_info(self, api_auth_id : StrictStr, scope_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def delete_scope_with_http_info(self, api_auth_id : StrictStr, scope_id : StrictInt, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Api Auth Server Scope  # noqa: E501
 
         Delete Scope  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_scope_with_http_info(api_auth_id, scope_id, content_type, async_req=True)
@@ -259,21 +259,22 @@
         :type api_auth_id: str
         :param scope_id: (required)
         :type scope_id: int
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -376,32 +377,30 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[AuthScope]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_scopes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_scopes_with_http_info(api_auth_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_scopes_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def get_scopes_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Api Auth Server Scopes  # noqa: E501
 
         List Authorization Scopes  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_scopes_with_http_info(api_auth_id, content_type, async_req=True)
@@ -409,21 +408,22 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -529,32 +529,30 @@
         :type scope_id: int
         :param content_type:
         :type content_type: str
         :param auth_scope:
         :type auth_scope: AuthScope
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthId
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_scope_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_scope_with_http_info(api_auth_id, scope_id, content_type, auth_scope, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_scope_with_http_info(self, api_auth_id : StrictStr, scope_id : StrictInt, content_type : Optional[StrictStr] = None, auth_scope : Optional[AuthScope] = None, **kwargs):  # noqa: E501
+    def update_scope_with_http_info(self, api_auth_id : StrictStr, scope_id : StrictInt, content_type : Optional[StrictStr] = None, auth_scope : Optional[AuthScope] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Api Auth Server Scope  # noqa: E501
 
         Update Scope  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_scope_with_http_info(api_auth_id, scope_id, content_type, auth_scope, async_req=True)
@@ -566,21 +564,22 @@
         :type scope_id: int
         :param content_type:
         :type content_type: str
         :param auth_scope:
         :type auth_scope: AuthScope
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -641,15 +640,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_scope']:
+        if _params['auth_scope'] is not None:
             _body_params = _params['auth_scope']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/api_authorization_server_api.py` & `onelogin-3.1.5/onelogin/api/api_authorization_server_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,25 +9,28 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.auth_server import AuthServer
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class APIAuthorizationServerApi(object):
@@ -55,32 +58,30 @@
 
         :param content_type:
         :type content_type: str
         :param auth_server:
         :type auth_server: AuthServer
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthServer
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_auth_server_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_auth_server_with_http_info(content_type, auth_server, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_auth_server_with_http_info(self, content_type : Optional[StrictStr] = None, auth_server : Optional[AuthServer] = None, **kwargs):  # noqa: E501
+    def create_auth_server_with_http_info(self, content_type : Optional[StrictStr] = None, auth_server : Optional[AuthServer] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Api Auth Server  # noqa: E501
 
         Create Auth Server  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_auth_server_with_http_info(content_type, auth_server, async_req=True)
@@ -88,21 +89,22 @@
 
         :param content_type:
         :type content_type: str
         :param auth_server:
         :type auth_server: AuthServer
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -155,15 +157,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_server']:
+        if _params['auth_server'] is not None:
             _body_params = _params['auth_server']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -212,32 +214,30 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_auth_server_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_auth_server_with_http_info(api_auth_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def delete_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Api Auth Server  # noqa: E501
 
         Delete Authentication Server  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_auth_server_with_http_info(api_auth_id, content_type, async_req=True)
@@ -245,21 +245,22 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -358,32 +359,30 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthServer
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_auth_server_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_auth_server_with_http_info(api_auth_id, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def get_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Api Auth Server  # noqa: E501
 
         Get Authorization Server  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_auth_server_with_http_info(api_auth_id, content_type, async_req=True)
@@ -391,21 +390,22 @@
 
         :param api_auth_id: (required)
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -503,50 +503,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_auth_servers(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[AuthServer]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_auth_servers_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_auth_servers_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_auth_servers_with_http_info(self, **kwargs):  # noqa: E501
+    def list_auth_servers_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """List Api Auth Servers  # noqa: E501
 
         List Authorization Servers  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_auth_servers_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -642,32 +641,30 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_server:
         :type auth_server: AuthServer
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AuthServer
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_auth_server_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_auth_server_with_http_info(api_auth_id, content_type, auth_server, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_server : Optional[AuthServer] = None, **kwargs):  # noqa: E501
+    def update_auth_server_with_http_info(self, api_auth_id : StrictStr, content_type : Optional[StrictStr] = None, auth_server : Optional[AuthServer] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Api Auth Server  # noqa: E501
 
         Update Authorization Server  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_auth_server_with_http_info(api_auth_id, content_type, auth_server, async_req=True)
@@ -677,21 +674,22 @@
         :type api_auth_id: str
         :param content_type:
         :type content_type: str
         :param auth_server:
         :type auth_server: AuthServer
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -748,15 +746,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['auth_server']:
+        if _params['auth_server'] is not None:
             _body_params = _params['auth_server']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/app_rules_api.py` & `onelogin-3.1.5/onelogin/api/user_mappings_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,123 +9,127 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist
 
-from typing import List, Optional
+from typing import Any, Dict, List, Optional
 
-from onelogin.models.app_rule import AppRule
-from onelogin.models.list_conditions200_response_inner import ListConditions200ResponseInner
-from onelogin.models.rule_action import RuleAction
-from onelogin.models.rule_condition import RuleCondition
+from onelogin.models.list_mapping_action_values200_response_inner import ListMappingActionValues200ResponseInner
+from onelogin.models.list_mapping_conditions200_response import ListMappingConditions200Response
+from onelogin.models.list_mapping_conditions_operators200_response_inner import ListMappingConditionsOperators200ResponseInner
+from onelogin.models.list_mapping_contion_values200_response_inner import ListMappingContionValues200ResponseInner
+from onelogin.models.list_mappings_actions200_response_inner import ListMappingsActions200ResponseInner
+from onelogin.models.mapping import Mapping
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
-class AppRulesApi(object):
+class UserMappingsApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
     @validate_arguments
-    def create_app_rule(self, app_id : StrictInt, app_rule : Optional[AppRule] = None, **kwargs) -> AppRule:  # noqa: E501
-        """create_app_rule  # noqa: E501
+    def create_mapping(self, content_type : Optional[StrictStr] = None, mapping : Optional[Mapping] = None, **kwargs) -> List[Mapping]:  # noqa: E501
+        """Create Mapping  # noqa: E501
 
-        Create App Rule  # noqa: E501
+        Create Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.create_app_rule(app_id, app_rule, async_req=True)
+        >>> thread = api.create_mapping(content_type, mapping, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param app_rule:
-        :type app_rule: AppRule
+        :param content_type:
+        :type content_type: str
+        :param mapping:
+        :type mapping: Mapping
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: AppRule
+        :rtype: List[Mapping]
         """
         kwargs['_return_http_data_only'] = True
-        return self.create_app_rule_with_http_info(app_id, app_rule, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_mapping_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.create_mapping_with_http_info(content_type, mapping, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_app_rule_with_http_info(self, app_id : StrictInt, app_rule : Optional[AppRule] = None, **kwargs):  # noqa: E501
-        """create_app_rule  # noqa: E501
+    def create_mapping_with_http_info(self, content_type : Optional[StrictStr] = None, mapping : Optional[Mapping] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """Create Mapping  # noqa: E501
 
-        Create App Rule  # noqa: E501
+        Create Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.create_app_rule_with_http_info(app_id, app_rule, async_req=True)
+        >>> thread = api.create_mapping_with_http_info(content_type, mapping, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param app_rule:
-        :type app_rule: AppRule
+        :param content_type:
+        :type content_type: str
+        :param mapping:
+        :type mapping: Mapping
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[Mapping], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'app_rule'
+            'content_type',
+            'mapping'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -136,38 +140,38 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_app_rule" % _key
+                    " to method create_mapping" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
+        if _params['content_type']:
+            _header_params['Content-Type'] = _params['content_type']
+
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['app_rule']:
-            _body_params = _params['app_rule']
+        if _params['mapping'] is not None:
+            _body_params = _params['mapping']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get('_content_type',
@@ -176,21 +180,21 @@
         if _content_types_list:
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '201': "AppRule",
-            '401': "AltErr",
-            '422': "AltErr",
+            '201': "List[Mapping]",
+            '401': "Error",
+            '422': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules', 'POST',
+            '/api/2/mappings', 'POST',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -199,70 +203,65 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def delete_rule(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> None:  # noqa: E501
-        """Delete Rule  # noqa: E501
+    def delete_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> None:  # noqa: E501
+        """Delete Mapping  # noqa: E501
 
-        Delete App Rule  # noqa: E501
+        Delete Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.delete_rule(app_id, rule_id, async_req=True)
+        >>> thread = api.delete_mapping(mapping_id, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
-        return self.delete_rule_with_http_info(app_id, rule_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_mapping_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.delete_mapping_with_http_info(mapping_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, **kwargs):  # noqa: E501
-        """Delete Rule  # noqa: E501
+    def delete_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> ApiResponse:  # noqa: E501
+        """Delete Mapping  # noqa: E501
 
-        Delete App Rule  # noqa: E501
+        Delete Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.delete_rule_with_http_info(app_id, rule_id, async_req=True)
+        >>> thread = api.delete_mapping_with_http_info(mapping_id, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -273,16 +272,15 @@
                  returns the request thread.
         :rtype: None
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_id'
+            'mapping_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -293,28 +291,25 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method delete_rule" % _key
+                    " to method delete_mapping" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_id']:
-            _path_params['rule_id'] = _params['rule_id']
+        if _params['mapping_id']:
+            _path_params['mapping_id'] = _params['mapping_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -328,15 +323,15 @@
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {}
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/{rule_id}', 'DELETE',
+            '/api/2/mappings/{mapping_id}', 'DELETE',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -345,90 +340,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def get_app_rule(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> AppRule:  # noqa: E501
-        """Get Rule  # noqa: E501
+    def get_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> Mapping:  # noqa: E501
+        """Get Mapping  # noqa: E501
 
-        Get App Rule  # noqa: E501
+        Get Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.get_app_rule(app_id, rule_id, async_req=True)
+        >>> thread = api.get_mapping(mapping_id, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: AppRule
+        :rtype: Mapping
         """
         kwargs['_return_http_data_only'] = True
-        return self.get_app_rule_with_http_info(app_id, rule_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_mapping_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.get_mapping_with_http_info(mapping_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_app_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, **kwargs):  # noqa: E501
-        """Get Rule  # noqa: E501
+    def get_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> ApiResponse:  # noqa: E501
+        """Get Mapping  # noqa: E501
 
-        Get App Rule  # noqa: E501
+        Get Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.get_app_rule_with_http_info(app_id, rule_id, async_req=True)
+        >>> thread = api.get_mapping_with_http_info(mapping_id, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(Mapping, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_id'
+            'mapping_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -439,28 +428,25 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_app_rule" % _key
+                    " to method get_mapping" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_id']:
-            _path_params['rule_id'] = _params['rule_id']
+        if _params['mapping_id']:
+            _path_params['mapping_id'] = _params['mapping_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -472,21 +458,21 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "AppRule",
-            '401': "AltErr",
-            '404': "AltErr",
+            '200': "Mapping",
+            '401': "Error",
+            '404': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/{rule_id}', 'GET',
+            '/api/2/mappings/{mapping_id}', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -495,90 +481,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_action_valies(self, app_id : StrictInt, rule_action_value : StrictStr, **kwargs) -> List[RuleAction]:  # noqa: E501
+    def list_mapping_action_values(self, mapping_action_value : StrictStr, **kwargs) -> List[ListMappingActionValues200ResponseInner]:  # noqa: E501
         """List Actions Values  # noqa: E501
 
-        Sort App rules  # noqa: E501
+        List Mappings' Actions' Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_action_valies(app_id, rule_action_value, async_req=True)
+        >>> thread = api.list_mapping_action_values(mapping_action_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_action_value: (required)
-        :type rule_action_value: str
+        :param mapping_action_value: (required)
+        :type mapping_action_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[RuleAction]
+        :rtype: List[ListMappingActionValues200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_action_valies_with_http_info(app_id, rule_action_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mapping_action_values_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mapping_action_values_with_http_info(mapping_action_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_action_valies_with_http_info(self, app_id : StrictInt, rule_action_value : StrictStr, **kwargs):  # noqa: E501
+    def list_mapping_action_values_with_http_info(self, mapping_action_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """List Actions Values  # noqa: E501
 
-        Sort App rules  # noqa: E501
+        List Mappings' Actions' Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_action_valies_with_http_info(app_id, rule_action_value, async_req=True)
+        >>> thread = api.list_mapping_action_values_with_http_info(mapping_action_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_action_value: (required)
-        :type rule_action_value: str
+        :param mapping_action_value: (required)
+        :type mapping_action_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[RuleAction], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[ListMappingActionValues200ResponseInner], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_action_value'
+            'mapping_action_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -589,28 +569,25 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_action_valies" % _key
+                    " to method list_mapping_action_values" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_action_value']:
-            _path_params['rule_action_value'] = _params['rule_action_value']
+        if _params['mapping_action_value']:
+            _path_params['mapping_action_value'] = _params['mapping_action_value']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -622,20 +599,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[RuleAction]",
-            '401': "AltErr",
+            '200': "List[ListMappingActionValues200ResponseInner]",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/actions/{rule_action_value}/values', 'GET',
+            '/api/2/mappings/actions/{mapping_action_value}/values', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -644,85 +621,79 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_actions(self, app_id : StrictInt, **kwargs) -> List[RuleAction]:  # noqa: E501
-        """List Actions  # noqa: E501
+    def list_mapping_conditions(self, **kwargs) -> ListMappingConditions200Response:  # noqa: E501
+        """List Conditions  # noqa: E501
 
-        List Actions  # noqa: E501
+        List Mappings' Conditions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_actions(app_id, async_req=True)
+        >>> thread = api.list_mapping_conditions(async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[RuleAction]
+        :rtype: ListMappingConditions200Response
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_actions_with_http_info(app_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mapping_conditions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mapping_conditions_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_actions_with_http_info(self, app_id : StrictInt, **kwargs):  # noqa: E501
-        """List Actions  # noqa: E501
+    def list_mapping_conditions_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions  # noqa: E501
 
-        List Actions  # noqa: E501
+        List Mappings' Conditions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_actions_with_http_info(app_id, async_req=True)
+        >>> thread = api.list_mapping_conditions_with_http_info(async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[RuleAction], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(ListMappingConditions200Response, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -733,26 +704,23 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_actions" % _key
+                    " to method list_mapping_conditions" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
@@ -763,20 +731,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[RuleAction]",
-            '401': "AltErr",
+            '200': "ListMappingConditions200Response",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/actions', 'GET',
+            '/api/2/mappings/conditions', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -785,110 +753,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_app_rules(self, app_id : StrictInt, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, **kwargs) -> List[AppRule]:  # noqa: E501
-        """List Rules  # noqa: E501
+    def list_mapping_conditions_operators(self, mapping_condition_value : StrictStr, **kwargs) -> List[ListMappingConditionsOperators200ResponseInner]:  # noqa: E501
+        """List Conditions Operators  # noqa: E501
 
-        List App Rules  # noqa: E501
+        List Mappings' Conditions' Operators  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_app_rules(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, async_req=True)
+        >>> thread = api.list_mapping_conditions_operators(mapping_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition: str
-        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition_type: str
-        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
-        :type has_action: str
-        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
-        :type has_action_type: str
-        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
-        :type enabled: bool
+        :param mapping_condition_value: (required)
+        :type mapping_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[AppRule]
+        :rtype: List[ListMappingConditionsOperators200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_app_rules_with_http_info(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mapping_conditions_operators_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mapping_conditions_operators_with_http_info(mapping_condition_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_app_rules_with_http_info(self, app_id : StrictInt, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, **kwargs):  # noqa: E501
-        """List Rules  # noqa: E501
+    def list_mapping_conditions_operators_with_http_info(self, mapping_condition_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions Operators  # noqa: E501
 
-        List App Rules  # noqa: E501
+        List Mappings' Conditions' Operators  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_app_rules_with_http_info(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, async_req=True)
+        >>> thread = api.list_mapping_conditions_operators_with_http_info(mapping_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition: str
-        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition_type: str
-        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
-        :type has_action: str
-        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
-        :type has_action_type: str
-        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
-        :type enabled: bool
+        :param mapping_condition_value: (required)
+        :type mapping_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[AppRule], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[ListMappingConditionsOperators200ResponseInner], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'has_condition',
-            'has_condition_type',
-            'has_action',
-            'has_action_type',
-            'enabled'
+            'mapping_condition_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -899,44 +841,29 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_app_rules" % _key
+                    " to method list_mapping_conditions_operators" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
+        if _params['mapping_condition_value']:
+            _path_params['mapping_condition_value'] = _params['mapping_condition_value']
 
 
         # process the query parameters
         _query_params = []
-        if _params.get('has_condition') is not None:  # noqa: E501
-            _query_params.append(('has_condition', _params['has_condition']))
-
-        if _params.get('has_condition_type') is not None:  # noqa: E501
-            _query_params.append(('has_condition_type', _params['has_condition_type']))
-
-        if _params.get('has_action') is not None:  # noqa: E501
-            _query_params.append(('has_action', _params['has_action']))
-
-        if _params.get('has_action_type') is not None:  # noqa: E501
-            _query_params.append(('has_action_type', _params['has_action_type']))
-
-        if _params.get('enabled') is not None:  # noqa: E501
-            _query_params.append(('enabled', _params['enabled']))
-
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
@@ -944,20 +871,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[AppRule]",
-            '401': "AltErr",
+            '200': "List[ListMappingConditionsOperators200ResponseInner]",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules', 'GET',
+            '/api/2/mappings/conditions/{mapping_condition_value}/operators', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -966,90 +893,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_condition_operators(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> List[RuleCondition]:  # noqa: E501
-        """List Conditions Operators  # noqa: E501
+    def list_mapping_contion_values(self, mapping_condition_value : StrictStr, **kwargs) -> List[ListMappingContionValues200ResponseInner]:  # noqa: E501
+        """List Conditions Values  # noqa: E501
 
-        List Condition Operators  # noqa: E501
+        List Mappings'  Conditions' Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_condition_operators(app_id, rule_condition_value, async_req=True)
+        >>> thread = api.list_mapping_contion_values(mapping_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_condition_value: (required)
-        :type rule_condition_value: str
+        :param mapping_condition_value: (required)
+        :type mapping_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[RuleCondition]
+        :rtype: List[ListMappingContionValues200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_condition_operators_with_http_info(app_id, rule_condition_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mapping_contion_values_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mapping_contion_values_with_http_info(mapping_condition_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_condition_operators_with_http_info(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs):  # noqa: E501
-        """List Conditions Operators  # noqa: E501
+    def list_mapping_contion_values_with_http_info(self, mapping_condition_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions Values  # noqa: E501
 
-        List Condition Operators  # noqa: E501
+        List Mappings'  Conditions' Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_condition_operators_with_http_info(app_id, rule_condition_value, async_req=True)
+        >>> thread = api.list_mapping_contion_values_with_http_info(mapping_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_condition_value: (required)
-        :type rule_condition_value: str
+        :param mapping_condition_value: (required)
+        :type mapping_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[RuleCondition], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[ListMappingContionValues200ResponseInner], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_condition_value'
+            'mapping_condition_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1060,28 +981,25 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_condition_operators" % _key
+                    " to method list_mapping_contion_values" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_condition_value']:
-            _path_params['rule_condition_value'] = _params['rule_condition_value']
+        if _params['mapping_condition_value']:
+            _path_params['mapping_condition_value'] = _params['mapping_condition_value']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -1093,20 +1011,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[RuleCondition]",
-            '401': "AltErr",
+            '200': "List[ListMappingContionValues200ResponseInner]",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/conditions/{rule_condition_value}/operators', 'GET',
+            '/api/2/mappings/conditions/{mapping_condition_value}/values', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1115,90 +1033,104 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_condition_values(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> RuleCondition:  # noqa: E501
-        """List Conditions Values  # noqa: E501
+    def list_mappings(self, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, **kwargs) -> List[Mapping]:  # noqa: E501
+        """List Mappings  # noqa: E501
 
-        List Condition Values  # noqa: E501
+        List Mappings  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_condition_values(app_id, rule_condition_value, async_req=True)
+        >>> thread = api.list_mappings(enabled, has_condition, has_condition_type, has_action, has_action_type, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_condition_value: (required)
-        :type rule_condition_value: str
+        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
+        :type enabled: bool
+        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition: str
+        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition_type: str
+        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
+        :type has_action: str
+        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
+        :type has_action_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: RuleCondition
+        :rtype: List[Mapping]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_condition_values_with_http_info(app_id, rule_condition_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mappings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mappings_with_http_info(enabled, has_condition, has_condition_type, has_action, has_action_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_condition_values_with_http_info(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs):  # noqa: E501
-        """List Conditions Values  # noqa: E501
+    def list_mappings_with_http_info(self, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Mappings  # noqa: E501
 
-        List Condition Values  # noqa: E501
+        List Mappings  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_condition_values_with_http_info(app_id, rule_condition_value, async_req=True)
+        >>> thread = api.list_mappings_with_http_info(enabled, has_condition, has_condition_type, has_action, has_action_type, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_condition_value: (required)
-        :type rule_condition_value: str
+        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
+        :type enabled: bool
+        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition: str
+        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition_type: str
+        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
+        :type has_action: str
+        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
+        :type has_action_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(RuleCondition, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[Mapping], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_condition_value'
+            'enabled',
+            'has_condition',
+            'has_condition_type',
+            'has_action',
+            'has_action_type'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1209,32 +1141,41 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_condition_values" % _key
+                    " to method list_mappings" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_condition_value']:
-            _path_params['rule_condition_value'] = _params['rule_condition_value']
-
 
         # process the query parameters
         _query_params = []
+        if _params.get('enabled') is not None:  # noqa: E501
+            _query_params.append(('enabled', _params['enabled']))
+
+        if _params.get('has_condition') is not None:  # noqa: E501
+            _query_params.append(('has_condition', _params['has_condition']))
+
+        if _params.get('has_condition_type') is not None:  # noqa: E501
+            _query_params.append(('has_condition_type', _params['has_condition_type']))
+
+        if _params.get('has_action') is not None:  # noqa: E501
+            _query_params.append(('has_action', _params['has_action']))
+
+        if _params.get('has_action_type') is not None:  # noqa: E501
+            _query_params.append(('has_action_type', _params['has_action_type']))
+
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
@@ -1242,20 +1183,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "RuleCondition",
-            '401': "AltErr",
+            '200': "List[Mapping]",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/conditions/{rule_condition_value}/values', 'GET',
+            '/api/2/mappings', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1264,85 +1205,79 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_conditions(self, app_id : StrictInt, **kwargs) -> List[ListConditions200ResponseInner]:  # noqa: E501
-        """List Conditions  # noqa: E501
+    def list_mappings_actions(self, **kwargs) -> List[ListMappingsActions200ResponseInner]:  # noqa: E501
+        """List Actions  # noqa: E501
 
-        List App Conditions  # noqa: E501
+        List Mappings' Actions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_conditions(app_id, async_req=True)
+        >>> thread = api.list_mappings_actions(async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[ListConditions200ResponseInner]
+        :rtype: List[ListMappingsActions200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_conditions_with_http_info(app_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_mappings_actions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_mappings_actions_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_conditions_with_http_info(self, app_id : StrictInt, **kwargs):  # noqa: E501
-        """List Conditions  # noqa: E501
+    def list_mappings_actions_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Actions  # noqa: E501
 
-        List App Conditions  # noqa: E501
+        List Mappings' Actions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_conditions_with_http_info(app_id, async_req=True)
+        >>> thread = api.list_mappings_actions_with_http_info(async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[ListConditions200ResponseInner], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[ListMappingsActions200ResponseInner], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1353,26 +1288,23 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_conditions" % _key
+                    " to method list_mappings_actions" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
@@ -1383,20 +1315,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[ListConditions200ResponseInner]",
-            '401': "AltErr",
+            '200': "List[ListMappingsActions200ResponseInner]",
+            '401': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/conditions', 'GET',
+            '/api/2/mappings/actions', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1405,70 +1337,65 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def sort_app_rules(self, app_id : StrictInt, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> List[int]:  # noqa: E501
+    def sort_mappings(self, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> List[int]:  # noqa: E501
         """Bulk Sort  # noqa: E501
 
-        Sort App rules  # noqa: E501
+        Bulk Sort Mappings  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.sort_app_rules(app_id, request_body, async_req=True)
+        >>> thread = api.sort_mappings(request_body, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param request_body:
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[int]
         """
         kwargs['_return_http_data_only'] = True
-        return self.sort_app_rules_with_http_info(app_id, request_body, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the sort_mappings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.sort_mappings_with_http_info(request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def sort_app_rules_with_http_info(self, app_id : StrictInt, request_body : Optional[conlist(StrictInt)] = None, **kwargs):  # noqa: E501
+    def sort_mappings_with_http_info(self, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Bulk Sort  # noqa: E501
 
-        Sort App rules  # noqa: E501
+        Bulk Sort Mappings  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.sort_app_rules_with_http_info(app_id, request_body, async_req=True)
+        >>> thread = api.sort_mappings_with_http_info(request_body, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
         :param request_body:
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1479,15 +1406,14 @@
                  returns the request thread.
         :rtype: tuple(List[int], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
             'request_body'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -1499,37 +1425,34 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method sort_app_rules" % _key
+                    " to method sort_mappings" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1540,20 +1463,20 @@
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
             '200': "List[int]",
-            '401': "AltErr",
-            '422': "AltErr",
+            '401': "Error",
+            '422': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/sort', 'PUT',
+            '/api/2/mappings/sort', 'PUT',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1562,95 +1485,94 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def update_app_rule(self, app_id : StrictInt, rule_id : StrictStr, app_rule : Optional[AppRule] = None, **kwargs) -> AppRule:  # noqa: E501
-        """Update Rule  # noqa: E501
+    def update_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], content_type : Optional[StrictStr] = None, body : Optional[Dict[str, Any]] = None, **kwargs) -> int:  # noqa: E501
+        """Update Mapping  # noqa: E501
 
-        Update App Rule.  # noqa: E501
+        Update Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.update_app_rule(app_id, rule_id, app_rule, async_req=True)
+        >>> thread = api.update_mapping(mapping_id, content_type, body, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
-        :param app_rule:
-        :type app_rule: AppRule
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
+        :param content_type:
+        :type content_type: str
+        :param body:
+        :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: AppRule
+        :rtype: int
         """
         kwargs['_return_http_data_only'] = True
-        return self.update_app_rule_with_http_info(app_id, rule_id, app_rule, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_mapping_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.update_mapping_with_http_info(mapping_id, content_type, body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_app_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, app_rule : Optional[AppRule] = None, **kwargs):  # noqa: E501
-        """Update Rule  # noqa: E501
+    def update_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], content_type : Optional[StrictStr] = None, body : Optional[Dict[str, Any]] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """Update Mapping  # noqa: E501
 
-        Update App Rule.  # noqa: E501
+        Update Mapping  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.update_app_rule_with_http_info(app_id, rule_id, app_rule, async_req=True)
+        >>> thread = api.update_mapping_with_http_info(mapping_id, content_type, body, async_req=True)
         >>> result = thread.get()
 
-        :param app_id: (required)
-        :type app_id: int
-        :param rule_id: (required)
-        :type rule_id: str
-        :param app_rule:
-        :type app_rule: AppRule
+        :param mapping_id: The id of the user mapping to locate. (required)
+        :type mapping_id: int
+        :param content_type:
+        :type content_type: str
+        :param body:
+        :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(int, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'app_id',
-            'rule_id',
-            'app_rule'
+            'mapping_id',
+            'content_type',
+            'body'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1661,41 +1583,41 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_app_rule" % _key
+                    " to method update_mapping" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['app_id']:
-            _path_params['app_id'] = _params['app_id']
-
-        if _params['rule_id']:
-            _path_params['rule_id'] = _params['rule_id']
+        if _params['mapping_id']:
+            _path_params['mapping_id'] = _params['mapping_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
+        if _params['content_type']:
+            _header_params['Content-Type'] = _params['content_type']
+
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['app_rule']:
-            _body_params = _params['app_rule']
+        if _params['body'] is not None:
+            _body_params = _params['body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get('_content_type',
@@ -1704,21 +1626,21 @@
         if _content_types_list:
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "AppRule",
-            '401': "AltErr",
-            '422': "AltErr",
+            '200': "int",
+            '401': "Error",
+            '422': "Error",
         }
 
         return self.api_client.call_api(
-            '/api/2/apps/{app_id}/rules/{rule_id}', 'PUT',
+            '/api/2/mappings/{mapping_id}', 'PUT',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
```

### Comparing `onelogin-3.1.4/onelogin/api/apps_api.py` & `onelogin-3.1.5/onelogin/api/apps_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,14 +10,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictInt, StrictStr
 
 from typing import Any, Dict, List, Optional
@@ -24,14 +27,15 @@
 from onelogin.models.connector import Connector
 from onelogin.models.create_app200_response import CreateApp200Response
 from onelogin.models.create_app_request import CreateAppRequest
 from onelogin.models.generic_app import GenericApp
 from onelogin.models.user import User
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class AppsApi(object):
@@ -59,32 +63,30 @@
 
         :param content_type:
         :type content_type: str
         :param create_app_request:
         :type create_app_request: CreateAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CreateApp200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_app_with_http_info(content_type, create_app_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_app_with_http_info(self, content_type : Optional[StrictStr] = None, create_app_request : Optional[CreateAppRequest] = None, **kwargs):  # noqa: E501
+    def create_app_with_http_info(self, content_type : Optional[StrictStr] = None, create_app_request : Optional[CreateAppRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create App  # noqa: E501
 
         Create App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_app_with_http_info(content_type, create_app_request, async_req=True)
@@ -92,21 +94,22 @@
 
         :param content_type:
         :type content_type: str
         :param create_app_request:
         :type create_app_request: CreateAppRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -159,15 +162,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['create_app_request']:
+        if _params['create_app_request'] is not None:
             _body_params = _params['create_app_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -214,52 +217,51 @@
         >>> thread = api.delete_app(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_app_with_http_info(app_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_app_with_http_info(self, app_id : StrictInt, **kwargs):  # noqa: E501
+    def delete_app_with_http_info(self, app_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete App  # noqa: E501
 
         Delete App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_app_with_http_info(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -354,32 +356,30 @@
 
         :param app_id: (required)
         :type app_id: int
         :param parameter_id: (required)
         :type parameter_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_app_parameter_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_app_parameter_with_http_info(app_id, parameter_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_app_parameter_with_http_info(self, app_id : StrictInt, parameter_id : StrictStr, **kwargs):  # noqa: E501
+    def delete_app_parameter_with_http_info(self, app_id : StrictInt, parameter_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Parameter from App  # noqa: E501
 
         Delete Parameter from App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_app_parameter_with_http_info(app_id, parameter_id, async_req=True)
@@ -387,21 +387,22 @@
 
         :param app_id: (required)
         :type app_id: int
         :param parameter_id: (required)
         :type parameter_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -498,52 +499,51 @@
         >>> thread = api.get_app(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenericApp
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_app_with_http_info(app_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_app_with_http_info(self, app_id : StrictInt, **kwargs):  # noqa: E501
+    def get_app_with_http_info(self, app_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
         """Get App  # noqa: E501
 
         Get App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_app_with_http_info(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -640,52 +640,51 @@
         >>> thread = api.get_app_users(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[User]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_app_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_app_users_with_http_info(app_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_app_users_with_http_info(self, app_id : StrictInt, **kwargs):  # noqa: E501
+    def get_app_users_with_http_info(self, app_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
         """Get App Users  # noqa: E501
 
         Get App Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_app_users_with_http_info(app_id, async_req=True)
         >>> result = thread.get()
 
         :param app_id: (required)
         :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -779,50 +778,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_apps(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[GenericApp]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_apps_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_apps_with_http_info(self, **kwargs):  # noqa: E501
+    def list_apps_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """List Apps  # noqa: E501
 
         List Apps  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_apps_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -915,52 +913,51 @@
         >>> thread = api.list_connectors(name, async_req=True)
         >>> result = thread.get()
 
         :param name:
         :type name: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Connector
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_connectors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_connectors_with_http_info(name, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_connectors_with_http_info(self, name : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def list_connectors_with_http_info(self, name : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Connectors  # noqa: E501
 
         List Connectors  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_connectors_with_http_info(name, async_req=True)
         >>> result = thread.get()
 
         :param name:
         :type name: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1059,32 +1056,30 @@
 
         :param app_id: (required)
         :type app_id: int
         :param request_body:
         :type request_body: Dict[str, object]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenericApp
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_app_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_app_with_http_info(app_id, request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_app_with_http_info(self, app_id : StrictInt, request_body : Optional[Dict[str, Any]] = None, **kwargs):  # noqa: E501
+    def update_app_with_http_info(self, app_id : StrictInt, request_body : Optional[Dict[str, Any]] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update App  # noqa: E501
 
         Update App  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_app_with_http_info(app_id, request_body, async_req=True)
@@ -1092,21 +1087,22 @@
 
         :param app_id: (required)
         :type app_id: int
         :param request_body:
         :type request_body: Dict[str, object]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1159,15 +1155,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/branding_service_api.py` & `onelogin-3.1.5/onelogin/api/branding_service_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,28 +10,31 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt
 
 from typing import List, Optional
 
 from onelogin.models.brand import Brand
 from onelogin.models.brand_app import BrandApp
 from onelogin.models.brand_req import BrandReq
 from onelogin.models.request_brand import RequestBrand
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class BrandingServiceApi(object):
@@ -56,52 +60,51 @@
         >>> thread = api.create_brand(brand, async_req=True)
         >>> result = thread.get()
 
         :param brand:
         :type brand: Brand
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Brand
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_brand_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_brand_with_http_info(brand, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_brand_with_http_info(self, brand : Optional[Brand] = None, **kwargs):  # noqa: E501
+    def create_brand_with_http_info(self, brand : Optional[Brand] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Brand  # noqa: E501
 
         Create a new Account Brand  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_brand_with_http_info(brand, async_req=True)
         >>> result = thread.get()
 
         :param brand:
         :type brand: Brand
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -150,15 +153,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['brand']:
+        if _params['brand'] is not None:
             _body_params = _params['brand']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -205,52 +208,51 @@
         >>> thread = api.delete_brand(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_brand_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_brand_with_http_info(brand_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs):  # noqa: E501
+    def delete_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Brand  # noqa: E501
 
         Delete Brand  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_brand_with_http_info(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -343,52 +345,51 @@
         >>> thread = api.get_brand(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Brand
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_brand_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_brand_with_http_info(brand_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs):  # noqa: E501
+    def get_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Brand  # noqa: E501
 
         Retrieve a single brand via ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_brand_with_http_info(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -485,52 +486,51 @@
         >>> thread = api.get_brand_apps(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[BrandApp]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_brand_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_brand_apps_with_http_info(brand_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_brand_apps_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs):  # noqa: E501
+    def get_brand_apps_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Brand Apps  # noqa: E501
 
         Get Apps Associated with Account Brand  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_brand_apps_with_http_info(brand_id, async_req=True)
         >>> result = thread.get()
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -625,50 +625,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_brands(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[BrandReq]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_brands_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_brands_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_brands_with_http_info(self, **kwargs):  # noqa: E501
+    def list_brands_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """List Account Brands  # noqa: E501
 
         List Account Brands  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_brands_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -761,32 +760,30 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param request_brand:
         :type request_brand: RequestBrand
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Brand
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_brand_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_brand_with_http_info(brand_id, request_brand, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], request_brand : Optional[RequestBrand] = None, **kwargs):  # noqa: E501
+    def update_brand_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], request_brand : Optional[RequestBrand] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Brand  # noqa: E501
 
         Update Account Brand  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_brand_with_http_info(brand_id, request_brand, async_req=True)
@@ -794,21 +791,22 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param request_brand:
         :type request_brand: RequestBrand
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -861,15 +859,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_brand']:
+        if _params['request_brand'] is not None:
             _body_params = _params['request_brand']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/branding_service_smtp_api.py` & `onelogin-3.1.5/onelogin/api/branding_service_smtp_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,25 +10,28 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from typing import Optional
 
 from onelogin.models.alt_err import AltErr
 from onelogin.models.email_config import EmailConfig
 from onelogin.models.get_email_settings200_response import GetEmailSettings200Response
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class BrandingServiceSMTPApi(object):
@@ -51,50 +55,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_email_settings(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AltErr
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_email_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_email_settings_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_email_settings_with_http_info(self, **kwargs):  # noqa: E501
+    def delete_email_settings_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Custom Email Settings  # noqa: E501
 
         Reset Email Setting config  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_email_settings_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -184,50 +187,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_email_settings(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEmailSettings200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_email_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_email_settings_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_email_settings_with_http_info(self, **kwargs):  # noqa: E501
+    def get_email_settings_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Email Settings  # noqa: E501
 
         Get Email Settings Config  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_email_settings_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -319,52 +321,51 @@
         >>> thread = api.update_email_settings(email_config, async_req=True)
         >>> result = thread.get()
 
         :param email_config:
         :type email_config: EmailConfig
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AltErr
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_email_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_email_settings_with_http_info(email_config, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_email_settings_with_http_info(self, email_config : Optional[EmailConfig] = None, **kwargs):  # noqa: E501
+    def update_email_settings_with_http_info(self, email_config : Optional[EmailConfig] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Email Settings  # noqa: E501
 
         Update Email Settings Config  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_email_settings_with_http_info(email_config, async_req=True)
         >>> result = thread.get()
 
         :param email_config:
         :type email_config: EmailConfig
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -413,15 +414,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['email_config']:
+        if _params['email_config'] is not None:
             _body_params = _params['email_config']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/branding_service_templates_api.py` & `onelogin-3.1.5/onelogin/api/branding_service_templates_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,26 +9,29 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr, constr, validator
 
 from typing import List, Optional
 
 from onelogin.models.list_message_templates200_response_inner import ListMessageTemplates200ResponseInner
 from onelogin.models.message_template import MessageTemplate
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class BrandingServiceTemplatesApi(object):
@@ -58,32 +61,30 @@
         :type brand_id: int
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish
         :type locale: str
         :param message_template:
         :type message_template: MessageTemplate
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_message_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_message_template_with_http_info(brand_id, locale, message_template, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_message_template_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], locale : Annotated[Optional[constr(strict=True)], Field(description="The 2 character language locale for the template. e.g. en = English, es = Spanish")] = None, message_template : Optional[MessageTemplate] = None, **kwargs):  # noqa: E501
+    def create_message_template_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], locale : Annotated[Optional[constr(strict=True)], Field(description="The 2 character language locale for the template. e.g. en = English, es = Spanish")] = None, message_template : Optional[MessageTemplate] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Message Template  # noqa: E501
 
         Create Message Template  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_message_template_with_http_info(brand_id, locale, message_template, async_req=True)
@@ -93,21 +94,22 @@
         :type brand_id: int
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish
         :type locale: str
         :param message_template:
         :type message_template: MessageTemplate
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -164,15 +166,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['message_template']:
+        if _params['message_template'] is not None:
             _body_params = _params['message_template']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -221,32 +223,30 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_message_template_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_message_template_with_http_info(brand_id, template_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_message_template_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs):  # noqa: E501
+    def delete_message_template_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Message Template  # noqa: E501
 
         Delete Message Template  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_message_template_with_http_info(brand_id, template_id, async_req=True)
@@ -254,21 +254,22 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -365,52 +366,51 @@
         >>> thread = api.get_master_by_type(template_type, async_req=True)
         >>> result = thread.get()
 
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_master_by_type_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_master_by_type_with_http_info(template_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_master_by_type_with_http_info(self, template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], **kwargs):  # noqa: E501
+    def get_master_by_type_with_http_info(self, template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Master Template by Type  # noqa: E501
 
         Get Master Template by Type  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_master_by_type_with_http_info(template_type, async_req=True)
         >>> result = thread.get()
 
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -509,32 +509,30 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_message_template_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_message_template_by_id_with_http_info(brand_id, template_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_message_template_by_id_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs):  # noqa: E501
+    def get_message_template_by_id_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Message Template  # noqa: E501
 
         Get Message Template by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_message_template_by_id_with_http_info(brand_id, template_id, async_req=True)
@@ -542,21 +540,22 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -661,32 +660,30 @@
         :type brand_id: int
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish (required)
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_template_by_locale_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_template_by_locale_with_http_info(brand_id, template_type, locale, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_template_by_locale_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], locale : Annotated[constr(strict=True), Field(..., description="The 2 character language locale for the template. e.g. en = English, es = Spanish")], **kwargs):  # noqa: E501
+    def get_template_by_locale_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], locale : Annotated[constr(strict=True), Field(..., description="The 2 character language locale for the template. e.g. en = English, es = Spanish")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Template by Type & Locale  # noqa: E501
 
         Get Template by Type and Locale  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_template_by_locale_with_http_info(brand_id, template_type, locale, async_req=True)
@@ -696,21 +693,22 @@
         :type brand_id: int
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish (required)
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -817,32 +815,30 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[ListMessageTemplates200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_message_templates_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_message_templates_with_http_info(brand_id, locale, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_message_templates_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], locale : Annotated[Optional[constr(strict=True)], Field(description="The 2 character language locale for the template. e.g. en = English, es = Spanish")] = None, **kwargs):  # noqa: E501
+    def list_message_templates_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], locale : Annotated[Optional[constr(strict=True)], Field(description="The 2 character language locale for the template. e.g. en = English, es = Spanish")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Message Templates  # noqa: E501
 
         List Message Templates  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_message_templates_with_http_info(brand_id, locale, async_req=True)
@@ -850,21 +846,22 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -967,32 +964,30 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_message_template_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_message_template_by_id_with_http_info(brand_id, template_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_message_template_by_id_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs):  # noqa: E501
+    def update_message_template_by_id_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_id : Annotated[StrictInt, Field(..., description="Unique identifier for the template to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Update Message Template  # noqa: E501
 
         Update Message Template by ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_message_template_by_id_with_http_info(brand_id, template_id, async_req=True)
@@ -1000,21 +995,22 @@
 
         :param brand_id: Unique identifier for the branding object. (required)
         :type brand_id: int
         :param template_id: Unique identifier for the template to return. (required)
         :type template_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1119,32 +1115,30 @@
         :type brand_id: int
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish (required)
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: MessageTemplate
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_template_by_locale_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_template_by_locale_with_http_info(brand_id, template_type, locale, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_template_by_locale_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], locale : Annotated[constr(strict=True), Field(..., description="The 2 character language locale for the template. e.g. en = English, es = Spanish")], **kwargs):  # noqa: E501
+    def update_template_by_locale_with_http_info(self, brand_id : Annotated[StrictInt, Field(..., description="Unique identifier for the branding object.")], template_type : Annotated[StrictStr, Field(..., description="The message template type to return.")], locale : Annotated[constr(strict=True), Field(..., description="The 2 character language locale for the template. e.g. en = English, es = Spanish")], **kwargs) -> ApiResponse:  # noqa: E501
         """Update Template by Type & Locale  # noqa: E501
 
         Update Template by Type and Locale  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_template_by_locale_with_http_info(brand_id, template_type, locale, async_req=True)
@@ -1154,21 +1148,22 @@
         :type brand_id: int
         :param template_type: The message template type to return. (required)
         :type template_type: str
         :param locale: The 2 character language locale for the template. e.g. en = English, es = Spanish (required)
         :type locale: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `onelogin-3.1.4/onelogin/api/events_api.py` & `onelogin-3.1.5/onelogin/api/events_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,27 +9,30 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr, conlist
 
 from typing import Optional
 
 from onelogin.models.get_event_by_id200_response import GetEventById200Response
 from onelogin.models.get_event_types200_response import GetEventTypes200Response
 from onelogin.models.get_events200_response import GetEvents200Response
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class EventsApi(object):
@@ -55,52 +58,51 @@
         >>> thread = api.get_event_by_id(event_id, async_req=True)
         >>> result = thread.get()
 
         :param event_id: (required)
         :type event_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEventById200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_event_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_event_by_id_with_http_info(event_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_event_by_id_with_http_info(self, event_id : StrictInt, **kwargs):  # noqa: E501
+    def get_event_by_id_with_http_info(self, event_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Event by ID  # noqa: E501
 
         Get Event By ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_event_by_id_with_http_info(event_id, async_req=True)
         >>> result = thread.get()
 
         :param event_id: (required)
         :type event_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -198,52 +200,51 @@
         >>> thread = api.get_event_types(content_type, async_req=True)
         >>> result = thread.get()
 
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEventTypes200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_event_types_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_event_types_with_http_info(content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_event_types_with_http_info(self, content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def get_event_types_with_http_info(self, content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Event Types  # noqa: E501
 
         Get Event types  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_event_types_with_http_info(content_type, async_req=True)
         >>> result = thread.get()
 
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -354,32 +355,30 @@
         :type since: str
         :param until:
         :type until: str
         :param user_id: Set to the id of the user that you want to return.
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEvents200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_events_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_events_with_http_info(event_type_id, client_id, directory_id, id, created_at, resolution, since, until, user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_events_with_http_info(self, event_type_id : Optional[conlist(StrictInt)] = None, client_id : Optional[StrictInt] = None, directory_id : Optional[StrictInt] = None, id : Optional[StrictInt] = None, created_at : Optional[StrictStr] = None, resolution : Optional[StrictStr] = None, since : Optional[StrictStr] = None, until : Optional[StrictStr] = None, user_id : Annotated[Optional[StrictInt], Field(description="Set to the id of the user that you want to return.")] = None, **kwargs):  # noqa: E501
+    def get_events_with_http_info(self, event_type_id : Optional[conlist(StrictInt)] = None, client_id : Optional[StrictInt] = None, directory_id : Optional[StrictInt] = None, id : Optional[StrictInt] = None, created_at : Optional[StrictStr] = None, resolution : Optional[StrictStr] = None, since : Optional[StrictStr] = None, until : Optional[StrictStr] = None, user_id : Annotated[Optional[StrictInt], Field(description="Set to the id of the user that you want to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Events  # noqa: E501
 
         Get Events  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_events_with_http_info(event_type_id, client_id, directory_id, id, created_at, resolution, since, until, user_id, async_req=True)
@@ -401,21 +400,22 @@
         :type since: str
         :param until:
         :type until: str
         :param user_id: Set to the id of the user that you want to return.
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `onelogin-3.1.4/onelogin/api/groups_api.py` & `onelogin-3.1.5/onelogin/api/groups_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,23 +9,26 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictStr
 
 from onelogin.models.get_groups200_response import GetGroups200Response
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class GroupsApi(object):
@@ -51,52 +54,51 @@
         >>> thread = api.get_group_by_id(group_id, async_req=True)
         >>> result = thread.get()
 
         :param group_id: (required)
         :type group_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetGroups200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_group_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_group_by_id_with_http_info(group_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_group_by_id_with_http_info(self, group_id : StrictStr, **kwargs):  # noqa: E501
+    def get_group_by_id_with_http_info(self, group_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Group by ID  # noqa: E501
 
         Get Group By ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_group_by_id_with_http_info(group_id, async_req=True)
         >>> result = thread.get()
 
         :param group_id: (required)
         :type group_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -192,50 +194,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_groups(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetGroups200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_groups_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_groups_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_groups_with_http_info(self, **kwargs):  # noqa: E501
+    def get_groups_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Groups  # noqa: E501
 
         Get Groups  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_groups_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `onelogin-3.1.4/onelogin/api/invite_links_api.py` & `onelogin-3.1.5/onelogin/api/invite_links_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,26 +9,29 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from typing import Optional
 
 from onelogin.models.get_invite_link200_response import GetInviteLink200Response
 from onelogin.models.get_invite_link_request import GetInviteLinkRequest
 from onelogin.models.send_invite_link200_response import SendInviteLink200Response
 from onelogin.models.send_invite_link_request import SendInviteLinkRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class InviteLinksApi(object):
@@ -54,52 +57,51 @@
         >>> thread = api.get_invite_link(get_invite_link_request, async_req=True)
         >>> result = thread.get()
 
         :param get_invite_link_request:
         :type get_invite_link_request: GetInviteLinkRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetInviteLink200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_invite_link_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_invite_link_with_http_info(get_invite_link_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_invite_link_with_http_info(self, get_invite_link_request : Optional[GetInviteLinkRequest] = None, **kwargs):  # noqa: E501
+    def get_invite_link_with_http_info(self, get_invite_link_request : Optional[GetInviteLinkRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate Invite Link  # noqa: E501
 
         Generate Invite Link  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_invite_link_with_http_info(get_invite_link_request, async_req=True)
         >>> result = thread.get()
 
         :param get_invite_link_request:
         :type get_invite_link_request: GetInviteLinkRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -148,15 +150,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['get_invite_link_request']:
+        if _params['get_invite_link_request'] is not None:
             _body_params = _params['get_invite_link_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -203,52 +205,51 @@
         >>> thread = api.send_invite_link(send_invite_link_request, async_req=True)
         >>> result = thread.get()
 
         :param send_invite_link_request:
         :type send_invite_link_request: SendInviteLinkRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SendInviteLink200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the send_invite_link_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.send_invite_link_with_http_info(send_invite_link_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def send_invite_link_with_http_info(self, send_invite_link_request : Optional[SendInviteLinkRequest] = None, **kwargs):  # noqa: E501
+    def send_invite_link_with_http_info(self, send_invite_link_request : Optional[SendInviteLinkRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Send  Invite Link  # noqa: E501
 
         Send Invite Link  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.send_invite_link_with_http_info(send_invite_link_request, async_req=True)
         >>> result = thread.get()
 
         :param send_invite_link_request:
         :type send_invite_link_request: SendInviteLinkRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -297,15 +298,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['send_invite_link_request']:
+        if _params['send_invite_link_request'] is not None:
             _body_params = _params['send_invite_link_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/multi_factor_authentication_api.py` & `onelogin-3.1.5/onelogin/api/multi_factor_authentication_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,14 +9,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr
 
 from typing import Any, Dict, List, Optional
@@ -32,14 +34,15 @@
 from onelogin.models.get_authentication_devices200_response_inner import GetAuthenticationDevices200ResponseInner
 from onelogin.models.get_user_verification200_response import GetUserVerification200Response
 from onelogin.models.verify_user_registration200_response import VerifyUserRegistration200Response
 from onelogin.models.verify_user_registration_request import VerifyUserRegistrationRequest
 from onelogin.models.verify_user_verification_request import VerifyUserVerificationRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class MultiFactorAuthenticationApi(object):
@@ -69,32 +72,30 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param create_device_verification_request:
         :type create_device_verification_request: CreateDeviceVerificationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CreateDeviceVerification201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_device_verification_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_device_verification_with_http_info(user_id, content_type, create_device_verification_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_device_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, create_device_verification_request : Optional[CreateDeviceVerificationRequest] = None, **kwargs):  # noqa: E501
+    def create_device_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, create_device_verification_request : Optional[CreateDeviceVerificationRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Device Verification  # noqa: E501
 
         Create a new verification process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_device_verification_with_http_info(user_id, content_type, create_device_verification_request, async_req=True)
@@ -104,21 +105,22 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param create_device_verification_request:
         :type create_device_verification_request: CreateDeviceVerificationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -175,15 +177,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['create_device_verification_request']:
+        if _params['create_device_verification_request'] is not None:
             _body_params = _params['create_device_verification_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -233,32 +235,30 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param create_factor_registration_request:
         :type create_factor_registration_request: CreateFactorRegistrationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CreateFactorRegistration201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_factor_registration_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_factor_registration_with_http_info(user_id, content_type, create_factor_registration_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_factor_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, create_factor_registration_request : Optional[CreateFactorRegistrationRequest] = None, **kwargs):  # noqa: E501
+    def create_factor_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, create_factor_registration_request : Optional[CreateFactorRegistrationRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Factor Registration  # noqa: E501
 
         Create a new registration process  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_factor_registration_with_http_info(user_id, content_type, create_factor_registration_request, async_req=True)
@@ -268,21 +268,22 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param create_factor_registration_request:
         :type create_factor_registration_request: CreateFactorRegistrationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -339,15 +340,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['create_factor_registration_request']:
+        if _params['create_factor_registration_request'] is not None:
             _body_params = _params['create_factor_registration_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -395,32 +396,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_enrolled_factor_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_enrolled_factor_with_http_info(user_id, device_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_enrolled_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, **kwargs):  # noqa: E501
+    def delete_enrolled_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Enrolled Factor  # noqa: E501
 
         Delete a user\\'s authentication device  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_enrolled_factor_with_http_info(user_id, device_id, async_req=True)
@@ -428,21 +427,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -539,32 +539,30 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param generate_otp_request:
         :type generate_otp_request: GenerateOTPRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenerateOTP201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the generate_otp_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.generate_otp_with_http_info(user_id, content_type, generate_otp_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def generate_otp_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, generate_otp_request : Optional[GenerateOTPRequest] = None, **kwargs):  # noqa: E501
+    def generate_otp_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], content_type : Optional[StrictStr] = None, generate_otp_request : Optional[GenerateOTPRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate MFA token  # noqa: E501
 
         Create new MFA token on the user's account  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.generate_otp_with_http_info(user_id, content_type, generate_otp_request, async_req=True)
@@ -574,21 +572,22 @@
         :type user_id: int
         :param content_type:
         :type content_type: str
         :param generate_otp_request:
         :type generate_otp_request: GenerateOTPRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -645,15 +644,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['generate_otp_request']:
+        if _params['generate_otp_request'] is not None:
             _body_params = _params['generate_otp_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -700,52 +699,51 @@
         >>> thread = api.get_auth_factors(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetAuthFactors200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_auth_factors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_auth_factors_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_auth_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_auth_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User Factors  # noqa: E501
 
         Get a user\\'s available authentication factors  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_auth_factors_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -841,52 +839,51 @@
         >>> thread = api.get_authentication_devices(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[GetAuthenticationDevices200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_authentication_devices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_authentication_devices_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_authentication_devices_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_authentication_devices_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User Devices  # noqa: E501
 
         Get a user authentication devices  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_authentication_devices_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -984,32 +981,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param registration_id: The id of a registration (required)
         :type registration_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: object
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_registration_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_registration_with_http_info(user_id, registration_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], registration_id : Annotated[StrictStr, Field(..., description="The id of a registration")], **kwargs):  # noqa: E501
+    def get_user_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], registration_id : Annotated[StrictStr, Field(..., description="The id of a registration")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User Registration  # noqa: E501
 
         Get registration state by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_registration_with_http_info(user_id, registration_id, async_req=True)
@@ -1017,21 +1012,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param registration_id: The id of a registration (required)
         :type registration_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1133,32 +1129,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param verification_id: The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call. (required)
         :type verification_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetUserVerification200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_verification_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_verification_with_http_info(user_id, verification_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], verification_id : Annotated[StrictStr, Field(..., description="The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call.")], **kwargs):  # noqa: E501
+    def get_user_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], verification_id : Annotated[StrictStr, Field(..., description="The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User Verification  # noqa: E501
 
         Get verification state by id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_verification_with_http_info(user_id, verification_id, async_req=True)
@@ -1166,21 +1160,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param verification_id: The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call. (required)
         :type verification_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1287,32 +1282,30 @@
         :type registration_id: str
         :param content_type:
         :type content_type: str
         :param verify_user_registration_request:
         :type verify_user_registration_request: VerifyUserRegistrationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VerifyUserRegistration200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the verify_user_registration_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.verify_user_registration_with_http_info(user_id, registration_id, content_type, verify_user_registration_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def verify_user_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], registration_id : Annotated[StrictStr, Field(..., description="The id of a registration")], content_type : Optional[StrictStr] = None, verify_user_registration_request : Optional[VerifyUserRegistrationRequest] = None, **kwargs):  # noqa: E501
+    def verify_user_registration_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], registration_id : Annotated[StrictStr, Field(..., description="The id of a registration")], content_type : Optional[StrictStr] = None, verify_user_registration_request : Optional[VerifyUserRegistrationRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Verify User Registration  # noqa: E501
 
         Submit an otp for verification.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.verify_user_registration_with_http_info(user_id, registration_id, content_type, verify_user_registration_request, async_req=True)
@@ -1324,21 +1317,22 @@
         :type registration_id: str
         :param content_type:
         :type content_type: str
         :param verify_user_registration_request:
         :type verify_user_registration_request: VerifyUserRegistrationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1399,15 +1393,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['verify_user_registration_request']:
+        if _params['verify_user_registration_request'] is not None:
             _body_params = _params['verify_user_registration_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1459,32 +1453,30 @@
         :type verification_id: str
         :param content_type:
         :type content_type: str
         :param verify_user_verification_request:
         :type verify_user_verification_request: VerifyUserVerificationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the verify_user_verification_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.verify_user_verification_with_http_info(user_id, verification_id, content_type, verify_user_verification_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def verify_user_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], verification_id : Annotated[StrictStr, Field(..., description="The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call.")], content_type : Optional[StrictStr] = None, verify_user_verification_request : Optional[VerifyUserVerificationRequest] = None, **kwargs):  # noqa: E501
+    def verify_user_verification_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], verification_id : Annotated[StrictStr, Field(..., description="The verification_id is returned on activation of the factor or you can get the device_id using the Activate Factor API call.")], content_type : Optional[StrictStr] = None, verify_user_verification_request : Optional[VerifyUserVerificationRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Verify User Verification  # noqa: E501
 
         Submit an otp for verification.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.verify_user_verification_with_http_info(user_id, verification_id, content_type, verify_user_verification_request, async_req=True)
@@ -1496,21 +1488,22 @@
         :type verification_id: str
         :param content_type:
         :type content_type: str
         :param verify_user_verification_request:
         :type verify_user_verification_request: VerifyUserVerificationRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1571,15 +1564,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['verify_user_verification_request']:
+        if _params['verify_user_verification_request'] is not None:
             _body_params = _params['verify_user_verification_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/multi_factor_authentication_v1_api.py` & `onelogin-3.1.5/onelogin/api/multi_factor_authentication_v1_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,14 +9,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr
 
 from typing import Optional
@@ -28,14 +30,15 @@
 from onelogin.models.generate_mf_atoken_request import GenerateMFAtokenRequest
 from onelogin.models.get_enrolled_factors200_response import GetEnrolledFactors200Response
 from onelogin.models.get_mfa_factors200_response import GetMFAFactors200Response
 from onelogin.models.otp_device import OtpDevice
 from onelogin.models.verify_mfa_factor_request import VerifyMfaFactorRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class MultiFactorAuthenticationV1Api(object):
@@ -65,32 +68,30 @@
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param activate_mfa_factors_request:
         :type activate_mfa_factors_request: ActivateMfaFactorsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEnrolledFactors200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the activate_mfa_factors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.activate_mfa_factors_with_http_info(user_id, device_id, activate_mfa_factors_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def activate_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, activate_mfa_factors_request : Optional[ActivateMfaFactorsRequest] = None, **kwargs):  # noqa: E501
+    def activate_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, activate_mfa_factors_request : Optional[ActivateMfaFactorsRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Activate a Factor  # noqa: E501
 
         Activate a Factor  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.activate_mfa_factors_with_http_info(user_id, device_id, activate_mfa_factors_request, async_req=True)
@@ -100,21 +101,22 @@
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param activate_mfa_factors_request:
         :type activate_mfa_factors_request: ActivateMfaFactorsRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -171,15 +173,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['activate_mfa_factors_request']:
+        if _params['activate_mfa_factors_request'] is not None:
             _body_params = _params['activate_mfa_factors_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -228,32 +230,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param otp_device:
         :type otp_device: OtpDevice
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EnrollMfaFactor200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the enroll_mfa_factor_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.enroll_mfa_factor_with_http_info(user_id, otp_device, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def enroll_mfa_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], otp_device : Optional[OtpDevice] = None, **kwargs):  # noqa: E501
+    def enroll_mfa_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], otp_device : Optional[OtpDevice] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Enroll a Factor  # noqa: E501
 
          Enroll an Authentication Factor  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.enroll_mfa_factor_with_http_info(user_id, otp_device, async_req=True)
@@ -261,21 +261,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param otp_device:
         :type otp_device: OtpDevice
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -328,15 +329,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['otp_device']:
+        if _params['otp_device'] is not None:
             _body_params = _params['otp_device']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -385,32 +386,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param generate_mf_atoken_request:
         :type generate_mf_atoken_request: GenerateMFAtokenRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenerateMFAtoken200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the generate_mf_atoken_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.generate_mf_atoken_with_http_info(user_id, generate_mf_atoken_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def generate_mf_atoken_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], generate_mf_atoken_request : Optional[GenerateMFAtokenRequest] = None, **kwargs):  # noqa: E501
+    def generate_mf_atoken_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], generate_mf_atoken_request : Optional[GenerateMFAtokenRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate Temp MFA Token  # noqa: E501
 
         Generate MFA Token  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.generate_mf_atoken_with_http_info(user_id, generate_mf_atoken_request, async_req=True)
@@ -418,21 +417,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param generate_mf_atoken_request:
         :type generate_mf_atoken_request: GenerateMFAtokenRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -485,15 +485,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['generate_mf_atoken_request']:
+        if _params['generate_mf_atoken_request'] is not None:
             _body_params = _params['generate_mf_atoken_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -538,52 +538,51 @@
         >>> thread = api.get_enrolled_factors(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetEnrolledFactors200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_enrolled_factors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_enrolled_factors_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_enrolled_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_enrolled_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Enrolled Factors  # noqa: E501
 
         Get Enrolled Factors  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_enrolled_factors_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -680,52 +679,51 @@
         >>> thread = api.get_mfa_factors(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetMFAFactors200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_mfa_factors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_mfa_factors_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Available Factors  # noqa: E501
 
         Get MFA Factors  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_mfa_factors_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -825,32 +823,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the remove_mfa_factors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.remove_mfa_factors_with_http_info(user_id, device_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def remove_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, **kwargs):  # noqa: E501
+    def remove_mfa_factors_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Remove an Enrolled Factor  # noqa: E501
 
         Remove an enrolled MFA device for a user  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.remove_mfa_factors_with_http_info(user_id, device_id, async_req=True)
@@ -858,21 +854,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -973,32 +970,30 @@
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param verify_mfa_factor_request:
         :type verify_mfa_factor_request: VerifyMfaFactorRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the verify_mfa_factor_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.verify_mfa_factor_with_http_info(user_id, device_id, verify_mfa_factor_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def verify_mfa_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, verify_mfa_factor_request : Optional[VerifyMfaFactorRequest] = None, **kwargs):  # noqa: E501
+    def verify_mfa_factor_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], device_id : StrictStr, verify_mfa_factor_request : Optional[VerifyMfaFactorRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Verify a Factor  # noqa: E501
 
         Verify a Factor  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.verify_mfa_factor_with_http_info(user_id, device_id, verify_mfa_factor_request, async_req=True)
@@ -1008,21 +1003,22 @@
         :type user_id: int
         :param device_id: (required)
         :type device_id: str
         :param verify_mfa_factor_request:
         :type verify_mfa_factor_request: VerifyMfaFactorRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1079,15 +1075,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['verify_mfa_factor_request']:
+        if _params['verify_mfa_factor_request'] is not None:
             _body_params = _params['verify_mfa_factor_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/o_auth2_api.py` & `onelogin-3.1.5/onelogin/api/o_auth2_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictStr
 
 from typing import Optional
@@ -24,14 +26,15 @@
 from onelogin.models.error import Error
 from onelogin.models.generate_token_request import GenerateTokenRequest
 from onelogin.models.get_rate_limit200_response import GetRateLimit200Response
 from onelogin.models.oauth_token import OauthToken
 from onelogin.models.revoke_tokens_request import RevokeTokensRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class OAuth2Api(object):
@@ -59,32 +62,30 @@
 
         :param generate_token_request: Request Body to Generate OAuth Token (required)
         :type generate_token_request: GenerateTokenRequest
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OauthToken
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the generate_token_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.generate_token_with_http_info(generate_token_request, content_type, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def generate_token_with_http_info(self, generate_token_request : Annotated[GenerateTokenRequest, Field(..., description="Request Body to Generate OAuth Token")], content_type : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def generate_token_with_http_info(self, generate_token_request : Annotated[GenerateTokenRequest, Field(..., description="Request Body to Generate OAuth Token")], content_type : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate Token  # noqa: E501
 
         Generate Token  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.generate_token_with_http_info(generate_token_request, content_type, async_req=True)
@@ -92,21 +93,22 @@
 
         :param generate_token_request: Request Body to Generate OAuth Token (required)
         :type generate_token_request: GenerateTokenRequest
         :param content_type:
         :type content_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -159,15 +161,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['generate_token_request']:
+        if _params['generate_token_request'] is not None:
             _body_params = _params['generate_token_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -213,50 +215,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_rate_limit(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetRateLimit200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_rate_limit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_rate_limit_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_rate_limit_with_http_info(self, **kwargs):  # noqa: E501
+    def get_rate_limit_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Rate Limit  # noqa: E501
 
         Get Rate Limit  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_rate_limit_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -352,32 +353,30 @@
 
         :param content_type:
         :type content_type: str
         :param revoke_tokens_request:
         :type revoke_tokens_request: RevokeTokensRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the revoke_tokens_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.revoke_tokens_with_http_info(content_type, revoke_tokens_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def revoke_tokens_with_http_info(self, content_type : Optional[StrictStr] = None, revoke_tokens_request : Optional[RevokeTokensRequest] = None, **kwargs):  # noqa: E501
+    def revoke_tokens_with_http_info(self, content_type : Optional[StrictStr] = None, revoke_tokens_request : Optional[RevokeTokensRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Revoke Tokens  # noqa: E501
 
         Revoke Tokens  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.revoke_tokens_with_http_info(content_type, revoke_tokens_request, async_req=True)
@@ -385,21 +384,22 @@
 
         :param content_type:
         :type content_type: str
         :param revoke_tokens_request:
         :type revoke_tokens_request: RevokeTokensRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -452,15 +452,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['revoke_tokens_request']:
+        if _params['revoke_tokens_request'] is not None:
             _body_params = _params['revoke_tokens_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/privileges_api.py` & `onelogin-3.1.5/onelogin/api/privileges_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,32 +9,34 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.add_privilege_to_role201_response import AddPrivilegeToRole201Response
 from onelogin.models.add_privilege_to_role_request import AddPrivilegeToRoleRequest
 from onelogin.models.assign_users_to_privilege_request import AssignUsersToPrivilegeRequest
-from onelogin.models.create_privilege200_response import CreatePrivilege200Response
 from onelogin.models.get_assigned_user200_response import GetAssignedUser200Response
-from onelogin.models.list_privelege_roles200_response import ListPrivelegeRoles200Response
+from onelogin.models.list_privilege_roles200_response import ListPrivilegeRoles200Response
 from onelogin.models.privilege import Privilege
 from onelogin.models.update_privilege200_response import UpdatePrivilege200Response
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class PrivilegesApi(object):
@@ -62,32 +64,30 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param add_privilege_to_role_request:
         :type add_privilege_to_role_request: AddPrivilegeToRoleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AddPrivilegeToRole201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the add_privilege_to_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.add_privilege_to_role_with_http_info(privilege_id, add_privilege_to_role_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def add_privilege_to_role_with_http_info(self, privilege_id : StrictStr, add_privilege_to_role_request : Optional[AddPrivilegeToRoleRequest] = None, **kwargs):  # noqa: E501
+    def add_privilege_to_role_with_http_info(self, privilege_id : StrictStr, add_privilege_to_role_request : Optional[AddPrivilegeToRoleRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Assign a Privilege to Roles  # noqa: E501
 
         Add roles to privilege   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.add_privilege_to_role_with_http_info(privilege_id, add_privilege_to_role_request, async_req=True)
@@ -95,21 +95,22 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param add_privilege_to_role_request:
         :type add_privilege_to_role_request: AddPrivilegeToRoleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -162,15 +163,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['add_privilege_to_role_request']:
+        if _params['add_privilege_to_role_request'] is not None:
             _body_params = _params['add_privilege_to_role_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -219,32 +220,30 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param assign_users_to_privilege_request:
         :type assign_users_to_privilege_request: AssignUsersToPrivilegeRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AddPrivilegeToRole201Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the assign_users_to_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.assign_users_to_privilege_with_http_info(privilege_id, assign_users_to_privilege_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def assign_users_to_privilege_with_http_info(self, privilege_id : StrictStr, assign_users_to_privilege_request : Optional[AssignUsersToPrivilegeRequest] = None, **kwargs):  # noqa: E501
+    def assign_users_to_privilege_with_http_info(self, privilege_id : StrictStr, assign_users_to_privilege_request : Optional[AssignUsersToPrivilegeRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Assign Users to a Privilege  # noqa: E501
 
         Assign Users to Privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.assign_users_to_privilege_with_http_info(privilege_id, assign_users_to_privilege_request, async_req=True)
@@ -252,21 +251,22 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param assign_users_to_privilege_request:
         :type assign_users_to_privilege_request: AssignUsersToPrivilegeRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -319,15 +319,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['assign_users_to_privilege_request']:
+        if _params['assign_users_to_privilege_request'] is not None:
             _body_params = _params['assign_users_to_privilege_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -360,79 +360,78 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def create_privilege(self, privilege : Optional[Privilege] = None, **kwargs) -> CreatePrivilege200Response:  # noqa: E501
+    def create_privilege(self, privilege : Optional[Privilege] = None, **kwargs) -> Privilege:  # noqa: E501
         """Create a Privilege  # noqa: E501
 
         Create privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_privilege(privilege, async_req=True)
         >>> result = thread.get()
 
         :param privilege:
         :type privilege: Privilege
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: CreatePrivilege200Response
+        :rtype: Privilege
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_privilege_with_http_info(privilege, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_privilege_with_http_info(self, privilege : Optional[Privilege] = None, **kwargs):  # noqa: E501
+    def create_privilege_with_http_info(self, privilege : Optional[Privilege] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create a Privilege  # noqa: E501
 
         Create privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_privilege_with_http_info(privilege, async_req=True)
         >>> result = thread.get()
 
         :param privilege:
         :type privilege: Privilege
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(CreatePrivilege200Response, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(Privilege, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
             'privilege'
         ]
@@ -468,15 +467,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['privilege']:
+        if _params['privilege'] is not None:
             _body_params = _params['privilege']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -486,15 +485,15 @@
         if _content_types_list:
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "CreatePrivilege200Response",
+            '200': "Privilege",
             '400': "AltErr",
             '401': "AltErr",
         }
 
         return self.api_client.call_api(
             '/api/1/privileges', 'POST',
             _path_params,
@@ -523,52 +522,51 @@
         >>> thread = api.delete_privilege(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_privilege_with_http_info(privilege_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_privilege_with_http_info(self, privilege_id : StrictStr, **kwargs):  # noqa: E501
+    def delete_privilege_with_http_info(self, privilege_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete a Privilege  # noqa: E501
 
         Delete  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_privilege_with_http_info(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -663,32 +661,30 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_role_from_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_role_from_privilege_with_http_info(privilege_id, role_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_role_from_privilege_with_http_info(self, privilege_id : StrictStr, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs):  # noqa: E501
+    def delete_role_from_privilege_with_http_info(self, privilege_id : StrictStr, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Remove a Privilege from a Role  # noqa: E501
 
         Add roles to privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_role_from_privilege_with_http_info(privilege_id, role_id, async_req=True)
@@ -696,21 +692,22 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -807,52 +804,51 @@
         >>> thread = api.get_assigned_user(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetAssignedUser200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_assigned_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_assigned_user_with_http_info(privilege_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_assigned_user_with_http_info(self, privilege_id : StrictStr, **kwargs):  # noqa: E501
+    def get_assigned_user_with_http_info(self, privilege_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Users assigned to a Privilege  # noqa: E501
 
         Get Assigned Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_assigned_user_with_http_info(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -949,52 +945,51 @@
         >>> thread = api.get_privilege(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Privilege
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_privilege_with_http_info(privilege_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_privilege_with_http_info(self, privilege_id : StrictStr, **kwargs):  # noqa: E501
+    def get_privilege_with_http_info(self, privilege_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Get a Privilege  # noqa: E501
 
         Get a Privilige  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_privilege_with_http_info(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1077,79 +1072,78 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_privelege_roles(self, privilege_id : StrictStr, **kwargs) -> ListPrivelegeRoles200Response:  # noqa: E501
+    def list_privilege_roles(self, privilege_id : StrictStr, **kwargs) -> ListPrivilegeRoles200Response:  # noqa: E501
         """Get Roles assigned to Privilege  # noqa: E501
 
         List roles for privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_privelege_roles(privilege_id, async_req=True)
+        >>> thread = api.list_privilege_roles(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: ListPrivelegeRoles200Response
+        :rtype: ListPrivilegeRoles200Response
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_privelege_roles_with_http_info(privilege_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_privilege_roles_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_privilege_roles_with_http_info(privilege_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_privelege_roles_with_http_info(self, privilege_id : StrictStr, **kwargs):  # noqa: E501
+    def list_privilege_roles_with_http_info(self, privilege_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Roles assigned to Privilege  # noqa: E501
 
         List roles for privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_privelege_roles_with_http_info(privilege_id, async_req=True)
+        >>> thread = api.list_privilege_roles_with_http_info(privilege_id, async_req=True)
         >>> result = thread.get()
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(ListPrivelegeRoles200Response, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(ListPrivilegeRoles200Response, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
             'privilege_id'
         ]
@@ -1166,15 +1160,15 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_privelege_roles" % _key
+                    " to method list_privilege_roles" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
@@ -1196,15 +1190,15 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "ListPrivelegeRoles200Response",
+            '200': "ListPrivilegeRoles200Response",
             '401': "AltErr",
             '404': "AltErr",
         }
 
         return self.api_client.call_api(
             '/api/1/privileges/{privilege_id}/roles', 'GET',
             _path_params,
@@ -1219,62 +1213,61 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_priveleges(self, **kwargs) -> List[Privilege]:  # noqa: E501
+    def list_privileges(self, **kwargs) -> List[Privilege]:  # noqa: E501
         """List Privileges  # noqa: E501
 
         List Privileges  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_priveleges(async_req=True)
+        >>> thread = api.list_privileges(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[Privilege]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_priveleges_with_http_info(**kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_privileges_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_privileges_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_priveleges_with_http_info(self, **kwargs):  # noqa: E501
+    def list_privileges_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """List Privileges  # noqa: E501
 
         List Privileges  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_priveleges_with_http_info(async_req=True)
+        >>> thread = api.list_privileges_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1303,15 +1296,15 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_priveleges" % _key
+                    " to method list_privileges" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
@@ -1368,32 +1361,30 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the remove_user_from_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.remove_user_from_privilege_with_http_info(privilege_id, user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def remove_user_from_privilege_with_http_info(self, privilege_id : StrictStr, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def remove_user_from_privilege_with_http_info(self, privilege_id : StrictStr, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Remove a Privilege from Users  # noqa: E501
 
         Remove a Privilege from Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.remove_user_from_privilege_with_http_info(privilege_id, user_id, async_req=True)
@@ -1401,21 +1392,22 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1514,32 +1506,30 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param privilege:
         :type privilege: Privilege
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: UpdatePrivilege200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_privilege_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_privilege_with_http_info(privilege_id, privilege, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_privilege_with_http_info(self, privilege_id : StrictStr, privilege : Optional[Privilege] = None, **kwargs):  # noqa: E501
+    def update_privilege_with_http_info(self, privilege_id : StrictStr, privilege : Optional[Privilege] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update a Privilege  # noqa: E501
 
         Update privilege  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_privilege_with_http_info(privilege_id, privilege, async_req=True)
@@ -1547,21 +1537,22 @@
 
         :param privilege_id: (required)
         :type privilege_id: str
         :param privilege:
         :type privilege: Privilege
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1614,15 +1605,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['privilege']:
+        if _params['privilege'] is not None:
             _body_params = _params['privilege']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/roles_api.py` & `onelogin-3.1.5/onelogin/api/roles_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,14 +9,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist
 
 from typing import List, Optional
@@ -27,14 +29,15 @@
 from onelogin.models.get_role_by_name200_response import GetRoleByName200Response
 from onelogin.models.remove_role_users_request import RemoveRoleUsersRequest
 from onelogin.models.role import Role
 from onelogin.models.update_role200_response import UpdateRole200Response
 from onelogin.models.user import User
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class RolesApi(object):
@@ -62,32 +65,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[CreateRole201ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the add_role_admins_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.add_role_admins_with_http_info(role_id, request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def add_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs):  # noqa: E501
+    def add_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs) -> ApiResponse:  # noqa: E501
         """Add Role Admins  # noqa: E501
 
         Add Role Admins  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.add_role_admins_with_http_info(role_id, request_body, async_req=True)
@@ -95,21 +96,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -162,15 +164,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -218,32 +220,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[CreateRole201ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the add_role_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.add_role_users_with_http_info(role_id, request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def add_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs):  # noqa: E501
+    def add_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs) -> ApiResponse:  # noqa: E501
         """Add Role Users  # noqa: E501
 
         Add Role Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.add_role_users_with_http_info(role_id, request_body, async_req=True)
@@ -251,21 +251,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -318,15 +319,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -373,52 +374,51 @@
         >>> thread = api.create_role(role, async_req=True)
         >>> result = thread.get()
 
         :param role:
         :type role: Role
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[CreateRole201ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_role_with_http_info(role, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_role_with_http_info(self, role : Optional[Role] = None, **kwargs):  # noqa: E501
+    def create_role_with_http_info(self, role : Optional[Role] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Role  # noqa: E501
 
         Create Role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_role_with_http_info(role, async_req=True)
         >>> result = thread.get()
 
         :param role:
         :type role: Role
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -467,15 +467,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['role']:
+        if _params['role'] is not None:
             _body_params = _params['role']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -521,52 +521,51 @@
         >>> thread = api.delete_role(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_role_with_http_info(role_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs):  # noqa: E501
+    def delete_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Role by ID  # noqa: E501
 
         Delete Role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_role_with_http_info(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,52 +658,51 @@
         >>> thread = api.get_role(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Role
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_with_http_info(role_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs):  # noqa: E501
+    def get_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Role by ID  # noqa: E501
 
         Get Role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_with_http_info(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -811,32 +809,30 @@
         :type cursor: str
         :param name: Allows you to filter on first name, last name, username, and email address.
         :type name: str
         :param include_unassigned: Optional. Defaults to false. Include users that arent assigned to the role.
         :type include_unassigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[User]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_admins_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_admins_with_http_info(role_id, limit, page, cursor, name, include_unassigned, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, name : Annotated[Optional[StrictStr], Field(description="Allows you to filter on first name, last name, username, and email address.")] = None, include_unassigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to false. Include users that arent assigned to the role.")] = None, **kwargs):  # noqa: E501
+    def get_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, name : Annotated[Optional[StrictStr], Field(description="Allows you to filter on first name, last name, username, and email address.")] = None, include_unassigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to false. Include users that arent assigned to the role.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Role Admins  # noqa: E501
 
         Get Role Admins  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_admins_with_http_info(role_id, limit, page, cursor, name, include_unassigned, async_req=True)
@@ -852,21 +848,22 @@
         :type cursor: str
         :param name: Allows you to filter on first name, last name, username, and email address.
         :type name: str
         :param include_unassigned: Optional. Defaults to false. Include users that arent assigned to the role.
         :type include_unassigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -991,32 +988,30 @@
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param assigned: Optional. Defaults to true. Returns all apps not yet assigned to the role.
         :type assigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[GetRoleApps200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_apps_with_http_info(role_id, limit, page, cursor, assigned, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_apps_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, assigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to true. Returns all apps not yet assigned to the role.")] = None, **kwargs):  # noqa: E501
+    def get_role_apps_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, assigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to true. Returns all apps not yet assigned to the role.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get all Apps assigned to Role  # noqa: E501
 
         Get Role Apps  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_apps_with_http_info(role_id, limit, page, cursor, assigned, async_req=True)
@@ -1030,21 +1025,22 @@
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param assigned: Optional. Defaults to true. Returns all apps not yet assigned to the role.
         :type assigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1157,52 +1153,51 @@
         >>> thread = api.get_role_by_id(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetRoleById200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_by_id_with_http_info(role_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_by_id_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs):  # noqa: E501
+    def get_role_by_id_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Role by ID  # noqa: E501
 
         Get Role By ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_by_id_with_http_info(role_id, async_req=True)
         >>> result = thread.get()
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1301,52 +1296,51 @@
         >>> thread = api.get_role_by_name(name, async_req=True)
         >>> result = thread.get()
 
         :param name:
         :type name: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetRoleByName200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_by_name_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_by_name_with_http_info(name, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_by_name_with_http_info(self, name : Optional[StrictStr] = None, **kwargs):  # noqa: E501
+    def get_role_by_name_with_http_info(self, name : Optional[StrictStr] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Role by Name  # noqa: E501
 
         Get Role by Name  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_by_name_with_http_info(name, async_req=True)
         >>> result = thread.get()
 
         :param name:
         :type name: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1453,32 +1447,30 @@
         :type cursor: str
         :param name: Allows you to filter on first name, last name, username, and email address.
         :type name: str
         :param include_unassigned: Optional. Defaults to false. Include users that arent assigned to the role.
         :type include_unassigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[User]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_role_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_role_users_with_http_info(role_id, limit, page, cursor, name, include_unassigned, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, name : Annotated[Optional[StrictStr], Field(description="Allows you to filter on first name, last name, username, and email address.")] = None, include_unassigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to false. Include users that arent assigned to the role.")] = None, **kwargs):  # noqa: E501
+    def get_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, name : Annotated[Optional[StrictStr], Field(description="Allows you to filter on first name, last name, username, and email address.")] = None, include_unassigned : Annotated[Optional[StrictBool], Field(description="Optional. Defaults to false. Include users that arent assigned to the role.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Role Users  # noqa: E501
 
         Get Role Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_role_users_with_http_info(role_id, limit, page, cursor, name, include_unassigned, async_req=True)
@@ -1494,21 +1486,22 @@
         :type cursor: str
         :param name: Allows you to filter on first name, last name, username, and email address.
         :type name: str
         :param include_unassigned: Optional. Defaults to false. Include users that arent assigned to the role.
         :type include_unassigned: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1637,32 +1630,30 @@
         :type app_id: int
         :param app_name: Optional. Returns roles that contain this app name.
         :type app_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[Role]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_roles_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_roles_with_http_info(limit, page, cursor, role_name, app_id, app_name, fields, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_roles_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, role_name : Annotated[Optional[StrictStr], Field(description="Optional. Filters by role name.")] = None, app_id : Optional[StrictInt] = None, app_name : Annotated[Optional[StrictStr], Field(description="Optional. Returns roles that contain this app name.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs):  # noqa: E501
+    def list_roles_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, role_name : Annotated[Optional[StrictStr], Field(description="Optional. Filters by role name.")] = None, app_id : Optional[StrictInt] = None, app_name : Annotated[Optional[StrictStr], Field(description="Optional. Returns roles that contain this app name.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Roles  # noqa: E501
 
         List Roles  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_roles_with_http_info(limit, page, cursor, role_name, app_id, app_name, fields, async_req=True)
@@ -1680,21 +1671,22 @@
         :type app_id: int
         :param app_name: Optional. Returns roles that contain this app name.
         :type app_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1816,32 +1808,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param remove_role_users_request: (required)
         :type remove_role_users_request: RemoveRoleUsersRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the remove_role_admins_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.remove_role_admins_with_http_info(role_id, remove_role_users_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def remove_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], remove_role_users_request : RemoveRoleUsersRequest, **kwargs):  # noqa: E501
+    def remove_role_admins_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], remove_role_users_request : RemoveRoleUsersRequest, **kwargs) -> ApiResponse:  # noqa: E501
         """Remove Role Admins  # noqa: E501
 
         Remove Role Admins  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.remove_role_admins_with_http_info(role_id, remove_role_users_request, async_req=True)
@@ -1849,21 +1839,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param remove_role_users_request: (required)
         :type remove_role_users_request: RemoveRoleUsersRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1916,15 +1907,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['remove_role_users_request']:
+        if _params['remove_role_users_request'] is not None:
             _body_params = _params['remove_role_users_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1969,32 +1960,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param remove_role_users_request: (required)
         :type remove_role_users_request: RemoveRoleUsersRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the remove_role_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.remove_role_users_with_http_info(role_id, remove_role_users_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def remove_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], remove_role_users_request : RemoveRoleUsersRequest, **kwargs):  # noqa: E501
+    def remove_role_users_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], remove_role_users_request : RemoveRoleUsersRequest, **kwargs) -> ApiResponse:  # noqa: E501
         """Remove Role Users  # noqa: E501
 
         Remove Role Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.remove_role_users_with_http_info(role_id, remove_role_users_request, async_req=True)
@@ -2002,21 +1991,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param remove_role_users_request: (required)
         :type remove_role_users_request: RemoveRoleUsersRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2069,15 +2059,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['remove_role_users_request']:
+        if _params['remove_role_users_request'] is not None:
             _body_params = _params['remove_role_users_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -2122,32 +2112,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[CreateRole201ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the set_role_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.set_role_apps_with_http_info(role_id, request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def set_role_apps_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs):  # noqa: E501
+    def set_role_apps_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], request_body : conlist(StrictInt), **kwargs) -> ApiResponse:  # noqa: E501
         """Set Role Apps  # noqa: E501
 
         Set Role Apps  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.set_role_apps_with_http_info(role_id, request_body, async_req=True)
@@ -2155,21 +2143,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param request_body: (required)
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2222,15 +2211,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -2279,32 +2268,30 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param role:
         :type role: Role
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: UpdateRole200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_role_with_http_info(role_id, role, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], role : Optional[Role] = None, **kwargs):  # noqa: E501
+    def update_role_with_http_info(self, role_id : Annotated[StrictStr, Field(..., description="Set to the id of the role you want to return.")], role : Optional[Role] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Role  # noqa: E501
 
         Update Role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_role_with_http_info(role_id, role, async_req=True)
@@ -2312,21 +2299,22 @@
 
         :param role_id: Set to the id of the role you want to return. (required)
         :type role_id: str
         :param role:
         :type role: Role
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2379,15 +2367,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['role']:
+        if _params['role'] is not None:
             _body_params = _params['role']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/saml_assertions_api.py` & `onelogin-3.1.5/onelogin/api/saml_assertions_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,28 +9,31 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import StrictStr
 
 from typing import Optional
 
 from onelogin.models.generate_saml_assert200_response import GenerateSamlAssert200Response
 from onelogin.models.saml_assert import SamlAssert
 from onelogin.models.saml_factor import SamlFactor
 from onelogin.models.ver_factor_saml200_response import VerFactorSaml200Response
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class SAMLAssertionsApi(object):
@@ -58,32 +61,30 @@
 
         :param content_type:
         :type content_type: str
         :param saml_assert:
         :type saml_assert: SamlAssert
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenerateSamlAssert200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the generate_saml_assert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.generate_saml_assert_with_http_info(content_type, saml_assert, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def generate_saml_assert_with_http_info(self, content_type : Optional[StrictStr] = None, saml_assert : Optional[SamlAssert] = None, **kwargs):  # noqa: E501
+    def generate_saml_assert_with_http_info(self, content_type : Optional[StrictStr] = None, saml_assert : Optional[SamlAssert] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate SAML Assertion  # noqa: E501
 
         Generate SAML Assertion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.generate_saml_assert_with_http_info(content_type, saml_assert, async_req=True)
@@ -91,21 +92,22 @@
 
         :param content_type:
         :type content_type: str
         :param saml_assert:
         :type saml_assert: SamlAssert
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -158,15 +160,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['saml_assert']:
+        if _params['saml_assert'] is not None:
             _body_params = _params['saml_assert']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -215,32 +217,30 @@
 
         :param content_type:
         :type content_type: str
         :param saml_assert:
         :type saml_assert: SamlAssert
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GenerateSamlAssert200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the generate_saml_assert2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.generate_saml_assert2_with_http_info(content_type, saml_assert, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def generate_saml_assert2_with_http_info(self, content_type : Optional[StrictStr] = None, saml_assert : Optional[SamlAssert] = None, **kwargs):  # noqa: E501
+    def generate_saml_assert2_with_http_info(self, content_type : Optional[StrictStr] = None, saml_assert : Optional[SamlAssert] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Generate SAML Assertion  # noqa: E501
 
         Generate SAML Assertion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.generate_saml_assert2_with_http_info(content_type, saml_assert, async_req=True)
@@ -248,21 +248,22 @@
 
         :param content_type:
         :type content_type: str
         :param saml_assert:
         :type saml_assert: SamlAssert
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -315,15 +316,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['saml_assert']:
+        if _params['saml_assert'] is not None:
             _body_params = _params['saml_assert']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -372,32 +373,30 @@
 
         :param content_type:
         :type content_type: str
         :param saml_factor:
         :type saml_factor: SamlFactor
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VerFactorSaml200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the ver_factor_saml_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.ver_factor_saml_with_http_info(content_type, saml_factor, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def ver_factor_saml_with_http_info(self, content_type : Optional[StrictStr] = None, saml_factor : Optional[SamlFactor] = None, **kwargs):  # noqa: E501
+    def ver_factor_saml_with_http_info(self, content_type : Optional[StrictStr] = None, saml_factor : Optional[SamlFactor] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Verify Factor SAML  # noqa: E501
 
         Verify Factor: SAML  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ver_factor_saml_with_http_info(content_type, saml_factor, async_req=True)
@@ -405,21 +404,22 @@
 
         :param content_type:
         :type content_type: str
         :param saml_factor:
         :type saml_factor: SamlFactor
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -472,15 +472,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['saml_factor']:
+        if _params['saml_factor'] is not None:
             _body_params = _params['saml_factor']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -530,32 +530,30 @@
 
         :param content_type:
         :type content_type: str
         :param saml_factor:
         :type saml_factor: SamlFactor
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VerFactorSaml200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the ver_factor_saml2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.ver_factor_saml2_with_http_info(content_type, saml_factor, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def ver_factor_saml2_with_http_info(self, content_type : Optional[StrictStr] = None, saml_factor : Optional[SamlFactor] = None, **kwargs):  # noqa: E501
+    def ver_factor_saml2_with_http_info(self, content_type : Optional[StrictStr] = None, saml_factor : Optional[SamlFactor] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Verify Factor SAML  # noqa: E501
 
         Verify Factor: SAML  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ver_factor_saml2_with_http_info(content_type, saml_factor, async_req=True)
@@ -563,21 +561,22 @@
 
         :param content_type:
         :type content_type: str
         :param saml_factor:
         :type saml_factor: SamlFactor
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -630,15 +629,15 @@
             _header_params['Content-Type'] = _params['content_type']
 
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['saml_factor']:
+        if _params['saml_factor'] is not None:
             _body_params = _params['saml_factor']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/smart_hooks_api.py` & `onelogin-3.1.5/onelogin/api/smart_hooks_api.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,28 +9,31 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictInt, StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.hook import Hook
 from onelogin.models.hook_envvar import HookEnvvar
 from onelogin.models.hook_log import HookLog
 from onelogin.models.update_environment_variable_request import UpdateEnvironmentVariableRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class SmartHooksApi(object):
@@ -56,52 +59,51 @@
         >>> thread = api.create_environment_variable(hook_envvar, async_req=True)
         >>> result = thread.get()
 
         :param hook_envvar: (required)
         :type hook_envvar: HookEnvvar
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: HookEnvvar
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_environment_variable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_environment_variable_with_http_info(hook_envvar, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_environment_variable_with_http_info(self, hook_envvar : HookEnvvar, **kwargs):  # noqa: E501
+    def create_environment_variable_with_http_info(self, hook_envvar : HookEnvvar, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Environment Variable  # noqa: E501
 
         Create Environment Variable  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_environment_variable_with_http_info(hook_envvar, async_req=True)
         >>> result = thread.get()
 
         :param hook_envvar: (required)
         :type hook_envvar: HookEnvvar
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -150,15 +152,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['hook_envvar']:
+        if _params['hook_envvar'] is not None:
             _body_params = _params['hook_envvar']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -205,52 +207,51 @@
         >>> thread = api.create_hook(hook, async_req=True)
         >>> result = thread.get()
 
         :param hook: (required)
         :type hook: Hook
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Hook
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_hook_with_http_info(hook, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_hook_with_http_info(self, hook : Hook, **kwargs):  # noqa: E501
+    def create_hook_with_http_info(self, hook : Hook, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Smart Hook  # noqa: E501
 
         Create Smart Hook  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_hook_with_http_info(hook, async_req=True)
         >>> result = thread.get()
 
         :param hook: (required)
         :type hook: Hook
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -299,15 +300,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['hook']:
+        if _params['hook'] is not None:
             _body_params = _params['hook']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -355,52 +356,51 @@
         >>> thread = api.delete_environment_variable(envvar_id, async_req=True)
         >>> result = thread.get()
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_environment_variable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_environment_variable_with_http_info(envvar_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], **kwargs):  # noqa: E501
+    def delete_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Environment Variable  # noqa: E501
 
         Delete Environment Variable  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_environment_variable_with_http_info(envvar_id, async_req=True)
         >>> result = thread.get()
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -493,52 +493,51 @@
         >>> thread = api.delete_hook(hook_id, async_req=True)
         >>> result = thread.get()
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_hook_with_http_info(hook_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], **kwargs):  # noqa: E501
+    def delete_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Smart Hook by ID  # noqa: E501
 
         Delete Smart Hook  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_hook_with_http_info(hook_id, async_req=True)
         >>> result = thread.get()
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -631,52 +630,51 @@
         >>> thread = api.get_environment_variable(envvar_id, async_req=True)
         >>> result = thread.get()
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: HookEnvvar
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_environment_variable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_environment_variable_with_http_info(envvar_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], **kwargs):  # noqa: E501
+    def get_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Environment Variable  # noqa: E501
 
         Get Environment Variable  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_environment_variable_with_http_info(envvar_id, async_req=True)
         >>> result = thread.get()
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -772,52 +770,51 @@
         >>> thread = api.get_hook(hook_id, async_req=True)
         >>> result = thread.get()
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Hook
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_hook_with_http_info(hook_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], **kwargs):  # noqa: E501
+    def get_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Smart Hook by ID  # noqa: E501
 
         Get Smart Hook  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_hook_with_http_info(hook_id, async_req=True)
         >>> result = thread.get()
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -924,32 +921,30 @@
         :type cursor: str
         :param request_id: Returns logs that contain this request_id.
         :type request_id: str
         :param correlation_id: Returns logs that contain this correlation_id.
         :type correlation_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[HookLog]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_logs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_logs_with_http_info(hook_id, limit, page, cursor, request_id, correlation_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_logs_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, request_id : Annotated[Optional[StrictStr], Field(description="Returns logs that contain this request_id.")] = None, correlation_id : Annotated[Optional[StrictStr], Field(description="Returns logs that contain this correlation_id.")] = None, **kwargs):  # noqa: E501
+    def get_logs_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, request_id : Annotated[Optional[StrictStr], Field(description="Returns logs that contain this request_id.")] = None, correlation_id : Annotated[Optional[StrictStr], Field(description="Returns logs that contain this correlation_id.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Smart Hook Logs  # noqa: E501
 
         Get Smart Hook Logs  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_logs_with_http_info(hook_id, limit, page, cursor, request_id, correlation_id, async_req=True)
@@ -965,21 +960,22 @@
         :type cursor: str
         :param request_id: Returns logs that contain this request_id.
         :type request_id: str
         :param correlation_id: Returns logs that contain this correlation_id.
         :type correlation_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1100,32 +1096,30 @@
         :type limit: int
         :param page: The page number of results to return.
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[HookEnvvar]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_environment_variables_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_environment_variables_with_http_info(limit, page, cursor, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_environment_variables_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, **kwargs):  # noqa: E501
+    def list_environment_variables_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Environment Variables  # noqa: E501
 
         List Environment Variables  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_environment_variables_with_http_info(limit, page, cursor, async_req=True)
@@ -1135,21 +1129,22 @@
         :type limit: int
         :param page: The page number of results to return.
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1257,32 +1252,30 @@
         :type limit: int
         :param page: The page number of results to return.
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[Hook]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_hooks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_hooks_with_http_info(limit, page, cursor, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_hooks_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, **kwargs):  # noqa: E501
+    def list_hooks_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List all Smart Hooks  # noqa: E501
 
         List Smart Hooks  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_hooks_with_http_info(limit, page, cursor, async_req=True)
@@ -1292,21 +1285,22 @@
         :type limit: int
         :param page: The page number of results to return.
         :type page: int
         :param cursor: Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.
         :type cursor: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1412,32 +1406,30 @@
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param update_environment_variable_request: (required)
         :type update_environment_variable_request: UpdateEnvironmentVariableRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: HookEnvvar
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_environment_variable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_environment_variable_with_http_info(envvar_id, update_environment_variable_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], update_environment_variable_request : UpdateEnvironmentVariableRequest, **kwargs):  # noqa: E501
+    def update_environment_variable_with_http_info(self, envvar_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook Environment Variable that you want to fetch.")], update_environment_variable_request : UpdateEnvironmentVariableRequest, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Environment Variable  # noqa: E501
 
         Update Environment Variable  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_environment_variable_with_http_info(envvar_id, update_environment_variable_request, async_req=True)
@@ -1445,21 +1437,22 @@
 
         :param envvar_id: Set to the id of the Hook Environment Variable that you want to fetch. (required)
         :type envvar_id: str
         :param update_environment_variable_request: (required)
         :type update_environment_variable_request: UpdateEnvironmentVariableRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1512,15 +1505,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['update_environment_variable_request']:
+        if _params['update_environment_variable_request'] is not None:
             _body_params = _params['update_environment_variable_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1570,32 +1563,30 @@
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param hook: (required)
         :type hook: Hook
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Hook
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_hook_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_hook_with_http_info(hook_id, hook, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], hook : Hook, **kwargs):  # noqa: E501
+    def update_hook_with_http_info(self, hook_id : Annotated[StrictStr, Field(..., description="Set to the id of the Hook that you want to return.")], hook : Hook, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Smart Hook by ID  # noqa: E501
 
         Update Smart Hook  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_hook_with_http_info(hook_id, hook, async_req=True)
@@ -1603,21 +1594,22 @@
 
         :param hook_id: Set to the id of the Hook that you want to return. (required)
         :type hook_id: str
         :param hook: (required)
         :type hook: Hook
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1670,15 +1662,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['hook']:
+        if _params['hook'] is not None:
             _body_params = _params['hook']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/user_mappings_api.py` & `onelogin-3.1.5/onelogin/api/app_rules_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,125 +9,125 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist
 
-from typing import Any, Dict, List, Optional
+from typing import List, Optional
 
-from onelogin.models.list_mapping_action_values200_response_inner import ListMappingActionValues200ResponseInner
-from onelogin.models.list_mapping_conditions200_response import ListMappingConditions200Response
-from onelogin.models.list_mapping_conditions_operators200_response_inner import ListMappingConditionsOperators200ResponseInner
-from onelogin.models.list_mapping_contion_values200_response_inner import ListMappingContionValues200ResponseInner
-from onelogin.models.list_mappings_actions200_response_inner import ListMappingsActions200ResponseInner
-from onelogin.models.mapping import Mapping
+from onelogin.models.app_rule import AppRule
+from onelogin.models.list_conditions200_response_inner import ListConditions200ResponseInner
+from onelogin.models.rule_action import RuleAction
+from onelogin.models.rule_condition import RuleCondition
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
-class UserMappingsApi(object):
+class AppRulesApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient.get_default()
         self.api_client = api_client
 
     @validate_arguments
-    def create_mapping(self, content_type : Optional[StrictStr] = None, mapping : Optional[Mapping] = None, **kwargs) -> List[Mapping]:  # noqa: E501
-        """Create Mapping  # noqa: E501
+    def create_app_rule(self, app_id : StrictInt, app_rule : Optional[AppRule] = None, **kwargs) -> AppRule:  # noqa: E501
+        """create_app_rule  # noqa: E501
 
-        Create Mapping  # noqa: E501
+        Create App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.create_mapping(content_type, mapping, async_req=True)
+        >>> thread = api.create_app_rule(app_id, app_rule, async_req=True)
         >>> result = thread.get()
 
-        :param content_type:
-        :type content_type: str
-        :param mapping:
-        :type mapping: Mapping
+        :param app_id: (required)
+        :type app_id: int
+        :param app_rule:
+        :type app_rule: AppRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[Mapping]
+        :rtype: AppRule
         """
         kwargs['_return_http_data_only'] = True
-        return self.create_mapping_with_http_info(content_type, mapping, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_app_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.create_app_rule_with_http_info(app_id, app_rule, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_mapping_with_http_info(self, content_type : Optional[StrictStr] = None, mapping : Optional[Mapping] = None, **kwargs):  # noqa: E501
-        """Create Mapping  # noqa: E501
+    def create_app_rule_with_http_info(self, app_id : StrictInt, app_rule : Optional[AppRule] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """create_app_rule  # noqa: E501
 
-        Create Mapping  # noqa: E501
+        Create App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.create_mapping_with_http_info(content_type, mapping, async_req=True)
+        >>> thread = api.create_app_rule_with_http_info(app_id, app_rule, async_req=True)
         >>> result = thread.get()
 
-        :param content_type:
-        :type content_type: str
-        :param mapping:
-        :type mapping: Mapping
+        :param app_id: (required)
+        :type app_id: int
+        :param app_rule:
+        :type app_rule: AppRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[Mapping], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'content_type',
-            'mapping'
+            'app_id',
+            'app_rule'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -138,38 +138,38 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_mapping" % _key
+                    " to method create_app_rule" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
-        if _params['content_type']:
-            _header_params['Content-Type'] = _params['content_type']
-
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['mapping']:
-            _body_params = _params['mapping']
+        if _params['app_rule'] is not None:
+            _body_params = _params['app_rule']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get('_content_type',
@@ -178,21 +178,21 @@
         if _content_types_list:
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '201': "List[Mapping]",
-            '401': "Error",
-            '422': "Error",
+            '201': "AppRule",
+            '401': "AltErr",
+            '422': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings', 'POST',
+            '/api/2/apps/{app_id}/rules', 'POST',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -201,66 +201,69 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def delete_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> None:  # noqa: E501
-        """Delete Mapping  # noqa: E501
+    def delete_rule(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> None:  # noqa: E501
+        """Delete Rule  # noqa: E501
 
-        Delete Mapping  # noqa: E501
+        Delete App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.delete_mapping(mapping_id, async_req=True)
+        >>> thread = api.delete_rule(app_id, rule_id, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
-        return self.delete_mapping_with_http_info(mapping_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.delete_rule_with_http_info(app_id, rule_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs):  # noqa: E501
-        """Delete Mapping  # noqa: E501
+    def delete_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """Delete Rule  # noqa: E501
 
-        Delete Mapping  # noqa: E501
+        Delete App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.delete_mapping_with_http_info(mapping_id, async_req=True)
+        >>> thread = api.delete_rule_with_http_info(app_id, rule_id, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -271,15 +274,16 @@
                  returns the request thread.
         :rtype: None
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_id'
+            'app_id',
+            'rule_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -290,25 +294,28 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method delete_mapping" % _key
+                    " to method delete_rule" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_id']:
-            _path_params['mapping_id'] = _params['mapping_id']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
+        if _params['rule_id']:
+            _path_params['rule_id'] = _params['rule_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -322,15 +329,15 @@
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {}
 
         return self.api_client.call_api(
-            '/api/2/mappings/{mapping_id}', 'DELETE',
+            '/api/2/apps/{app_id}/rules/{rule_id}', 'DELETE',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -339,85 +346,89 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def get_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs) -> Mapping:  # noqa: E501
-        """Get Mapping  # noqa: E501
+    def get_app_rule(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> AppRule:  # noqa: E501
+        """Get Rule  # noqa: E501
 
-        Get Mapping  # noqa: E501
+        Get App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.get_mapping(mapping_id, async_req=True)
+        >>> thread = api.get_app_rule(app_id, rule_id, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: Mapping
+        :rtype: AppRule
         """
         kwargs['_return_http_data_only'] = True
-        return self.get_mapping_with_http_info(mapping_id, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_app_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.get_app_rule_with_http_info(app_id, rule_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], **kwargs):  # noqa: E501
-        """Get Mapping  # noqa: E501
+    def get_app_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """Get Rule  # noqa: E501
 
-        Get Mapping  # noqa: E501
+        Get App Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.get_mapping_with_http_info(mapping_id, async_req=True)
+        >>> thread = api.get_app_rule_with_http_info(app_id, rule_id, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(Mapping, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_id'
+            'app_id',
+            'rule_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -428,25 +439,28 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_mapping" % _key
+                    " to method get_app_rule" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_id']:
-            _path_params['mapping_id'] = _params['mapping_id']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
+        if _params['rule_id']:
+            _path_params['rule_id'] = _params['rule_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -458,21 +472,21 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "Mapping",
-            '401': "Error",
-            '404': "Error",
+            '200': "AppRule",
+            '401': "AltErr",
+            '404': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/{mapping_id}', 'GET',
+            '/api/2/apps/{app_id}/rules/{rule_id}', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -481,85 +495,89 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mapping_action_values(self, mapping_action_value : StrictStr, **kwargs) -> List[ListMappingActionValues200ResponseInner]:  # noqa: E501
+    def list_action_valies(self, app_id : StrictInt, rule_action_value : StrictStr, **kwargs) -> List[RuleAction]:  # noqa: E501
         """List Actions Values  # noqa: E501
 
-        List Mappings' Actions' Values  # noqa: E501
+        Sort App rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_action_values(mapping_action_value, async_req=True)
+        >>> thread = api.list_action_valies(app_id, rule_action_value, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_action_value: (required)
-        :type mapping_action_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_action_value: (required)
+        :type rule_action_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[ListMappingActionValues200ResponseInner]
+        :rtype: List[RuleAction]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mapping_action_values_with_http_info(mapping_action_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_action_valies_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_action_valies_with_http_info(app_id, rule_action_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mapping_action_values_with_http_info(self, mapping_action_value : StrictStr, **kwargs):  # noqa: E501
+    def list_action_valies_with_http_info(self, app_id : StrictInt, rule_action_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """List Actions Values  # noqa: E501
 
-        List Mappings' Actions' Values  # noqa: E501
+        Sort App rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_action_values_with_http_info(mapping_action_value, async_req=True)
+        >>> thread = api.list_action_valies_with_http_info(app_id, rule_action_value, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_action_value: (required)
-        :type mapping_action_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_action_value: (required)
+        :type rule_action_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[ListMappingActionValues200ResponseInner], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[RuleAction], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_action_value'
+            'app_id',
+            'rule_action_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -570,25 +588,28 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mapping_action_values" % _key
+                    " to method list_action_valies" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_action_value']:
-            _path_params['mapping_action_value'] = _params['mapping_action_value']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
+        if _params['rule_action_value']:
+            _path_params['rule_action_value'] = _params['rule_action_value']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -600,20 +621,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[ListMappingActionValues200ResponseInner]",
-            '401': "Error",
+            '200': "List[RuleAction]",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/actions/{mapping_action_value}/values', 'GET',
+            '/api/2/apps/{app_id}/rules/actions/{rule_action_value}/values', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -622,80 +643,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mapping_conditions(self, **kwargs) -> ListMappingConditions200Response:  # noqa: E501
-        """List Conditions  # noqa: E501
+    def list_actions(self, app_id : StrictInt, **kwargs) -> List[RuleAction]:  # noqa: E501
+        """List Actions  # noqa: E501
 
-        List Mappings' Conditions  # noqa: E501
+        List Actions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_conditions(async_req=True)
+        >>> thread = api.list_actions(app_id, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: ListMappingConditions200Response
+        :rtype: List[RuleAction]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mapping_conditions_with_http_info(**kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_actions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_actions_with_http_info(app_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mapping_conditions_with_http_info(self, **kwargs):  # noqa: E501
-        """List Conditions  # noqa: E501
+    def list_actions_with_http_info(self, app_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Actions  # noqa: E501
 
-        List Mappings' Conditions  # noqa: E501
+        List Actions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_conditions_with_http_info(async_req=True)
+        >>> thread = api.list_actions_with_http_info(app_id, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(ListMappingConditions200Response, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[RuleAction], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
+            'app_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -706,23 +731,26 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mapping_conditions" % _key
+                    " to method list_actions" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
@@ -733,20 +761,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "ListMappingConditions200Response",
-            '401': "Error",
+            '200': "List[RuleAction]",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/conditions', 'GET',
+            '/api/2/apps/{app_id}/rules/actions', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -755,85 +783,109 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mapping_conditions_operators(self, mapping_condition_value : StrictStr, **kwargs) -> List[ListMappingConditionsOperators200ResponseInner]:  # noqa: E501
-        """List Conditions Operators  # noqa: E501
+    def list_app_rules(self, app_id : StrictInt, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, **kwargs) -> List[AppRule]:  # noqa: E501
+        """List Rules  # noqa: E501
 
-        List Mappings' Conditions' Operators  # noqa: E501
+        List App Rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_conditions_operators(mapping_condition_value, async_req=True)
+        >>> thread = api.list_app_rules(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_condition_value: (required)
-        :type mapping_condition_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition: str
+        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition_type: str
+        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
+        :type has_action: str
+        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
+        :type has_action_type: str
+        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
+        :type enabled: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[ListMappingConditionsOperators200ResponseInner]
+        :rtype: List[AppRule]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mapping_conditions_operators_with_http_info(mapping_condition_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_app_rules_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_app_rules_with_http_info(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mapping_conditions_operators_with_http_info(self, mapping_condition_value : StrictStr, **kwargs):  # noqa: E501
-        """List Conditions Operators  # noqa: E501
+    def list_app_rules_with_http_info(self, app_id : StrictInt, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Rules  # noqa: E501
 
-        List Mappings' Conditions' Operators  # noqa: E501
+        List App Rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_conditions_operators_with_http_info(mapping_condition_value, async_req=True)
+        >>> thread = api.list_app_rules_with_http_info(app_id, has_condition, has_condition_type, has_action, has_action_type, enabled, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_condition_value: (required)
-        :type mapping_condition_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition: str
+        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
+        :type has_condition_type: str
+        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
+        :type has_action: str
+        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
+        :type has_action_type: str
+        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
+        :type enabled: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[ListMappingConditionsOperators200ResponseInner], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[AppRule], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_condition_value'
+            'app_id',
+            'has_condition',
+            'has_condition_type',
+            'has_action',
+            'has_action_type',
+            'enabled'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -844,29 +896,44 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mapping_conditions_operators" % _key
+                    " to method list_app_rules" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_condition_value']:
-            _path_params['mapping_condition_value'] = _params['mapping_condition_value']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
 
 
         # process the query parameters
         _query_params = []
+        if _params.get('has_condition') is not None:  # noqa: E501
+            _query_params.append(('has_condition', _params['has_condition']))
+
+        if _params.get('has_condition_type') is not None:  # noqa: E501
+            _query_params.append(('has_condition_type', _params['has_condition_type']))
+
+        if _params.get('has_action') is not None:  # noqa: E501
+            _query_params.append(('has_action', _params['has_action']))
+
+        if _params.get('has_action_type') is not None:  # noqa: E501
+            _query_params.append(('has_action_type', _params['has_action_type']))
+
+        if _params.get('enabled') is not None:  # noqa: E501
+            _query_params.append(('enabled', _params['enabled']))
+
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
@@ -874,20 +941,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[ListMappingConditionsOperators200ResponseInner]",
-            '401': "Error",
+            '200': "List[AppRule]",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/conditions/{mapping_condition_value}/operators', 'GET',
+            '/api/2/apps/{app_id}/rules', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -896,85 +963,89 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mapping_contion_values(self, mapping_condition_value : StrictStr, **kwargs) -> List[ListMappingContionValues200ResponseInner]:  # noqa: E501
-        """List Conditions Values  # noqa: E501
+    def list_condition_operators(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> List[RuleCondition]:  # noqa: E501
+        """List Conditions Operators  # noqa: E501
 
-        List Mappings'  Conditions' Values  # noqa: E501
+        List Condition Operators  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_contion_values(mapping_condition_value, async_req=True)
+        >>> thread = api.list_condition_operators(app_id, rule_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_condition_value: (required)
-        :type mapping_condition_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_condition_value: (required)
+        :type rule_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[ListMappingContionValues200ResponseInner]
+        :rtype: List[RuleCondition]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mapping_contion_values_with_http_info(mapping_condition_value, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_condition_operators_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_condition_operators_with_http_info(app_id, rule_condition_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mapping_contion_values_with_http_info(self, mapping_condition_value : StrictStr, **kwargs):  # noqa: E501
-        """List Conditions Values  # noqa: E501
+    def list_condition_operators_with_http_info(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions Operators  # noqa: E501
 
-        List Mappings'  Conditions' Values  # noqa: E501
+        List Condition Operators  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mapping_contion_values_with_http_info(mapping_condition_value, async_req=True)
+        >>> thread = api.list_condition_operators_with_http_info(app_id, rule_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_condition_value: (required)
-        :type mapping_condition_value: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_condition_value: (required)
+        :type rule_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[ListMappingContionValues200ResponseInner], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[RuleCondition], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_condition_value'
+            'app_id',
+            'rule_condition_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -985,25 +1056,28 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mapping_contion_values" % _key
+                    " to method list_condition_operators" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_condition_value']:
-            _path_params['mapping_condition_value'] = _params['mapping_condition_value']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
+        if _params['rule_condition_value']:
+            _path_params['rule_condition_value'] = _params['rule_condition_value']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
@@ -1015,20 +1089,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[ListMappingContionValues200ResponseInner]",
-            '401': "Error",
+            '200': "List[RuleCondition]",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/conditions/{mapping_condition_value}/values', 'GET',
+            '/api/2/apps/{app_id}/rules/conditions/{rule_condition_value}/operators', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1037,105 +1111,89 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mappings(self, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, **kwargs) -> List[Mapping]:  # noqa: E501
-        """List Mappings  # noqa: E501
+    def list_condition_values(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> RuleCondition:  # noqa: E501
+        """List Conditions Values  # noqa: E501
 
-        List Mappings  # noqa: E501
+        List Condition Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mappings(enabled, has_condition, has_condition_type, has_action, has_action_type, async_req=True)
+        >>> thread = api.list_condition_values(app_id, rule_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
-        :type enabled: bool
-        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition: str
-        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition_type: str
-        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
-        :type has_action: str
-        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
-        :type has_action_type: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_condition_value: (required)
+        :type rule_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[Mapping]
+        :rtype: RuleCondition
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mappings_with_http_info(enabled, has_condition, has_condition_type, has_action, has_action_type, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_condition_values_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_condition_values_with_http_info(app_id, rule_condition_value, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mappings_with_http_info(self, enabled : Annotated[Optional[StrictBool], Field(description="Defaults to true. When set to `false` will return all disabled mappings.")] = None, has_condition : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_condition_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*")] = None, has_action : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*")] = None, has_action_type : Annotated[Optional[StrictStr], Field(description="Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none")] = None, **kwargs):  # noqa: E501
-        """List Mappings  # noqa: E501
+    def list_condition_values_with_http_info(self, app_id : StrictInt, rule_condition_value : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions Values  # noqa: E501
 
-        List Mappings  # noqa: E501
+        List Condition Values  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mappings_with_http_info(enabled, has_condition, has_condition_type, has_action, has_action_type, async_req=True)
+        >>> thread = api.list_condition_values_with_http_info(app_id, rule_condition_value, async_req=True)
         >>> result = thread.get()
 
-        :param enabled: Defaults to true. When set to `false` will return all disabled mappings.
-        :type enabled: bool
-        :param has_condition: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition: str
-        :param has_condition_type: Filters Rules based on their Conditions. Values formatted as :, where name is the Condition to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_condition=has_role:123456 Multiple filters. has_condition=has_role:123456,status:1 Wildcard for conditions. has_condition=*:123456 Wildcard for condition values. has_condition=has_role:*
-        :type has_condition_type: str
-        :param has_action: Filters Rules based on their Actions. Values formatted as :, where name is the Action to look for, and value is the value to find. Multiple filters can be declared by using a comma delimited list. Wildcards are supported in both the name and value fields. For example: Single filter. has_action=set_licenses:123456 Multiple filters. has_action=set_groups:123456,set_usertype:* Wildcard for actions. has_action=*:123456 Wildcard for action values. has_action=set_userprincipalname:*
-        :type has_action: str
-        :param has_action_type: Filters Rules based on their action types. Allowed values are: builtin - actions that involve standard attributes custom - actions that involve custom attributes none - no actions are defined For example: Find Rules with no actions has_action_type=none
-        :type has_action_type: str
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_condition_value: (required)
+        :type rule_condition_value: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[Mapping], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(RuleCondition, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'enabled',
-            'has_condition',
-            'has_condition_type',
-            'has_action',
-            'has_action_type'
+            'app_id',
+            'rule_condition_value'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1146,41 +1204,32 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mappings" % _key
+                    " to method list_condition_values" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
 
-        # process the query parameters
-        _query_params = []
-        if _params.get('enabled') is not None:  # noqa: E501
-            _query_params.append(('enabled', _params['enabled']))
+        if _params['rule_condition_value']:
+            _path_params['rule_condition_value'] = _params['rule_condition_value']
 
-        if _params.get('has_condition') is not None:  # noqa: E501
-            _query_params.append(('has_condition', _params['has_condition']))
-
-        if _params.get('has_condition_type') is not None:  # noqa: E501
-            _query_params.append(('has_condition_type', _params['has_condition_type']))
-
-        if _params.get('has_action') is not None:  # noqa: E501
-            _query_params.append(('has_action', _params['has_action']))
-
-        if _params.get('has_action_type') is not None:  # noqa: E501
-            _query_params.append(('has_action_type', _params['has_action_type']))
 
+        # process the query parameters
+        _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
@@ -1188,20 +1237,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[Mapping]",
-            '401': "Error",
+            '200': "RuleCondition",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings', 'GET',
+            '/api/2/apps/{app_id}/rules/conditions/{rule_condition_value}/values', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1210,80 +1259,84 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def list_mappings_actions(self, **kwargs) -> List[ListMappingsActions200ResponseInner]:  # noqa: E501
-        """List Actions  # noqa: E501
+    def list_conditions(self, app_id : StrictInt, **kwargs) -> List[ListConditions200ResponseInner]:  # noqa: E501
+        """List Conditions  # noqa: E501
 
-        List Mappings' Actions  # noqa: E501
+        List App Conditions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mappings_actions(async_req=True)
+        >>> thread = api.list_conditions(app_id, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: List[ListMappingsActions200ResponseInner]
+        :rtype: List[ListConditions200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
-        return self.list_mappings_actions_with_http_info(**kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_conditions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.list_conditions_with_http_info(app_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_mappings_actions_with_http_info(self, **kwargs):  # noqa: E501
-        """List Actions  # noqa: E501
+    def list_conditions_with_http_info(self, app_id : StrictInt, **kwargs) -> ApiResponse:  # noqa: E501
+        """List Conditions  # noqa: E501
 
-        List Mappings' Actions  # noqa: E501
+        List App Conditions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.list_mappings_actions_with_http_info(async_req=True)
+        >>> thread = api.list_conditions_with_http_info(app_id, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(List[ListMappingsActions200ResponseInner], status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(List[ListConditions200ResponseInner], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
+            'app_id'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1294,23 +1347,26 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method list_mappings_actions" % _key
+                    " to method list_conditions" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
@@ -1321,20 +1377,20 @@
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "List[ListMappingsActions200ResponseInner]",
-            '401': "Error",
+            '200': "List[ListConditions200ResponseInner]",
+            '401': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/actions', 'GET',
+            '/api/2/apps/{app_id}/rules/conditions', 'GET',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1343,66 +1399,69 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def sort_mappings(self, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> List[int]:  # noqa: E501
+    def sort_app_rules(self, app_id : StrictInt, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> List[int]:  # noqa: E501
         """Bulk Sort  # noqa: E501
 
-        Bulk Sort Mappings  # noqa: E501
+        Sort App rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.sort_mappings(request_body, async_req=True)
+        >>> thread = api.sort_app_rules(app_id, request_body, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param request_body:
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[int]
         """
         kwargs['_return_http_data_only'] = True
-        return self.sort_mappings_with_http_info(request_body, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the sort_app_rules_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.sort_app_rules_with_http_info(app_id, request_body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def sort_mappings_with_http_info(self, request_body : Optional[conlist(StrictInt)] = None, **kwargs):  # noqa: E501
+    def sort_app_rules_with_http_info(self, app_id : StrictInt, request_body : Optional[conlist(StrictInt)] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Bulk Sort  # noqa: E501
 
-        Bulk Sort Mappings  # noqa: E501
+        Sort App rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.sort_mappings_with_http_info(request_body, async_req=True)
+        >>> thread = api.sort_app_rules_with_http_info(app_id, request_body, async_req=True)
         >>> result = thread.get()
 
+        :param app_id: (required)
+        :type app_id: int
         :param request_body:
         :type request_body: List[int]
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1413,14 +1472,15 @@
                  returns the request thread.
         :rtype: tuple(List[int], status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
+            'app_id',
             'request_body'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
@@ -1432,34 +1492,37 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method sort_mappings" % _key
+                    " to method sort_app_rules" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['request_body']:
+        if _params['request_body'] is not None:
             _body_params = _params['request_body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1470,20 +1533,20 @@
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
             '200': "List[int]",
-            '401': "Error",
-            '422': "Error",
+            '401': "AltErr",
+            '422': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/sort', 'PUT',
+            '/api/2/apps/{app_id}/rules/sort', 'PUT',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
@@ -1492,95 +1555,94 @@
             _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
             _preload_content=_params.get('_preload_content', True),
             _request_timeout=_params.get('_request_timeout'),
             collection_formats=_collection_formats,
             _request_auth=_params.get('_request_auth'))
 
     @validate_arguments
-    def update_mapping(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], content_type : Optional[StrictStr] = None, body : Optional[Dict[str, Any]] = None, **kwargs) -> int:  # noqa: E501
-        """Update Mapping  # noqa: E501
+    def update_app_rule(self, app_id : StrictInt, rule_id : StrictStr, app_rule : Optional[AppRule] = None, **kwargs) -> AppRule:  # noqa: E501
+        """Update Rule  # noqa: E501
 
-        Update Mapping  # noqa: E501
+        Update App Rule.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.update_mapping(mapping_id, content_type, body, async_req=True)
+        >>> thread = api.update_app_rule(app_id, rule_id, app_rule, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
-        :param content_type:
-        :type content_type: str
-        :param body:
-        :type body: object
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
+        :param app_rule:
+        :type app_rule: AppRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: int
+        :rtype: AppRule
         """
         kwargs['_return_http_data_only'] = True
-        return self.update_mapping_with_http_info(mapping_id, content_type, body, **kwargs)  # noqa: E501
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_app_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
+        return self.update_app_rule_with_http_info(app_id, rule_id, app_rule, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_mapping_with_http_info(self, mapping_id : Annotated[StrictInt, Field(..., description="The id of the user mapping to locate.")], content_type : Optional[StrictStr] = None, body : Optional[Dict[str, Any]] = None, **kwargs):  # noqa: E501
-        """Update Mapping  # noqa: E501
+    def update_app_rule_with_http_info(self, app_id : StrictInt, rule_id : StrictStr, app_rule : Optional[AppRule] = None, **kwargs) -> ApiResponse:  # noqa: E501
+        """Update Rule  # noqa: E501
 
-        Update Mapping  # noqa: E501
+        Update App Rule.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.update_mapping_with_http_info(mapping_id, content_type, body, async_req=True)
+        >>> thread = api.update_app_rule_with_http_info(app_id, rule_id, app_rule, async_req=True)
         >>> result = thread.get()
 
-        :param mapping_id: The id of the user mapping to locate. (required)
-        :type mapping_id: int
-        :param content_type:
-        :type content_type: str
-        :param body:
-        :type body: object
+        :param app_id: (required)
+        :type app_id: int
+        :param rule_id: (required)
+        :type rule_id: str
+        :param app_rule:
+        :type app_rule: AppRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :type _request_auth: dict, optional
         :type _content_type: string, optional: force content-type for the request
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
-        :rtype: tuple(int, status_code(int), headers(HTTPHeaderDict))
+        :rtype: tuple(AppRule, status_code(int), headers(HTTPHeaderDict))
         """
 
         _params = locals()
 
         _all_params = [
-            'mapping_id',
-            'content_type',
-            'body'
+            'app_id',
+            'rule_id',
+            'app_rule'
         ]
         _all_params.extend(
             [
                 'async_req',
                 '_return_http_data_only',
                 '_preload_content',
                 '_request_timeout',
@@ -1591,41 +1653,41 @@
         )
 
         # validate the arguments
         for _key, _val in _params['kwargs'].items():
             if _key not in _all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_mapping" % _key
+                    " to method update_app_rule" % _key
                 )
             _params[_key] = _val
         del _params['kwargs']
 
         _collection_formats = {}
 
         # process the path parameters
         _path_params = {}
-        if _params['mapping_id']:
-            _path_params['mapping_id'] = _params['mapping_id']
+        if _params['app_id']:
+            _path_params['app_id'] = _params['app_id']
+
+        if _params['rule_id']:
+            _path_params['rule_id'] = _params['rule_id']
 
 
         # process the query parameters
         _query_params = []
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
-        if _params['content_type']:
-            _header_params['Content-Type'] = _params['content_type']
-
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['body']:
-            _body_params = _params['body']
+        if _params['app_rule'] is not None:
+            _body_params = _params['app_rule']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get('_content_type',
@@ -1634,21 +1696,21 @@
         if _content_types_list:
                 _header_params['Content-Type'] = _content_types_list
 
         # authentication setting
         _auth_settings = ['OAuth2']  # noqa: E501
 
         _response_types_map = {
-            '200': "int",
-            '401': "Error",
-            '422': "Error",
+            '200': "AppRule",
+            '401': "AltErr",
+            '422': "AltErr",
         }
 
         return self.api_client.call_api(
-            '/api/2/mappings/{mapping_id}', 'PUT',
+            '/api/2/apps/{app_id}/rules/{rule_id}', 'PUT',
             _path_params,
             _query_params,
             _header_params,
             body=_body_params,
             post_params=_form_params,
             files=_files,
             response_types_map=_response_types_map,
```

### Comparing `onelogin-3.1.4/onelogin/api/users_v1_api.py` & `onelogin-3.1.5/onelogin/api/users_v1_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,14 +9,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr
 
 from typing import Any, Dict, List, Optional
@@ -30,14 +32,15 @@
 from onelogin.models.remove_user_role_request import RemoveUserRoleRequest
 from onelogin.models.set_user_state_request import SetUserStateRequest
 from onelogin.models.update_password_insecure_request import UpdatePasswordInsecureRequest
 from onelogin.models.update_password_secure_request import UpdatePasswordSecureRequest
 from onelogin.models.user import User
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class UsersV1Api(object):
@@ -65,32 +68,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param add_roles_to_user_request:
         :type add_roles_to_user_request: AddRolesToUserRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the add_roles_to_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.add_roles_to_user_with_http_info(user_id, add_roles_to_user_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def add_roles_to_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], add_roles_to_user_request : Optional[AddRolesToUserRequest] = None, **kwargs):  # noqa: E501
+    def add_roles_to_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], add_roles_to_user_request : Optional[AddRolesToUserRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Add Roles for a User  # noqa: E501
 
         Add Roles for a User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.add_roles_to_user_with_http_info(user_id, add_roles_to_user_request, async_req=True)
@@ -98,21 +99,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param add_roles_to_user_request:
         :type add_roles_to_user_request: AddRolesToUserRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -165,15 +167,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['add_roles_to_user_request']:
+        if _params['add_roles_to_user_request'] is not None:
             _body_params = _params['add_roles_to_user_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -226,32 +228,30 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_user_with_http_info(mappings, validate_policy, user, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_user_with_http_info(self, mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs):  # noqa: E501
+    def create_user_with_http_info(self, mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create a User  # noqa: E501
 
         Create a User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_user_with_http_info(mappings, validate_policy, user, async_req=True)
@@ -261,21 +261,22 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -332,15 +333,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['user']:
+        if _params['user'] is not None:
             _body_params = _params['user']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -388,52 +389,51 @@
         >>> thread = api.delete_user(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def delete_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete a User  # noqa: E501
 
         Delete A User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_user_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -524,50 +524,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_custom_attributes(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetCustomAttributes200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_custom_attributes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_custom_attributes_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_custom_attributes_with_http_info(self, **kwargs):  # noqa: E501
+    def get_custom_attributes_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Custom Attributes  # noqa: E501
 
         Get Custom Attributes  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_custom_attributes_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -662,32 +661,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param ignore_visibility: Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.
         :type ignore_visibility: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[GetUserApps200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_apps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_apps_with_http_info(user_id, ignore_visibility, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_apps_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], ignore_visibility : Annotated[Optional[StrictBool], Field(description="Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.")] = None, **kwargs):  # noqa: E501
+    def get_user_apps_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], ignore_visibility : Annotated[Optional[StrictBool], Field(description="Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Apps for a User  # noqa: E501
 
         Get Apps for User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_apps_with_http_info(user_id, ignore_visibility, async_req=True)
@@ -695,21 +692,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param ignore_visibility: Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.
         :type ignore_visibility: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,52 +808,51 @@
         >>> thread = api.get_user_by_id(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_by_id_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_by_id_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_user_by_id_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User by ID  # noqa: E501
 
         Get User By ID  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_by_id_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -952,52 +949,51 @@
         >>> thread = api.get_user_roles(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetUserRoles200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_roles_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_roles_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_roles_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_user_roles_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get Roles for a User  # noqa: E501
 
         Get User Roles  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_roles_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1132,32 +1128,30 @@
         :type user_ids: str
         :param custom_attributes_attribute_name: The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.
         :type custom_attributes_attribute_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[User]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_users_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_users_with_http_info(limit, page, cursor, created_since, created_until, updated_since, updated_until, last_login_since, last_login_until, firstname, lastname, email, username, samaccountname, directory_id, external_id, user_ids, custom_attributes_attribute_name, fields, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_users_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, created_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created after a given date & time.")] = None, created_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created before a given date & time.")] = None, updated_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated after a given date & time.")] = None, updated_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated before a given date & time.")] = None, last_login_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in after a given date & time.")] = None, last_login_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in before a given date & time.")] = None, firstname : Annotated[Optional[StrictStr], Field(description="The first name of the user")] = None, lastname : Annotated[Optional[StrictStr], Field(description="The last name of the user")] = None, email : Annotated[Optional[StrictStr], Field(description="The email address of the user")] = None, username : Annotated[Optional[StrictStr], Field(description="The username for the user")] = None, samaccountname : Annotated[Optional[StrictStr], Field(description="The AD login name for the user")] = None, directory_id : Optional[StrictInt] = None, external_id : Annotated[Optional[StrictStr], Field(description="An external identifier that has been set on the user")] = None, user_ids : Annotated[Optional[StrictStr], Field(description="A comma separated list of OneLogin User IDs")] = None, custom_attributes_attribute_name : Annotated[Optional[StrictStr], Field(description="The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs):  # noqa: E501
+    def list_users_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, created_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created after a given date & time.")] = None, created_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created before a given date & time.")] = None, updated_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated after a given date & time.")] = None, updated_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated before a given date & time.")] = None, last_login_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in after a given date & time.")] = None, last_login_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in before a given date & time.")] = None, firstname : Annotated[Optional[StrictStr], Field(description="The first name of the user")] = None, lastname : Annotated[Optional[StrictStr], Field(description="The last name of the user")] = None, email : Annotated[Optional[StrictStr], Field(description="The email address of the user")] = None, username : Annotated[Optional[StrictStr], Field(description="The username for the user")] = None, samaccountname : Annotated[Optional[StrictStr], Field(description="The AD login name for the user")] = None, directory_id : Optional[StrictInt] = None, external_id : Annotated[Optional[StrictStr], Field(description="An external identifier that has been set on the user")] = None, user_ids : Annotated[Optional[StrictStr], Field(description="A comma separated list of OneLogin User IDs")] = None, custom_attributes_attribute_name : Annotated[Optional[StrictStr], Field(description="The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Users  # noqa: E501
 
         List Users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_users_with_http_info(limit, page, cursor, created_since, created_until, updated_since, updated_until, last_login_since, last_login_until, firstname, lastname, email, username, samaccountname, directory_id, external_id, user_ids, custom_attributes_attribute_name, fields, async_req=True)
@@ -1199,21 +1193,22 @@
         :type user_ids: str
         :param custom_attributes_attribute_name: The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.
         :type custom_attributes_attribute_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1385,32 +1380,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param lock_account_user_request:
         :type lock_account_user_request: LockAccountUserRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the lock_account_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.lock_account_user_with_http_info(user_id, lock_account_user_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def lock_account_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], lock_account_user_request : Optional[LockAccountUserRequest] = None, **kwargs):  # noqa: E501
+    def lock_account_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], lock_account_user_request : Optional[LockAccountUserRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Lock User Account  # noqa: E501
 
         Lock User Account  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.lock_account_user_with_http_info(user_id, lock_account_user_request, async_req=True)
@@ -1418,21 +1411,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param lock_account_user_request:
         :type lock_account_user_request: LockAccountUserRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1485,15 +1479,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['lock_account_user_request']:
+        if _params['lock_account_user_request'] is not None:
             _body_params = _params['lock_account_user_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1544,32 +1538,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param body:
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the log_out_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.log_out_user_with_http_info(user_id, body, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def log_out_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], body : Optional[Dict[str, Any]] = None, **kwargs):  # noqa: E501
+    def log_out_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], body : Optional[Dict[str, Any]] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Log User Out  # noqa: E501
 
         Log Out User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.log_out_user_with_http_info(user_id, body, async_req=True)
@@ -1577,21 +1569,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param body:
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1644,15 +1637,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['body']:
+        if _params['body'] is not None:
             _body_params = _params['body']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1703,32 +1696,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param remove_user_role_request:
         :type remove_user_role_request: RemoveUserRoleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the remove_user_role_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.remove_user_role_with_http_info(user_id, remove_user_role_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def remove_user_role_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], remove_user_role_request : Optional[RemoveUserRoleRequest] = None, **kwargs):  # noqa: E501
+    def remove_user_role_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], remove_user_role_request : Optional[RemoveUserRoleRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Remove Roles for a User  # noqa: E501
 
         Remove Roles for a User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.remove_user_role_with_http_info(user_id, remove_user_role_request, async_req=True)
@@ -1736,21 +1727,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param remove_user_role_request:
         :type remove_user_role_request: RemoveUserRoleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1803,15 +1795,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['remove_user_role_request']:
+        if _params['remove_user_role_request'] is not None:
             _body_params = _params['remove_user_role_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1862,32 +1854,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param set_user_state_request:
         :type set_user_state_request: SetUserStateRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the set_user_state_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.set_user_state_with_http_info(user_id, set_user_state_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def set_user_state_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], set_user_state_request : Optional[SetUserStateRequest] = None, **kwargs):  # noqa: E501
+    def set_user_state_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], set_user_state_request : Optional[SetUserStateRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Set User State  # noqa: E501
 
         Set User State  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.set_user_state_with_http_info(user_id, set_user_state_request, async_req=True)
@@ -1895,21 +1885,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param set_user_state_request:
         :type set_user_state_request: SetUserStateRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1962,15 +1953,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['set_user_state_request']:
+        if _params['set_user_state_request'] is not None:
             _body_params = _params['set_user_state_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -2021,32 +2012,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param update_password_insecure_request:
         :type update_password_insecure_request: UpdatePasswordInsecureRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_password_insecure_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_password_insecure_with_http_info(user_id, update_password_insecure_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_password_insecure_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], update_password_insecure_request : Optional[UpdatePasswordInsecureRequest] = None, **kwargs):  # noqa: E501
+    def update_password_insecure_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], update_password_insecure_request : Optional[UpdatePasswordInsecureRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Set Password Using ID in Cleartext  # noqa: E501
 
         Update User password using their ID. This is done in cleartext and is insecure.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_password_insecure_with_http_info(user_id, update_password_insecure_request, async_req=True)
@@ -2054,21 +2043,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param update_password_insecure_request:
         :type update_password_insecure_request: UpdatePasswordInsecureRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2121,15 +2111,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['update_password_insecure_request']:
+        if _params['update_password_insecure_request'] is not None:
             _body_params = _params['update_password_insecure_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -2180,32 +2170,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param update_password_secure_request:
         :type update_password_secure_request: UpdatePasswordSecureRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: Error
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_password_secure_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_password_secure_with_http_info(user_id, update_password_secure_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_password_secure_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], update_password_secure_request : Optional[UpdatePasswordSecureRequest] = None, **kwargs):  # noqa: E501
+    def update_password_secure_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], update_password_secure_request : Optional[UpdatePasswordSecureRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Set Password Using ID and SHA-256 and Salt  # noqa: E501
 
         Update User Password Using ID and SHA-256 with salt.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_password_secure_with_http_info(user_id, update_password_secure_request, async_req=True)
@@ -2213,21 +2201,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param update_password_secure_request:
         :type update_password_secure_request: UpdatePasswordSecureRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2280,15 +2269,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['update_password_secure_request']:
+        if _params['update_password_secure_request'] is not None:
             _body_params = _params['update_password_secure_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -2343,32 +2332,30 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_user_with_http_info(user_id, mappings, validate_policy, user, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs):  # noqa: E501
+    def update_user_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update a User  # noqa: E501
 
         Update a User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_user_with_http_info(user_id, mappings, validate_policy, user, async_req=True)
@@ -2380,21 +2367,22 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2455,15 +2443,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['user']:
+        if _params['user'] is not None:
             _body_params = _params['user']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/users_v2_api.py` & `onelogin-3.1.5/onelogin/api/users_v2_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,26 +9,29 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr
 
 from typing import List, Optional
 
 from onelogin.models.get_user_apps200_response_inner import GetUserApps200ResponseInner
 from onelogin.models.user import User
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class UsersV2Api(object):
@@ -58,32 +61,30 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_user2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_user2_with_http_info(mappings, validate_policy, user, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_user2_with_http_info(self, mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs):  # noqa: E501
+    def create_user2_with_http_info(self, mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create User  # noqa: E501
 
         Create User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_user2_with_http_info(mappings, validate_policy, user, async_req=True)
@@ -93,21 +94,22 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -164,15 +166,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['user']:
+        if _params['user'] is not None:
             _body_params = _params['user']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -220,52 +222,51 @@
         >>> thread = api.delete_user2(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_user2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_user2_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def delete_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Delete User  # noqa: E501
 
         Delete User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_user2_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -358,52 +359,51 @@
         >>> thread = api.get_user2(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user2_with_http_info(user_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs):  # noqa: E501
+    def get_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], **kwargs) -> ApiResponse:  # noqa: E501
         """Get User  # noqa: E501
 
         Get User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user2_with_http_info(user_id, async_req=True)
         >>> result = thread.get()
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -502,32 +502,30 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param ignore_visibility: Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.
         :type ignore_visibility: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[GetUserApps200ResponseInner]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_user_apps2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_user_apps2_with_http_info(user_id, ignore_visibility, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_user_apps2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], ignore_visibility : Annotated[Optional[StrictBool], Field(description="Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.")] = None, **kwargs):  # noqa: E501
+    def get_user_apps2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], ignore_visibility : Annotated[Optional[StrictBool], Field(description="Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get User Apps  # noqa: E501
 
         Get User Apps  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_user_apps2_with_http_info(user_id, ignore_visibility, async_req=True)
@@ -535,21 +533,22 @@
 
         :param user_id: Set to the id of the user that you want to return. (required)
         :type user_id: int
         :param ignore_visibility: Defaults to `false`. When `true` will show all apps that are assigned to a user regardless of their portal visibility setting.
         :type ignore_visibility: bool
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -686,32 +685,30 @@
         :type user_ids: str
         :param custom_attributes_attribute_name: The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.
         :type custom_attributes_attribute_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[User]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_users2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_users2_with_http_info(limit, page, cursor, created_since, created_until, updated_since, updated_until, last_login_since, last_login_until, firstname, lastname, email, username, samaccountname, directory_id, external_id, user_ids, custom_attributes_attribute_name, fields, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_users2_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, created_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created after a given date & time.")] = None, created_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created before a given date & time.")] = None, updated_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated after a given date & time.")] = None, updated_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated before a given date & time.")] = None, last_login_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in after a given date & time.")] = None, last_login_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in before a given date & time.")] = None, firstname : Annotated[Optional[StrictStr], Field(description="The first name of the user")] = None, lastname : Annotated[Optional[StrictStr], Field(description="The last name of the user")] = None, email : Annotated[Optional[StrictStr], Field(description="The email address of the user")] = None, username : Annotated[Optional[StrictStr], Field(description="The username for the user")] = None, samaccountname : Annotated[Optional[StrictStr], Field(description="The AD login name for the user")] = None, directory_id : Optional[StrictInt] = None, external_id : Annotated[Optional[StrictStr], Field(description="An external identifier that has been set on the user")] = None, user_ids : Annotated[Optional[StrictStr], Field(description="A comma separated list of OneLogin User IDs")] = None, custom_attributes_attribute_name : Annotated[Optional[StrictStr], Field(description="The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs):  # noqa: E501
+    def list_users2_with_http_info(self, limit : Annotated[Optional[StrictInt], Field(description="How many items to return at one time (max 100)")] = None, page : Annotated[Optional[StrictInt], Field(description="The page number of results to return.")] = None, cursor : Annotated[Optional[StrictStr], Field(description="Set to the value extracted from Before-Cursor or After-Cursor headers to return the previous or next page.")] = None, created_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created after a given date & time.")] = None, created_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users created before a given date & time.")] = None, updated_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated after a given date & time.")] = None, updated_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users updated before a given date & time.")] = None, last_login_since : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in after a given date & time.")] = None, last_login_until : Annotated[Optional[StrictStr], Field(description="An ISO8601 timestamp value that returns all users that logged in before a given date & time.")] = None, firstname : Annotated[Optional[StrictStr], Field(description="The first name of the user")] = None, lastname : Annotated[Optional[StrictStr], Field(description="The last name of the user")] = None, email : Annotated[Optional[StrictStr], Field(description="The email address of the user")] = None, username : Annotated[Optional[StrictStr], Field(description="The username for the user")] = None, samaccountname : Annotated[Optional[StrictStr], Field(description="The AD login name for the user")] = None, directory_id : Optional[StrictInt] = None, external_id : Annotated[Optional[StrictStr], Field(description="An external identifier that has been set on the user")] = None, user_ids : Annotated[Optional[StrictStr], Field(description="A comma separated list of OneLogin User IDs")] = None, custom_attributes_attribute_name : Annotated[Optional[StrictStr], Field(description="The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.")] = None, fields : Annotated[Optional[StrictStr], Field(description="Optional. Comma delimited list of fields to return.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """List Users  # noqa: E501
 
         Get a list of users  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_users2_with_http_info(limit, page, cursor, created_since, created_until, updated_since, updated_until, last_login_since, last_login_until, firstname, lastname, email, username, samaccountname, directory_id, external_id, user_ids, custom_attributes_attribute_name, fields, async_req=True)
@@ -753,21 +750,22 @@
         :type user_ids: str
         :param custom_attributes_attribute_name: The short name of a custom attribute. Note that the attribute name is prefixed with custom_attributes.
         :type custom_attributes_attribute_name: str
         :param fields: Optional. Comma delimited list of fields to return.
         :type fields: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -943,32 +941,30 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: User
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_user2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_user2_with_http_info(user_id, mappings, validate_policy, user, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs):  # noqa: E501
+    def update_user2_with_http_info(self, user_id : Annotated[StrictInt, Field(..., description="Set to the id of the user that you want to return.")], mappings : Annotated[Optional[StrictStr], Field(description="Controls how mappings will be applied to the user on creation. Defaults to async.")] = None, validate_policy : Annotated[Optional[StrictBool], Field(description="Will passwords validate against the User Policy? Defaults to true.")] = None, user : Optional[User] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update User  # noqa: E501
 
         Update User  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_user2_with_http_info(user_id, mappings, validate_policy, user, async_req=True)
@@ -980,21 +976,22 @@
         :type mappings: str
         :param validate_policy: Will passwords validate against the User Policy? Defaults to true.
         :type validate_policy: bool
         :param user:
         :type user: User
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1055,15 +1052,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['user']:
+        if _params['user'] is not None:
             _body_params = _params['user']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api/vigilance_ai_api.py` & `onelogin-3.1.5/onelogin/api/vigilance_ai_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,14 +10,16 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 import re  # noqa: F401
+import io
+import warnings
 
 from pydantic import validate_arguments, ValidationError
 from typing_extensions import Annotated
 
 from pydantic import Field, StrictStr
 
 from typing import List, Optional
@@ -25,14 +28,15 @@
 from onelogin.models.get_risk_score_request import GetRiskScoreRequest
 from onelogin.models.get_risk_scores200_response import GetRiskScores200Response
 from onelogin.models.risk_rule import RiskRule
 from onelogin.models.track_risk_event_request import TrackRiskEventRequest
 from onelogin.models.update_risk_rule_request import UpdateRiskRuleRequest
 
 from onelogin.api_client import ApiClient
+from onelogin.api_response import ApiResponse
 from onelogin.exceptions import (  # noqa: F401
     ApiTypeError,
     ApiValueError
 )
 
 
 class VigilanceAIApi(object):
@@ -58,52 +62,51 @@
         >>> thread = api.create_risk_rule(risk_rule, async_req=True)
         >>> result = thread.get()
 
         :param risk_rule:
         :type risk_rule: RiskRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RiskRule
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the create_risk_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.create_risk_rule_with_http_info(risk_rule, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def create_risk_rule_with_http_info(self, risk_rule : Optional[RiskRule] = None, **kwargs):  # noqa: E501
+    def create_risk_rule_with_http_info(self, risk_rule : Optional[RiskRule] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Create Rule  # noqa: E501
 
         Create Vigilance AI (Risk Service) Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.create_risk_rule_with_http_info(risk_rule, async_req=True)
         >>> result = thread.get()
 
         :param risk_rule:
         :type risk_rule: RiskRule
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -152,15 +155,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['risk_rule']:
+        if _params['risk_rule'] is not None:
             _body_params = _params['risk_rule']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -207,52 +210,51 @@
         >>> thread = api.delete_risk_rule(rule_id, async_req=True)
         >>> result = thread.get()
 
         :param rule_id: (required)
         :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the delete_risk_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.delete_risk_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def delete_risk_rule_with_http_info(self, rule_id : StrictStr, **kwargs):  # noqa: E501
+    def delete_risk_rule_with_http_info(self, rule_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """Delete Rule  # noqa: E501
 
         Delete Vigilance AI (Risk Service)  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_risk_rule_with_http_info(rule_id, async_req=True)
         >>> result = thread.get()
 
         :param rule_id: (required)
         :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -345,52 +347,51 @@
         >>> thread = api.get_risk_rule(rule_id, async_req=True)
         >>> result = thread.get()
 
         :param rule_id: (required)
         :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RiskRule
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_risk_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_risk_rule_with_http_info(rule_id, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_risk_rule_with_http_info(self, rule_id : StrictStr, **kwargs):  # noqa: E501
+    def get_risk_rule_with_http_info(self, rule_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
         """get Risk Rule  # noqa: E501
 
         Use this API to return a single rule that has been created in the Risk Sevice.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_risk_rule_with_http_info(rule_id, async_req=True)
         >>> result = thread.get()
 
         :param rule_id: (required)
         :type rule_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -490,32 +491,30 @@
         :type get_risk_score_request: GetRiskScoreRequest
         :param before: Optional ISO8601 formatted date string. Defaults to current date. Maximum date is 90 days ago.
         :type before: str
         :param after: Optional ISO8601 formatted date string. Defaults to 30 days ago. Maximum date is 90 days ago.
         :type after: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetRiskScore200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_risk_score_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_risk_score_with_http_info(get_risk_score_request, before, after, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_risk_score_with_http_info(self, get_risk_score_request : GetRiskScoreRequest, before : Annotated[Optional[StrictStr], Field(description="Optional ISO8601 formatted date string. Defaults to current date. Maximum date is 90 days ago.")] = None, after : Annotated[Optional[StrictStr], Field(description="Optional ISO8601 formatted date string. Defaults to 30 days ago. Maximum date is 90 days ago.")] = None, **kwargs):  # noqa: E501
+    def get_risk_score_with_http_info(self, get_risk_score_request : GetRiskScoreRequest, before : Annotated[Optional[StrictStr], Field(description="Optional ISO8601 formatted date string. Defaults to current date. Maximum date is 90 days ago.")] = None, after : Annotated[Optional[StrictStr], Field(description="Optional ISO8601 formatted date string. Defaults to 30 days ago. Maximum date is 90 days ago.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Get a Risk Score  # noqa: E501
 
         Get Vigilance AI (Risk Service) Score  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_risk_score_with_http_info(get_risk_score_request, before, after, async_req=True)
@@ -525,21 +524,22 @@
         :type get_risk_score_request: GetRiskScoreRequest
         :param before: Optional ISO8601 formatted date string. Defaults to current date. Maximum date is 90 days ago.
         :type before: str
         :param after: Optional ISO8601 formatted date string. Defaults to 30 days ago. Maximum date is 90 days ago.
         :type after: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -596,15 +596,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['get_risk_score_request']:
+        if _params['get_risk_score_request'] is not None:
             _body_params = _params['get_risk_score_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -649,50 +649,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_risk_scores(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GetRiskScores200Response
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the get_risk_scores_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.get_risk_scores_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def get_risk_scores_with_http_info(self, **kwargs):  # noqa: E501
+    def get_risk_scores_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """Get Score Summary  # noqa: E501
 
         Get Vigilance AI (Risk Service) Score Summary  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.get_risk_scores_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -782,50 +781,49 @@
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_risk_rules(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: List[RiskRule]
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the list_risk_rules_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.list_risk_rules_with_http_info(**kwargs)  # noqa: E501
 
     @validate_arguments
-    def list_risk_rules_with_http_info(self, **kwargs):  # noqa: E501
+    def list_risk_rules_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
         """List Rules  # noqa: E501
 
         List Vigilance AI (Risk Service) Rules  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.list_risk_rules_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -917,52 +915,51 @@
         >>> thread = api.track_risk_event(track_risk_event_request, async_req=True)
         >>> result = thread.get()
 
         :param track_risk_event_request: (required)
         :type track_risk_event_request: TrackRiskEventRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: None
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the track_risk_event_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.track_risk_event_with_http_info(track_risk_event_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def track_risk_event_with_http_info(self, track_risk_event_request : TrackRiskEventRequest, **kwargs):  # noqa: E501
+    def track_risk_event_with_http_info(self, track_risk_event_request : TrackRiskEventRequest, **kwargs) -> ApiResponse:  # noqa: E501
         """Track an Event  # noqa: E501
 
         Track Vigilance AI (Risk Service) Event  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.track_risk_event_with_http_info(track_risk_event_request, async_req=True)
         >>> result = thread.get()
 
         :param track_risk_event_request: (required)
         :type track_risk_event_request: TrackRiskEventRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1011,15 +1008,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['track_risk_event_request']:
+        if _params['track_risk_event_request'] is not None:
             _body_params = _params['track_risk_event_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
@@ -1064,32 +1061,30 @@
 
         :param rule_id: (required)
         :type rule_id: str
         :param update_risk_rule_request:
         :type update_risk_rule_request: UpdateRiskRuleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RiskRule
         """
         kwargs['_return_http_data_only'] = True
+        if '_preload_content' in kwargs:
+            raise ValueError("Error! Please call the update_risk_rule_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
         return self.update_risk_rule_with_http_info(rule_id, update_risk_rule_request, **kwargs)  # noqa: E501
 
     @validate_arguments
-    def update_risk_rule_with_http_info(self, rule_id : StrictStr, update_risk_rule_request : Optional[UpdateRiskRuleRequest] = None, **kwargs):  # noqa: E501
+    def update_risk_rule_with_http_info(self, rule_id : StrictStr, update_risk_rule_request : Optional[UpdateRiskRuleRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
         """Update Rule  # noqa: E501
 
         Update Vigilance AI (Risk Service) Rule  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.update_risk_rule_with_http_info(rule_id, update_risk_rule_request, async_req=True)
@@ -1097,21 +1092,22 @@
 
         :param rule_id: (required)
         :type rule_id: str
         :param update_risk_rule_request:
         :type update_risk_rule_request: UpdateRiskRuleRequest
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the 
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1164,15 +1160,15 @@
         # process the header parameters
         _header_params = dict(_params.get('_headers', {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params['update_risk_rule_request']:
+        if _params['update_risk_rule_request'] is not None:
             _body_params = _params['update_risk_rule_request']
 
         # set the HTTP header `Accept`
         _header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json'])  # noqa: E501
 
         # set the HTTP header `Content-Type`
```

### Comparing `onelogin-3.1.4/onelogin/api_client.py` & `onelogin-3.1.5/onelogin/api_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -21,14 +22,15 @@
 import os
 import re
 import tempfile
 
 from urllib.parse import quote
 
 from onelogin.configuration import Configuration
+from onelogin.api_response import ApiResponse
 import onelogin.models
 from onelogin import rest
 from onelogin.exceptions import ApiValueError, ApiException
 
 
 class ApiClient(object):
     """Generic API client for OpenAPI client library builds.
@@ -71,15 +73,15 @@
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/3.1.4/python'
+        self.user_agent = 'OpenAPI-Generator/3.1.5/python'
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
         self.close()
@@ -217,44 +219,44 @@
         except ApiException as e:
             if e.body:
                 e.body = e.body.decode('utf-8')
             raise e
 
         self.last_response = response_data
 
-        return_data = response_data
-
-        if not _preload_content:
-            return return_data
-
-        response_type = response_types_map.get(str(response_data.status), None)
-
-        if response_type == "bytearray":
-            response_data.data = response_data.data
-        else:
-            match = None
-            content_type = response_data.getheader('content-type')
-            if content_type is not None:
-                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-            encoding = match.group(1) if match else "utf-8"
-            response_data.data = response_data.data.decode(encoding)
-
-        # deserialize response data
-        if response_type == "bytearray":
-            return_data = response_data.data
-        elif response_type:
-            return_data = self.deserialize(response_data, response_type)
-        else:
-            return_data = None
+        return_data = None # assuming derialization is not needed
+        # data needs deserialization or returns HTTP data (deserialized) only
+        if _preload_content or _return_http_data_only:
+          response_type = response_types_map.get(str(response_data.status), None)
+
+          if response_type == "bytearray":
+              response_data.data = response_data.data
+          else:
+              match = None
+              content_type = response_data.getheader('content-type')
+              if content_type is not None:
+                  match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+              encoding = match.group(1) if match else "utf-8"
+              response_data.data = response_data.data.decode(encoding)
+
+          # deserialize response data
+          if response_type == "bytearray":
+              return_data = response_data.data
+          elif response_type:
+              return_data = self.deserialize(response_data, response_type)
+          else:
+              return_data = None
 
         if _return_http_data_only:
-            return (return_data)
+            return return_data
         else:
-            return (return_data, response_data.status,
-                    response_data.getheaders())
+            return ApiResponse(status_code = response_data.status,
+                           data = return_data,
+                           headers = response_data.getheaders(),
+                           raw_data = response_data.data)
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -354,16 +356,16 @@
             return self.__deserialize_model(data, klass)
 
     def call_api(self, resource_path, method,
                  path_params=None, query_params=None, header_params=None,
                  body=None, post_params=None, files=None,
                  response_types_map=None, auth_settings=None,
                  async_req=None, _return_http_data_only=None,
-                 collection_formats=None,_preload_content=True,
-                  _request_timeout=None, _host=None, _request_auth=None):
+                 collection_formats=None, _preload_content=True,
+                 _request_timeout=None, _host=None, _request_auth=None):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async_req request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
@@ -374,21 +376,22 @@
         :param post_params dict: Request post form parameters,
             for `application/x-www-form-urlencoded`, `multipart/form-data`.
         :param auth_settings list: Auth Settings names for the request.
         :param response: Response data type.
         :param files dict: key -> filename, value -> filepath,
             for `multipart/form-data`.
         :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data without head status code
-                                       and headers
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :param collection_formats: dict of collection formats for path, query,
             header, and post parameters.
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `onelogin-3.1.4/onelogin/configuration.py` & `onelogin-3.1.5/onelogin/configuration.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -158,14 +159,18 @@
         """
         self.key_file = None
         """client key file
         """
         self.assert_hostname = None
         """Set this to True/False to enable/disable SSL hostname verification.
         """
+        self.tls_server_name = None
+        """SSL/TLS Server Name Indication (SNI)
+           Set this to the SNI value expected by the server.
+        """
 
         self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
         """urllib3 connection pool's maximum number of connections saved
            per pool. urllib3 uses 1 connection as default value, but this is
            not the best value when you are making a lot of possibly parallel
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
@@ -394,15 +399,15 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: 3.1.1\n"\
-               "SDK Package Version: 3.1.4".\
+               "SDK Package Version: 3.1.5".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `onelogin-3.1.4/onelogin/exceptions.py` & `onelogin-3.1.5/onelogin/exceptions.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/onelogin/models/__init__.py` & `onelogin-3.1.5/onelogin/models/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -46,15 +46,14 @@
 from onelogin.models.connector import Connector
 from onelogin.models.create_app200_response import CreateApp200Response
 from onelogin.models.create_app_request import CreateAppRequest
 from onelogin.models.create_device_verification201_response import CreateDeviceVerification201Response
 from onelogin.models.create_device_verification_request import CreateDeviceVerificationRequest
 from onelogin.models.create_factor_registration201_response import CreateFactorRegistration201Response
 from onelogin.models.create_factor_registration_request import CreateFactorRegistrationRequest
-from onelogin.models.create_privilege200_response import CreatePrivilege200Response
 from onelogin.models.create_role201_response_inner import CreateRole201ResponseInner
 from onelogin.models.device import Device
 from onelogin.models.email_config import EmailConfig
 from onelogin.models.enforcement_point import EnforcementPoint
 from onelogin.models.enforcement_point_resources_inner import EnforcementPointResourcesInner
 from onelogin.models.enroll_mfa_factor200_response import EnrollMfaFactor200Response
 from onelogin.models.error import Error
@@ -110,15 +109,15 @@
 from onelogin.models.list_conditions200_response_inner import ListConditions200ResponseInner
 from onelogin.models.list_mapping_action_values200_response_inner import ListMappingActionValues200ResponseInner
 from onelogin.models.list_mapping_conditions200_response import ListMappingConditions200Response
 from onelogin.models.list_mapping_conditions_operators200_response_inner import ListMappingConditionsOperators200ResponseInner
 from onelogin.models.list_mapping_contion_values200_response_inner import ListMappingContionValues200ResponseInner
 from onelogin.models.list_mappings_actions200_response_inner import ListMappingsActions200ResponseInner
 from onelogin.models.list_message_templates200_response_inner import ListMessageTemplates200ResponseInner
-from onelogin.models.list_privelege_roles200_response import ListPrivelegeRoles200Response
+from onelogin.models.list_privilege_roles200_response import ListPrivilegeRoles200Response
 from onelogin.models.locale import Locale
 from onelogin.models.lock_account_user_request import LockAccountUserRequest
 from onelogin.models.mapping import Mapping
 from onelogin.models.message_template import MessageTemplate
 from onelogin.models.message_template_template import MessageTemplateTemplate
 from onelogin.models.message_template_template_one_of import MessageTemplateTemplateOneOf
 from onelogin.models.message_template_template_one_of1 import MessageTemplateTemplateOneOf1
```

### Comparing `onelogin-3.1.4/onelogin/models/action_obj.py` & `onelogin-3.1.5/onelogin/models/action_obj.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictStr, conlist
@@ -27,14 +26,15 @@
     ActionObj
     """
     action: Optional[StrictStr] = Field(None, description="The action to apply")
     value: Optional[conlist(StrictStr)] = Field(None, description="Only applicable to provisioned and set_* actions. Items in the array will be a plain text string or valid value for the selected action.")
     __properties = ["action", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ActionObj:
         """Create an instance of ActionObj from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ActionObj.parse_obj(obj)
 
         _obj = ActionObj.parse_obj({
             "action": obj.get("action"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/activate_mfa_factors_request.py` & `onelogin-3.1.5/onelogin/models/activate_mfa_factors_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     state_token_expires_in: Optional[StrictInt] = Field(None, description="Optional. Sets the window of time in seconds that the factor must be verified within. Defaults to 120 seconds (2 minutes). Max 900 seconds (15 minutes).")
     numeric_sms_otp: Optional[StrictBool] = Field(None, description="Optional. Defaults to false. Only applies to SMS factor. When set to `true` a 6 digit numeric code will be sent to the user instead of the standard code which is alphanumeric.")
     sms_message: Optional[StrictStr] = Field(None, description="Optional. Only applies to SMS factor. A message template that will be sent via SMS. Max length of the message after template items are inserted is 160 characters. The following template variables can be included in the message. - {{otp_code}} - The security code. - {{expiration}} - The number of minutes until the one time code expires.")
     __properties = ["state_token_expires_in", "numeric_sms_otp", "sms_message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ActivateMfaFactorsRequest:
         """Create an instance of ActivateMfaFactorsRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ActivateMfaFactorsRequest.parse_obj(obj)
 
         _obj = ActivateMfaFactorsRequest.parse_obj({
             "state_token_expires_in": obj.get("state_token_expires_in"),
             "numeric_sms_otp": obj.get("numeric_sms_otp"),
             "sms_message": obj.get("sms_message")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/add_client_app201_response.py` & `onelogin-3.1.5/onelogin/models/add_client_app201_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -27,14 +26,15 @@
     AddClientApp201Response
     """
     app_id: Optional[StrictInt] = None
     api_auth_id: Optional[StrictInt] = None
     __properties = ["app_id", "api_auth_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AddClientApp201Response:
         """Create an instance of AddClientApp201Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AddClientApp201Response.parse_obj(obj)
 
         _obj = AddClientApp201Response.parse_obj({
             "app_id": obj.get("app_id"),
             "api_auth_id": obj.get("api_auth_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/add_client_app_request.py` & `onelogin-3.1.5/onelogin/models/add_client_app_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, conlist
@@ -27,14 +26,15 @@
     AddClientAppRequest
     """
     app_id: Optional[StrictInt] = Field(None, description="The ID of the OpenId Connect app to allow access through.")
     scopes: Optional[conlist(StrictInt)] = Field(None, description="An array of Scope IDs that represent scopes the app can request")
     __properties = ["app_id", "scopes"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AddClientAppRequest:
         """Create an instance of AddClientAppRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AddClientAppRequest.parse_obj(obj)
 
         _obj = AddClientAppRequest.parse_obj({
             "app_id": obj.get("app_id"),
             "scopes": obj.get("scopes")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/add_privilege_to_role201_response.py` & `onelogin-3.1.5/onelogin/models/add_privilege_to_role201_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictBool
@@ -26,14 +25,15 @@
     """
     AddPrivilegeToRole201Response
     """
     success: Optional[StrictBool] = None
     __properties = ["success"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AddPrivilegeToRole201Response:
         """Create an instance of AddPrivilegeToRole201Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AddPrivilegeToRole201Response.parse_obj(obj)
 
         _obj = AddPrivilegeToRole201Response.parse_obj({
             "success": obj.get("success")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/add_privilege_to_role_request.py` & `onelogin-3.1.5/onelogin/models/add_privilege_to_role_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, StrictInt, conlist
@@ -26,14 +25,15 @@
     """
     AddPrivilegeToRoleRequest
     """
     roles: Optional[conlist(StrictInt)] = None
     __properties = ["roles"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AddPrivilegeToRoleRequest:
         """Create an instance of AddPrivilegeToRoleRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AddPrivilegeToRoleRequest.parse_obj(obj)
 
         _obj = AddPrivilegeToRoleRequest.parse_obj({
             "roles": obj.get("roles")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/add_roles_to_user_request.py` & `onelogin-3.1.5/onelogin/models/add_roles_to_user_request.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List
 from pydantic import BaseModel, Field, StrictInt, conlist
@@ -26,14 +25,15 @@
     """
     AddRolesToUserRequest
     """
     role_id_array: conlist(StrictInt) = Field(..., description="Set to an array of one or more role IDs. The IDs must be positive integers.")
     __properties = ["role_id_array"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AddRolesToUserRequest:
         """Create an instance of AddRolesToUserRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AddRolesToUserRequest.parse_obj(obj)
 
         _obj = AddRolesToUserRequest.parse_obj({
             "role_id_array": obj.get("role_id_array")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/alt_err.py` & `onelogin-3.1.5/onelogin/models/alt_err.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     status_code: Optional[StrictInt] = Field(None, alias="statusCode", description="HTTP error code https://developer.mozilla.org/en-US/docs/Web/HTTP/Status")
     name: Optional[StrictStr] = Field(None, description="Error Code Name")
     message: Optional[StrictStr] = Field(None, description="Description of Error")
     __properties = ["statusCode", "name", "message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AltErr:
         """Create an instance of AltErr from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AltErr.parse_obj(obj)
 
         _obj = AltErr.parse_obj({
             "status_code": obj.get("statusCode"),
             "name": obj.get("name"),
             "message": obj.get("message")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/app_parameters.py` & `onelogin-3.1.5/onelogin/models/app_parameters.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -30,14 +29,15 @@
     user_attribute_macros: Optional[StrictStr] = Field(None, description="When `user_attribute_mappings` is set to `_macro_` this macro will be used to assign the parameter value.")
     label: Optional[StrictStr] = Field(None, description="The can only be set when creating a new parameter. It can not be updated.")
     include_in_saml_assertion: Optional[StrictBool] = Field(None, description="When true, this parameter will be included in a SAML assertion payload.")
     additional_properties: Dict[str, Any] = {}
     __properties = ["user_attribute_mappings", "user_attribute_macros", "label", "include_in_saml_assertion"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -66,15 +66,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AppParameters:
         """Create an instance of AppParameters from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AppParameters.parse_obj(obj)
 
         _obj = AppParameters.parse_obj({
             "user_attribute_mappings": obj.get("user_attribute_mappings"),
             "user_attribute_macros": obj.get("user_attribute_macros"),
             "label": obj.get("label"),
             "include_in_saml_assertion": obj.get("include_in_saml_assertion")
```

### Comparing `onelogin-3.1.4/onelogin/models/app_rule.py` & `onelogin-3.1.5/onelogin/models/app_rule.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, validator
@@ -34,22 +33,25 @@
     enabled: Optional[StrictBool] = Field(None, description="Indicates if the rule is enabled or not.")
     position: Optional[StrictInt] = Field(None, description="Indicates the order of the rule. When `null` this will default to last position.")
     conditions: Optional[conlist(Condition)] = Field(None, description="An array of conditions that the user must meet in order for the rule to be applied.")
     actions: Optional[conlist(ActionObj)] = None
     __properties = ["id", "name", "match", "enabled", "position", "conditions", "actions"]
 
     @validator('match')
-    def match_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('all', 'any'):
+    def match_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('all', 'any'):
             raise ValueError("must be one of enum values ('all', 'any')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -86,15 +88,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AppRule:
         """Create an instance of AppRule from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AppRule.parse_obj(obj)
 
         _obj = AppRule.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "match": obj.get("match"),
             "enabled": obj.get("enabled"),
```

### Comparing `onelogin-3.1.4/onelogin/models/assign_users_to_privilege_request.py` & `onelogin-3.1.5/onelogin/models/assign_users_to_privilege_request.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, StrictInt, conlist
@@ -26,14 +25,15 @@
     """
     AssignUsersToPrivilegeRequest
     """
     users: Optional[conlist(StrictInt)] = None
     __properties = ["users"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AssignUsersToPrivilegeRequest:
         """Create an instance of AssignUsersToPrivilegeRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AssignUsersToPrivilegeRequest.parse_obj(obj)
 
         _obj = AssignUsersToPrivilegeRequest.parse_obj({
             "users": obj.get("users")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_claim.py` & `onelogin-3.1.5/onelogin/models/auth_claim.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -28,14 +27,15 @@
     """
     name: StrictStr = Field(..., description="The attribute name for the claim when its returned in an Access Token")
     user_attribute_mappings: Optional[StrictStr] = Field(None, description="A user attribute to map values from For custom attributes prefix the name of the attribute with `custom_attribute_`. e.g. To get the value for custom attribute `employee_id` use `custom_attribute_employee_id`.")
     user_attribute_macros: Optional[StrictStr] = Field(None, description="When `user_attribute_mappings` is set to `_macro_` this macro will be used to assign the parameter value.")
     __properties = ["name", "user_attribute_mappings", "user_attribute_macros"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AuthClaim:
         """Create an instance of AuthClaim from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AuthClaim.parse_obj(obj)
 
         _obj = AuthClaim.parse_obj({
             "name": obj.get("name"),
             "user_attribute_mappings": obj.get("user_attribute_mappings"),
             "user_attribute_macros": obj.get("user_attribute_macros")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_id.py` & `onelogin-3.1.5/onelogin/models/auth_id.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt
@@ -26,14 +25,15 @@
     """
     AuthId
     """
     id: Optional[StrictInt] = Field(None, description="Unique ID for the Scope")
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AuthId:
         """Create an instance of AuthId from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AuthId.parse_obj(obj)
 
         _obj = AuthId.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_method.py` & `onelogin-3.1.5/onelogin/models/auth_method.py`

 * *Files 21% similar despite different names*

```diff
@@ -8,15 +8,15 @@
     The version of the OpenAPI document: 3.1.1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
-from inspect import getfullargspec
+import json
 import pprint
 import re  # noqa: F401
 from aenum import Enum, no_arg
 
 
 
 
@@ -35,7 +35,13 @@
     NUMBER_3 = 3
     NUMBER_4 = 4
     NUMBER_5 = 5
     NUMBER_6 = 6
     NUMBER_7 = 7
     NUMBER_8 = 8
 
+    @classmethod
+    def from_json(cls, json_str: str) -> AuthMethod:
+        """Create an instance of AuthMethod from a JSON string"""
+        return AuthMethod(json.loads(json_str))
+
+
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_scope.py` & `onelogin-3.1.5/onelogin/models/auth_scope.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="Unique ID for the Scope")
     value: Optional[StrictStr] = Field(None, description="A value representing the api scope that with be authorized")
     description: Optional[StrictStr] = Field(None, description="A description of what access the scope enables")
     __properties = ["id", "value", "description"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AuthScope:
         """Create an instance of AuthScope from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AuthScope.parse_obj(obj)
 
         _obj = AuthScope.parse_obj({
             "id": obj.get("id"),
             "value": obj.get("value"),
             "description": obj.get("description")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_server.py` & `onelogin-3.1.5/onelogin/models/auth_server.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -30,14 +29,15 @@
     id: Optional[StrictInt] = Field(None, description="Auth server unique ID in Onelogin")
     name: StrictStr = Field(..., description="Name of the API.")
     description: StrictStr = Field(..., description="Description of what the API does.")
     configuration: AuthServerConfiguration = ...
     __properties = ["id", "name", "description", "configuration"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AuthServer:
         """Create an instance of AuthServer from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AuthServer.parse_obj(obj)
 
         _obj = AuthServer.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "description": obj.get("description"),
             "configuration": AuthServerConfiguration.from_dict(obj.get("configuration")) if obj.get("configuration") is not None else None
```

### Comparing `onelogin-3.1.4/onelogin/models/auth_server_configuration.py` & `onelogin-3.1.5/onelogin/models/auth_server_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
@@ -29,14 +28,15 @@
     audiences: conlist(StrictStr) = Field(..., description="List of API endpoints that will be returned in Access Tokens.")
     refresh_token_expiration_minutes: Optional[StrictInt] = Field(None, description="The number of minutes until refresh token expires. There is no maximum expiry limit.")
     resource_identifier: StrictStr = Field(..., description="Unique identifier for the API that the Authorization Server will issue Access Tokens for.")
     access_token_expiration_minutes: Optional[StrictInt] = Field(None, description="The number of minutes until access token expires. There is no maximum expiry limit.")
     __properties = ["audiences", "refresh_token_expiration_minutes", "resource_identifier", "access_token_expiration_minutes"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AuthServerConfiguration:
         """Create an instance of AuthServerConfiguration from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AuthServerConfiguration.parse_obj(obj)
 
         _obj = AuthServerConfiguration.parse_obj({
             "audiences": obj.get("audiences"),
             "refresh_token_expiration_minutes": obj.get("refresh_token_expiration_minutes"),
             "resource_identifier": obj.get("resource_identifier"),
             "access_token_expiration_minutes": obj.get("access_token_expiration_minutes")
```

### Comparing `onelogin-3.1.4/onelogin/models/brand.py` & `onelogin-3.1.5/onelogin/models/brand.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -42,14 +41,15 @@
     login_instruction_title: StrictStr = Field(..., description="Link text to show login instruction screen.")
     hide_onelogin_footer: StrictBool = Field(..., description="Indicates if the OneLogin footer will appear at the bottom of the login page.")
     background: BrandBackground = ...
     logo: BrandLogo = ...
     __properties = ["id", "enabled", "custom_support_enabled", "custom_color", "custom_accent_color", "custom_masking_color", "custom_masking_opacity", "mfa_enrollment_message", "enable_custom_label_for_login_screen", "custom_label_text_for_login_screen", "login_instruction", "login_instruction_title", "hide_onelogin_footer", "background", "logo"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -78,15 +78,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Brand:
         """Create an instance of Brand from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Brand.parse_obj(obj)
 
         _obj = Brand.parse_obj({
             "id": obj.get("id"),
             "enabled": obj.get("enabled") if obj.get("enabled") is not None else False,
             "custom_support_enabled": obj.get("custom_support_enabled"),
             "custom_color": obj.get("custom_color"),
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_app.py` & `onelogin-3.1.5/onelogin/models/brand_app.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
@@ -34,14 +33,15 @@
     description: StrictStr = ...
     auth_method: StrictInt = ...
     created_at: StrictStr = ...
     visible: StrictBool = ...
     __properties = ["id", "updated_at", "name", "connector_id", "auth_method_description", "description", "auth_method", "created_at", "visible"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandApp:
         """Create an instance of BrandApp from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandApp.parse_obj(obj)
 
         _obj = BrandApp.parse_obj({
             "id": obj.get("id"),
             "updated_at": obj.get("updated_at"),
             "name": obj.get("name"),
             "connector_id": obj.get("connector_id"),
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_background.py` & `onelogin-3.1.5/onelogin/models/brand_background.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictInt, StrictStr
@@ -30,14 +29,15 @@
     urls: BrandBackgroundUrls = ...
     file_size: StrictInt = ...
     updated_at: StrictStr = ...
     content_type: StrictStr = ...
     __properties = ["urls", "file_size", "updated_at", "content_type"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -63,15 +63,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandBackground:
         """Create an instance of BrandBackground from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandBackground.parse_obj(obj)
 
         _obj = BrandBackground.parse_obj({
             "urls": BrandBackgroundUrls.from_dict(obj.get("urls")) if obj.get("urls") is not None else None,
             "file_size": obj.get("file_size"),
             "updated_at": obj.get("updated_at"),
             "content_type": obj.get("content_type")
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_background_urls.py` & `onelogin-3.1.5/onelogin/models/brand_background_urls.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictStr
@@ -28,14 +27,15 @@
     """
     original: StrictStr = ...
     login: StrictStr = ...
     branding: StrictStr = ...
     __properties = ["original", "login", "branding"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandBackgroundUrls:
         """Create an instance of BrandBackgroundUrls from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandBackgroundUrls.parse_obj(obj)
 
         _obj = BrandBackgroundUrls.parse_obj({
             "original": obj.get("original"),
             "login": obj.get("login"),
             "branding": obj.get("branding")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_logo.py` & `onelogin-3.1.5/onelogin/models/brand_logo.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictInt, StrictStr
@@ -30,14 +29,15 @@
     urls: BrandLogoUrls = ...
     file_size: StrictInt = ...
     updated_at: StrictStr = ...
     content_type: StrictStr = ...
     __properties = ["urls", "file_size", "updated_at", "content_type"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -63,15 +63,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandLogo:
         """Create an instance of BrandLogo from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandLogo.parse_obj(obj)
 
         _obj = BrandLogo.parse_obj({
             "urls": BrandLogoUrls.from_dict(obj.get("urls")) if obj.get("urls") is not None else None,
             "file_size": obj.get("file_size"),
             "updated_at": obj.get("updated_at"),
             "content_type": obj.get("content_type")
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_logo_urls.py` & `onelogin-3.1.5/onelogin/models/brand_logo_urls.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictStr
@@ -28,14 +27,15 @@
     """
     original: StrictStr = ...
     login: StrictStr = ...
     navigation: StrictStr = ...
     __properties = ["original", "login", "navigation"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandLogoUrls:
         """Create an instance of BrandLogoUrls from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandLogoUrls.parse_obj(obj)
 
         _obj = BrandLogoUrls.parse_obj({
             "original": obj.get("original"),
             "login": obj.get("login"),
             "navigation": obj.get("navigation")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/brand_req.py` & `onelogin-3.1.5/onelogin/models/brand_req.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="Brands unique ID in OneLogin.")
     enabled: Optional[StrictBool] = Field(None, description="Indicates if the brand is enabled or not.")
     name: Optional[StrictStr] = Field(None, description="Brand name for humans. This isnt related to subdomains.")
     __properties = ["id", "enabled", "name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BrandReq:
         """Create an instance of BrandReq from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BrandReq.parse_obj(obj)
 
         _obj = BrandReq.parse_obj({
             "id": obj.get("id"),
             "enabled": obj.get("enabled"),
             "name": obj.get("name")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/client_app_full.py` & `onelogin-3.1.5/onelogin/models/client_app_full.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
@@ -30,14 +29,15 @@
     scopes: Optional[conlist(Scope)] = Field(None, description="List of All Scopes assigned to a client app")
     app_id: Optional[StrictInt] = Field(None, description="Unique Client App ID")
     name: Optional[StrictStr] = Field(None, description="Name of client app")
     api_auth_id: Optional[StrictInt] = None
     __properties = ["scopes", "app_id", "name", "api_auth_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -67,15 +67,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ClientAppFull:
         """Create an instance of ClientAppFull from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ClientAppFull.parse_obj(obj)
 
         _obj = ClientAppFull.parse_obj({
             "scopes": [Scope.from_dict(_item) for _item in obj.get("scopes")] if obj.get("scopes") is not None else None,
             "app_id": obj.get("app_id"),
             "name": obj.get("name"),
             "api_auth_id": obj.get("api_auth_id")
```

### Comparing `onelogin-3.1.4/onelogin/models/clock_counter.py` & `onelogin-3.1.5/onelogin/models/clock_counter.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -27,14 +26,15 @@
     unit: - 0 = Seconds - 1 = Minutes - 2 = Hours value: - When Unit = 0 or 1 value must be 0-60 - When Unit = 2 value must be 0-24
     """
     value: Optional[StrictInt] = None
     unit: Optional[StrictInt] = None
     __properties = ["value", "unit"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ClockCounter:
         """Create an instance of ClockCounter from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ClockCounter.parse_obj(obj)
 
         _obj = ClockCounter.parse_obj({
             "value": obj.get("value"),
             "unit": obj.get("unit")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/condition.py` & `onelogin-3.1.5/onelogin/models/condition.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -28,14 +27,15 @@
     """
     source: Optional[StrictStr] = Field(None, description="source field to check.")
     operator: Optional[StrictStr] = Field(None, description="A valid operator for the selected condition source")
     value: Optional[StrictStr] = Field(None, description="A plain text string or valid value for the selected  condition source")
     __properties = ["source", "operator", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Condition:
         """Create an instance of Condition from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Condition.parse_obj(obj)
 
         _obj = Condition.parse_obj({
             "source": obj.get("source"),
             "operator": obj.get("operator"),
             "value": obj.get("value")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/configuration_oidc.py` & `onelogin-3.1.5/onelogin/models/risk_rule.py`

 * *Files 19% similar despite different names*

```diff
@@ -9,84 +9,98 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
+from typing import List, Optional
+from pydantic import BaseModel, Field, StrictStr, conlist, validator
+from onelogin.models.source import Source
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr, validator
-
-class ConfigurationOidc(BaseModel):
+class RiskRule(BaseModel):
     """
-    ConfigurationOidc
+    RiskRule
     """
-    login_url: StrictStr = Field(..., description="The OpenId Connect Client Id. Note that client_secret is only returned after Creating an App.")
-    redirect_uri: StrictStr = Field(..., description="Comma or newline separated list of valid redirect uris for the OpenId Connect Authorization Code flow.")
-    access_token_expiration_minutes: StrictInt = Field(..., description="Number of minutes the refresh token will be valid for.")
-    refresh_token_expiration_minutes: StrictInt = Field(..., description="Number of minutes the refresh token will be valid for.")
-    token_endpoint_auth_method: StrictInt = Field(..., description="- 0: Basic - 1: POST - 2: None / PKCE")
-    oidc_application_type: StrictInt = Field(..., description="- 0 : Web - 1 : Native / Mobile")
-    __properties = ["login_url", "redirect_uri", "access_token_expiration_minutes", "refresh_token_expiration_minutes", "token_endpoint_auth_method", "oidc_application_type"]
-
-    @validator('token_endpoint_auth_method')
-    def token_endpoint_auth_method_validate_enum(cls, v):
-        if v not in (0, 1, 2):
-            raise ValueError("must be one of enum values (0, 1, 2)")
-        return v
-
-    @validator('oidc_application_type')
-    def oidc_application_type_validate_enum(cls, v):
-        if v not in (0, 1):
-            raise ValueError("must be one of enum values (0, 1)")
-        return v
+    id: Optional[StrictStr] = None
+    name: Optional[StrictStr] = Field(None, description="The name of this rule")
+    description: Optional[StrictStr] = None
+    type: Optional[StrictStr] = Field(None, description="The type parameter specifies the type of rule that will be created.")
+    target: Optional[StrictStr] = Field(None, description="The target parameter that will be used when evaluating the rule against an incoming event.")
+    filters: Optional[conlist(StrictStr)] = Field(None, description="A list of IP addresses or country codes or names to evaluate against each event.")
+    source: Optional[Source] = None
+    __properties = ["id", "name", "description", "type", "target", "filters", "source"]
+
+    @validator('type')
+    def type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('blacklist', 'whitelist'):
+            raise ValueError("must be one of enum values ('blacklist', 'whitelist')")
+        return value
+
+    @validator('target')
+    def target_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('location.ip', 'location.address.country_iso_code'):
+            raise ValueError("must be one of enum values ('location.ip', 'location.address.country_iso_code')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConfigurationOidc:
-        """Create an instance of ConfigurationOidc from a JSON string"""
+    def from_json(cls, json_str: str) -> RiskRule:
+        """Create an instance of RiskRule from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
+        # override the default output from pydantic by calling `to_dict()` of source
+        if self.source:
+            _dict['source'] = self.source.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConfigurationOidc:
-        """Create an instance of ConfigurationOidc from a dict"""
+    def from_dict(cls, obj: dict) -> RiskRule:
+        """Create an instance of RiskRule from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return ConfigurationOidc.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return RiskRule.parse_obj(obj)
 
-        _obj = ConfigurationOidc.parse_obj({
-            "login_url": obj.get("login_url"),
-            "redirect_uri": obj.get("redirect_uri"),
-            "access_token_expiration_minutes": obj.get("access_token_expiration_minutes"),
-            "refresh_token_expiration_minutes": obj.get("refresh_token_expiration_minutes"),
-            "token_endpoint_auth_method": obj.get("token_endpoint_auth_method"),
-            "oidc_application_type": obj.get("oidc_application_type")
+        _obj = RiskRule.parse_obj({
+            "id": obj.get("id"),
+            "name": obj.get("name"),
+            "description": obj.get("description"),
+            "type": obj.get("type"),
+            "target": obj.get("target"),
+            "filters": obj.get("filters"),
+            "source": Source.from_dict(obj.get("source")) if obj.get("source") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/configuration_saml.py` & `onelogin-3.1.5/onelogin/models/configuration_saml.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     ConfigurationSaml
     """
     signature_algorithm: Optional[StrictStr] = Field(None, description="One of the following:   - SHA-1   - SHA-256   - SHA-348   - SHA-512")
     certificate_id: Optional[StrictInt] = Field(None, description="When creating apps the default certificate will be used unless the `certificate_id` attribute is applied in the `configuration` object.")
     __properties = ["signature_algorithm", "certificate_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConfigurationSaml:
         """Create an instance of ConfigurationSaml from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConfigurationSaml.parse_obj(obj)
 
         _obj = ConfigurationSaml.parse_obj({
             "signature_algorithm": obj.get("signature_algorithm"),
             "certificate_id": obj.get("certificate_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/connector.py` & `onelogin-3.1.5/onelogin/models/connector.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -31,14 +30,15 @@
     name: Optional[StrictStr] = Field(None, description="Name of Connector")
     icon_url: Optional[StrictStr] = Field(None, description="A link to the icon's url.")
     auth_method: Optional[AuthMethod] = None
     allows_new_parameters: Optional[StrictBool] = Field(None, description="Indicates if apps created using this connector will be allowed to create custom parameters.")
     __properties = ["id", "name", "icon_url", "auth_method", "allows_new_parameters"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Connector:
         """Create an instance of Connector from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Connector.parse_obj(obj)
 
         _obj = Connector.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "icon_url": obj.get("icon_url"),
             "auth_method": obj.get("auth_method"),
```

### Comparing `onelogin-3.1.4/onelogin/models/create_app200_response.py` & `onelogin-3.1.5/onelogin/models/create_app_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,117 +22,130 @@
 from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from onelogin.models.generic_app import GenericApp
 from onelogin.models.oidc_app import OidcApp
 from onelogin.models.saml_app import SamlApp
 from typing import Any, List
 from pydantic import StrictStr, Field
 
-CREATEAPP200RESPONSE_ONE_OF_SCHEMAS = ["GenericApp", "OidcApp", "SamlApp"]
+CREATEAPPREQUEST_ONE_OF_SCHEMAS = ["GenericApp", "OidcApp", "SamlApp"]
 
-class CreateApp200Response(BaseModel):
+class CreateAppRequest(BaseModel):
     """
-    CreateApp200Response
+    CreateAppRequest
     """
     # data type: OidcApp
     oneof_schema_1_validator: Optional[OidcApp] = None
     # data type: SamlApp
     oneof_schema_2_validator: Optional[SamlApp] = None
     # data type: GenericApp
     oneof_schema_3_validator: Optional[GenericApp] = None
     actual_instance: Any
-    one_of_schemas: List[str] = Field(CREATEAPP200RESPONSE_ONE_OF_SCHEMAS, const=True)
+    one_of_schemas: List[str] = Field(CREATEAPPREQUEST_ONE_OF_SCHEMAS, const=True)
 
     class Config:
         validate_assignment = True
 
-    discriminator_value_class_map = {
-    }
+    def __init__(self, *args, **kwargs):
+        if args:
+            if len(args) > 1:
+                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
+            if kwargs:
+                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
+            super().__init__(actual_instance=args[0])
+        else:
+            super().__init__(**kwargs)
 
     @validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = cls()
+        instance = CreateAppRequest.construct()
         error_messages = []
         match = 0
         # validate data type: OidcApp
-        if type(v) is not OidcApp:
+        if not isinstance(v, OidcApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `OidcApp`")
         else:
             match += 1
-
         # validate data type: SamlApp
-        if type(v) is not SamlApp:
+        if not isinstance(v, SamlApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `SamlApp`")
         else:
             match += 1
-
         # validate data type: GenericApp
-        if type(v) is not GenericApp:
+        if not isinstance(v, GenericApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `GenericApp`")
         else:
             match += 1
-
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateApp200Response:
+    def from_dict(cls, obj: dict) -> CreateAppRequest:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateApp200Response:
+    def from_json(cls, json_str: str) -> CreateAppRequest:
         """Returns the object represented by the json string"""
-        instance = cls()
+        instance = CreateAppRequest.construct()
         error_messages = []
         match = 0
 
         # deserialize data into OidcApp
         try:
             instance.actual_instance = OidcApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into SamlApp
         try:
             instance.actual_instance = SamlApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into GenericApp
         try:
             instance.actual_instance = GenericApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return "null"
+
+        to_json = getattr(self.actual_instance, "to_json", None)
+        if callable(to_json):
             return self.actual_instance.to_json()
         else:
-            return "null"
+            return json.dumps(self.actual_instance)
 
     def to_dict(self) -> dict:
         """Returns the dict representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return None
+
+        to_dict = getattr(self.actual_instance, "to_dict", None)
+        if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
-            return dict()
+            # primitive type
+            return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
         return pprint.pformat(self.dict())
```

### Comparing `onelogin-3.1.4/onelogin/models/create_app_request.py` & `onelogin-3.1.5/onelogin/models/create_app200_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -22,114 +22,133 @@
 from pydantic import BaseModel, Field, StrictStr, ValidationError, validator
 from onelogin.models.generic_app import GenericApp
 from onelogin.models.oidc_app import OidcApp
 from onelogin.models.saml_app import SamlApp
 from typing import Any, List
 from pydantic import StrictStr, Field
 
-CREATEAPPREQUEST_ONE_OF_SCHEMAS = ["GenericApp", "OidcApp", "SamlApp"]
+CREATEAPP200RESPONSE_ONE_OF_SCHEMAS = ["GenericApp", "OidcApp", "SamlApp"]
 
-class CreateAppRequest(BaseModel):
+class CreateApp200Response(BaseModel):
     """
-    CreateAppRequest
+    CreateApp200Response
     """
     # data type: OidcApp
     oneof_schema_1_validator: Optional[OidcApp] = None
     # data type: SamlApp
     oneof_schema_2_validator: Optional[SamlApp] = None
     # data type: GenericApp
     oneof_schema_3_validator: Optional[GenericApp] = None
     actual_instance: Any
-    one_of_schemas: List[str] = Field(CREATEAPPREQUEST_ONE_OF_SCHEMAS, const=True)
+    one_of_schemas: List[str] = Field(CREATEAPP200RESPONSE_ONE_OF_SCHEMAS, const=True)
 
     class Config:
         validate_assignment = True
 
+    discriminator_value_class_map = {
+    }
+
+    def __init__(self, *args, **kwargs):
+        if args:
+            if len(args) > 1:
+                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
+            if kwargs:
+                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
+            super().__init__(actual_instance=args[0])
+        else:
+            super().__init__(**kwargs)
+
     @validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = cls()
+        instance = CreateApp200Response.construct()
         error_messages = []
         match = 0
         # validate data type: OidcApp
-        if type(v) is not OidcApp:
+        if not isinstance(v, OidcApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `OidcApp`")
         else:
             match += 1
-
         # validate data type: SamlApp
-        if type(v) is not SamlApp:
+        if not isinstance(v, SamlApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `SamlApp`")
         else:
             match += 1
-
         # validate data type: GenericApp
-        if type(v) is not GenericApp:
+        if not isinstance(v, GenericApp):
             error_messages.append(f"Error! Input type `{type(v)}` is not `GenericApp`")
         else:
             match += 1
-
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CreateAppRequest:
+    def from_dict(cls, obj: dict) -> CreateApp200Response:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
-    def from_json(cls, json_str: str) -> CreateAppRequest:
+    def from_json(cls, json_str: str) -> CreateApp200Response:
         """Returns the object represented by the json string"""
-        instance = cls()
+        instance = CreateApp200Response.construct()
         error_messages = []
         match = 0
 
         # deserialize data into OidcApp
         try:
             instance.actual_instance = OidcApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into SamlApp
         try:
             instance.actual_instance = SamlApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into GenericApp
         try:
             instance.actual_instance = GenericApp.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into CreateAppRequest with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when deserializing the JSON string into CreateApp200Response with oneOf schemas: GenericApp, OidcApp, SamlApp. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return "null"
+
+        to_json = getattr(self.actual_instance, "to_json", None)
+        if callable(to_json):
             return self.actual_instance.to_json()
         else:
-            return "null"
+            return json.dumps(self.actual_instance)
 
     def to_dict(self) -> dict:
         """Returns the dict representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return None
+
+        to_dict = getattr(self.actual_instance, "to_dict", None)
+        if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
-            return dict()
+            # primitive type
+            return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
         return pprint.pformat(self.dict())
```

### Comparing `onelogin-3.1.4/onelogin/models/create_device_verification201_response.py` & `onelogin-3.1.5/onelogin/models/create_device_verification201_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -33,14 +32,15 @@
     user_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name assigned by users when they register the device.")
     id: Optional[StrictStr] = Field(None, description="Registration identifier.")
     type_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name as it appears to users upon initial registration, as defined by admins at Settings > Authentication Factors.")
     auth_factor_name: Optional[StrictStr] = Field(None, description="Authentication factor name, as it appears to administrators in OneLogin.")
     __properties = ["device_id", "display_name", "expires_at", "redirect_to", "user_display_name", "id", "type_display_name", "auth_factor_name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -63,15 +63,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CreateDeviceVerification201Response:
         """Create an instance of CreateDeviceVerification201Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CreateDeviceVerification201Response.parse_obj(obj)
 
         _obj = CreateDeviceVerification201Response.parse_obj({
             "device_id": obj.get("device_id"),
             "display_name": obj.get("display_name"),
             "expires_at": obj.get("expires_at"),
             "redirect_to": obj.get("redirect_to"),
```

### Comparing `onelogin-3.1.4/onelogin/models/create_device_verification_request.py` & `onelogin-3.1.5/onelogin/models/create_device_verification_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -30,14 +29,15 @@
     display_name: Optional[StrictStr] = Field(None, description="A name for the users device")
     expires_in: Optional[StrictStr] = Field(None, description="Defaults to 120. Valid values are: 120-900 seconds.")
     redirect_to: Optional[StrictStr] = Field(None, description="Only applies to Email MagicLink factor. Redirects MagicLink success page to specified URL after 2 seconds. Email must already be configured by the user.")
     custom_message: Optional[StrictStr] = Field(None, description="Only applies to SMS factor. A message template that will be sent via SMS. Max length of the message after template items are inserted is 160 characters including the OTP code. SMS must already be configured by the user. The following template variables can be included in the message. - {{otp_code}} - The security code. - {{otp_expiry}} - The number of minutes until the one time code expires.")
     __properties = ["device_id", "display_name", "expires_in", "redirect_to", "custom_message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CreateDeviceVerificationRequest:
         """Create an instance of CreateDeviceVerificationRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CreateDeviceVerificationRequest.parse_obj(obj)
 
         _obj = CreateDeviceVerificationRequest.parse_obj({
             "device_id": obj.get("device_id"),
             "display_name": obj.get("display_name"),
             "expires_in": obj.get("expires_in"),
             "redirect_to": obj.get("redirect_to"),
```

### Comparing `onelogin-3.1.4/onelogin/models/create_factor_registration201_response.py` & `onelogin-3.1.5/onelogin/models/create_factor_registration201_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -31,14 +30,15 @@
     type_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name as it appears to users upon initial registration, as defined by admins at Settings > Authentication Factors.")
     auth_factor_name: Optional[StrictStr] = Field(None, description="Authentication factor name, as it appears to administrators in OneLogin.")
     id: Optional[StrictStr] = Field(None, description="Verification identifier used in subsequent verification step.")
     user_id: Optional[StrictStr] = Field(None, description="User identifier")
     __properties = ["device_id", "user_display_name", "type_display_name", "auth_factor_name", "id", "user_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CreateFactorRegistration201Response:
         """Create an instance of CreateFactorRegistration201Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CreateFactorRegistration201Response.parse_obj(obj)
 
         _obj = CreateFactorRegistration201Response.parse_obj({
             "device_id": obj.get("device_id"),
             "user_display_name": obj.get("user_display_name"),
             "type_display_name": obj.get("type_display_name"),
             "auth_factor_name": obj.get("auth_factor_name"),
```

### Comparing `onelogin-3.1.4/onelogin/models/create_factor_registration_request.py` & `onelogin-3.1.5/onelogin/models/create_factor_registration_request.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -31,14 +30,15 @@
     expires_in: Optional[StrictStr] = Field(None, description="Defaults to 120. Valid values are: 120-900 seconds.")
     verified: Optional[StrictBool] = Field(None, description="Defaults to false. The following factors support verified = true as part of the initial registration request: OneLogin SMS, OneLogin Voice, OneLogin Email. When using verified = true it is critical that the supported factors have pre-verified values, most likely imported from an existing directory or by the users themselvdes. Factors such as Authenticator and OneLogin Protect do not support verification = true as the user interaction is required to verify the factor.")
     redirect_to: Optional[StrictStr] = Field(None, description="Only applies to Email MagicLink factor. Redirects MagicLink success page to specified URL after 2 seconds. Email must already be configured by the user.")
     custom_message: Optional[StrictStr] = Field(None, description="Only applies to SMS factor. A message template that will be sent via SMS. Max length of the message after template items are inserted is 160 characters including the OTP code. SMS must already be configured by the user. The following template variables can be included in the message. - {{otp_code}} - The security code. - {{otp_expiry}} - The number of minutes until the one time code expires.")
     __properties = ["factor_id", "display_name", "expires_in", "verified", "redirect_to", "custom_message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CreateFactorRegistrationRequest:
         """Create an instance of CreateFactorRegistrationRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CreateFactorRegistrationRequest.parse_obj(obj)
 
         _obj = CreateFactorRegistrationRequest.parse_obj({
             "factor_id": obj.get("factor_id"),
             "display_name": obj.get("display_name"),
             "expires_in": obj.get("expires_in"),
             "verified": obj.get("verified"),
```

### Comparing `onelogin-3.1.4/onelogin/models/create_privilege200_response.py` & `onelogin-3.1.5/onelogin/models/create_privilege200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/onelogin/models/create_role201_response_inner.py` & `onelogin-3.1.5/onelogin/models/create_role201_response_inner.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -26,14 +25,15 @@
     """
     CreateRole201ResponseInner
     """
     id: Optional[StrictInt] = None
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CreateRole201ResponseInner:
         """Create an instance of CreateRole201ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CreateRole201ResponseInner.parse_obj(obj)
 
         _obj = CreateRole201ResponseInner.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/device.py` & `onelogin-3.1.5/onelogin/models/device.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     Device
     """
     device_id: Optional[StrictInt] = Field(None, description="an ID for the device type that must be submitted with the Verify Factor API call.")
     device_type: Optional[StrictStr] = Field(None, description="Lists an available MFA device type, such as OneLogin OTP SMS or Google Authenticator.")
     __properties = ["device_id", "device_type"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Device:
         """Create an instance of Device from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Device.parse_obj(obj)
 
         _obj = Device.parse_obj({
             "device_id": obj.get("device_id"),
             "device_type": obj.get("device_type")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/email_config.py` & `onelogin-3.1.5/onelogin/models/email_config.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, SecretStr, StrictBool, StrictInt, StrictStr
@@ -32,14 +31,15 @@
     domain: StrictStr = Field(..., description="Domain of the From address.")
     user_name: Optional[StrictStr] = Field(None, description="The user name of the account to authenticate with the Email Settings server.")
     password: Optional[SecretStr] = Field(None, description="The password of the account to authenticate with the Email Settings server.")
     port: Optional[StrictInt] = Field(25, description="Defaults to 25.")
     __properties = ["address", "use_tls", "from", "domain", "user_name", "password", "port"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -62,15 +62,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EmailConfig:
         """Create an instance of EmailConfig from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EmailConfig.parse_obj(obj)
 
         _obj = EmailConfig.parse_obj({
             "address": obj.get("address"),
             "use_tls": obj.get("use_tls") if obj.get("use_tls") is not None else True,
             "var_from": obj.get("from"),
             "domain": obj.get("domain"),
```

### Comparing `onelogin-3.1.4/onelogin/models/enforcement_point.py` & `onelogin-3.1.5/onelogin/models/enforcement_point.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist, validator
@@ -40,22 +39,25 @@
     use_target_host_header: Optional[StrictBool] = Field(None, description="Use the target host header as opposed to the original gateway or upstream host header.")
     vhost: Optional[StrictStr] = Field(None, description="A comma-delimited list of one or more virtual hosts that map to applications assigned to the enforcement point. A VHOST may be a host name or an IP address. VHOST distinguish between applications that are at the same context root.")
     landing_page: Optional[StrictStr] = Field(None, description="The location within the context root to which the browser will be redirected for IdP-initiated single sign-on. For example, the landing page might be an index page in the context root such as index.html or default.aspx. The landing page cannot begin with a slash and must use valid URL characters.")
     case_sensitive: Optional[StrictBool] = Field(None, description="The URL path evaluation is case insensitive by default. Resources hosted on web servers such as Apache, NGINX and Java EE are case sensitive paths. Web servers such as Microsoft IIS are not case-sensitive.")
     __properties = ["require_sitewide_authentication", "conditions", "session_expiry_fixed", "session_expiry_inactivity", "permissions", "token", "target", "resources", "context_root", "use_target_host_header", "vhost", "landing_page", "case_sensitive"]
 
     @validator('permissions')
-    def permissions_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('allow', 'deny', 'conditional'):
+    def permissions_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('allow', 'deny', 'conditional'):
             raise ValueError("must be one of enum values ('allow', 'deny', 'conditional')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -107,15 +109,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EnforcementPoint:
         """Create an instance of EnforcementPoint from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EnforcementPoint.parse_obj(obj)
 
         _obj = EnforcementPoint.parse_obj({
             "require_sitewide_authentication": obj.get("require_sitewide_authentication"),
             "conditions": obj.get("conditions"),
             "session_expiry_fixed": ClockCounter.from_dict(obj.get("session_expiry_fixed")) if obj.get("session_expiry_fixed") is not None else None,
             "session_expiry_inactivity": ClockCounter.from_dict(obj.get("session_expiry_inactivity")) if obj.get("session_expiry_inactivity") is not None else None,
```

### Comparing `onelogin-3.1.4/onelogin/models/enforcement_point_resources_inner.py` & `onelogin-3.1.5/onelogin/models/enforcement_point_resources_inner.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr, validator
@@ -30,22 +29,25 @@
     is_path_regex: Optional[StrictBool] = None
     require_auth: Optional[StrictBool] = None
     permission: Optional[StrictStr] = None
     conditions: Optional[StrictStr] = Field(None, description="required if permission == \"conditions\"")
     __properties = ["path", "is_path_regex", "require_auth", "permission", "conditions"]
 
     @validator('permission')
-    def permission_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('allow', 'deny', 'conditions'):
+    def permission_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('allow', 'deny', 'conditions'):
             raise ValueError("must be one of enum values ('allow', 'deny', 'conditions')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -73,15 +75,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EnforcementPointResourcesInner:
         """Create an instance of EnforcementPointResourcesInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EnforcementPointResourcesInner.parse_obj(obj)
 
         _obj = EnforcementPointResourcesInner.parse_obj({
             "path": obj.get("path"),
             "is_path_regex": obj.get("is_path_regex"),
             "require_auth": obj.get("require_auth"),
             "permission": obj.get("permission"),
```

### Comparing `onelogin-3.1.4/onelogin/models/enroll_mfa_factor200_response.py` & `onelogin-3.1.5/onelogin/models/enroll_mfa_factor200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +11,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -29,14 +30,15 @@
     EnrollMfaFactor200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(GetEnrolledFactors200ResponseDataOtpDevicesInner)] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -69,15 +71,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EnrollMfaFactor200Response:
         """Create an instance of EnrollMfaFactor200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EnrollMfaFactor200Response.parse_obj(obj)
 
         _obj = EnrollMfaFactor200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": [GetEnrolledFactors200ResponseDataOtpDevicesInner.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/error.py` & `onelogin-3.1.5/onelogin/models/source.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,68 +9,64 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+from pydantic import BaseModel, Field, StrictStr
 
-class Error(BaseModel):
+class Source(BaseModel):
     """
-    Error
+    Used for targeting custom rules based on a group of people, customers, accounts, or even a single user.
     """
-    error: Optional[StrictBool] = None
-    code: StrictInt = ...
-    type: Optional[StrictStr] = None
-    message: StrictStr = ...
-    __properties = ["error", "code", "type", "message"]
+    id: Optional[StrictStr] = Field(None, description="A unique id that represents the source of the event.")
+    name: Optional[StrictStr] = Field(None, description="The name of the source")
+    __properties = ["id", "name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Error:
-        """Create an instance of Error from a JSON string"""
+    def from_json(cls, json_str: str) -> Source:
+        """Create an instance of Source from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Error:
-        """Create an instance of Error from a dict"""
+    def from_dict(cls, obj: dict) -> Source:
+        """Create an instance of Source from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return Error.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return Source.parse_obj(obj)
 
-        _obj = Error.parse_obj({
-            "error": obj.get("error"),
-            "code": obj.get("code"),
-            "type": obj.get("type"),
-            "message": obj.get("message")
+        _obj = Source.parse_obj({
+            "id": obj.get("id"),
+            "name": obj.get("name")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/event.py` & `onelogin-3.1.5/onelogin/models/event.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +11,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, validator
@@ -70,22 +71,25 @@
     trusted_idp_id: Optional[StrictInt] = None
     user_field_id: Optional[StrictInt] = None
     user_id: Optional[StrictInt] = Field(None, description="ID of the user that was acted upon to trigger the event.")
     user_name: Optional[StrictStr] = Field(None, description="Name of the user that was acted upon to trigger the event.")
     __properties = ["account_id", "actor_system", "actor_user_id", "actor_user_name", "adc_id", "app-name", "app_id", "assumed_by_superadmin_or_reseller", "assuming_acting_user_id", "certificate_id", "client_id", "created_at", "custom_message", "directory_sync_run_id", "error_description", "event_type_id", "group-name", "group_id", "id", "ipaddr", "mapping_id", "notes", "object_id", "otp_device_id", "otp_device_name", "param", "policy_id", "policy_name", "policy_type", "privilege_id", "proxy_ip", "radius_config_id", "resolved_at", "resource_type_id", "risk_cookie_id", "risk_reasons", "risk_score", "role_id", "role_name", "service_directory_id", "solved", "trusted_idp_id", "user_field_id", "user_id", "user_name"]
 
     @validator('event_type_id')
-    def event_type_id_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 100, 101, 102, 103, 104, 105, 106, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 291, 300, 301, 303, 304, 305, 306, 307, 330, 331, 332, 333, 334, 400, 401, 402, 410, 411, 412, 501, 502, 503, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 545, 546, 550, 551, 552, 553, 554, 555, 600, 601, 602, 700, 701, 702, 703, 704, 705, 706, 800, 801, 802, 803, 804, 805, 900, 901, 902, 903, 904, 905, 906, 907, 911, 912, 931, 932, 950, 1001, 1002, 1010, 1100, 1101, 1200, 1201, 1244, 1245, 1300, 1301, 1302, 1303, 1304, 1305, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1700, 1701, 1702, 1801, 1802, 1900, 1901, 1902, 1903, 1904, 1905, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2201, 2202, 2203, 2204, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017, 9018, 9019, 9020, 9021, 9022, 9023, 9024, 9025, 9026, 9027, 9028, 9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9037, 9038, 9039, 9040, 9041, 9042, 9043, 9044, 9045, 9046, 9047, 9048, 9049, 9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058, 9059):
+    def event_type_id_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 100, 101, 102, 103, 104, 105, 106, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 291, 300, 301, 303, 304, 305, 306, 307, 330, 331, 332, 333, 334, 400, 401, 402, 410, 411, 412, 501, 502, 503, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 545, 546, 550, 551, 552, 553, 554, 555, 600, 601, 602, 700, 701, 702, 703, 704, 705, 706, 800, 801, 802, 803, 804, 805, 900, 901, 902, 903, 904, 905, 906, 907, 911, 912, 931, 932, 950, 1001, 1002, 1010, 1100, 1101, 1200, 1201, 1244, 1245, 1300, 1301, 1302, 1303, 1304, 1305, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1700, 1701, 1702, 1801, 1802, 1900, 1901, 1902, 1903, 1904, 1905, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2201, 2202, 2203, 2204, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017, 9018, 9019, 9020, 9021, 9022, 9023, 9024, 9025, 9026, 9027, 9028, 9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9037, 9038, 9039, 9040, 9041, 9042, 9043, 9044, 9045, 9046, 9047, 9048, 9049, 9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058, 9059):
             raise ValueError("must be one of enum values (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 100, 101, 102, 103, 104, 105, 106, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 291, 300, 301, 303, 304, 305, 306, 307, 330, 331, 332, 333, 334, 400, 401, 402, 410, 411, 412, 501, 502, 503, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 545, 546, 550, 551, 552, 553, 554, 555, 600, 601, 602, 700, 701, 702, 703, 704, 705, 706, 800, 801, 802, 803, 804, 805, 900, 901, 902, 903, 904, 905, 906, 907, 911, 912, 931, 932, 950, 1001, 1002, 1010, 1100, 1101, 1200, 1201, 1244, 1245, 1300, 1301, 1302, 1303, 1304, 1305, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1700, 1701, 1702, 1801, 1802, 1900, 1901, 1902, 1903, 1904, 1905, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2201, 2202, 2203, 2204, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 9000, 9001, 9002, 9003, 9004, 9005, 9006, 9007, 9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017, 9018, 9019, 9020, 9021, 9022, 9023, 9024, 9025, 9026, 9027, 9028, 9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9037, 9038, 9039, 9040, 9041, 9042, 9043, 9044, 9045, 9046, 9047, 9048, 9049, 9050, 9051, 9052, 9053, 9054, 9055, 9056, 9057, 9058, 9059)")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -108,15 +112,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Event:
         """Create an instance of Event from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Event.parse_obj(obj)
 
         _obj = Event.parse_obj({
             "account_id": obj.get("account_id"),
             "actor_system": obj.get("actor_system"),
             "actor_user_id": obj.get("actor_user_id"),
             "actor_user_name": obj.get("actor_user_name"),
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_mf_atoken200_response.py` & `onelogin-3.1.5/onelogin/models/generate_mf_atoken200_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +11,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -28,14 +29,15 @@
     """
     mfa_token: Optional[StrictStr] = Field(None, description="Token can function as a temporary MFA token. It can be used to authenticate for any app when valid.")
     resuable: Optional[StrictBool] = Field(None, description="true indcates the token can be used multiple times, until it expires. false indicates the token is invalid after a single use or once it expires. Defaults to false.")
     expires_at: Optional[StrictStr] = Field(None, description="Defines the expiration time and date for the token. Format is UTC time.")
     __properties = ["mfa_token", "resuable", "expires_at"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateMFAtoken200Response:
         """Create an instance of GenerateMFAtoken200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateMFAtoken200Response.parse_obj(obj)
 
         _obj = GenerateMFAtoken200Response.parse_obj({
             "mfa_token": obj.get("mfa_token"),
             "resuable": obj.get("resuable"),
             "expires_at": obj.get("expires_at")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_mf_atoken_request.py` & `onelogin-3.1.5/onelogin/models/generate_mf_atoken_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +11,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt
@@ -27,14 +28,15 @@
     GenerateMFAtokenRequest
     """
     expires_in: Optional[StrictInt] = Field(None, description="Set the duration of the token in seconds. Token expiration defaults to 259200 seconds = 72 hours. 72 hours is the max value.")
     reusable: Optional[StrictBool] = Field(False, description="Defines if the token is reusable multiple times within the expiry window. Value defaults to false. If set to true, token can be used multiple times, until it expires.")
     __properties = ["expires_in", "reusable"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateMFAtokenRequest:
         """Create an instance of GenerateMFAtokenRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateMFAtokenRequest.parse_obj(obj)
 
         _obj = GenerateMFAtokenRequest.parse_obj({
             "expires_in": obj.get("expires_in"),
             "reusable": obj.get("reusable") if obj.get("reusable") is not None else False
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_otp201_response.py` & `onelogin-3.1.5/onelogin/models/generate_otp201_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -29,14 +28,15 @@
     mfa_token: Optional[StrictStr] = Field(None, description="Token can function as a temporary MFA token. It can be used to authenticate for any app when valid.")
     reusable: Optional[StrictBool] = Field(False, description="true indcates the token can be used multiple times, until it expires. false indicates the token is invalid after a single use or once it expires. Defaults to false.")
     expires_at: Optional[StrictStr] = Field(None, description="Defines the expiration time and date for the token. Format is UTC time.")
     device_id: Optional[StrictStr] = Field(None, description="A unique identifier for the temp otp device that has been created for this token.")
     __properties = ["mfa_token", "reusable", "expires_at", "device_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateOTP201Response:
         """Create an instance of GenerateOTP201Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateOTP201Response.parse_obj(obj)
 
         _obj = GenerateOTP201Response.parse_obj({
             "mfa_token": obj.get("mfa_token"),
             "reusable": obj.get("reusable") if obj.get("reusable") is not None else False,
             "expires_at": obj.get("expires_at"),
             "device_id": obj.get("device_id")
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_otp_request.py` & `onelogin-3.1.5/onelogin/models/generate_otp_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt
@@ -27,14 +27,15 @@
     GenerateOTPRequest
     """
     expires_in: Optional[StrictInt] = Field(None, description="Set the duration of the token in seconds. Token expiration defaults to 259200 seconds = 72 hours. 72 hours is the max value.")
     reusable: Optional[StrictBool] = Field(False, description="Defines if the token is reusable multiple times within the expiry window. Value defaults to false. If set to true, token can be used multiple times, until it expires.")
     __properties = ["expires_in", "reusable"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateOTPRequest:
         """Create an instance of GenerateOTPRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateOTPRequest.parse_obj(obj)
 
         _obj = GenerateOTPRequest.parse_obj({
             "expires_in": obj.get("expires_in"),
             "reusable": obj.get("reusable") if obj.get("reusable") is not None else False
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_saml_assert200_response.py` & `onelogin-3.1.5/onelogin/models/generate_saml_assert200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Any, Dict, List, Optional
 from pydantic import BaseModel, conlist
@@ -28,14 +27,15 @@
     GenerateSamlAssert200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(Dict[str, Any])] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateSamlAssert200Response:
         """Create an instance of GenerateSamlAssert200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateSamlAssert200Response.parse_obj(obj)
 
         _obj = GenerateSamlAssert200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": obj.get("data")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/generate_token_request.py` & `onelogin-3.1.5/onelogin/models/generate_token_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     GenerateTokenRequest
     """
     grant_type: StrictStr = Field(..., description="Set to client_credentials.")
     __properties = ["grant_type"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenerateTokenRequest:
         """Create an instance of GenerateTokenRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenerateTokenRequest.parse_obj(obj)
 
         _obj = GenerateTokenRequest.parse_obj({
             "grant_type": obj.get("grant_type") if obj.get("grant_type") is not None else 'client_credentials'
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/generic_app.py` & `onelogin-3.1.5/onelogin/models/generic_app.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
@@ -47,14 +46,15 @@
     provisioning: Optional[GenericAppProvisioning] = None
     parameters: Optional[AppParameters] = None
     enforcement_point: Optional[EnforcementPoint] = None
     additional_properties: Dict[str, Any] = {}
     __properties = ["id", "name", "visible", "description", "notes", "icon_url", "auth_method", "policy_id", "allow_assumed_signin", "tab_id", "connector_id", "created_at", "updated_at", "role_ids", "provisioning", "parameters", "enforcement_point"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -93,15 +93,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenericApp:
         """Create an instance of GenericApp from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenericApp.parse_obj(obj)
 
         _obj = GenericApp.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "visible": obj.get("visible"),
             "description": obj.get("description"),
```

### Comparing `onelogin-3.1.4/onelogin/models/generic_app_provisioning.py` & `onelogin-3.1.5/onelogin/models/generic_app_provisioning.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictBool
@@ -26,14 +25,15 @@
     """
     Indicates if provisioning is enabled for this app.
     """
     enabled: Optional[StrictBool] = None
     __properties = ["enabled"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GenericAppProvisioning:
         """Create an instance of GenericAppProvisioning from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GenericAppProvisioning.parse_obj(obj)
 
         _obj = GenericAppProvisioning.parse_obj({
             "enabled": obj.get("enabled")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_assigned_user200_response.py` & `onelogin-3.1.5/onelogin/models/get_assigned_user200_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
@@ -31,14 +30,15 @@
     before_cursor: Optional[StrictInt] = Field(None, alias="beforeCursor")
     previous_link: Optional[StrictStr] = Field(None, alias="previousLink")
     after_cursor: Optional[StrictInt] = Field(None, alias="afterCursor")
     next_link: Optional[StrictStr] = Field(None, alias="nextLink")
     __properties = ["total", "users", "beforeCursor", "previousLink", "afterCursor", "nextLink"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +81,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetAssignedUser200Response:
         """Create an instance of GetAssignedUser200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetAssignedUser200Response.parse_obj(obj)
 
         _obj = GetAssignedUser200Response.parse_obj({
             "total": obj.get("total"),
             "users": obj.get("users"),
             "before_cursor": obj.get("beforeCursor"),
             "previous_link": obj.get("previousLink"),
```

### Comparing `onelogin-3.1.4/onelogin/models/get_auth_factors200_response.py` & `onelogin-3.1.5/onelogin/models/get_auth_factors200_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     factor_id: Optional[StrictInt] = Field(None, description="Identifier for the factor which will be used for user enrollment")
     name: Optional[StrictStr] = Field(None, description="Authentication factor name, as it appears to administrators in OneLogin.")
     auth_factor_name: Optional[StrictStr] = Field(None, description="Internal use only")
     __properties = ["factor_id", "name", "auth_factor_name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetAuthFactors200Response:
         """Create an instance of GetAuthFactors200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetAuthFactors200Response.parse_obj(obj)
 
         _obj = GetAuthFactors200Response.parse_obj({
             "factor_id": obj.get("factor_id"),
             "name": obj.get("name"),
             "auth_factor_name": obj.get("auth_factor_name")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/get_authentication_devices200_response_inner.py` & `onelogin-3.1.5/onelogin/models/get_authentication_devices200_response_inner.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -30,14 +29,15 @@
     user_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name assigned by users when they register the device.")
     type_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name as it appears to users upon initial registration, as defined by admins at Settings > Authentication Factors.")
     auth_factor_name: Optional[StrictStr] = Field(None, description="Authentication factor name, as it appears to administrators in OneLogin.")
     default: Optional[StrictBool] = Field(False, description="true = is users default MFA device for OneLogin.")
     __properties = ["device_id", "user_display_name", "type_display_name", "auth_factor_name", "default"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetAuthenticationDevices200ResponseInner:
         """Create an instance of GetAuthenticationDevices200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetAuthenticationDevices200ResponseInner.parse_obj(obj)
 
         _obj = GetAuthenticationDevices200ResponseInner.parse_obj({
             "device_id": obj.get("device_id"),
             "user_display_name": obj.get("user_display_name"),
             "type_display_name": obj.get("type_display_name"),
             "auth_factor_name": obj.get("auth_factor_name"),
```

### Comparing `onelogin-3.1.4/onelogin/models/get_custom_attributes200_response.py` & `onelogin-3.1.5/onelogin/models/get_custom_attributes200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictStr, conlist
@@ -28,14 +27,15 @@
     GetCustomAttributes200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(conlist(StrictStr))] = Field(None, description="Provides a list of custom attribute fields (also known as custom user fields) that are available for your account. The values returned correspond to the values you provided in the Shortname field when you defined the custom user field. For details about defining custom user fields, see Custom User Fields.")
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetCustomAttributes200Response:
         """Create an instance of GetCustomAttributes200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetCustomAttributes200Response.parse_obj(obj)
 
         _obj = GetCustomAttributes200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": obj.get("data")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_email_settings200_response.py` & `onelogin-3.1.5/onelogin/models/get_email_settings200_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -37,84 +37,101 @@
     oneof_schema_2_validator: Optional[EmailConfig] = None
     actual_instance: Any
     one_of_schemas: List[str] = Field(GETEMAILSETTINGS200RESPONSE_ONE_OF_SCHEMAS, const=True)
 
     class Config:
         validate_assignment = True
 
+    def __init__(self, *args, **kwargs):
+        if args:
+            if len(args) > 1:
+                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
+            if kwargs:
+                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
+            super().__init__(actual_instance=args[0])
+        else:
+            super().__init__(**kwargs)
+
     @validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = cls()
+        instance = GetEmailSettings200Response.construct()
         error_messages = []
         match = 0
         # validate data type: GetEmailSettings200ResponseOneOf
-        if type(v) is not GetEmailSettings200ResponseOneOf:
+        if not isinstance(v, GetEmailSettings200ResponseOneOf):
             error_messages.append(f"Error! Input type `{type(v)}` is not `GetEmailSettings200ResponseOneOf`")
         else:
             match += 1
-
         # validate data type: EmailConfig
-        if type(v) is not EmailConfig:
+        if not isinstance(v, EmailConfig):
             error_messages.append(f"Error! Input type `{type(v)}` is not `EmailConfig`")
         else:
             match += 1
-
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEmailSettings200Response:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
     def from_json(cls, json_str: str) -> GetEmailSettings200Response:
         """Returns the object represented by the json string"""
-        instance = cls()
+        instance = GetEmailSettings200Response.construct()
         error_messages = []
         match = 0
 
         # deserialize data into GetEmailSettings200ResponseOneOf
         try:
             instance.actual_instance = GetEmailSettings200ResponseOneOf.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into EmailConfig
         try:
             instance.actual_instance = EmailConfig.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
             raise ValueError("Multiple matches found when deserializing the JSON string into GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
             raise ValueError("No match found when deserializing the JSON string into GetEmailSettings200Response with oneOf schemas: EmailConfig, GetEmailSettings200ResponseOneOf. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return "null"
+
+        to_json = getattr(self.actual_instance, "to_json", None)
+        if callable(to_json):
             return self.actual_instance.to_json()
         else:
-            return "null"
+            return json.dumps(self.actual_instance)
 
     def to_dict(self) -> dict:
         """Returns the dict representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return None
+
+        to_dict = getattr(self.actual_instance, "to_dict", None)
+        if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
-            return dict()
+            # primitive type
+            return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
         return pprint.pformat(self.dict())
```

### Comparing `onelogin-3.1.4/onelogin/models/get_email_settings200_response_one_of.py` & `onelogin-3.1.5/onelogin/models/get_email_settings200_response_one_of.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictStr
@@ -26,14 +25,15 @@
     """
     GetEmailSettings200ResponseOneOf
     """
     mode: Optional[StrictStr] = None
     __properties = ["mode"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEmailSettings200ResponseOneOf:
         """Create an instance of GetEmailSettings200ResponseOneOf from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEmailSettings200ResponseOneOf.parse_obj(obj)
 
         _obj = GetEmailSettings200ResponseOneOf.parse_obj({
             "mode": obj.get("mode")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response.py` & `onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -29,14 +28,15 @@
     GetEnrolledFactors200Response
     """
     status: Optional[Error] = None
     data: Optional[GetEnrolledFactors200ResponseData] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEnrolledFactors200Response:
         """Create an instance of GetEnrolledFactors200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEnrolledFactors200Response.parse_obj(obj)
 
         _obj = GetEnrolledFactors200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": GetEnrolledFactors200ResponseData.from_dict(obj.get("data")) if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response_data.py` & `onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response_data.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -27,14 +26,15 @@
     """
     GetEnrolledFactors200ResponseData
     """
     otp_devices: Optional[conlist(GetEnrolledFactors200ResponseDataOtpDevicesInner)] = None
     __properties = ["otp_devices"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEnrolledFactors200ResponseData:
         """Create an instance of GetEnrolledFactors200ResponseData from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEnrolledFactors200ResponseData.parse_obj(obj)
 
         _obj = GetEnrolledFactors200ResponseData.parse_obj({
             "otp_devices": [GetEnrolledFactors200ResponseDataOtpDevicesInner.from_dict(_item) for _item in obj.get("otp_devices")] if obj.get("otp_devices") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_enrolled_factors200_response_data_otp_devices_inner.py` & `onelogin-3.1.5/onelogin/models/get_enrolled_factors200_response_data_otp_devices_inner.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -34,14 +33,15 @@
     type_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name as it appears to users upon initial registration, as defined by admins at Settings > Authentication Factors.")
     needs_trigger: Optional[StrictBool] = Field(None, description="true: You MUST Activate this Factor to trigger an SMS or Push notification before Verifying the OTP code. false: No Activation required. You can Verify the OTP immediately. MFA factors that provide both push notifications (user accepts notification) and pull code submission (user initiates code submission from device or enters it manually) should appear twice; once with needs_trigger: true and once with needs_trigger: false.")
     user_display_name: Optional[StrictStr] = Field(None, description="Authentication factor display name assigned by users when they enroll the device.")
     id: Optional[StrictInt] = Field(None, description="MFA device identifier.")
     __properties = ["active", "default", "state_token", "auth_factor_name", "phone_number", "type_display_name", "needs_trigger", "user_display_name", "id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEnrolledFactors200ResponseDataOtpDevicesInner:
         """Create an instance of GetEnrolledFactors200ResponseDataOtpDevicesInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEnrolledFactors200ResponseDataOtpDevicesInner.parse_obj(obj)
 
         _obj = GetEnrolledFactors200ResponseDataOtpDevicesInner.parse_obj({
             "active": obj.get("active"),
             "default": obj.get("default"),
             "state_token": obj.get("state_token"),
             "auth_factor_name": obj.get("auth_factor_name"),
```

### Comparing `onelogin-3.1.4/onelogin/models/get_event_by_id200_response.py` & `onelogin-3.1.5/onelogin/models/get_event_by_id200_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -29,14 +28,15 @@
     GetEventById200Response
     """
     status: Optional[Error] = None
     data: Optional[Event] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEventById200Response:
         """Create an instance of GetEventById200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEventById200Response.parse_obj(obj)
 
         _obj = GetEventById200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": Event.from_dict(obj.get("data")) if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_event_types200_response.py` & `onelogin-3.1.5/onelogin/models/get_event_types200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -29,14 +28,15 @@
     GetEventTypes200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(GetEventTypes200ResponseDataInner)] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -69,15 +69,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEventTypes200Response:
         """Create an instance of GetEventTypes200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEventTypes200Response.parse_obj(obj)
 
         _obj = GetEventTypes200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": [GetEventTypes200ResponseDataInner.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_event_types200_response_data_inner.py` & `onelogin-3.1.5/onelogin/models/get_event_types200_response_data_inner.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     name: Optional[StrictStr] = None
     description: Optional[StrictStr] = None
     id: Optional[StrictInt] = None
     __properties = ["name", "description", "id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEventTypes200ResponseDataInner:
         """Create an instance of GetEventTypes200ResponseDataInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEventTypes200ResponseDataInner.parse_obj(obj)
 
         _obj = GetEventTypes200ResponseDataInner.parse_obj({
             "name": obj.get("name"),
             "description": obj.get("description"),
             "id": obj.get("id")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/get_events200_response.py` & `onelogin-3.1.5/onelogin/models/get_events200_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -31,14 +30,15 @@
     """
     status: Optional[Error] = None
     pagination: Optional[GetEvents200ResponsePagination] = None
     data: Optional[conlist(Event)] = None
     __properties = ["status", "pagination", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -74,15 +74,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEvents200Response:
         """Create an instance of GetEvents200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEvents200Response.parse_obj(obj)
 
         _obj = GetEvents200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "pagination": GetEvents200ResponsePagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
             "data": [Event.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/get_events200_response_pagination.py` & `onelogin-3.1.5/onelogin/models/get_events200_response_pagination.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictStr
@@ -29,14 +28,15 @@
     before_cursor: Optional[StrictStr] = None
     after_cursor: Optional[StrictStr] = None
     previous_link: Optional[StrictStr] = None
     next_link: Optional[StrictStr] = None
     __properties = ["before_cursor", "after_cursor", "previous_link", "next_link"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetEvents200ResponsePagination:
         """Create an instance of GetEvents200ResponsePagination from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetEvents200ResponsePagination.parse_obj(obj)
 
         _obj = GetEvents200ResponsePagination.parse_obj({
             "before_cursor": obj.get("before_cursor"),
             "after_cursor": obj.get("after_cursor"),
             "previous_link": obj.get("previous_link"),
             "next_link": obj.get("next_link")
```

### Comparing `onelogin-3.1.4/onelogin/models/get_groups200_response.py` & `onelogin-3.1.5/onelogin/models/get_groups200_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -29,14 +28,15 @@
     GetGroups200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(Group)] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -69,15 +69,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetGroups200Response:
         """Create an instance of GetGroups200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetGroups200Response.parse_obj(obj)
 
         _obj = GetGroups200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": [Group.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_invite_link200_response.py` & `onelogin-3.1.5/onelogin/models/get_invite_link200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictStr, conlist
@@ -28,14 +27,15 @@
     GetInviteLink200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(StrictStr)] = Field(None, description="Provides reset password link")
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetInviteLink200Response:
         """Create an instance of GetInviteLink200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetInviteLink200Response.parse_obj(obj)
 
         _obj = GetInviteLink200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": obj.get("data")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_invite_link_request.py` & `onelogin-3.1.5/onelogin/models/get_invite_link_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     GetInviteLinkRequest
     """
     email: Optional[StrictStr] = Field(None, description="Set to the user email address to generate an invite link. The value is case sensitive.")
     __properties = ["email"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetInviteLinkRequest:
         """Create an instance of GetInviteLinkRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetInviteLinkRequest.parse_obj(obj)
 
         _obj = GetInviteLinkRequest.parse_obj({
             "email": obj.get("email")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_mfa_factors200_response.py` & `onelogin-3.1.5/onelogin/models/get_mfa_factors200_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -29,14 +28,15 @@
     GetMFAFactors200Response
     """
     status: Optional[Error] = None
     data: Optional[GetMFAFactors200ResponseData] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetMFAFactors200Response:
         """Create an instance of GetMFAFactors200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetMFAFactors200Response.parse_obj(obj)
 
         _obj = GetMFAFactors200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": GetMFAFactors200ResponseData.from_dict(obj.get("data")) if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_mfa_factors200_response_data.py` & `onelogin-3.1.5/onelogin/models/get_mfa_factors200_response_data.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -27,14 +26,15 @@
     """
     GetMFAFactors200ResponseData
     """
     auth_factors: Optional[conlist(GetMFAFactors200ResponseDataAuthFactorsInner)] = None
     __properties = ["auth_factors"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetMFAFactors200ResponseData:
         """Create an instance of GetMFAFactors200ResponseData from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetMFAFactors200ResponseData.parse_obj(obj)
 
         _obj = GetMFAFactors200ResponseData.parse_obj({
             "auth_factors": [GetMFAFactors200ResponseDataAuthFactorsInner.from_dict(_item) for _item in obj.get("auth_factors")] if obj.get("auth_factors") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_mfa_factors200_response_data_auth_factors_inner.py` & `onelogin-3.1.5/onelogin/models/get_mfa_factors200_response_data_auth_factors_inner.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     GetMFAFactors200ResponseDataAuthFactorsInner
     """
     name: Optional[StrictStr] = Field(None, description="Official authentication factor name, as it appears to administrators in OneLogin.")
     factor_id: Optional[StrictInt] = Field(None, description="Identifier for the factor which will be used for user enrollment")
     __properties = ["name", "factor_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetMFAFactors200ResponseDataAuthFactorsInner:
         """Create an instance of GetMFAFactors200ResponseDataAuthFactorsInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetMFAFactors200ResponseDataAuthFactorsInner.parse_obj(obj)
 
         _obj = GetMFAFactors200ResponseDataAuthFactorsInner.parse_obj({
             "name": obj.get("name"),
             "factor_id": obj.get("factor_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_rate_limit200_response.py` & `onelogin-3.1.5/onelogin/models/get_rate_limit200_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -29,14 +29,15 @@
     GetRateLimit200Response
     """
     status: Optional[Error] = None
     data: Optional[RateLimit] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +66,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRateLimit200Response:
         """Create an instance of GetRateLimit200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRateLimit200Response.parse_obj(obj)
 
         _obj = GetRateLimit200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": RateLimit.from_dict(obj.get("data")) if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_risk_score200_response.py` & `onelogin-3.1.5/onelogin/models/get_risk_score200_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictStr, confloat, conlist
@@ -27,14 +27,15 @@
     GetRiskScore200Response
     """
     score: Optional[confloat(le=100, ge=0, strict=True)] = Field(None, description="A risk score 0 is low risk and 100 is the highest risk level possible.")
     triggers: Optional[conlist(StrictStr)] = Field(None, description="Triggers are indicators of some of the key items that influenced the risk score.")
     __properties = ["score", "triggers"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRiskScore200Response:
         """Create an instance of GetRiskScore200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRiskScore200Response.parse_obj(obj)
 
         _obj = GetRiskScore200Response.parse_obj({
             "score": obj.get("score"),
             "triggers": obj.get("triggers")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_risk_score_request.py` & `onelogin-3.1.5/onelogin/models/get_risk_score_request.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -36,14 +35,15 @@
     source: Optional[Source] = None
     session: Optional[Session] = None
     device: Optional[RiskDevice] = None
     fp: Optional[StrictStr] = Field(None, description="Set to the value of the __tdli_fp cookie.")
     __properties = ["ip", "user_agent", "user", "source", "session", "device", "fp"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -78,15 +78,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRiskScoreRequest:
         """Create an instance of GetRiskScoreRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRiskScoreRequest.parse_obj(obj)
 
         _obj = GetRiskScoreRequest.parse_obj({
             "ip": obj.get("ip"),
             "user_agent": obj.get("user_agent"),
             "user": RiskUser.from_dict(obj.get("user")) if obj.get("user") is not None else None,
             "source": Source.from_dict(obj.get("source")) if obj.get("source") is not None else None,
```

### Comparing `onelogin-3.1.4/onelogin/models/get_risk_scores200_response.py` & `onelogin-3.1.5/onelogin/models/get_risk_scores200_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -28,14 +27,15 @@
     GetRiskScores200Response
     """
     scores: Optional[GetRiskScores200ResponseScores] = None
     total: Optional[StrictInt] = None
     __properties = ["scores", "total"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRiskScores200Response:
         """Create an instance of GetRiskScores200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRiskScores200Response.parse_obj(obj)
 
         _obj = GetRiskScores200Response.parse_obj({
             "scores": GetRiskScores200ResponseScores.from_dict(obj.get("scores")) if obj.get("scores") is not None else None,
             "total": obj.get("total")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_risk_scores200_response_scores.py` & `onelogin-3.1.5/onelogin/models/get_risk_scores200_response_scores.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -30,14 +30,15 @@
     low: Optional[StrictInt] = None
     medium: Optional[StrictInt] = None
     high: Optional[StrictInt] = None
     very_high: Optional[StrictInt] = None
     __properties = ["minimal", "low", "medium", "high", "very_high"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRiskScores200ResponseScores:
         """Create an instance of GetRiskScores200ResponseScores from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRiskScores200ResponseScores.parse_obj(obj)
 
         _obj = GetRiskScores200ResponseScores.parse_obj({
             "minimal": obj.get("minimal"),
             "low": obj.get("low"),
             "medium": obj.get("medium"),
             "high": obj.get("high"),
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_apps200_response_inner.py` & `onelogin-3.1.5/onelogin/models/get_role_apps200_response_inner.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="app id")
     name: Optional[StrictStr] = Field(None, description="app name")
     icon_url: Optional[StrictStr] = Field(None, description="url of Icon")
     __properties = ["id", "name", "icon_url"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleApps200ResponseInner:
         """Create an instance of GetRoleApps200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleApps200ResponseInner.parse_obj(obj)
 
         _obj = GetRoleApps200ResponseInner.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "icon_url": obj.get("icon_url")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_by_id200_response.py` & `onelogin-3.1.5/onelogin/models/get_role_by_id200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -29,14 +28,15 @@
     GetRoleById200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(GetRoleById200ResponseDataInner)] = None
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -69,15 +69,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleById200Response:
         """Create an instance of GetRoleById200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleById200Response.parse_obj(obj)
 
         _obj = GetRoleById200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": [GetRoleById200ResponseDataInner.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_by_id200_response_data_inner.py` & `onelogin-3.1.5/onelogin/models/get_role_by_id200_response_data_inner.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     GetRoleById200ResponseDataInner
     """
     id: Optional[StrictInt] = Field(None, description="role's unique ID in Onelogin")
     name: Optional[StrictStr] = Field(None, description="Role name")
     __properties = ["id", "name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleById200ResponseDataInner:
         """Create an instance of GetRoleById200ResponseDataInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleById200ResponseDataInner.parse_obj(obj)
 
         _obj = GetRoleById200ResponseDataInner.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_by_name200_response.py` & `onelogin-3.1.5/onelogin/models/get_role_by_name200_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, conlist
@@ -31,14 +30,15 @@
     """
     status: Optional[Error] = None
     pagination: Optional[GetRoleByName200ResponsePagination] = None
     data: Optional[conlist(GetRoleByName200ResponseDataInner)] = None
     __properties = ["status", "pagination", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -74,15 +74,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleByName200Response:
         """Create an instance of GetRoleByName200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleByName200Response.parse_obj(obj)
 
         _obj = GetRoleByName200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "pagination": GetRoleByName200ResponsePagination.from_dict(obj.get("pagination")) if obj.get("pagination") is not None else None,
             "data": [GetRoleByName200ResponseDataInner.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_by_name200_response_data_inner.py` & `onelogin-3.1.5/onelogin/models/get_role_by_name200_response_data_inner.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     GetRoleByName200ResponseDataInner
     """
     id: Optional[StrictInt] = Field(None, description="Role ID")
     name: Optional[StrictStr] = Field(None, description="Role Name")
     __properties = ["id", "name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleByName200ResponseDataInner:
         """Create an instance of GetRoleByName200ResponseDataInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleByName200ResponseDataInner.parse_obj(obj)
 
         _obj = GetRoleByName200ResponseDataInner.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_role_by_name200_response_pagination.py` & `onelogin-3.1.5/onelogin/models/get_role_by_name200_response_pagination.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictStr
@@ -29,14 +28,15 @@
     after_cursor: Optional[StrictStr] = None
     before_cursor: Optional[StrictStr] = None
     next_link: Optional[StrictStr] = None
     previous_link: Optional[StrictStr] = None
     __properties = ["after_cursor", "before_cursor", "next_link", "previous_link"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetRoleByName200ResponsePagination:
         """Create an instance of GetRoleByName200ResponsePagination from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetRoleByName200ResponsePagination.parse_obj(obj)
 
         _obj = GetRoleByName200ResponsePagination.parse_obj({
             "after_cursor": obj.get("after_cursor"),
             "before_cursor": obj.get("before_cursor"),
             "next_link": obj.get("next_link"),
             "previous_link": obj.get("previous_link")
```

### Comparing `onelogin-3.1.4/onelogin/models/get_user_apps200_response_inner.py` & `onelogin-3.1.5/onelogin/models/get_user_apps200_response_inner.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, validator
@@ -33,30 +32,35 @@
     name: Optional[StrictStr] = Field(None, description="The name of the app.")
     provisioning_status: Optional[StrictStr] = None
     provisioning_state: Optional[StrictStr] = Field(None, description="If provisioning is enabled this indicates the state of provisioning for the given user.")
     provisioning_enabled: Optional[StrictBool] = Field(None, description="Indicates if provisioning is enabled for this app.")
     __properties = ["id", "icon_url", "extension", "login_id", "name", "provisioning_status", "provisioning_state", "provisioning_enabled"]
 
     @validator('provisioning_status')
-    def provisioning_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('enabling', 'disabling', 'enabling_pending_approval', 'disabling_pendding_approval', 'enabled', 'disabled', 'disabling_failed', 'enabling_failed'):
+    def provisioning_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('enabling', 'disabling', 'enabling_pending_approval', 'disabling_pendding_approval', 'enabled', 'disabled', 'disabling_failed', 'enabling_failed'):
             raise ValueError("must be one of enum values ('enabling', 'disabling', 'enabling_pending_approval', 'disabling_pendding_approval', 'enabled', 'disabled', 'disabling_failed', 'enabling_failed')")
-        return v
+        return value
 
     @validator('provisioning_state')
-    def provisioning_state_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('unknown', 'provisioning', 'modifying', 'deleting', 'provisioning_pending_approval', 'deleting_pending_approval', 'modifying_pending_approval', 'linking', 'provisioned', 'deleted', 'modifying_failed', 'provisioning_failed', 'deleting_failed', 'linking_failed', 'disabled', 'nonexistent', 'modifying_pending_approval_then_disabled'):
+    def provisioning_state_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('unknown', 'provisioning', 'modifying', 'deleting', 'provisioning_pending_approval', 'deleting_pending_approval', 'modifying_pending_approval', 'linking', 'provisioned', 'deleted', 'modifying_failed', 'provisioning_failed', 'deleting_failed', 'linking_failed', 'disabled', 'nonexistent', 'modifying_pending_approval_then_disabled'):
             raise ValueError("must be one of enum values ('unknown', 'provisioning', 'modifying', 'deleting', 'provisioning_pending_approval', 'deleting_pending_approval', 'modifying_pending_approval', 'linking', 'provisioned', 'deleted', 'modifying_failed', 'provisioning_failed', 'deleting_failed', 'linking_failed', 'disabled', 'nonexistent', 'modifying_pending_approval_then_disabled')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +83,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetUserApps200ResponseInner:
         """Create an instance of GetUserApps200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetUserApps200ResponseInner.parse_obj(obj)
 
         _obj = GetUserApps200ResponseInner.parse_obj({
             "id": obj.get("id"),
             "icon_url": obj.get("icon_url"),
             "extension": obj.get("extension"),
             "login_id": obj.get("login_id"),
```

### Comparing `onelogin-3.1.4/onelogin/models/get_user_roles200_response.py` & `onelogin-3.1.5/onelogin/models/get_user_roles200_response.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, conlist
@@ -28,14 +27,15 @@
     GetUserRoles200Response
     """
     status: Optional[Error] = None
     data: Optional[conlist(StrictInt)] = Field(None, description="List of Role IDs that are assigned to the User")
     __properties = ["status", "data"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetUserRoles200Response:
         """Create an instance of GetUserRoles200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetUserRoles200Response.parse_obj(obj)
 
         _obj = GetUserRoles200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None,
             "data": obj.get("data")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/get_user_verification200_response.py` & `onelogin-3.1.5/onelogin/models/get_user_verification200_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictStr] = Field(None, description="registration identifier")
     status: Optional[StrictStr] = Field(None, description="pending = has not been completed. accepted registration has successfully completed, rejected user has denied the MFA attempt or incorrectly provided the OneLogin Voice OTP code.")
     device_id: Optional[StrictStr] = Field(None, description="Device Id to be used with verify factor")
     __properties = ["id", "status", "device_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GetUserVerification200Response:
         """Create an instance of GetUserVerification200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GetUserVerification200Response.parse_obj(obj)
 
         _obj = GetUserVerification200Response.parse_obj({
             "id": obj.get("id"),
             "status": obj.get("status"),
             "device_id": obj.get("device_id")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/group.py` & `onelogin-3.1.5/onelogin/models/group.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="Group's unique Onelogin ID")
     name: Optional[StrictStr] = Field(None, description="Group name")
     reference: Optional[StrictStr] = Field(None, description="Deprecated. Will always show the attribute nil=\"true\".")
     __properties = ["id", "name", "reference"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Group:
         """Create an instance of Group from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Group.parse_obj(obj)
 
         _obj = Group.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "reference": obj.get("reference")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/hook.py` & `onelogin-3.1.5/onelogin/models/hook.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Dict, List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist, validator
@@ -42,22 +41,25 @@
     options: Optional[HookOptions] = None
     conditions: Optional[conlist(Condition)] = Field(None, description="An array of objects that let you limit the execution of a hook to users in specific roles.")
     created_at: Optional[StrictStr] = Field(None, description="ISO8601 format date that they hook function was created.")
     updated_at: Optional[StrictStr] = Field(None, description="ISO8601 format date that they hook function was last updated.")
     __properties = ["id", "type", "disabled", "timeout", "env_vars", "runtime", "retries", "packages", "function", "context_version", "status", "options", "conditions", "created_at", "updated_at"]
 
     @validator('status')
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ('ready', 'create-queued', 'create-running', 'create-failed', 'update-queued', 'update-running', 'update-failed'):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ('ready', 'create-queued', 'create-running', 'create-failed', 'update-queued', 'update-running', 'update-failed'):
             raise ValueError("must be one of enum values ('ready', 'create-queued', 'create-running', 'create-failed', 'update-queued', 'update-running', 'update-failed')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -90,15 +92,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Hook:
         """Create an instance of Hook from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Hook.parse_obj(obj)
 
         _obj = Hook.parse_obj({
             "id": obj.get("id"),
             "type": obj.get("type"),
             "disabled": obj.get("disabled") if obj.get("disabled") is not None else True,
             "timeout": obj.get("timeout") if obj.get("timeout") is not None else 1,
```

### Comparing `onelogin-3.1.4/onelogin/models/hook_envvar.py` & `onelogin-3.1.5/onelogin/models/hook_envvar.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -30,14 +29,15 @@
     name: StrictStr = Field(..., description="The name of the environment variable.")
     created_at: Optional[StrictStr] = Field(None, description="The ISO8601 formatted date that the environment variable was created.")
     updated_at: Optional[StrictStr] = Field(None, description="The ISO8601 formatted date that the environment variable was last updated.")
     value: StrictStr = Field(..., description="The secret value that will be encrypted at rest and injected in applicable hook functions at run time.")
     __properties = ["id", "name", "created_at", "updated_at", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HookEnvvar:
         """Create an instance of HookEnvvar from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HookEnvvar.parse_obj(obj)
 
         _obj = HookEnvvar.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "created_at": obj.get("created_at"),
             "updated_at": obj.get("updated_at"),
```

### Comparing `onelogin-3.1.4/onelogin/models/hook_log.py` & `onelogin-3.1.5/onelogin/models/hook_log.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, StrictStr, conlist
@@ -29,14 +28,15 @@
     request_id: Optional[StrictStr] = None
     correlation_id: Optional[StrictStr] = None
     created_at: Optional[StrictStr] = None
     events: Optional[conlist(StrictStr)] = None
     __properties = ["request_id", "correlation_id", "created_at", "events"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HookLog:
         """Create an instance of HookLog from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HookLog.parse_obj(obj)
 
         _obj = HookLog.parse_obj({
             "request_id": obj.get("request_id"),
             "correlation_id": obj.get("correlation_id"),
             "created_at": obj.get("created_at"),
             "events": obj.get("events")
```

### Comparing `onelogin-3.1.4/onelogin/models/hook_options.py` & `onelogin-3.1.5/onelogin/models/hook_options.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictBool
@@ -28,14 +27,15 @@
     """
     risk_enabled: Optional[StrictBool] = None
     location_enabled: Optional[StrictBool] = None
     mfa_device_info_enabled: Optional[StrictBool] = None
     __properties = ["risk_enabled", "location_enabled", "mfa_device_info_enabled"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HookOptions:
         """Create an instance of HookOptions from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HookOptions.parse_obj(obj)
 
         _obj = HookOptions.parse_obj({
             "risk_enabled": obj.get("risk_enabled"),
             "location_enabled": obj.get("location_enabled"),
             "mfa_device_info_enabled": obj.get("mfa_device_info_enabled")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/hook_status.py` & `onelogin-3.1.5/onelogin/models/hook_status.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     HookStatus
     """
     name: Optional[StrictStr] = Field(None, description="responses status nam")
     message: Optional[StrictStr] = Field(None, description="your operation was successful")
     __properties = ["name", "message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HookStatus:
         """Create an instance of HookStatus from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HookStatus.parse_obj(obj)
 
         _obj = HookStatus.parse_obj({
             "name": obj.get("name"),
             "message": obj.get("message")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_conditions200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_conditions200_response_inner.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     ListConditions200ResponseInner
     """
     name: Optional[StrictStr] = Field(None, description="Name of the rule condition")
     value: Optional[StrictStr] = Field(None, description="The unique identifier of the condition. This should be used when defining conditions for a rule.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListConditions200ResponseInner:
         """Create an instance of ListConditions200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListConditions200ResponseInner.parse_obj(obj)
 
         _obj = ListConditions200ResponseInner.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_mapping_action_values200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_mapping_action_values200_response_inner.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     ListMappingActionValues200ResponseInner
     """
     name: Optional[StrictStr] = Field(None, description="Name or description of operator")
     value: Optional[StrictInt] = Field(None, description="The action operator value to use when creating or updating User Mappings.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMappingActionValues200ResponseInner:
         """Create an instance of ListMappingActionValues200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMappingActionValues200ResponseInner.parse_obj(obj)
 
         _obj = ListMappingActionValues200ResponseInner.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_mapping_conditions200_response.py` & `onelogin-3.1.5/onelogin/models/list_mapping_conditions200_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     ListMappingConditions200Response
     """
     name: Optional[StrictStr] = Field(None, description="Name of Condition")
     value: Optional[StrictStr] = Field(None, description="The unique identifier of the condition. This should be used when defining conditions for a User Mapping")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMappingConditions200Response:
         """Create an instance of ListMappingConditions200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMappingConditions200Response.parse_obj(obj)
 
         _obj = ListMappingConditions200Response.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_mapping_conditions_operators200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_mapping_conditions_operators200_response_inner.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     ListMappingConditionsOperators200ResponseInner
     """
     name: Optional[StrictStr] = Field(None, description="Name or description of operator")
     value: Optional[StrictStr] = Field(None, description="The condition operator value to use when creating or updating User Mappings.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMappingConditionsOperators200ResponseInner:
         """Create an instance of ListMappingConditionsOperators200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMappingConditionsOperators200ResponseInner.parse_obj(obj)
 
         _obj = ListMappingConditionsOperators200ResponseInner.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_mapping_contion_values200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_mapping_contion_values200_response_inner.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     ListMappingContionValues200ResponseInner
     """
     name: Optional[StrictStr] = Field(None, description="Name or description of operator")
     value: Optional[StrictInt] = Field(None, description="The condition operator value to use when creating or updating User Mappings.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMappingContionValues200ResponseInner:
         """Create an instance of ListMappingContionValues200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMappingContionValues200ResponseInner.parse_obj(obj)
 
         _obj = ListMappingContionValues200ResponseInner.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_mappings_actions200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_mappings_actions200_response_inner.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     ListMappingsActions200ResponseInner
     """
     name: Optional[StrictStr] = Field(None, description="Name of the action")
     value: Optional[StrictStr] = Field(None, description="The unique identifier of the action. This should be used when defining actions for a User Mapping.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMappingsActions200ResponseInner:
         """Create an instance of ListMappingsActions200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMappingsActions200ResponseInner.parse_obj(obj)
 
         _obj = ListMappingsActions200ResponseInner.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/list_message_templates200_response_inner.py` & `onelogin-3.1.5/onelogin/models/list_message_templates200_response_inner.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="template ID")
     enabled: Optional[StrictBool] = Field(None, description="indicator if template is enabled")
     name: Optional[StrictStr] = Field(None, description="name of message template")
     __properties = ["id", "enabled", "name"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ListMessageTemplates200ResponseInner:
         """Create an instance of ListMessageTemplates200ResponseInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ListMessageTemplates200ResponseInner.parse_obj(obj)
 
         _obj = ListMessageTemplates200ResponseInner.parse_obj({
             "id": obj.get("id"),
             "enabled": obj.get("enabled"),
             "name": obj.get("name")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/list_privelege_roles200_response.py` & `onelogin-3.1.5/onelogin/models/list_privelege_roles200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/onelogin/models/locale.py` & `onelogin-3.1.5/onelogin/models/locale.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -27,14 +26,15 @@
     Locale
     """
     language: Optional[StrictStr] = Field(None, description="locale string")
     is_default: Optional[StrictBool] = Field(None, description="indicator if language is default")
     __properties = ["language", "is_default"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Locale:
         """Create an instance of Locale from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Locale.parse_obj(obj)
 
         _obj = Locale.parse_obj({
             "language": obj.get("language"),
             "is_default": obj.get("is_default")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/lock_account_user_request.py` & `onelogin-3.1.5/onelogin/models/lock_account_user_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictInt
@@ -26,14 +25,15 @@
     """
     LockAccountUserRequest
     """
     locked_until: StrictInt = Field(..., description="Set to the number of minutes for which you want to lock the user account. Set to 0 if you want to lock the user account based on the Lock effective period set in the policy assigned to the user. If no policy is assigned to the user, setting this value to 0 will lock the users account until you unlock it Note that this value can not be less time that the Lock Effective Period specified on a user policy.")
     __properties = ["locked_until"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LockAccountUserRequest:
         """Create an instance of LockAccountUserRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LockAccountUserRequest.parse_obj(obj)
 
         _obj = LockAccountUserRequest.parse_obj({
             "locked_until": obj.get("locked_until")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/mapping.py` & `onelogin-3.1.5/onelogin/models/mapping.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, validator
@@ -34,20 +33,22 @@
     match: StrictStr = Field(..., description="Indicates how conditions should be matched.")
     position: StrictInt = Field(..., description="Indicates the order of the mapping. When `null` this will default to last position.")
     conditions: conlist(Condition) = Field(..., description="An array of conditions that the user must meet in order for the mapping to be applied.")
     actions: conlist(ActionObj) = Field(..., description="An array of actions that will be applied to the users that are matched by the conditions.")
     __properties = ["id", "name", "enabled", "match", "position", "conditions", "actions"]
 
     @validator('match')
-    def match_validate_enum(cls, v):
-        if v not in ('all', 'any'):
+    def match_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ('all', 'any'):
             raise ValueError("must be one of enum values ('all', 'any')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -84,15 +85,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Mapping:
         """Create an instance of Mapping from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Mapping.parse_obj(obj)
 
         _obj = Mapping.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "enabled": obj.get("enabled"),
             "match": obj.get("match"),
```

### Comparing `onelogin-3.1.4/onelogin/models/message_template.py` & `onelogin-3.1.5/onelogin/models/message_template.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
@@ -34,26 +33,29 @@
     template: MessageTemplateTemplate = ...
     template_class: Optional[StrictStr] = None
     updated_at: Optional[StrictStr] = Field(None, description="Last time template was updated")
     brand_id: Optional[StrictInt] = Field(None, description="brand id number")
     __properties = ["id", "account_id", "type", "locale", "template", "template_class", "updated_at", "brand_id"]
 
     @validator('type')
-    def type_validate_enum(cls, v):
-        if v not in ('email_forgot_password', 'email_code_registration', 'email_code_login_verification', 'email_code_app_verification', 'email_code_pw_reset_verification', 'email_magiclink_registration', 'email_magiclink_login_verification', 'email_magiclink_app_verification', 'email_magiclink_pw_reset_verification', 'sms_registration', 'sms_login_verification', 'sms_app_verification', 'sms_pw_reset_verification'):
+    def type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ('email_forgot_password', 'email_code_registration', 'email_code_login_verification', 'email_code_app_verification', 'email_code_pw_reset_verification', 'email_magiclink_registration', 'email_magiclink_login_verification', 'email_magiclink_app_verification', 'email_magiclink_pw_reset_verification', 'sms_registration', 'sms_login_verification', 'sms_app_verification', 'sms_pw_reset_verification'):
             raise ValueError("must be one of enum values ('email_forgot_password', 'email_code_registration', 'email_code_login_verification', 'email_code_app_verification', 'email_code_pw_reset_verification', 'email_magiclink_registration', 'email_magiclink_login_verification', 'email_magiclink_app_verification', 'email_magiclink_pw_reset_verification', 'sms_registration', 'sms_login_verification', 'sms_app_verification', 'sms_pw_reset_verification')")
-        return v
+        return value
 
     @validator('locale')
-    def locale_validate_regular_expression(cls, v):
-        if not re.match(r"^[a-z]{2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[a-z]{2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2}$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -84,15 +86,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> MessageTemplate:
         """Create an instance of MessageTemplate from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return MessageTemplate.parse_obj(obj)
 
         _obj = MessageTemplate.parse_obj({
             "id": obj.get("id"),
             "account_id": obj.get("account_id"),
             "type": obj.get("type"),
             "locale": obj.get("locale"),
```

### Comparing `onelogin-3.1.4/onelogin/models/message_template_template.py` & `onelogin-3.1.5/onelogin/models/message_template_template.py`

 * *Files 14% similar despite different names*

```diff
@@ -37,84 +37,101 @@
     oneof_schema_2_validator: Optional[MessageTemplateTemplateOneOf1] = None
     actual_instance: Any
     one_of_schemas: List[str] = Field(MESSAGETEMPLATETEMPLATE_ONE_OF_SCHEMAS, const=True)
 
     class Config:
         validate_assignment = True
 
+    def __init__(self, *args, **kwargs):
+        if args:
+            if len(args) > 1:
+                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
+            if kwargs:
+                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
+            super().__init__(actual_instance=args[0])
+        else:
+            super().__init__(**kwargs)
+
     @validator('actual_instance')
     def actual_instance_must_validate_oneof(cls, v):
-        instance = cls()
+        instance = MessageTemplateTemplate.construct()
         error_messages = []
         match = 0
         # validate data type: MessageTemplateTemplateOneOf
-        if type(v) is not MessageTemplateTemplateOneOf:
+        if not isinstance(v, MessageTemplateTemplateOneOf):
             error_messages.append(f"Error! Input type `{type(v)}` is not `MessageTemplateTemplateOneOf`")
         else:
             match += 1
-
         # validate data type: MessageTemplateTemplateOneOf1
-        if type(v) is not MessageTemplateTemplateOneOf1:
+        if not isinstance(v, MessageTemplateTemplateOneOf1):
             error_messages.append(f"Error! Input type `{type(v)}` is not `MessageTemplateTemplateOneOf1`")
         else:
             match += 1
-
         if match > 1:
             # more than 1 match
-            raise ValueError("Multiple matches found when deserializing the JSON string into MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
+            raise ValueError("Multiple matches found when setting `actual_instance` in MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
-            raise ValueError("No match found when deserializing the JSON string into MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
+            raise ValueError("No match found when setting `actual_instance` in MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
         else:
             return v
 
     @classmethod
     def from_dict(cls, obj: dict) -> MessageTemplateTemplate:
         return cls.from_json(json.dumps(obj))
 
     @classmethod
     def from_json(cls, json_str: str) -> MessageTemplateTemplate:
         """Returns the object represented by the json string"""
-        instance = cls()
+        instance = MessageTemplateTemplate.construct()
         error_messages = []
         match = 0
 
         # deserialize data into MessageTemplateTemplateOneOf
         try:
             instance.actual_instance = MessageTemplateTemplateOneOf.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
         # deserialize data into MessageTemplateTemplateOneOf1
         try:
             instance.actual_instance = MessageTemplateTemplateOneOf1.from_json(json_str)
             match += 1
-        except ValidationError as e:
+        except (ValidationError, ValueError) as e:
             error_messages.append(str(e))
 
         if match > 1:
             # more than 1 match
             raise ValueError("Multiple matches found when deserializing the JSON string into MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
         elif match == 0:
             # no match
             raise ValueError("No match found when deserializing the JSON string into MessageTemplateTemplate with oneOf schemas: MessageTemplateTemplateOneOf, MessageTemplateTemplateOneOf1. Details: " + ", ".join(error_messages))
         else:
             return instance
 
     def to_json(self) -> str:
         """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return "null"
+
+        to_json = getattr(self.actual_instance, "to_json", None)
+        if callable(to_json):
             return self.actual_instance.to_json()
         else:
-            return "null"
+            return json.dumps(self.actual_instance)
 
     def to_dict(self) -> dict:
         """Returns the dict representation of the actual instance"""
-        if self.actual_instance is not None:
+        if self.actual_instance is None:
+            return None
+
+        to_dict = getattr(self.actual_instance, "to_dict", None)
+        if callable(to_dict):
             return self.actual_instance.to_dict()
         else:
-            return dict()
+            # primitive type
+            return self.actual_instance
 
     def to_str(self) -> str:
         """Returns the string representation of the actual instance"""
         return pprint.pformat(self.dict())
```

### Comparing `onelogin-3.1.4/onelogin/models/message_template_template_one_of.py` & `onelogin-3.1.5/onelogin/models/message_template_template_one_of.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictStr
@@ -28,14 +27,15 @@
     """
     subject: StrictStr = Field(..., description="Custom Email Subject")
     html: StrictStr = Field(..., description="The HTML body of the Custom Email")
     plain: StrictStr = Field(..., description="The Plain text body of the email")
     __properties = ["subject", "html", "plain"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> MessageTemplateTemplateOneOf:
         """Create an instance of MessageTemplateTemplateOneOf from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return MessageTemplateTemplateOneOf.parse_obj(obj)
 
         _obj = MessageTemplateTemplateOneOf.parse_obj({
             "subject": obj.get("subject"),
             "html": obj.get("html"),
             "plain": obj.get("plain")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/message_template_template_one_of1.py` & `onelogin-3.1.5/onelogin/models/message_template_template_one_of1.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, constr
@@ -26,14 +25,15 @@
     """
     MessageTemplateTemplateOneOf1
     """
     message: constr(strict=True, max_length=160) = Field(..., description="The body of the SMS message. Max length 160 characters.")
     __properties = ["message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> MessageTemplateTemplateOneOf1:
         """Create an instance of MessageTemplateTemplateOneOf1 from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return MessageTemplateTemplateOneOf1.parse_obj(obj)
 
         _obj = MessageTemplateTemplateOneOf1.parse_obj({
             "message": obj.get("message")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/oauth_token.py` & `onelogin-3.1.5/onelogin/models/oauth_token.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -31,14 +31,15 @@
     expires_in: Optional[StrictInt] = Field(None, description="Indicates that the generated access token expires in 36,000 seconds, 600 minutes, or 10 hours. An expired access token cannot be used to make resource API calls, but it can still be used along with its associated refresh token to call the Refresh Tokens v2 API.")
     refresh_token: Optional[StrictStr] = Field(None, description="deprecated No longer in use")
     token_type: Optional[StrictStr] = Field(None, description="Indicates that the generated access token is a bearer token.")
     account_id: Optional[StrictInt] = Field(None, description="Account ID associated with the API credentials used to generate the token.")
     __properties = ["access_token", "created_at", "expires_in", "refresh_token", "token_type", "account_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +62,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OauthToken:
         """Create an instance of OauthToken from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OauthToken.parse_obj(obj)
 
         _obj = OauthToken.parse_obj({
             "access_token": obj.get("access_token"),
             "created_at": obj.get("created_at"),
             "expires_in": obj.get("expires_in"),
             "refresh_token": obj.get("refresh_token"),
```

### Comparing `onelogin-3.1.4/onelogin/models/oidc_app.py` & `onelogin-3.1.5/onelogin/models/oidc_app.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
@@ -50,14 +49,15 @@
     parameters: Optional[AppParameters] = None
     enforcement_point: Optional[EnforcementPoint] = None
     configuration: ConfigurationOidc = ...
     sso: Optional[SsoOidc] = None
     __properties = ["id", "name", "visible", "description", "notes", "icon_url", "auth_method", "policy_id", "allow_assumed_signin", "tab_id", "connector_id", "created_at", "updated_at", "role_ids", "provisioning", "parameters", "enforcement_point", "configuration", "sso"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -96,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OidcApp:
         """Create an instance of OidcApp from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OidcApp.parse_obj(obj)
 
         _obj = OidcApp.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "visible": obj.get("visible"),
             "description": obj.get("description"),
```

### Comparing `onelogin-3.1.4/onelogin/models/oidc_app_all_of.py` & `onelogin-3.1.5/onelogin/models/oidc_app_all_of.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -29,14 +28,15 @@
     OidcAppAllOf
     """
     configuration: ConfigurationOidc = ...
     sso: Optional[SsoOidc] = None
     __properties = ["configuration", "sso"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OidcAppAllOf:
         """Create an instance of OidcAppAllOf from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OidcAppAllOf.parse_obj(obj)
 
         _obj = OidcAppAllOf.parse_obj({
             "configuration": ConfigurationOidc.from_dict(obj.get("configuration")) if obj.get("configuration") is not None else None,
             "sso": SsoOidc.from_dict(obj.get("sso")) if obj.get("sso") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/otp_device.py` & `onelogin-3.1.5/onelogin/models/otp_device.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -29,14 +28,15 @@
     factor_id: StrictInt = Field(..., description="The identifier of the factor to enroll the user with.")
     display_name: StrictStr = Field(..., description="A name for the users device")
     number: StrictStr = Field(..., description="The phone number of the user in E.164 format.")
     verified: Optional[StrictBool] = Field(None, description="Defaults to false. Some factors like SMS or Voice require that a user recieve a token and then that token is supplied to the Verify endpoint before the device is considered active. You can set verfied to `true` which indicates the the users phone number is pre verified and the device can be immediately activated.           ")
     __properties = ["factor_id", "display_name", "number", "verified"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OtpDevice:
         """Create an instance of OtpDevice from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OtpDevice.parse_obj(obj)
 
         _obj = OtpDevice.parse_obj({
             "factor_id": obj.get("factor_id"),
             "display_name": obj.get("display_name"),
             "number": obj.get("number"),
             "verified": obj.get("verified")
```

### Comparing `onelogin-3.1.4/onelogin/models/privilege.py` & `onelogin-3.1.5/onelogin/models/privilege.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictStr
@@ -30,14 +29,15 @@
     id: Optional[StrictStr] = None
     name: StrictStr = ...
     description: Optional[StrictStr] = None
     privilege: PrivilegePrivilege = ...
     __properties = ["id", "name", "description", "privilege"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -63,15 +63,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Privilege:
         """Create an instance of Privilege from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Privilege.parse_obj(obj)
 
         _obj = Privilege.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "description": obj.get("description"),
             "privilege": PrivilegePrivilege.from_dict(obj.get("privilege")) if obj.get("privilege") is not None else None
```

### Comparing `onelogin-3.1.4/onelogin/models/privilege_privilege.py` & `onelogin-3.1.5/onelogin/models/privilege_privilege.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictStr, conlist
@@ -28,14 +27,15 @@
     PrivilegePrivilege
     """
     version: Optional[StrictStr] = Field(None, alias="Version")
     statement: Optional[conlist(PrivilegePrivilegeStatementInner)] = Field(None, alias="Statement")
     __properties = ["Version", "Statement"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PrivilegePrivilege:
         """Create an instance of PrivilegePrivilege from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PrivilegePrivilege.parse_obj(obj)
 
         _obj = PrivilegePrivilege.parse_obj({
             "version": obj.get("Version"),
             "statement": [PrivilegePrivilegeStatementInner.from_dict(_item) for _item in obj.get("Statement")] if obj.get("Statement") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/privilege_privilege_statement_inner.py` & `onelogin-3.1.5/onelogin/models/privilege_privilege_statement_inner.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List
 from pydantic import BaseModel, Field, StrictStr, conlist, validator
@@ -28,21 +28,23 @@
     """
     effect: StrictStr = Field(..., alias="Effect", description="Set to Allow. By default, all actions are denied, this Statement allows the listed actions to be executed.")
     action: conlist(StrictStr) = Field(..., alias="Action", description="An array of strings that represent actions within OneLogin. Actions are prefixed with the class of object they are related to and followed by a specific action for the given class. e.g. users:List, where the class is users and the specific action is List. Dont mix classes within an Action array. To create a privilege that includes multiple different classes, create multiple statements. A wildcard * that includes all actions is supported. Use wildcards to create a Super User privilege.")
     scope: conlist(StrictStr) = Field(..., alias="Scope", description="Target the privileged action against specific resources with the scope. The scope pattern is the class of object used by the Action, followed by an ID that represents a resource in OneLogin. e.g. apps/1234, where apps is the class and 1234 is the ID of an app. The wildcard * is supported and indicates that all resources of the class type declared, in the Action, are in scope. The Action and Scope classes must match. However, there is an exception, a scope of roles/{role_id} can be combined with Actions on the user or app class. The exception allows you to target groups of users or apps with specific actions.")
     __properties = ["Effect", "Action", "Scope"]
 
     @validator('action')
-    def action_validate_enum(cls, v):
-        for i in v:
+    def action_validate_enum(cls, value):
+        """Validates the enum"""
+        for i in value:
             if i not in ('Apps:Create', 'Apps:Delete', 'Apps:List', 'Apps:Get', 'Apps:Update', 'Apps:ManageConnectors', 'Apps:ManageRoles', 'Apps:ManageTabs', 'Apps:ManageUsers', 'Apps:ReapplyMappings', 'Users:Create', 'Users:Delete', 'Users:List', 'Users:Get', 'Users:Update', 'Users:AssumeUser', 'Users:ManageApps', 'Users:Unlock', 'Users:GenerateTempMfaToken', 'Users:ResetPassword', 'Users:ReapplyMappings', 'Users:ManageLicense', 'Users:Invite', 'Users:ManageRoles', 'Roles:Create', 'Roles:Get', 'Roles:List', 'Roles:Update', 'Roles:Delete', 'Roles:ManageUsers', 'Roles:ManageApps', 'Reports:Create', 'Reports:Get', 'Reports:List', 'Reports:Update', 'Reports:Delete', 'Reports:Clone', 'Events:Get', 'Events:List', 'Groups:Create', 'Groups:Get', 'Groups:List', 'Groups:Update', 'Groups:Delete', 'Policies:Create', 'Policies:Get', 'Policies:List', 'Policies:Update', 'Policies:Delete', 'Policies:SetDefault'):
                 raise ValueError("each list item must be one of ('Apps:Create', 'Apps:Delete', 'Apps:List', 'Apps:Get', 'Apps:Update', 'Apps:ManageConnectors', 'Apps:ManageRoles', 'Apps:ManageTabs', 'Apps:ManageUsers', 'Apps:ReapplyMappings', 'Users:Create', 'Users:Delete', 'Users:List', 'Users:Get', 'Users:Update', 'Users:AssumeUser', 'Users:ManageApps', 'Users:Unlock', 'Users:GenerateTempMfaToken', 'Users:ResetPassword', 'Users:ReapplyMappings', 'Users:ManageLicense', 'Users:Invite', 'Users:ManageRoles', 'Roles:Create', 'Roles:Get', 'Roles:List', 'Roles:Update', 'Roles:Delete', 'Roles:ManageUsers', 'Roles:ManageApps', 'Reports:Create', 'Reports:Get', 'Reports:List', 'Reports:Update', 'Reports:Delete', 'Reports:Clone', 'Events:Get', 'Events:List', 'Groups:Create', 'Groups:Get', 'Groups:List', 'Groups:Update', 'Groups:Delete', 'Policies:Create', 'Policies:Get', 'Policies:List', 'Policies:Update', 'Policies:Delete', 'Policies:SetDefault')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +67,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PrivilegePrivilegeStatementInner:
         """Create an instance of PrivilegePrivilegeStatementInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PrivilegePrivilegeStatementInner.parse_obj(obj)
 
         _obj = PrivilegePrivilegeStatementInner.parse_obj({
             "effect": obj.get("Effect"),
             "action": obj.get("Action"),
             "scope": obj.get("Scope")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/rate_limit.py` & `onelogin-3.1.5/onelogin/models/rate_limit.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt
@@ -28,14 +27,15 @@
     """
     x_rate_limit_limit: Optional[StrictInt] = Field(None, alias="X-RateLimit-Limit", description="Rate Limit Limit")
     x_rate_limit_remaining: Optional[StrictInt] = Field(None, alias="X-RateLimit-Remaining", description="Rate Limit Remaining")
     x_rate_limit_reset: Optional[StrictInt] = Field(None, alias="X-RateLimit-Reset", description="Rate Limit Reset")
     __properties = ["X-RateLimit-Limit", "X-RateLimit-Remaining", "X-RateLimit-Reset"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RateLimit:
         """Create an instance of RateLimit from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RateLimit.parse_obj(obj)
 
         _obj = RateLimit.parse_obj({
             "x_rate_limit_limit": obj.get("X-RateLimit-Limit"),
             "x_rate_limit_remaining": obj.get("X-RateLimit-Remaining"),
             "x_rate_limit_reset": obj.get("X-RateLimit-Reset")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/remove_role_users_request.py` & `onelogin-3.1.5/onelogin/models/remove_role_users_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, StrictInt, conlist
@@ -26,14 +25,15 @@
     """
     RemoveRoleUsersRequest
     """
     user_id: Optional[conlist(StrictInt)] = None
     __properties = ["user_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RemoveRoleUsersRequest:
         """Create an instance of RemoveRoleUsersRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RemoveRoleUsersRequest.parse_obj(obj)
 
         _obj = RemoveRoleUsersRequest.parse_obj({
             "user_id": obj.get("user_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/remove_user_role_request.py` & `onelogin-3.1.5/onelogin/models/remove_user_role_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List
 from pydantic import BaseModel, conlist
@@ -27,14 +26,15 @@
     """
     RemoveUserRoleRequest
     """
     role_id_array: conlist(RemoveUserRoleRequestRoleIdArrayInner) = ...
     __properties = ["role_id_array"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RemoveUserRoleRequest:
         """Create an instance of RemoveUserRoleRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RemoveUserRoleRequest.parse_obj(obj)
 
         _obj = RemoveUserRoleRequest.parse_obj({
             "role_id_array": [RemoveUserRoleRequestRoleIdArrayInner.from_dict(_item) for _item in obj.get("role_id_array")] if obj.get("role_id_array") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/remove_user_role_request_role_id_array_inner.py` & `onelogin-3.1.5/onelogin/models/remove_user_role_request_role_id_array_inner.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -26,14 +25,15 @@
     """
     RemoveUserRoleRequestRoleIdArrayInner
     """
     role_id: Optional[StrictInt] = None
     __properties = ["role_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RemoveUserRoleRequestRoleIdArrayInner:
         """Create an instance of RemoveUserRoleRequestRoleIdArrayInner from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RemoveUserRoleRequestRoleIdArrayInner.parse_obj(obj)
 
         _obj = RemoveUserRoleRequestRoleIdArrayInner.parse_obj({
             "role_id": obj.get("role_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/request_brand.py` & `onelogin-3.1.5/onelogin/models/request_brand.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
@@ -40,14 +39,15 @@
     hide_onelogin_footer: Optional[StrictBool] = Field(None, description="Indicates if the OneLogin footer will appear at the bottom of the login page.")
     mfa_enrollment_message: Optional[StrictStr] = Field(None, description="Text that replaces the default text displayed on the initial screen of the MFA Registration.")
     background: Optional[StrictStr] = Field(None, description="Base64 encoded image data (JPG/PNG, <5MB)")
     logo: Optional[StrictStr] = Field(None, description="Base64 encoded image data (PNG, <1MB)")
     __properties = ["enabled", "name", "custom_support_enabled", "custom_color", "custom_accent_color", "custom_masking_color", "custom_masking_opacity", "enable_custom_label_for_login_screen", "custom_label_text_for_login_screen", "login_instruction_title", "login_instruction", "hide_onelogin_footer", "mfa_enrollment_message", "background", "logo"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -70,15 +70,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RequestBrand:
         """Create an instance of RequestBrand from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RequestBrand.parse_obj(obj)
 
         _obj = RequestBrand.parse_obj({
             "enabled": obj.get("enabled") if obj.get("enabled") is not None else False,
             "name": obj.get("name"),
             "custom_support_enabled": obj.get("custom_support_enabled"),
             "custom_color": obj.get("custom_color"),
```

### Comparing `onelogin-3.1.4/onelogin/models/revoke_tokens_request.py` & `onelogin-3.1.5/onelogin/models/revoke_tokens_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +26,15 @@
     """
     RevokeTokensRequest
     """
     access_token: StrictStr = Field(..., description="Set to the access token you want to revoke. This access token must have been generated using the client_id and client_secret provided in the Authorization header.")
     __properties = ["access_token"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RevokeTokensRequest:
         """Create an instance of RevokeTokensRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RevokeTokensRequest.parse_obj(obj)
 
         _obj = RevokeTokensRequest.parse_obj({
             "access_token": obj.get("access_token")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/risk_device.py` & `onelogin-3.1.5/onelogin/models/risk_device.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     Information about the device being used.
     """
     id: Optional[StrictStr] = Field(None, description="This device's unique identifier")
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RiskDevice:
         """Create an instance of RiskDevice from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RiskDevice.parse_obj(obj)
 
         _obj = RiskDevice.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/risk_user.py` & `onelogin-3.1.5/onelogin/models/risk_user.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -28,14 +28,15 @@
     """
     id: StrictStr = Field(..., description="A unique identifier for the user.")
     name: Optional[StrictStr] = Field(None, description="A name for the user.")
     authenticated: Optional[StrictBool] = Field(False, description="Indicates if the metadata supplied in this event should be considered as trusted for the user.")
     __properties = ["id", "name", "authenticated"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RiskUser:
         """Create an instance of RiskUser from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RiskUser.parse_obj(obj)
 
         _obj = RiskUser.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "authenticated": obj.get("authenticated") if obj.get("authenticated") is not None else False
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/role.py` & `onelogin-3.1.5/onelogin/models/role.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
@@ -30,14 +29,15 @@
     name: StrictStr = Field(..., description="The name of the role.")
     apps: Optional[conlist(StrictInt)] = Field(None, description="A list of app IDs that will be assigned to the role.")
     users: Optional[conlist(StrictInt)] = Field(None, description="A list of user IDs to assign to the role.")
     admins: Optional[conlist(StrictInt)] = Field(None, description="A list of user IDs to assign as role administrators.")
     __properties = ["id", "name", "apps", "users", "admins"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +61,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Role:
         """Create an instance of Role from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Role.parse_obj(obj)
 
         _obj = Role.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "apps": obj.get("apps"),
             "users": obj.get("users"),
```

### Comparing `onelogin-3.1.4/onelogin/models/rule_action.py` & `onelogin-3.1.5/onelogin/models/rule_condition.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,64 +9,64 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
 
-class RuleAction(BaseModel):
+class RuleCondition(BaseModel):
     """
-    RuleAction
+    RuleCondition
     """
-    name: Optional[StrictStr] = Field(None, description="Name of the Action")
-    value: Optional[StrictStr] = Field(None, description="The unique identifier of the action. This should be used when defining actions for a User Mapping.")
+    name: Optional[StrictStr] = Field(None, description="Name of the operator")
+    value: Optional[StrictStr] = Field(None, description="The condition operator value to use when creating or updating rules.")
     __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RuleAction:
-        """Create an instance of RuleAction from a JSON string"""
+    def from_json(cls, json_str: str) -> RuleCondition:
+        """Create an instance of RuleCondition from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RuleAction:
-        """Create an instance of RuleAction from a dict"""
+    def from_dict(cls, obj: dict) -> RuleCondition:
+        """Create an instance of RuleCondition from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return RuleAction.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return RuleCondition.parse_obj(obj)
 
-        _obj = RuleAction.parse_obj({
+        _obj = RuleCondition.parse_obj({
             "name": obj.get("name"),
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/rule_condition.py` & `onelogin-3.1.5/onelogin/models/update_client_app_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,64 +9,62 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from typing import List, Optional
+from pydantic import BaseModel, Field, StrictInt, conlist
 
-class RuleCondition(BaseModel):
+class UpdateClientAppRequest(BaseModel):
     """
-    RuleCondition
+    UpdateClientAppRequest
     """
-    name: Optional[StrictStr] = Field(None, description="Name of the operator")
-    value: Optional[StrictStr] = Field(None, description="The condition operator value to use when creating or updating rules.")
-    __properties = ["name", "value"]
+    scopes: Optional[conlist(StrictInt)] = Field(None, description="An array of Scope IDs the scopes the app can request")
+    __properties = ["scopes"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RuleCondition:
-        """Create an instance of RuleCondition from a JSON string"""
+    def from_json(cls, json_str: str) -> UpdateClientAppRequest:
+        """Create an instance of UpdateClientAppRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RuleCondition:
-        """Create an instance of RuleCondition from a dict"""
+    def from_dict(cls, obj: dict) -> UpdateClientAppRequest:
+        """Create an instance of UpdateClientAppRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return RuleCondition.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return UpdateClientAppRequest.parse_obj(obj)
 
-        _obj = RuleCondition.parse_obj({
-            "name": obj.get("name"),
-            "value": obj.get("value")
+        _obj = UpdateClientAppRequest.parse_obj({
+            "scopes": obj.get("scopes")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_app.py` & `onelogin-3.1.5/onelogin/models/saml_app.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
@@ -50,14 +49,15 @@
     parameters: Optional[SamlAppAllOfParameters] = None
     enforcement_point: Optional[EnforcementPoint] = None
     configuration: Optional[ConfigurationSaml] = None
     sso: Optional[SsoSaml] = None
     __properties = ["id", "name", "visible", "description", "notes", "icon_url", "auth_method", "policy_id", "allow_assumed_signin", "tab_id", "connector_id", "created_at", "updated_at", "role_ids", "provisioning", "parameters", "enforcement_point", "configuration", "sso"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -96,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlApp:
         """Create an instance of SamlApp from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlApp.parse_obj(obj)
 
         _obj = SamlApp.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "visible": obj.get("visible"),
             "description": obj.get("description"),
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_app_all_of.py` & `onelogin-3.1.5/onelogin/models/saml_app_all_of.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -31,14 +30,15 @@
     """
     configuration: Optional[ConfigurationSaml] = None
     sso: Optional[SsoSaml] = None
     parameters: Optional[SamlAppAllOfParameters] = None
     __properties = ["configuration", "sso", "parameters"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -70,15 +70,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlAppAllOf:
         """Create an instance of SamlAppAllOf from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlAppAllOf.parse_obj(obj)
 
         _obj = SamlAppAllOf.parse_obj({
             "configuration": ConfigurationSaml.from_dict(obj.get("configuration")) if obj.get("configuration") is not None else None,
             "sso": SsoSaml.from_dict(obj.get("sso")) if obj.get("sso") is not None else None,
             "parameters": SamlAppAllOfParameters.from_dict(obj.get("parameters")) if obj.get("parameters") is not None else None
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_app_all_of_parameters.py` & `onelogin-3.1.5/onelogin/models/saml_app_all_of_parameters.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel
@@ -27,14 +26,15 @@
     """
     SamlAppAllOfParameters
     """
     saml_username: SamlAppAllOfParametersSamlUsername = ...
     __properties = ["saml_username"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlAppAllOfParameters:
         """Create an instance of SamlAppAllOfParameters from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlAppAllOfParameters.parse_obj(obj)
 
         _obj = SamlAppAllOfParameters.parse_obj({
             "saml_username": SamlAppAllOfParametersSamlUsername.from_dict(obj.get("saml_username")) if obj.get("saml_username") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_app_all_of_parameters_saml_username.py` & `onelogin-3.1.5/onelogin/models/saml_app_all_of_parameters_saml_username.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, StrictStr
@@ -26,14 +25,15 @@
     """
     SamlAppAllOfParametersSamlUsername
     """
     user_attribute_mappings: StrictStr = ...
     __properties = ["user_attribute_mappings"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlAppAllOfParametersSamlUsername:
         """Create an instance of SamlAppAllOfParametersSamlUsername from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlAppAllOfParametersSamlUsername.parse_obj(obj)
 
         _obj = SamlAppAllOfParametersSamlUsername.parse_obj({
             "user_attribute_mappings": obj.get("user_attribute_mappings")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_assert.py` & `onelogin-3.1.5/onelogin/models/saml_assert.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -30,14 +29,15 @@
     password: StrictStr = Field(..., description="Password of the OneLogin user accessing the app for which you want to generate a SAML token.")
     app_id: StrictStr = Field(..., description="App ID of the app for which you want to generate a SAML token. This is the app ID in OneLogin.")
     subdomain: StrictStr = Field(..., description="Set to the subdomain of the OneLogin user accessing the app for which you want to generate a SAML token.")
     ip_address: Optional[StrictStr] = Field(None, description="If you are using this API in a scenario in which MFA is required and youll need to be able to honor IP address whitelisting defined in MFA policies, provide this parameter and set its value to the whitelisted IP address that needs to be bypassed.")
     __properties = ["username_or_email", "password", "app_id", "subdomain", "ip_address"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlAssert:
         """Create an instance of SamlAssert from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlAssert.parse_obj(obj)
 
         _obj = SamlAssert.parse_obj({
             "username_or_email": obj.get("username_or_email"),
             "password": obj.get("password"),
             "app_id": obj.get("app_id"),
             "subdomain": obj.get("subdomain"),
```

### Comparing `onelogin-3.1.4/onelogin/models/saml_factor.py` & `onelogin-3.1.5/onelogin/models/saml_factor.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -30,14 +29,15 @@
     device_id: StrictStr = Field(..., description="Provide the MFA device_id you are submitting for verification. The device_id is supplied by the Generate SAML Assertion API.")
     state_token: StrictStr = Field(..., description="Provide the state_token associated with the MFA device_id you are submitting for verification. The state_token is supplied by the Generate SAML Assertion API.")
     otp_token: Optional[StrictStr] = Field(None, description="Provide the OTP value for the MFA factor you are submitting for verification. For some MFA factors; such as OneLogin OTP SMS, which requires the user to request an OTP; the otp_token value is not required, and if not included, returns a 200 OK - Pending result. Youll make a subsequent Verify Factor API call to provide the otp_token value once it has been provided to the user.")
     do_not_notify: Optional[StrictBool] = Field(None, description="When verifying MFA via Protect Push, set this to true to stop additional push notifications being sent to the OneLogin Protect device.")
     __properties = ["app_id", "device_id", "state_token", "otp_token", "do_not_notify"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SamlFactor:
         """Create an instance of SamlFactor from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SamlFactor.parse_obj(obj)
 
         _obj = SamlFactor.parse_obj({
             "app_id": obj.get("app_id"),
             "device_id": obj.get("device_id"),
             "state_token": obj.get("state_token"),
             "otp_token": obj.get("otp_token"),
```

### Comparing `onelogin-3.1.4/onelogin/models/scope.py` & `onelogin-3.1.5/onelogin/models/scope.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +28,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="Unique Scope ID value")
     value: Optional[StrictStr] = Field(None, description="Scope Value")
     description: Optional[StrictStr] = Field(None, description="Description of the scope")
     __properties = ["id", "value", "description"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Scope:
         """Create an instance of Scope from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Scope.parse_obj(obj)
 
         _obj = Scope.parse_obj({
             "id": obj.get("id"),
             "value": obj.get("value"),
             "description": obj.get("description")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/send_invite_link200_response.py` & `onelogin-3.1.5/onelogin/models/send_invite_link200_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel
@@ -27,14 +26,15 @@
     """
     SendInviteLink200Response
     """
     status: Optional[Error] = None
     __properties = ["status"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -60,15 +60,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SendInviteLink200Response:
         """Create an instance of SendInviteLink200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SendInviteLink200Response.parse_obj(obj)
 
         _obj = SendInviteLink200Response.parse_obj({
             "status": Error.from_dict(obj.get("status")) if obj.get("status") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/send_invite_link_request.py` & `onelogin-3.1.5/onelogin/models/send_invite_link_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     SendInviteLinkRequest
     """
     email: Optional[StrictStr] = Field(None, description="Set to the user email address to generate an invite link. The value is case sensitive.")
     personal_email: Optional[StrictStr] = Field(None, description="To send an invite email to a different address than the one provided in email, provide it here. The invite link is sent to this address instead.")
     __properties = ["email", "personal_email"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SendInviteLinkRequest:
         """Create an instance of SendInviteLinkRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SendInviteLinkRequest.parse_obj(obj)
 
         _obj = SendInviteLinkRequest.parse_obj({
             "email": obj.get("email"),
             "personal_email": obj.get("personal_email")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/session.py` & `onelogin-3.1.5/onelogin/models/session.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     A dictionary of extra information that provides useful context about the session, for example the session ID, or some cookie information.
     """
     id: Optional[StrictStr] = Field(None, description="If you use a database to track sessions, you can send us the session ID.")
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Session:
         """Create an instance of Session from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Session.parse_obj(obj)
 
         _obj = Session.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/set_user_state_request.py` & `onelogin-3.1.5/onelogin/models/set_user_state_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictInt, validator
@@ -26,20 +25,22 @@
     """
     SetUserStateRequest
     """
     state: StrictInt = Field(..., description="Set to the state value. Valid values include:   - 0 : Unapproved   - 1 : Approved   - 2 : Rejected   - 3 : Unlicensed")
     __properties = ["state"]
 
     @validator('state')
-    def state_validate_enum(cls, v):
-        if v not in (0, 1, 2, 3):
+    def state_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (0, 1, 2, 3):
             raise ValueError("must be one of enum values (0, 1, 2, 3)")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -62,15 +63,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SetUserStateRequest:
         """Create an instance of SetUserStateRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SetUserStateRequest.parse_obj(obj)
 
         _obj = SetUserStateRequest.parse_obj({
             "state": obj.get("state")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/source.py` & `onelogin-3.1.5/onelogin/models/sso_saml.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,64 +9,74 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
-from pydantic import BaseModel, Field, StrictStr
+from pydantic import BaseModel, StrictStr
+from onelogin.models.sso_saml_certificate import SsoSamlCertificate
 
-class Source(BaseModel):
+class SsoSaml(BaseModel):
     """
-    Used for targeting custom rules based on a group of people, customers, accounts, or even a single user.
+    SsoSaml
     """
-    id: Optional[StrictStr] = Field(None, description="A unique id that represents the source of the event.")
-    name: Optional[StrictStr] = Field(None, description="The name of the source")
-    __properties = ["id", "name"]
+    metadata_url: Optional[StrictStr] = None
+    acs_url: Optional[StrictStr] = None
+    sls_url: Optional[StrictStr] = None
+    issuer: Optional[StrictStr] = None
+    certificate: Optional[SsoSamlCertificate] = None
+    __properties = ["metadata_url", "acs_url", "sls_url", "issuer", "certificate"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> Source:
-        """Create an instance of Source from a JSON string"""
+    def from_json(cls, json_str: str) -> SsoSaml:
+        """Create an instance of SsoSaml from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
+        # override the default output from pydantic by calling `to_dict()` of certificate
+        if self.certificate:
+            _dict['certificate'] = self.certificate.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> Source:
-        """Create an instance of Source from a dict"""
+    def from_dict(cls, obj: dict) -> SsoSaml:
+        """Create an instance of SsoSaml from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return Source.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SsoSaml.parse_obj(obj)
 
-        _obj = Source.parse_obj({
-            "id": obj.get("id"),
-            "name": obj.get("name")
+        _obj = SsoSaml.parse_obj({
+            "metadata_url": obj.get("metadata_url"),
+            "acs_url": obj.get("acs_url"),
+            "sls_url": obj.get("sls_url"),
+            "issuer": obj.get("issuer"),
+            "certificate": SsoSamlCertificate.from_dict(obj.get("certificate")) if obj.get("certificate") is not None else None
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/sso_oidc.py` & `onelogin-3.1.5/onelogin/models/sso_oidc.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     SsoOidc
     """
     client_id: Optional[StrictStr] = Field(None, description="OIDC: The OpenId Connect Client Id.  Note that client_secret is only returned after Creating an App")
     __properties = ["client_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SsoOidc:
         """Create an instance of SsoOidc from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SsoOidc.parse_obj(obj)
 
         _obj = SsoOidc.parse_obj({
             "client_id": obj.get("client_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/sso_saml.py` & `onelogin-3.1.5/onelogin/models/error.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,74 +11,68 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
-from pydantic import BaseModel, StrictStr
-from onelogin.models.sso_saml_certificate import SsoSamlCertificate
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
 
-class SsoSaml(BaseModel):
+class Error(BaseModel):
     """
-    SsoSaml
+    Error
     """
-    metadata_url: Optional[StrictStr] = None
-    acs_url: Optional[StrictStr] = None
-    sls_url: Optional[StrictStr] = None
-    issuer: Optional[StrictStr] = None
-    certificate: Optional[SsoSamlCertificate] = None
-    __properties = ["metadata_url", "acs_url", "sls_url", "issuer", "certificate"]
+    error: Optional[StrictBool] = None
+    code: StrictInt = ...
+    type: Optional[StrictStr] = None
+    message: StrictStr = ...
+    __properties = ["error", "code", "type", "message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SsoSaml:
-        """Create an instance of SsoSaml from a JSON string"""
+    def from_json(cls, json_str: str) -> Error:
+        """Create an instance of Error from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of certificate
-        if self.certificate:
-            _dict['certificate'] = self.certificate.to_dict()
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SsoSaml:
-        """Create an instance of SsoSaml from a dict"""
+    def from_dict(cls, obj: dict) -> Error:
+        """Create an instance of Error from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SsoSaml.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return Error.parse_obj(obj)
 
-        _obj = SsoSaml.parse_obj({
-            "metadata_url": obj.get("metadata_url"),
-            "acs_url": obj.get("acs_url"),
-            "sls_url": obj.get("sls_url"),
-            "issuer": obj.get("issuer"),
-            "certificate": SsoSamlCertificate.from_dict(obj.get("certificate")) if obj.get("certificate") is not None else None
+        _obj = Error.parse_obj({
+            "error": obj.get("error"),
+            "code": obj.get("code"),
+            "type": obj.get("type"),
+            "message": obj.get("message")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/sso_saml_certificate.py` & `onelogin-3.1.5/onelogin/models/sso_saml_certificate.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictInt] = Field(None, description="SAML Certificate ID")
     name: Optional[StrictStr] = Field(None, description="SAML Certificate Name")
     value: Optional[StrictStr] = Field(None, description="SAML Certificate Value")
     __properties = ["id", "name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SsoSamlCertificate:
         """Create an instance of SsoSamlCertificate from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SsoSamlCertificate.parse_obj(obj)
 
         _obj = SsoSamlCertificate.parse_obj({
             "id": obj.get("id"),
             "name": obj.get("name"),
             "value": obj.get("value")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/token_claim.py` & `onelogin-3.1.5/onelogin/models/token_claim.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
@@ -34,14 +33,15 @@
     skip_if_blank: Optional[StrictBool] = Field(None, description="not used")
     values: Optional[conlist(StrictStr)] = Field(None, description="Relates to Rules/Entitlements. Not supported yet.")
     default_values: Optional[StrictStr] = Field(None, description="Relates to Rules/Entitlements. Not supported yet.")
     provisioned_entitlements: Optional[StrictBool] = Field(None, description="Relates to Rules/Entitlements. Not supported yet.")
     __properties = ["id", "label", "user_attribute_mappings", "user_attribute_macros", "attribute_transformations", "skip_if_blank", "values", "default_values", "provisioned_entitlements"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +64,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> TokenClaim:
         """Create an instance of TokenClaim from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return TokenClaim.parse_obj(obj)
 
         _obj = TokenClaim.parse_obj({
             "id": obj.get("id"),
             "label": obj.get("label"),
             "user_attribute_mappings": obj.get("user_attribute_mappings"),
             "user_attribute_macros": obj.get("user_attribute_macros"),
```

### Comparing `onelogin-3.1.4/onelogin/models/track_risk_event_request.py` & `onelogin-3.1.5/onelogin/models/track_risk_event_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -38,14 +37,15 @@
     session: Optional[Session] = None
     device: Optional[RiskDevice] = None
     fp: Optional[StrictStr] = Field(None, description="Set to the value of the __tdli_fp cookie.")
     published: Optional[StrictStr] = Field(None, description="Date and time of the event in IS08601 format. Useful for preloading old events. Defaults to date time this API request is received.")
     __properties = ["verb", "ip", "user_agent", "user", "source", "session", "device", "fp", "published"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -80,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> TrackRiskEventRequest:
         """Create an instance of TrackRiskEventRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return TrackRiskEventRequest.parse_obj(obj)
 
         _obj = TrackRiskEventRequest.parse_obj({
             "verb": obj.get("verb"),
             "ip": obj.get("ip"),
             "user_agent": obj.get("user_agent"),
             "user": RiskUser.from_dict(obj.get("user")) if obj.get("user") is not None else None,
```

### Comparing `onelogin-3.1.4/onelogin/models/update_client_app_request.py` & `onelogin-3.1.5/onelogin/models/verify_user_registration_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,62 +9,62 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
-from typing import List, Optional
-from pydantic import BaseModel, Field, StrictInt, conlist
+from typing import Optional
+from pydantic import BaseModel, Field, StrictInt
 
-class UpdateClientAppRequest(BaseModel):
+class VerifyUserRegistrationRequest(BaseModel):
     """
-    UpdateClientAppRequest
+    VerifyUserRegistrationRequest
     """
-    scopes: Optional[conlist(StrictInt)] = Field(None, description="An array of Scope IDs the scopes the app can request")
-    __properties = ["scopes"]
+    otp: Optional[StrictInt] = Field(None, description="One-Time-Password (OTP) that was sent to the user based on the chosen factor. OneLogin SMS and OneLogin Email support this OTP code.")
+    __properties = ["otp"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> UpdateClientAppRequest:
-        """Create an instance of UpdateClientAppRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> VerifyUserRegistrationRequest:
+        """Create an instance of VerifyUserRegistrationRequest from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> UpdateClientAppRequest:
-        """Create an instance of UpdateClientAppRequest from a dict"""
+    def from_dict(cls, obj: dict) -> VerifyUserRegistrationRequest:
+        """Create an instance of VerifyUserRegistrationRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return UpdateClientAppRequest.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VerifyUserRegistrationRequest.parse_obj(obj)
 
-        _obj = UpdateClientAppRequest.parse_obj({
-            "scopes": obj.get("scopes")
+        _obj = VerifyUserRegistrationRequest.parse_obj({
+            "otp": obj.get("otp")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/update_environment_variable_request.py` & `onelogin-3.1.5/onelogin/models/update_environment_variable_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     UpdateEnvironmentVariableRequest
     """
     value: StrictStr = Field(..., description="The secret value that will be encrypted at rest and injected in applicable hook functions at run time.")
     __properties = ["value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdateEnvironmentVariableRequest:
         """Create an instance of UpdateEnvironmentVariableRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdateEnvironmentVariableRequest.parse_obj(obj)
 
         _obj = UpdateEnvironmentVariableRequest.parse_obj({
             "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/update_password_insecure_request.py` & `onelogin-3.1.5/onelogin/models/update_password_insecure_request.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictBool, StrictStr
@@ -28,14 +27,15 @@
     """
     password: StrictStr = Field(..., description="Set to the password value using cleartext. Hashes are never stored as cleartext. They are stored securely using cryptographic hash. OneLogin continuously upgrades the strength of the hash. Ensure that the value meets the password strength requirements set for the account.")
     password_confirmation: StrictStr = Field(..., description="Ensure that this value matches the password value exactly.")
     validate_policy: Optional[StrictBool] = Field(False, description="Will passwords validate against the User Policy. Defaults to false.")
     __properties = ["password", "password_confirmation", "validate_policy"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdatePasswordInsecureRequest:
         """Create an instance of UpdatePasswordInsecureRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdatePasswordInsecureRequest.parse_obj(obj)
 
         _obj = UpdatePasswordInsecureRequest.parse_obj({
             "password": obj.get("password"),
             "password_confirmation": obj.get("password_confirmation"),
             "validate_policy": obj.get("validate_policy") if obj.get("validate_policy") is not None else False
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/update_password_secure_request.py` & `onelogin-3.1.5/onelogin/models/update_password_secure_request.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -29,14 +28,15 @@
     password: StrictStr = Field(..., description="Set to the password value using a SHA-256-encoded value. If you are including your own password_salt value in your request, prepend the salt value to the cleartext password value before SHA-256-encoding it. For example, if your salt value is hello and your cleartext password value is password, the value you need to SHA-256-encode is hellopassword. The resulting encoded value would be b1c788abac15390de987ad17b65ac73c9b475d428a51f245c645a442fddd078b. Note that the alpha characters in this has must all be lower case.")
     password_confirmation: StrictStr = Field(..., description="This value must match the password value.")
     password_algorithm: StrictStr = Field(..., description="Set to salt+sha256.")
     password_salt: Optional[StrictStr] = Field(None, description="Optional. If your password hash has been salted then you can provide the salt used in this param. This assumes that the salt was prepended to the password before doing the SHA256 hash. The API supports a salt value that is up to 40 characters long.")
     __properties = ["password", "password_confirmation", "password_algorithm", "password_salt"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -59,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdatePasswordSecureRequest:
         """Create an instance of UpdatePasswordSecureRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdatePasswordSecureRequest.parse_obj(obj)
 
         _obj = UpdatePasswordSecureRequest.parse_obj({
             "password": obj.get("password"),
             "password_confirmation": obj.get("password_confirmation"),
             "password_algorithm": obj.get("password_algorithm"),
             "password_salt": obj.get("password_salt")
```

### Comparing `onelogin-3.1.4/onelogin/models/update_privilege200_response.py` & `onelogin-3.1.5/onelogin/models/update_privilege200_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +10,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +26,15 @@
     """
     UpdatePrivilege200Response
     """
     id: Optional[StrictStr] = Field(None, description="Privilege ID")
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdatePrivilege200Response:
         """Create an instance of UpdatePrivilege200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdatePrivilege200Response.parse_obj(obj)
 
         _obj = UpdatePrivilege200Response.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/update_risk_rule_request.py` & `onelogin-3.1.5/onelogin/models/update_risk_rule_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -26,14 +25,15 @@
     """
     UpdateRiskRuleRequest
     """
     id: Optional[StrictStr] = Field(None, description="The ID of the Rule to Update")
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdateRiskRuleRequest:
         """Create an instance of UpdateRiskRuleRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdateRiskRuleRequest.parse_obj(obj)
 
         _obj = UpdateRiskRuleRequest.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/update_role200_response.py` & `onelogin-3.1.5/onelogin/models/update_role200_response.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, StrictInt
@@ -26,14 +25,15 @@
     """
     UpdateRole200Response
     """
     id: Optional[StrictInt] = None
     __properties = ["id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -56,15 +56,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> UpdateRole200Response:
         """Create an instance of UpdateRole200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return UpdateRole200Response.parse_obj(obj)
 
         _obj = UpdateRole200Response.parse_obj({
             "id": obj.get("id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/user.py` & `onelogin-3.1.5/onelogin/models/user.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import List, Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, validator
@@ -61,30 +60,35 @@
     password: Optional[StrictStr] = Field(None, description="The password to set for a user.")
     password_confirmation: Optional[StrictStr] = Field(None, description="Required if the password is being set.")
     password_algorithm: Optional[StrictStr] = Field(None, description="Use this when importing a password that's already hashed. Prepend the salt value to the cleartext password value before SHA-256-encoding it")
     salt: Optional[StrictStr] = Field(None, description="The salt value used with the password_algorithm.")
     __properties = ["id", "username", "email", "firstname", "lastname", "title", "department", "company", "comment", "group_id", "role_ids", "phone", "state", "status", "directory_id", "trusted_idp_id", "manager_ad_id", "manager_user_id", "samaccountname", "member_of", "userprincipalname", "distinguished_name", "external_id", "activated_at", "last_login", "invitation_sent_at", "updated_at", "preferred_locale_code", "created_at", "invalid_login_attempts", "locked_until", "password_changed_at", "password", "password_confirmation", "password_algorithm", "salt"]
 
     @validator('state')
-    def state_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (0, 1, 2, 3):
+    def state_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (0, 1, 2, 3):
             raise ValueError("must be one of enum values (0, 1, 2, 3)")
-        return v
+        return value
 
     @validator('status')
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (0, 1, 2, 3, 4, 5, 7, 8):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (0, 1, 2, 3, 4, 5, 7, 8):
             raise ValueError("must be one of enum values (0, 1, 2, 3, 4, 5, 7, 8)")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -107,15 +111,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> User:
         """Create an instance of User from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return User.parse_obj(obj)
 
         _obj = User.parse_obj({
             "id": obj.get("id"),
             "username": obj.get("username"),
             "email": obj.get("email"),
             "firstname": obj.get("firstname"),
```

### Comparing `onelogin-3.1.4/onelogin/models/ver_factor_saml200_response.py` & `onelogin-3.1.5/onelogin/models/ver_factor_saml200_response.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,7 +1,9 @@
+
+
 # coding: utf-8
 
 """
     OneLogin API
 
     OpenAPI Specification for OneLogin  # noqa: E501
 
@@ -9,15 +11,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +28,15 @@
     VerFactorSaml200Response
     """
     data: Optional[StrictStr] = Field(None, description="Provides the SAML assertion.")
     message: Optional[StrictStr] = Field(None, description="Plain text description describing the outcome of the response.")
     __properties = ["data", "message"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +59,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VerFactorSaml200Response:
         """Create an instance of VerFactorSaml200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VerFactorSaml200Response.parse_obj(obj)
 
         _obj = VerFactorSaml200Response.parse_obj({
             "data": obj.get("data"),
             "message": obj.get("message")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/verb.py` & `onelogin-3.1.5/onelogin/models/verb.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,15 +8,15 @@
     The version of the OpenAPI document: 3.1.1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
-from inspect import getfullargspec
+import json
 import pprint
 import re  # noqa: F401
 from aenum import Enum, no_arg
 
 
 
 
@@ -32,7 +32,13 @@
     LOG_MINUS_IN = 'log-in'
     LOG_MINUS_OUT = 'log-out'
     LOG_MINUS_IN_MINUS_DENIED = 'log-in-denied'
     AUTHENTICATION_MINUS_CHALLENGE = 'authentication-challenge'
     AUTHENTICATION_MINUS_CHALLENGE_MINUS_PASS = 'authentication-challenge-pass'
     AUTHENTICATION_MINUS_CHALLENGE_MINUS_FAIL = 'authentication-challenge-fail'
 
+    @classmethod
+    def from_json(cls, json_str: str) -> Verb:
+        """Create an instance of Verb from a JSON string"""
+        return Verb(json.loads(json_str))
+
+
```

### Comparing `onelogin-3.1.4/onelogin/models/verify_mfa_factor_request.py` & `onelogin-3.1.5/onelogin/models/verify_mfa_factor_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -27,14 +26,15 @@
     VerifyMfaFactorRequest
     """
     state_token: Optional[StrictStr] = Field(None, description="The state_token is returned after a successful request to Enroll a Factor or Activate a Factor. The state_token MUST be provided if the needs_trigger attribute from the proceeding calls is set to true. Note that the state_token expires 120 seconds after creation. If the token is expired you will need to Activate the Factor again.")
     otp_token: Optional[StrictStr] = Field(None, description="OTP code provided by the device or SMS message sent to user. When a device like OneLogin Protect that supports Push has been used you do not need to provide the otp_token and can keep polling this endpoint until the state_token expires.")
     __properties = ["state_token", "otp_token"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VerifyMfaFactorRequest:
         """Create an instance of VerifyMfaFactorRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VerifyMfaFactorRequest.parse_obj(obj)
 
         _obj = VerifyMfaFactorRequest.parse_obj({
             "state_token": obj.get("state_token"),
             "otp_token": obj.get("otp_token")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/verify_user_registration200_response.py` & `onelogin-3.1.5/onelogin/models/verify_user_registration200_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictStr
@@ -28,14 +27,15 @@
     """
     id: Optional[StrictStr] = Field(None, description="Registration identifier.")
     status: Optional[StrictStr] = Field(None, description="pending registration has not been completed successfully. accepted registration has successfully completed.")
     device_id: Optional[StrictStr] = Field(None, description="Device id to be used with Verify the Factor.")
     __properties = ["id", "status", "device_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,15 +58,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VerifyUserRegistration200Response:
         """Create an instance of VerifyUserRegistration200Response from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VerifyUserRegistration200Response.parse_obj(obj)
 
         _obj = VerifyUserRegistration200Response.parse_obj({
             "id": obj.get("id"),
             "status": obj.get("status"),
             "device_id": obj.get("device_id")
         })
```

### Comparing `onelogin-3.1.4/onelogin/models/verify_user_registration_request.py` & `onelogin-3.1.5/onelogin/models/rule_action.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,62 +9,64 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
-from pydantic import BaseModel, Field, StrictInt
+from pydantic import BaseModel, Field, StrictStr
 
-class VerifyUserRegistrationRequest(BaseModel):
+class RuleAction(BaseModel):
     """
-    VerifyUserRegistrationRequest
+    RuleAction
     """
-    otp: Optional[StrictInt] = Field(None, description="One-Time-Password (OTP) that was sent to the user based on the chosen factor. OneLogin SMS and OneLogin Email support this OTP code.")
-    __properties = ["otp"]
+    name: Optional[StrictStr] = Field(None, description="Name of the Action")
+    value: Optional[StrictStr] = Field(None, description="The unique identifier of the action. This should be used when defining actions for a User Mapping.")
+    __properties = ["name", "value"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VerifyUserRegistrationRequest:
-        """Create an instance of VerifyUserRegistrationRequest from a JSON string"""
+    def from_json(cls, json_str: str) -> RuleAction:
+        """Create an instance of RuleAction from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True,
                           exclude={
                           },
                           exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VerifyUserRegistrationRequest:
-        """Create an instance of VerifyUserRegistrationRequest from a dict"""
+    def from_dict(cls, obj: dict) -> RuleAction:
+        """Create an instance of RuleAction from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VerifyUserRegistrationRequest.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return RuleAction.parse_obj(obj)
 
-        _obj = VerifyUserRegistrationRequest.parse_obj({
-            "otp": obj.get("otp")
+        _obj = RuleAction.parse_obj({
+            "name": obj.get("name"),
+            "value": obj.get("value")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/models/verify_user_verification_request.py` & `onelogin-3.1.5/onelogin/models/verify_user_verification_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,14 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """
 
 
 from __future__ import annotations
-from inspect import getfullargspec
 import pprint
 import re  # noqa: F401
 import json
 
 
 from typing import Optional
 from pydantic import BaseModel, Field, StrictInt, StrictStr
@@ -27,14 +26,15 @@
     VerifyUserVerificationRequest
     """
     otp: Optional[StrictStr] = Field(None, description="OTP code provided by the device or SMS message sent to user.")
     device_id: Optional[StrictInt] = Field(None, description="ID of the specified device which has been registerd for the given user. Available on Get Devices API call.")
     __properties = ["otp", "device_id"]
 
     class Config:
+        """Pydantic configuration"""
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,15 +57,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VerifyUserVerificationRequest:
         """Create an instance of VerifyUserVerificationRequest from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VerifyUserVerificationRequest.parse_obj(obj)
 
         _obj = VerifyUserVerificationRequest.parse_obj({
             "otp": obj.get("otp"),
             "device_id": obj.get("device_id")
         })
         return _obj
```

### Comparing `onelogin-3.1.4/onelogin/rest.py` & `onelogin-3.1.5/onelogin/rest.py`

 * *Files 2% similar despite different names*

```diff
@@ -62,14 +62,18 @@
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
             addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
 
         if configuration.retries is not None:
             addition_pool_args['retries'] = configuration.retries
 
+        if configuration.tls_server_name:
+            addition_pool_args['server_hostname'] = configuration.tls_server_name
+
+
         if configuration.socket_options is not None:
             addition_pool_args['socket_options'] = configuration.socket_options
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
```

### Comparing `onelogin-3.1.4/onelogin.egg-info/SOURCES.txt` & `onelogin-3.1.5/onelogin.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 README.md
 pyproject.toml
 setup.cfg
 setup.py
 onelogin/__init__.py
 onelogin/api_client.py
+onelogin/api_response.py
 onelogin/configuration.py
 onelogin/exceptions.py
 onelogin/rest.py
 onelogin.egg-info/PKG-INFO
 onelogin.egg-info/SOURCES.txt
 onelogin.egg-info/dependency_links.txt
 onelogin.egg-info/requires.txt
@@ -134,14 +135,15 @@
 onelogin/models/list_mapping_action_values200_response_inner.py
 onelogin/models/list_mapping_conditions200_response.py
 onelogin/models/list_mapping_conditions_operators200_response_inner.py
 onelogin/models/list_mapping_contion_values200_response_inner.py
 onelogin/models/list_mappings_actions200_response_inner.py
 onelogin/models/list_message_templates200_response_inner.py
 onelogin/models/list_privelege_roles200_response.py
+onelogin/models/list_privilege_roles200_response.py
 onelogin/models/locale.py
 onelogin/models/lock_account_user_request.py
 onelogin/models/mapping.py
 onelogin/models/message_template.py
 onelogin/models/message_template_template.py
 onelogin/models/message_template_template_one_of.py
 onelogin/models/message_template_template_one_of1.py
@@ -304,14 +306,15 @@
 test/test_list_mapping_action_values200_response_inner.py
 test/test_list_mapping_conditions200_response.py
 test/test_list_mapping_conditions_operators200_response_inner.py
 test/test_list_mapping_contion_values200_response_inner.py
 test/test_list_mappings_actions200_response_inner.py
 test/test_list_message_templates200_response_inner.py
 test/test_list_privelege_roles200_response.py
+test/test_list_privilege_roles200_response.py
 test/test_locale.py
 test/test_lock_account_user_request.py
 test/test_mapping.py
 test/test_message_template.py
 test/test_message_template_template.py
 test/test_message_template_template_one_of.py
 test/test_message_template_template_one_of1.py
```

### Comparing `onelogin-3.1.4/test/test_action_obj.py` & `onelogin-3.1.5/test/test_action_obj.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_activate_mfa_factors_request.py` & `onelogin-3.1.5/test/test_activate_mfa_factors_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_add_client_app201_response.py` & `onelogin-3.1.5/test/test_add_client_app201_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_add_client_app_request.py` & `onelogin-3.1.5/test/test_add_client_app_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_add_privilege_to_role201_response.py` & `onelogin-3.1.5/test/test_add_privilege_to_role201_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_add_privilege_to_role_request.py` & `onelogin-3.1.5/test/test_add_privilege_to_role_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_add_roles_to_user_request.py` & `onelogin-3.1.5/test/test_add_roles_to_user_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_alt_err.py` & `onelogin-3.1.5/test/test_alt_err.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_api_auth_claims_api.py` & `onelogin-3.1.5/test/test_api_auth_claims_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_api_auth_client_apps_api.py` & `onelogin-3.1.5/test/test_api_auth_client_apps_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_api_auth_scopes_api.py` & `onelogin-3.1.5/test/test_api_auth_scopes_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_api_authorization_server_api.py` & `onelogin-3.1.5/test/test_api_authorization_server_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_app_parameters.py` & `onelogin-3.1.5/test/test_app_parameters.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_app_rule.py` & `onelogin-3.1.5/test/test_app_rule.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_app_rules_api.py` & `onelogin-3.1.5/test/test_app_rules_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_apps_api.py` & `onelogin-3.1.5/test/test_apps_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_assign_users_to_privilege_request.py` & `onelogin-3.1.5/test/test_assign_users_to_privilege_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_claim.py` & `onelogin-3.1.5/test/test_auth_claim.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_id.py` & `onelogin-3.1.5/test/test_auth_id.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_method.py` & `onelogin-3.1.5/test/test_auth_method.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_scope.py` & `onelogin-3.1.5/test/test_auth_scope.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_server.py` & `onelogin-3.1.5/test/test_auth_server.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_auth_server_configuration.py` & `onelogin-3.1.5/test/test_auth_server_configuration.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand.py` & `onelogin-3.1.5/test/test_brand.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_app.py` & `onelogin-3.1.5/test/test_brand_app.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_background.py` & `onelogin-3.1.5/test/test_brand_background.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_background_urls.py` & `onelogin-3.1.5/test/test_brand_background_urls.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_logo.py` & `onelogin-3.1.5/test/test_brand_logo.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_logo_urls.py` & `onelogin-3.1.5/test/test_brand_logo_urls.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_brand_req.py` & `onelogin-3.1.5/test/test_brand_req.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_branding_service_api.py` & `onelogin-3.1.5/test/test_branding_service_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_branding_service_smtp_api.py` & `onelogin-3.1.5/test/test_branding_service_smtp_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_branding_service_templates_api.py` & `onelogin-3.1.5/test/test_branding_service_templates_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_client_app_full.py` & `onelogin-3.1.5/test/test_client_app_full.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_clock_counter.py` & `onelogin-3.1.5/test/test_clock_counter.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_condition.py` & `onelogin-3.1.5/test/test_condition.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_configuration_oidc.py` & `onelogin-3.1.5/test/test_configuration_oidc.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_configuration_saml.py` & `onelogin-3.1.5/test/test_configuration_saml.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_connector.py` & `onelogin-3.1.5/test/test_connector.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_app200_response.py` & `onelogin-3.1.5/test/test_create_app200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_app_request.py` & `onelogin-3.1.5/test/test_create_app_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_device_verification201_response.py` & `onelogin-3.1.5/test/test_create_device_verification201_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_device_verification_request.py` & `onelogin-3.1.5/test/test_create_device_verification_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_factor_registration201_response.py` & `onelogin-3.1.5/test/test_create_factor_registration201_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_factor_registration_request.py` & `onelogin-3.1.5/test/test_create_factor_registration_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_privilege200_response.py` & `onelogin-3.1.5/test/test_create_privilege200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_create_role201_response_inner.py` & `onelogin-3.1.5/test/test_create_role201_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_device.py` & `onelogin-3.1.5/test/test_device.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_email_config.py` & `onelogin-3.1.5/test/test_email_config.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_enforcement_point.py` & `onelogin-3.1.5/test/test_enforcement_point.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_enforcement_point_resources_inner.py` & `onelogin-3.1.5/test/test_enforcement_point_resources_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_enroll_mfa_factor200_response.py` & `onelogin-3.1.5/test/test_enroll_mfa_factor200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_error.py` & `onelogin-3.1.5/test/test_error.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_event.py` & `onelogin-3.1.5/test/test_event.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_events_api.py` & `onelogin-3.1.5/test/test_events_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_mf_atoken200_response.py` & `onelogin-3.1.5/test/test_generate_mf_atoken200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_mf_atoken_request.py` & `onelogin-3.1.5/test/test_generate_mf_atoken_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_otp201_response.py` & `onelogin-3.1.5/test/test_generate_otp201_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_otp_request.py` & `onelogin-3.1.5/test/test_generate_otp_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_saml_assert200_response.py` & `onelogin-3.1.5/test/test_generate_saml_assert200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generate_token_request.py` & `onelogin-3.1.5/test/test_generate_token_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generic_app.py` & `onelogin-3.1.5/test/test_generic_app.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_generic_app_provisioning.py` & `onelogin-3.1.5/test/test_generic_app_provisioning.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_assigned_user200_response.py` & `onelogin-3.1.5/test/test_get_assigned_user200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_auth_factors200_response.py` & `onelogin-3.1.5/test/test_get_auth_factors200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_authentication_devices200_response_inner.py` & `onelogin-3.1.5/test/test_get_authentication_devices200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_custom_attributes200_response.py` & `onelogin-3.1.5/test/test_get_custom_attributes200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_email_settings200_response.py` & `onelogin-3.1.5/test/test_get_email_settings200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_email_settings200_response_one_of.py` & `onelogin-3.1.5/test/test_get_email_settings200_response_one_of.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_enrolled_factors200_response.py` & `onelogin-3.1.5/test/test_get_enrolled_factors200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_enrolled_factors200_response_data.py` & `onelogin-3.1.5/test/test_get_enrolled_factors200_response_data.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_enrolled_factors200_response_data_otp_devices_inner.py` & `onelogin-3.1.5/test/test_get_enrolled_factors200_response_data_otp_devices_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_event_by_id200_response.py` & `onelogin-3.1.5/test/test_get_event_by_id200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_event_types200_response.py` & `onelogin-3.1.5/test/test_get_event_types200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_event_types200_response_data_inner.py` & `onelogin-3.1.5/test/test_get_event_types200_response_data_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_events200_response.py` & `onelogin-3.1.5/test/test_get_events200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_events200_response_pagination.py` & `onelogin-3.1.5/test/test_get_events200_response_pagination.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_groups200_response.py` & `onelogin-3.1.5/test/test_get_groups200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_invite_link200_response.py` & `onelogin-3.1.5/test/test_get_invite_link200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_invite_link_request.py` & `onelogin-3.1.5/test/test_get_invite_link_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_mfa_factors200_response.py` & `onelogin-3.1.5/test/test_get_mfa_factors200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_mfa_factors200_response_data.py` & `onelogin-3.1.5/test/test_get_mfa_factors200_response_data.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_mfa_factors200_response_data_auth_factors_inner.py` & `onelogin-3.1.5/test/test_get_mfa_factors200_response_data_auth_factors_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_rate_limit200_response.py` & `onelogin-3.1.5/test/test_get_rate_limit200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_risk_score200_response.py` & `onelogin-3.1.5/test/test_get_risk_score200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_risk_score_request.py` & `onelogin-3.1.5/test/test_get_risk_score_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_risk_scores200_response.py` & `onelogin-3.1.5/test/test_get_risk_scores200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_risk_scores200_response_scores.py` & `onelogin-3.1.5/test/test_get_risk_scores200_response_scores.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_apps200_response_inner.py` & `onelogin-3.1.5/test/test_get_role_apps200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_by_id200_response.py` & `onelogin-3.1.5/test/test_get_role_by_id200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_by_id200_response_data_inner.py` & `onelogin-3.1.5/test/test_get_role_by_id200_response_data_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_by_name200_response.py` & `onelogin-3.1.5/test/test_get_role_by_name200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_by_name200_response_data_inner.py` & `onelogin-3.1.5/test/test_get_role_by_name200_response_data_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_role_by_name200_response_pagination.py` & `onelogin-3.1.5/test/test_get_role_by_name200_response_pagination.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_user_apps200_response_inner.py` & `onelogin-3.1.5/test/test_get_user_apps200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_user_roles200_response.py` & `onelogin-3.1.5/test/test_get_user_roles200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_get_user_verification200_response.py` & `onelogin-3.1.5/test/test_get_user_verification200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_group.py` & `onelogin-3.1.5/test/test_group.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_groups_api.py` & `onelogin-3.1.5/test/test_groups_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_hook.py` & `onelogin-3.1.5/test/test_hook.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_hook_envvar.py` & `onelogin-3.1.5/test/test_hook_envvar.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_hook_log.py` & `onelogin-3.1.5/test/test_hook_log.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_hook_options.py` & `onelogin-3.1.5/test/test_hook_options.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_hook_status.py` & `onelogin-3.1.5/test/test_hook_status.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_invite_links_api.py` & `onelogin-3.1.5/test/test_invite_links_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_conditions200_response_inner.py` & `onelogin-3.1.5/test/test_list_conditions200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_mapping_action_values200_response_inner.py` & `onelogin-3.1.5/test/test_list_mapping_action_values200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_mapping_conditions200_response.py` & `onelogin-3.1.5/test/test_list_mapping_conditions200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_mapping_conditions_operators200_response_inner.py` & `onelogin-3.1.5/test/test_list_mapping_conditions_operators200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_mapping_contion_values200_response_inner.py` & `onelogin-3.1.5/test/test_list_mapping_contion_values200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_mappings_actions200_response_inner.py` & `onelogin-3.1.5/test/test_list_mappings_actions200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_message_templates200_response_inner.py` & `onelogin-3.1.5/test/test_list_message_templates200_response_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_list_privelege_roles200_response.py` & `onelogin-3.1.5/test/test_list_privelege_roles200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_locale.py` & `onelogin-3.1.5/test/test_locale.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_lock_account_user_request.py` & `onelogin-3.1.5/test/test_lock_account_user_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_mapping.py` & `onelogin-3.1.5/test/test_mapping.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_message_template.py` & `onelogin-3.1.5/test/test_message_template.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_message_template_template.py` & `onelogin-3.1.5/test/test_message_template_template.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_message_template_template_one_of.py` & `onelogin-3.1.5/test/test_message_template_template_one_of.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_message_template_template_one_of1.py` & `onelogin-3.1.5/test/test_message_template_template_one_of1.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_multi_factor_authentication_api.py` & `onelogin-3.1.5/test/test_multi_factor_authentication_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_multi_factor_authentication_v1_api.py` & `onelogin-3.1.5/test/test_multi_factor_authentication_v1_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_o_auth2_api.py` & `onelogin-3.1.5/test/test_o_auth2_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_oauth_token.py` & `onelogin-3.1.5/test/test_oauth_token.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_oidc_app.py` & `onelogin-3.1.5/test/test_oidc_app.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_oidc_app_all_of.py` & `onelogin-3.1.5/test/test_oidc_app_all_of.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_otp_device.py` & `onelogin-3.1.5/test/test_otp_device.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_privilege.py` & `onelogin-3.1.5/test/test_privilege.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_privilege_privilege.py` & `onelogin-3.1.5/test/test_privilege_privilege.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_privilege_privilege_statement_inner.py` & `onelogin-3.1.5/test/test_privilege_privilege_statement_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_privileges_api.py` & `onelogin-3.1.5/test/test_privileges_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -73,23 +73,23 @@
     def test_get_privilege(self):
         """Test case for get_privilege
 
         Get a Privilege  # noqa: E501
         """
         pass
 
-    def test_list_privelege_roles(self):
-        """Test case for list_privelege_roles
+    def test_list_privilege_roles(self):
+        """Test case for list_privilege_roles
 
         Get Roles assigned to Privilege  # noqa: E501
         """
         pass
 
-    def test_list_priveleges(self):
-        """Test case for list_priveleges
+    def test_list_privileges(self):
+        """Test case for list_privileges
 
         List Privileges  # noqa: E501
         """
         pass
 
     def test_remove_user_from_privilege(self):
         """Test case for remove_user_from_privilege
```

### Comparing `onelogin-3.1.4/test/test_rate_limit.py` & `onelogin-3.1.5/test/test_rate_limit.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_remove_role_users_request.py` & `onelogin-3.1.5/test/test_remove_role_users_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_remove_user_role_request.py` & `onelogin-3.1.5/test/test_remove_user_role_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_remove_user_role_request_role_id_array_inner.py` & `onelogin-3.1.5/test/test_remove_user_role_request_role_id_array_inner.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_request_brand.py` & `onelogin-3.1.5/test/test_request_brand.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_revoke_tokens_request.py` & `onelogin-3.1.5/test/test_revoke_tokens_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_risk_device.py` & `onelogin-3.1.5/test/test_risk_device.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_risk_rule.py` & `onelogin-3.1.5/test/test_risk_rule.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_risk_user.py` & `onelogin-3.1.5/test/test_risk_user.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_role.py` & `onelogin-3.1.5/test/test_role.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_roles_api.py` & `onelogin-3.1.5/test/test_roles_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_rule_action.py` & `onelogin-3.1.5/test/test_rule_action.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_rule_condition.py` & `onelogin-3.1.5/test/test_rule_condition.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_app.py` & `onelogin-3.1.5/test/test_saml_app.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_app_all_of.py` & `onelogin-3.1.5/test/test_saml_app_all_of.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_app_all_of_parameters.py` & `onelogin-3.1.5/test/test_saml_app_all_of_parameters.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_app_all_of_parameters_saml_username.py` & `onelogin-3.1.5/test/test_saml_app_all_of_parameters_saml_username.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_assert.py` & `onelogin-3.1.5/test/test_saml_assert.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_assertions_api.py` & `onelogin-3.1.5/test/test_saml_assertions_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_saml_factor.py` & `onelogin-3.1.5/test/test_saml_factor.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_scope.py` & `onelogin-3.1.5/test/test_scope.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_send_invite_link200_response.py` & `onelogin-3.1.5/test/test_send_invite_link200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_send_invite_link_request.py` & `onelogin-3.1.5/test/test_send_invite_link_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_session.py` & `onelogin-3.1.5/test/test_session.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_set_user_state_request.py` & `onelogin-3.1.5/test/test_set_user_state_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_smart_hooks_api.py` & `onelogin-3.1.5/test/test_smart_hooks_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_source.py` & `onelogin-3.1.5/test/test_source.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_sso_oidc.py` & `onelogin-3.1.5/test/test_sso_oidc.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_sso_saml.py` & `onelogin-3.1.5/test/test_sso_saml.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_sso_saml_certificate.py` & `onelogin-3.1.5/test/test_sso_saml_certificate.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_token_claim.py` & `onelogin-3.1.5/test/test_token_claim.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_track_risk_event_request.py` & `onelogin-3.1.5/test/test_track_risk_event_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_client_app_request.py` & `onelogin-3.1.5/test/test_update_client_app_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_environment_variable_request.py` & `onelogin-3.1.5/test/test_update_environment_variable_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_password_insecure_request.py` & `onelogin-3.1.5/test/test_update_password_insecure_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_password_secure_request.py` & `onelogin-3.1.5/test/test_update_password_secure_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_privilege200_response.py` & `onelogin-3.1.5/test/test_update_privilege200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_risk_rule_request.py` & `onelogin-3.1.5/test/test_update_risk_rule_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_update_role200_response.py` & `onelogin-3.1.5/test/test_update_role200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_user.py` & `onelogin-3.1.5/test/test_user.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_user_mappings_api.py` & `onelogin-3.1.5/test/test_user_mappings_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_users_v1_api.py` & `onelogin-3.1.5/test/test_users_v1_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_users_v2_api.py` & `onelogin-3.1.5/test/test_users_v2_api.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_ver_factor_saml200_response.py` & `onelogin-3.1.5/test/test_ver_factor_saml200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_verb.py` & `onelogin-3.1.5/test/test_verb.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_verify_mfa_factor_request.py` & `onelogin-3.1.5/test/test_verify_mfa_factor_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_verify_user_registration200_response.py` & `onelogin-3.1.5/test/test_verify_user_registration200_response.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_verify_user_registration_request.py` & `onelogin-3.1.5/test/test_verify_user_registration_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_verify_user_verification_request.py` & `onelogin-3.1.5/test/test_verify_user_verification_request.py`

 * *Files identical despite different names*

### Comparing `onelogin-3.1.4/test/test_vigilance_ai_api.py` & `onelogin-3.1.5/test/test_vigilance_ai_api.py`

 * *Files identical despite different names*

