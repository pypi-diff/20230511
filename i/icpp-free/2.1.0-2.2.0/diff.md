# Comparing `tmp/icpp_free-2.1.0-py3-none-any.whl.zip` & `tmp/icpp_free-2.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,166 +1,168 @@
-Zip file size: 168107 bytes, number of entries: 200
+Zip file size: 201409 bytes, number of entries: 202
 -rw-rw-r--  2.0 unx      747 b- defN 23-Apr-29 11:50 icpp/__init__.py
 -rw-rw-r--  2.0 unx     1083 b- defN 23-Apr-29 11:50 icpp/__main__.py
--rw-rw-r--  2.0 unx      925 b- defN 23-May-01 20:11 icpp/callbacks.py
--rw-rw-r--  2.0 unx      711 b- defN 23-May-01 20:11 icpp/commands_build_native.py
+-rw-rw-r--  2.0 unx      925 b- defN 23-May-10 23:04 icpp/callbacks.py
+-rw-rw-r--  2.0 unx      711 b- defN 23-May-10 23:04 icpp/commands_build_native.py
 -rw-rw-r--  2.0 unx     4919 b- defN 23-Apr-29 11:50 icpp/commands_build_wasm.py
 -rw-rw-r--  2.0 unx     1122 b- defN 23-Apr-29 11:50 icpp/commands_get.py
 -rw-rw-r--  2.0 unx      753 b- defN 23-Apr-29 11:50 icpp/commands_init.py
 -rw-rw-r--  2.0 unx     3584 b- defN 23-Apr-29 11:50 icpp/commands_install_wasi_sdk.py
 -rw-rw-r--  2.0 unx     5138 b- defN 23-Apr-29 17:59 icpp/config_default.py
--rw-rw-r--  2.0 unx     1191 b- defN 23-May-01 20:11 icpp/conftest_base.py
+-rw-rw-r--  2.0 unx     2306 b- defN 23-May-10 23:04 icpp/conftest_base.py
 -rw-rw-r--  2.0 unx     2892 b- defN 23-Apr-29 15:38 icpp/decorators.py
 -rw-rw-r--  2.0 unx     3776 b- defN 23-Apr-29 11:50 icpp/icpp_toml.py
--rw-rw-r--  2.0 unx      733 b- defN 23-May-01 20:11 icpp/pro.py
+-rw-rw-r--  2.0 unx      733 b- defN 23-May-10 23:04 icpp/pro.py
 -rw-rw-r--  2.0 unx       98 b- defN 23-Apr-29 11:50 icpp/py.typed
--rw-rw-r--  2.0 unx     4475 b- defN 23-Apr-29 11:50 icpp/run_shell_cmd.py
--rw-rw-r--  2.0 unx     1254 b- defN 23-May-01 20:11 icpp/smoketest.py
--rw-rw-r--  2.0 unx      322 b- defN 23-May-01 20:11 icpp/version.py
+-rw-rw-r--  2.0 unx     5280 b- defN 23-May-10 21:24 icpp/run_shell_cmd.py
+-rw-rw-r--  2.0 unx     1307 b- defN 23-May-10 23:04 icpp/smoketest.py
+-rw-rw-r--  2.0 unx      322 b- defN 23-May-10 22:43 icpp/version.py
 -rw-rw-r--  2.0 unx      272 b- defN 23-Apr-29 11:50 icpp/version_wasi_sdk.py
 -rw-r--r--  2.0 unx       92 b- defN 23-Apr-29 11:50 icpp/canisters/greet/README.md
 -rw-r--r--  2.0 unx      269 b- defN 23-Apr-29 11:50 icpp/canisters/greet/dfx.json
 -rw-r--r--  2.0 unx      474 b- defN 23-Apr-29 11:50 icpp/canisters/greet/icpp.toml
 -rw-rw-r--  2.0 unx     2086 b- defN 23-May-01 15:09 icpp/canisters/greet/native/main.cpp
 -rw-rw-r--  2.0 unx      162 b- defN 23-Apr-29 11:50 icpp/canisters/greet/native/main.h
 -rw-rw-r--  2.0 unx     3197 b- defN 23-May-01 15:09 icpp/canisters/greet/src/greet.cpp
 -rw-r--r--  2.0 unx      494 b- defN 23-Apr-29 11:50 icpp/canisters/greet/src/greet.did
 -rw-r--r--  2.0 unx      379 b- defN 23-Apr-29 11:50 icpp/canisters/greet/src/greet.h
 -rw-rw-r--  2.0 unx        0 b- defN 23-Apr-29 11:50 icpp/canisters/greet/test/__init__.py
 -rw-rw-r--  2.0 unx      298 b- defN 23-Apr-29 11:50 icpp/canisters/greet/test/conftest.py
--rw-rw-r--  2.0 unx     2531 b- defN 23-May-01 15:09 icpp/canisters/greet/test/test_apis.py
--rw-rw-r--  2.0 unx     6302 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid.h
--rw-rw-r--  2.0 unx      986 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_assert.cpp
--rw-rw-r--  2.0 unx      335 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_assert.h
--rw-rw-r--  2.0 unx    13739 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_deserialize.cpp
--rw-rw-r--  2.0 unx     1392 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_deserialize.h
--rw-rw-r--  2.0 unx     6958 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_opcode.cpp
--rw-rw-r--  2.0 unx     2878 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_opcode.h
--rw-r--r--  2.0 unx     4328 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_serialize.cpp
--rw-r--r--  2.0 unx     1000 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_serialize.h
--rw-rw-r--  2.0 unx     1761 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_base.cpp
--rw-rw-r--  2.0 unx     1976 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_base.h
--rw-rw-r--  2.0 unx     2048 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_bool.cpp
--rw-rw-r--  2.0 unx      552 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_bool.h
--rw-rw-r--  2.0 unx     1126 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_empty.cpp
--rw-rw-r--  2.0 unx      372 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_empty.h
--rw-rw-r--  2.0 unx      821 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_float32.cpp
--rw-rw-r--  2.0 unx      577 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_float32.h
--rw-rw-r--  2.0 unx      825 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_float64.cpp
--rw-rw-r--  2.0 unx      584 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_float64.h
--rw-r--r--  2.0 unx     1966 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int.cpp
--rw-r--r--  2.0 unx      589 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int.h
--rw-rw-r--  2.0 unx      797 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_int16.cpp
--rw-rw-r--  2.0 unx      579 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int16.h
--rw-rw-r--  2.0 unx      802 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_int32.cpp
--rw-rw-r--  2.0 unx      579 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int32.h
--rw-rw-r--  2.0 unx      797 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_int64.cpp
--rw-rw-r--  2.0 unx      579 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int64.h
--rw-rw-r--  2.0 unx      776 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_int8.cpp
--rw-rw-r--  2.0 unx      566 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_int8.h
--rw-rw-r--  2.0 unx      790 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_nat.cpp
--rw-rw-r--  2.0 unx      595 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_nat.h
--rw-rw-r--  2.0 unx      812 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_nat16.cpp
--rw-rw-r--  2.0 unx      586 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_nat16.h
--rw-rw-r--  2.0 unx      812 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_nat32.cpp
--rw-rw-r--  2.0 unx      586 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_nat32.h
--rw-rw-r--  2.0 unx      801 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_nat64.cpp
--rw-rw-r--  2.0 unx      586 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_nat64.h
--rw-rw-r--  2.0 unx      779 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_nat8.cpp
--rw-rw-r--  2.0 unx      573 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_nat8.h
--rw-rw-r--  2.0 unx      786 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_null.cpp
--rw-rw-r--  2.0 unx      291 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_null.h
--rw-rw-r--  2.0 unx      591 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_base.cpp
--rw-rw-r--  2.0 unx      412 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_base.h
--rw-rw-r--  2.0 unx      656 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_bool.cpp
--rw-rw-r--  2.0 unx      646 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_bool.h
--rw-rw-r--  2.0 unx      774 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_float32.cpp
--rw-rw-r--  2.0 unx      667 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_float32.h
--rw-rw-r--  2.0 unx      724 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_float64.cpp
--rw-rw-r--  2.0 unx      673 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_float64.h
--rw-rw-r--  2.0 unx      656 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_int.cpp
--rw-rw-r--  2.0 unx      677 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_int.h
--rw-rw-r--  2.0 unx      674 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_int16.cpp
--rw-rw-r--  2.0 unx      669 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_int16.h
--rw-rw-r--  2.0 unx      726 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_int32.cpp
--rw-rw-r--  2.0 unx      669 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_int32.h
--rw-rw-r--  2.0 unx      674 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_int64.cpp
--rw-rw-r--  2.0 unx      669 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_int64.h
--rw-rw-r--  2.0 unx      660 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_int8.cpp
--rw-rw-r--  2.0 unx      658 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_int8.h
--rw-rw-r--  2.0 unx      658 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_nat.cpp
--rw-rw-r--  2.0 unx      683 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_nat.h
--rw-rw-r--  2.0 unx      676 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_nat16.cpp
--rw-rw-r--  2.0 unx      675 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_nat16.h
--rw-rw-r--  2.0 unx      676 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_nat32.cpp
--rw-rw-r--  2.0 unx      675 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_nat32.h
--rw-rw-r--  2.0 unx      676 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_nat64.cpp
--rw-rw-r--  2.0 unx      675 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_nat64.h
--rw-rw-r--  2.0 unx      662 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_nat8.cpp
--rw-rw-r--  2.0 unx      664 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_nat8.h
--rw-rw-r--  2.0 unx      787 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_principal.cpp
--rw-rw-r--  2.0 unx      713 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_principal.h
--rw-rw-r--  2.0 unx      766 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_opt_text.cpp
--rw-rw-r--  2.0 unx      688 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_opt_text.h
--rw-rw-r--  2.0 unx      148 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_prim.cpp
--rw-rw-r--  2.0 unx      484 b- defN 23-May-01 15:09 icpp/ic/candid/candid_type_prim.h
--rw-r--r--  2.0 unx     9545 b- defN 23-May-01 15:08 icpp/ic/candid/candid_type_principal.cpp
--rw-rw-r--  2.0 unx     1692 b- defN 23-May-01 15:08 icpp/ic/candid/candid_type_principal.h
--rw-rw-r--  2.0 unx     1168 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_record.cpp
--rw-rw-r--  2.0 unx     1010 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_record.h
--rw-rw-r--  2.0 unx      548 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_reserved.cpp
--rw-rw-r--  2.0 unx      383 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_reserved.h
--rw-rw-r--  2.0 unx     2579 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_table.cpp
--rw-rw-r--  2.0 unx      676 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_table.h
--rw-rw-r--  2.0 unx     2861 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_text.cpp
--rw-rw-r--  2.0 unx      655 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_text.h
--rw-r--r--  2.0 unx      591 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_base.cpp
--rw-r--r--  2.0 unx      412 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_base.h
--rw-r--r--  2.0 unx      652 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_bool.cpp
--rw-r--r--  2.0 unx      634 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_bool.h
--rw-r--r--  2.0 unx      690 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_float32.cpp
--rw-r--r--  2.0 unx      655 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_float32.h
--rw-r--r--  2.0 unx      692 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_float64.cpp
--rw-r--r--  2.0 unx      661 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_float64.h
--rw-r--r--  2.0 unx      652 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_int.cpp
--rw-r--r--  2.0 unx      665 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_int.h
--rw-r--r--  2.0 unx      670 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_int16.cpp
--rw-r--r--  2.0 unx      657 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_int16.h
--rw-r--r--  2.0 unx      670 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_int32.cpp
--rw-r--r--  2.0 unx      657 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_int32.h
--rw-r--r--  2.0 unx      670 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_int64.cpp
--rw-r--r--  2.0 unx      657 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_int64.h
--rw-r--r--  2.0 unx      656 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_int8.cpp
--rw-r--r--  2.0 unx      646 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_int8.h
--rw-r--r--  2.0 unx      654 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_nat.cpp
--rw-r--r--  2.0 unx      671 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_nat.h
--rw-r--r--  2.0 unx      672 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_nat16.cpp
--rw-r--r--  2.0 unx      663 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_nat16.h
--rw-r--r--  2.0 unx      672 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_nat32.cpp
--rw-r--r--  2.0 unx      663 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_nat32.h
--rw-r--r--  2.0 unx      672 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_nat64.cpp
--rw-r--r--  2.0 unx      663 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_nat64.h
--rw-r--r--  2.0 unx      658 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_nat8.cpp
--rw-r--r--  2.0 unx      652 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_nat8.h
--rw-r--r--  2.0 unx      726 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_principal.cpp
--rw-r--r--  2.0 unx      701 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_principal.h
--rw-r--r--  2.0 unx      666 b- defN 23-May-01 20:11 icpp/ic/candid/candid_type_vec_text.cpp
--rw-r--r--  2.0 unx      676 b- defN 23-Apr-29 11:50 icpp/ic/candid/candid_type_vec_text.h
--rw-rw-r--  2.0 unx    15762 b- defN 23-Apr-29 11:50 icpp/ic/candid/vec_bytes.cpp
--rw-rw-r--  2.0 unx     7834 b- defN 23-Apr-29 11:50 icpp/ic/candid/vec_bytes.h
+-rw-rw-r--  2.0 unx     2500 b- defN 23-May-10 21:24 icpp/canisters/greet/test/test_apis.py
+-rw-rw-r--  2.0 unx     6153 b- defN 23-May-10 21:33 icpp/ic/candid/candid.h
+-rw-rw-r--  2.0 unx      986 b- defN 23-May-10 21:33 icpp/ic/candid/candid_assert.cpp
+-rw-rw-r--  2.0 unx      335 b- defN 23-May-10 21:33 icpp/ic/candid/candid_assert.h
+-rw-rw-r--  2.0 unx    14028 b- defN 23-May-10 21:33 icpp/ic/candid/candid_deserialize.cpp
+-rw-rw-r--  2.0 unx     1392 b- defN 23-May-10 21:33 icpp/ic/candid/candid_deserialize.h
+-rw-rw-r--  2.0 unx     7021 b- defN 23-May-10 21:33 icpp/ic/candid/candid_opcode.cpp
+-rw-rw-r--  2.0 unx     2878 b- defN 23-May-10 21:33 icpp/ic/candid/candid_opcode.h
+-rw-r--r--  2.0 unx     4328 b- defN 23-May-10 21:33 icpp/ic/candid/candid_serialize.cpp
+-rw-r--r--  2.0 unx     1000 b- defN 23-May-10 21:33 icpp/ic/candid/candid_serialize.h
+-rw-rw-r--  2.0 unx     1761 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_base.cpp
+-rw-rw-r--  2.0 unx     1976 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_base.h
+-rw-rw-r--  2.0 unx     2048 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_bool.cpp
+-rw-rw-r--  2.0 unx      552 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_bool.h
+-rw-rw-r--  2.0 unx     1126 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_empty.cpp
+-rw-rw-r--  2.0 unx      420 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_empty.h
+-rw-rw-r--  2.0 unx     2187 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_float32.cpp
+-rw-rw-r--  2.0 unx      577 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_float32.h
+-rw-rw-r--  2.0 unx     2195 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_float64.cpp
+-rw-rw-r--  2.0 unx      584 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_float64.h
+-rw-r--r--  2.0 unx     1966 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int.cpp
+-rw-r--r--  2.0 unx      589 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int.h
+-rw-rw-r--  2.0 unx     2016 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_int16.cpp
+-rw-rw-r--  2.0 unx      579 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int16.h
+-rw-rw-r--  2.0 unx     2016 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_int32.cpp
+-rw-rw-r--  2.0 unx      579 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int32.h
+-rw-rw-r--  2.0 unx     2016 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_int64.cpp
+-rw-rw-r--  2.0 unx      579 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int64.h
+-rw-rw-r--  2.0 unx     1990 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_int8.cpp
+-rw-rw-r--  2.0 unx      566 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_int8.h
+-rw-rw-r--  2.0 unx     1988 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_nat.cpp
+-rw-rw-r--  2.0 unx      595 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_nat.h
+-rw-rw-r--  2.0 unx     2008 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_nat16.cpp
+-rw-rw-r--  2.0 unx      586 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_nat16.h
+-rw-rw-r--  2.0 unx     2008 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_nat32.cpp
+-rw-rw-r--  2.0 unx      586 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_nat32.h
+-rw-rw-r--  2.0 unx     2008 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_nat64.cpp
+-rw-rw-r--  2.0 unx      586 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_nat64.h
+-rw-rw-r--  2.0 unx     1982 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_nat8.cpp
+-rw-rw-r--  2.0 unx      573 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_nat8.h
+-rw-rw-r--  2.0 unx      786 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_null.cpp
+-rw-rw-r--  2.0 unx      339 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_null.h
+-rw-rw-r--  2.0 unx     1819 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_opt_base.cpp
+-rw-rw-r--  2.0 unx      412 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_base.h
+-rw-rw-r--  2.0 unx     2674 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_bool.cpp
+-rw-rw-r--  2.0 unx      692 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_bool.h
+-rw-rw-r--  2.0 unx     2688 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_float32.cpp
+-rw-rw-r--  2.0 unx      714 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_float32.h
+-rw-rw-r--  2.0 unx     2694 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_float64.cpp
+-rw-rw-r--  2.0 unx      721 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_float64.h
+-rw-rw-r--  2.0 unx     2684 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int.cpp
+-rw-rw-r--  2.0 unx      729 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int.h
+-rw-rw-r--  2.0 unx     2672 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int16.cpp
+-rw-rw-r--  2.0 unx      718 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int16.h
+-rw-rw-r--  2.0 unx     2672 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int32.cpp
+-rw-rw-r--  2.0 unx      718 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int32.h
+-rw-rw-r--  2.0 unx     2672 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int64.cpp
+-rw-rw-r--  2.0 unx      718 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int64.h
+-rw-rw-r--  2.0 unx     2650 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int8.cpp
+-rw-rw-r--  2.0 unx      706 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_int8.h
+-rw-rw-r--  2.0 unx     2690 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat.cpp
+-rw-rw-r--  2.0 unx      736 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat.h
+-rw-rw-r--  2.0 unx     2678 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat16.cpp
+-rw-rw-r--  2.0 unx      725 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat16.h
+-rw-rw-r--  2.0 unx     2678 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat32.cpp
+-rw-rw-r--  2.0 unx      725 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat32.h
+-rw-rw-r--  2.0 unx     2678 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat64.cpp
+-rw-rw-r--  2.0 unx      725 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat64.h
+-rw-rw-r--  2.0 unx     2656 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat8.cpp
+-rw-rw-r--  2.0 unx      713 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_nat8.h
+-rw-rw-r--  2.0 unx     2916 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_principal.cpp
+-rw-rw-r--  2.0 unx      766 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_principal.h
+-rw-rw-r--  2.0 unx     2920 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_text.cpp
+-rw-rw-r--  2.0 unx      741 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_opt_text.h
+-rw-rw-r--  2.0 unx      148 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_prim.cpp
+-rw-rw-r--  2.0 unx      484 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_prim.h
+-rw-r--r--  2.0 unx     9545 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_principal.cpp
+-rw-rw-r--  2.0 unx     1692 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_principal.h
+-rw-rw-r--  2.0 unx    10646 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_record.cpp
+-rw-rw-r--  2.0 unx     1206 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_record.h
+-rw-rw-r--  2.0 unx     1045 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_reserved.cpp
+-rw-rw-r--  2.0 unx      434 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_reserved.h
+-rw-rw-r--  2.0 unx     2579 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_table.cpp
+-rw-rw-r--  2.0 unx      676 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_table.h
+-rw-rw-r--  2.0 unx     2861 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_text.cpp
+-rw-rw-r--  2.0 unx      655 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_text.h
+-rw-rw-r--  2.0 unx    11536 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_variant.cpp
+-rw-rw-r--  2.0 unx     1570 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_variant.h
+-rw-rw-r--  2.0 unx     1819 b- defN 23-May-10 22:24 icpp/ic/candid/candid_type_vec_base.cpp
+-rw-r--r--  2.0 unx      412 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_base.h
+-rw-r--r--  2.0 unx     2485 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_bool.cpp
+-rw-r--r--  2.0 unx      678 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_bool.h
+-rw-r--r--  2.0 unx     2485 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_float32.cpp
+-rw-r--r--  2.0 unx      700 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_float32.h
+-rw-r--r--  2.0 unx     2492 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_float64.cpp
+-rw-r--r--  2.0 unx      707 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_float64.h
+-rw-r--r--  2.0 unx     2457 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int.cpp
+-rw-r--r--  2.0 unx      715 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int.h
+-rw-r--r--  2.0 unx     2502 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int16.cpp
+-rw-r--r--  2.0 unx      704 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int16.h
+-rw-r--r--  2.0 unx     2502 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int32.cpp
+-rw-r--r--  2.0 unx      704 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int32.h
+-rw-r--r--  2.0 unx     2502 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int64.cpp
+-rw-r--r--  2.0 unx      704 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int64.h
+-rw-r--r--  2.0 unx     2479 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int8.cpp
+-rw-r--r--  2.0 unx      692 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_int8.h
+-rw-r--r--  2.0 unx     2504 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat.cpp
+-rw-r--r--  2.0 unx      722 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat.h
+-rw-r--r--  2.0 unx     2517 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat16.cpp
+-rw-r--r--  2.0 unx      711 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat16.h
+-rw-r--r--  2.0 unx     2517 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat32.cpp
+-rw-r--r--  2.0 unx      711 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat32.h
+-rw-r--r--  2.0 unx     2517 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat64.cpp
+-rw-r--r--  2.0 unx      711 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat64.h
+-rw-r--r--  2.0 unx     2493 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat8.cpp
+-rw-r--r--  2.0 unx      699 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_nat8.h
+-rw-r--r--  2.0 unx     2661 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_principal.cpp
+-rw-r--r--  2.0 unx      752 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_principal.h
+-rw-r--r--  2.0 unx     2724 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_text.cpp
+-rw-r--r--  2.0 unx      727 b- defN 23-May-10 21:33 icpp/ic/candid/candid_type_vec_text.h
+-rw-rw-r--  2.0 unx    15762 b- defN 23-May-10 21:33 icpp/ic/candid/vec_bytes.cpp
+-rw-rw-r--  2.0 unx     7834 b- defN 23-May-10 21:33 icpp/ic/candid/vec_bytes.h
 -rw-rw-r--  2.0 unx     3407 b- defN 23-Apr-29 11:50 icpp/ic/ic0/ic0.h
 -rw-r--r--  2.0 unx      110 b- defN 23-Apr-29 11:50 icpp/ic/ic0mock/global.h
--rw-r--r--  2.0 unx     3270 b- defN 23-May-01 20:11 icpp/ic/ic0mock/ic0.cpp
+-rw-r--r--  2.0 unx     3270 b- defN 23-May-10 23:04 icpp/ic/ic0mock/ic0.cpp
 -rw-rw-r--  2.0 unx     2091 b- defN 23-Apr-29 11:50 icpp/ic/ic0mock/ic0.h
--rw-rw-r--  2.0 unx     1372 b- defN 23-May-01 20:11 icpp/ic/ic0mock/mock_ic.cpp
+-rw-rw-r--  2.0 unx     1372 b- defN 23-May-10 23:04 icpp/ic/ic0mock/mock_ic.cpp
 -rw-rw-r--  2.0 unx     1495 b- defN 23-May-01 15:09 icpp/ic/ic0mock/mock_ic.h
 -rw-rw-r--  2.0 unx     3402 b- defN 23-May-01 15:09 icpp/ic/icapi/ic_api.cpp
 -rw-rw-r--  2.0 unx     1164 b- defN 23-May-01 15:09 icpp/ic/icapi/ic_api.h
 -rw-r--r--  2.0 unx      463 b- defN 23-Apr-29 11:50 icpp/ic/icapi/wasm_symbol.h
--rw-r--r--  2.0 unx      754 b- defN 23-May-01 20:11 icpp/ic/pro/pro.cpp
+-rw-r--r--  2.0 unx      754 b- defN 23-May-10 23:04 icpp/ic/pro/pro.cpp
 -rw-r--r--  2.0 unx      393 b- defN 23-Apr-29 17:59 icpp/ic/pro/pro.h
 -rw-rw-r--  2.0 unx     1155 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/LICENSE
 -rw-rw-r--  2.0 unx     3933 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/base32_crockford.hpp
 -rw-rw-r--  2.0 unx     1366 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/base32_default_crockford.hpp
 -rw-rw-r--  2.0 unx     1342 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/base32_default_hex.hpp
 -rw-rw-r--  2.0 unx     1356 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/base32_default_rfc4648.hpp
 -rw-rw-r--  2.0 unx     3090 b- defN 23-Apr-29 11:50 icpp/ic/vendors/cppcodec/base32_hex.hpp
@@ -189,14 +191,14 @@
 -rw-r--r--  2.0 unx     1736 b- defN 23-Apr-29 11:50 icpp/ic/vendors/hash-library/crc32.h
 -rw-r--r--  2.0 unx     1758 b- defN 23-Apr-29 11:50 icpp/ic/vendors/hash-library/readme.md
 -rw-rw-r--  2.0 unx     1370 b- defN 23-Apr-29 11:50 icpp/ic/wasi_sdk_traps/__wasilibc_initialize_environ.c
 -rw-rw-r--  2.0 unx      327 b- defN 23-Apr-29 11:50 icpp/ic/wasi_sdk_traps/ic_trap.c
 -rw-rw-r--  2.0 unx       70 b- defN 23-Apr-29 11:50 icpp/ic/wasi_sdk_traps/ic_trap.h
 -rw-rw-r--  2.0 unx     3717 b- defN 23-Apr-29 11:50 icpp/ic/wasi_sdk_traps/posix.c
 -rw-r--r--  2.0 unx     7527 b- defN 23-Apr-29 11:50 icpp/ic/wasi_sdk_traps/unreachable.c
--rw-r--r--  2.0 unx      983 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/LICENSE
--rw-rw-r--  2.0 unx     2077 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/WHEEL
--rw-rw-r--  2.0 unx       44 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx        5 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    18257 b- defN 23-May-01 20:13 icpp_free-2.1.0.dist-info/RECORD
-200 files, 389410 bytes uncompressed, 138805 bytes compressed:  64.4%
+-rw-r--r--  2.0 unx      983 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     2290 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       44 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx        5 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    18491 b- defN 23-May-10 23:21 icpp_free-2.2.0.dist-info/RECORD
+202 files, 490888 bytes uncompressed, 171807 bytes compressed:  65.0%
```

## zipnote {}

```diff
@@ -336,14 +336,20 @@
 
 Filename: icpp/ic/candid/candid_type_text.cpp
 Comment: 
 
 Filename: icpp/ic/candid/candid_type_text.h
 Comment: 
 
+Filename: icpp/ic/candid/candid_type_variant.cpp
+Comment: 
+
+Filename: icpp/ic/candid/candid_type_variant.h
+Comment: 
+
 Filename: icpp/ic/candid/candid_type_vec_base.cpp
 Comment: 
 
 Filename: icpp/ic/candid/candid_type_vec_base.h
 Comment: 
 
 Filename: icpp/ic/candid/candid_type_vec_bool.cpp
@@ -576,26 +582,26 @@
 
 Filename: icpp/ic/wasi_sdk_traps/posix.c
 Comment: 
 
 Filename: icpp/ic/wasi_sdk_traps/unreachable.c
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/LICENSE
+Filename: icpp_free-2.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/METADATA
+Filename: icpp_free-2.2.0.dist-info/METADATA
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/WHEEL
+Filename: icpp_free-2.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/entry_points.txt
+Filename: icpp_free-2.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/top_level.txt
+Filename: icpp_free-2.2.0.dist-info/top_level.txt
 Comment: 
 
-Filename: icpp_free-2.1.0.dist-info/RECORD
+Filename: icpp_free-2.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## icpp/conftest_base.py

```diff
@@ -15,21 +15,55 @@
 
 
 def pytest_addoption(parser: Any) -> None:
     """Adds options: `pytest --network=[local/ic] `"""
     pro.exit_if_not_pro()
 
 
+###########################################################
+# Some fixtures that always run, prior to the actual tests
+# They verify everything is OK with the network & identity
+
+
 @pytest.fixture(scope="session", autouse=True)
 def network(_request: Any) -> Any:
     """A fixture that verifies the network is up & returns the name."""
     pro.exit_if_not_pro()
 
 
-def handle_identity(identity: str) -> Generator[dict[str, str], None, None]:
+@pytest.fixture(scope="session", autouse=True)
+def identity() -> Any:
+    """A fixture that returns the name of the used identity."""
+    pro.exit_if_not_pro()
+    identity_ = get_identity()
+    if identity_.startswith("ERROR"):
+        raise Exception(identity_)
+    return identity_
+
+
+@pytest.fixture(scope="session", autouse=True)
+def principal() -> Any:
+    """A fixture that returns the principal of the used identity."""
+    pro.exit_if_not_pro()
+    principal_ = get_principal()
+    if principal_.startswith("ERROR"):
+        if "Please enter the passphrase for your identity" in principal_:
+            msg = (
+                f"Identity '{get_identity()}' uses a passphrase. "
+                f"Use identity created with '--storage-mode plaintext'!"
+            )
+            raise Exception(msg)
+        raise Exception(principal_)
+    return principal_
+
+
+###########################################################
+
+
+def handle_identity(identity_to_set: str) -> Generator[dict[str, str], None, None]:
     """A fixture that sets the dfx identity."""
     pro.exit_if_not_pro()
     yield {}
 
 
 @pytest.fixture(scope="function")
 def identity_anonymous() -> Generator[dict[str, str], None, None]:
```

## icpp/run_shell_cmd.py

```diff
@@ -32,14 +32,15 @@
 
 
 def run_shell_cmd(
     cmd: str,
     capture_output: bool = False,
     print_captured_output: bool = False,
     cwd: Optional[Path] = None,
+    timeout_seconds: Optional[int] = None,
 ) -> str:
     """Runs 'cmd' with following behavior, so we can
     use it in our sequential CI/CD pipeline:
 
     Example usage:
         import sys
         import subprocess
@@ -76,42 +77,61 @@
         - If an error occurs:
           - Throws a subprocess.CalledProcessError as e:
             return e.returncode
     """
     if cwd is None:
         cwd = Path(".")
 
+    if timeout_seconds is None:
+        timeout_seconds = 3
+
     capture_stdout = ""
 
     if capture_output is False:
         subprocess.run(cmd, shell=True, check=True, text=True, cwd=cwd)
     else:
         # These will block & cannot be used to start a background process from make.
         if print_captured_output is False:
-            # This will capture_output and:
-            # - return it if there is no error
-            # - includes it in a possibly raised error
-            p_1 = subprocess.run(
-                cmd,
-                stdout=subprocess.PIPE,
-                stderr=subprocess.STDOUT,
-                shell=True,
-                check=False,
-                text=True,
-                cwd=cwd,
-            )
-            if p_1.returncode != 0:
-                # typer.echo(p_1.stdout)
-                raise subprocess.CalledProcessError(
-                    returncode=p_1.returncode,
-                    cmd=p_1.args,
-                    output=escape_ansi(p_1.stdout),
-                    stderr=escape_ansi(p_1.stderr),
+            try:
+                # This will capture_output and:
+                # - return it if there is no error
+                # - includes it in a possibly raised error
+                p_1 = subprocess.run(
+                    cmd,
+                    stdout=subprocess.PIPE,
+                    stderr=subprocess.STDOUT,
+                    shell=True,
+                    check=False,
+                    text=True,
+                    cwd=cwd,
+                    timeout=timeout_seconds,
                 )
-            capture_stdout += p_1.stdout
+                if p_1.returncode != 0:
+                    # typer.echo(p_1.stdout)
+                    raise subprocess.CalledProcessError(
+                        returncode=p_1.returncode,
+                        cmd=p_1.args,
+                        output=escape_ansi(p_1.stdout),
+                        stderr=escape_ansi(p_1.stderr),
+                    )
+                capture_stdout += p_1.stdout
+            except subprocess.TimeoutExpired as e:
+                capture_stdout = (
+                    f"ERROR: Command '{e.cmd}' timed out after {e.timeout} seconds, "
+                    f"with stdout: "
+                )
+
+                if e.stdout is not None:
+                    lmax = 132
+                    lstdout = len(e.stdout)
+                    capture_stdout += e.stdout.decode("utf-8")[: min(lmax, lstdout)]
+                    if lstdout > lmax:
+                        capture_stdout += "..."
+
+                print(capture_output)
         else:
             # This prints output while running, and we capture it as well & return it
             # https://stackoverflow.com/a/28319191/5480536
             with subprocess.Popen(
                 cmd,
                 stdout=subprocess.PIPE,
                 stderr=subprocess.STDOUT,
```

## icpp/smoketest.py

```diff
@@ -17,14 +17,15 @@
     dfx_json_path: Path,
     canister_name: str,
     canister_method: str,
     canister_argument: Optional[str] = None,
     canister_input: str = "idl",
     canister_output: str = "idl",
     network: str = "local",
+    quiet: str = "-qq",  # limits dfx to errors only
 ) -> str:
     """Calls a canister method"""
     pro.exit_if_not_pro()
     return ""
 
 
 def dict_to_candid_text(d: dict[Any, Any]) -> str:
```

## icpp/version.py

```diff
@@ -5,8 +5,8 @@
 (-) do not add anything but the version number here!
 
 We do it this way, so both __init__.py and setup.py can use it.
 
 see:
 https://packaging.python.org/guides/single-sourcing-package-version/
 """
-__version__ = "2.1.0"
+__version__ = "2.2.0"
```

## icpp/canisters/greet/test/test_apis.py

```diff
@@ -5,15 +5,15 @@
    $ pytest --network=[local/ic] test_apis.py
 
 """
 # pylint: disable=missing-function-docstring, unused-import, wildcard-import, unused-wildcard-import, line-too-long
 
 from pathlib import Path
 import pytest
-from icpp.smoketest import call_canister_api, get_principal
+from icpp.smoketest import call_canister_api
 
 # Path to the dfx.json file
 DFX_JSON_PATH = Path(__file__).parent / "../dfx.json"
 
 # Canister in the dfx.json file we want to test
 CANISTER_NAME = "greet"
 
@@ -38,23 +38,22 @@
         canister_argument="()",
         network=network,
     )
     expected_response = "(2_023 : int)"
     assert response == expected_response
 
 
-def test__greet_2(network: str) -> None:
+def test__greet_2(network: str, principal: str) -> None:
     response = call_canister_api(
         dfx_json_path=DFX_JSON_PATH,
         canister_name=CANISTER_NAME,
         canister_method="greet_2",
         canister_argument='("C++ Developer")',
         network=network,
     )
-    principal = get_principal()
     expected_response = f'("hello C++ Developer!\\nYour principal is: {principal}")'
     assert response == expected_response
 
 
 def test__greet_3(network: str) -> None:
     response = call_canister_api(
         dfx_json_path=DFX_JSON_PATH,
```

## icpp/ic/candid/candid.h

```diff
@@ -81,41 +81,40 @@
 // class CandidTypeOptRecord;
 // These types are not used for opts
 // class CandidTypeOptNull;
 // class CandidTypeOptEmpty;
 // class CandidTypeOptReserved;
 
 class CandidTypeRecord;
-// class CandidTypeVariant;
+class CandidTypeVariant;
 
 // The Candid Type Table class
 class CandidTypeTable;
 
 // The (De)Serialization classes
 class CandidDeserialize;
 class CandidSerialize;
 
 // The std::variant alias
-using CandidType =
-    std::variant<CandidTypeNull, CandidTypeEmpty, CandidTypeReserved,
-                 CandidTypeBool, CandidTypeFloat32, CandidTypeFloat64,
-                 CandidTypeInt, CandidTypeNat, CandidTypeNat8, CandidTypeNat16,
-                 CandidTypeNat32, CandidTypeNat64, CandidTypeInt8,
-                 CandidTypeInt16, CandidTypeInt32, CandidTypeInt64,
-                 CandidTypeText, CandidTypePrincipal, CandidTypeVecBool,
-                 CandidTypeVecFloat32, CandidTypeVecFloat64, CandidTypeVecInt,
-                 CandidTypeVecNat, CandidTypeVecNat8, CandidTypeVecNat16,
-                 CandidTypeVecNat32, CandidTypeVecNat64, CandidTypeVecInt8,
-                 CandidTypeVecInt16, CandidTypeVecInt32, CandidTypeVecInt64,
-                 CandidTypeVecText, CandidTypeVecPrincipal, CandidTypeOptBool,
-                 CandidTypeOptFloat32, CandidTypeOptFloat64, CandidTypeOptInt,
-                 CandidTypeOptNat, CandidTypeOptNat8, CandidTypeOptNat16,
-                 CandidTypeOptNat32, CandidTypeOptNat64, CandidTypeOptInt8,
-                 CandidTypeOptInt16, CandidTypeOptInt32, CandidTypeOptInt64,
-                 CandidTypeOptText, CandidTypeOptPrincipal, CandidTypeRecord>;
+using CandidType = std::variant<
+    CandidTypeNull, CandidTypeEmpty, CandidTypeReserved, CandidTypeBool,
+    CandidTypeFloat32, CandidTypeFloat64, CandidTypeInt, CandidTypeNat,
+    CandidTypeNat8, CandidTypeNat16, CandidTypeNat32, CandidTypeNat64,
+    CandidTypeInt8, CandidTypeInt16, CandidTypeInt32, CandidTypeInt64,
+    CandidTypeText, CandidTypePrincipal, CandidTypeVecBool,
+    CandidTypeVecFloat32, CandidTypeVecFloat64, CandidTypeVecInt,
+    CandidTypeVecNat, CandidTypeVecNat8, CandidTypeVecNat16, CandidTypeVecNat32,
+    CandidTypeVecNat64, CandidTypeVecInt8, CandidTypeVecInt16,
+    CandidTypeVecInt32, CandidTypeVecInt64, CandidTypeVecText,
+    CandidTypeVecPrincipal, CandidTypeOptBool, CandidTypeOptFloat32,
+    CandidTypeOptFloat64, CandidTypeOptInt, CandidTypeOptNat, CandidTypeOptNat8,
+    CandidTypeOptNat16, CandidTypeOptNat32, CandidTypeOptNat64,
+    CandidTypeOptInt8, CandidTypeOptInt16, CandidTypeOptInt32,
+    CandidTypeOptInt64, CandidTypeOptText, CandidTypeOptPrincipal,
+    CandidTypeRecord, CandidTypeVariant>;
 
 // https://subscription.packtpub.com/book/programming/9781787120495/8/ch08lvl1sec91/storing-different-types-with-stdvariant
 template <typename T> bool is_CandidType(const CandidType &c) {
   return holds_alternative<T>(c);
 }
 
 // ------------------------------------------------------------------
@@ -193,14 +192,15 @@
 // #include "candid_type_opt_record.h"
 // These types are not used for opts
 // #include "candid_type_opt_empty.h"
 // #include "candid_type_opt_null.h"
 // #include "candid_type_opt_reserved.h"
 
 #include "candid_type_record.h"
+#include "candid_type_variant.h"
 
 // The Candid Type Table class
 #include "candid_type_table.h"
 
 // The (De)Serialization classes
 #include "candid_deserialize.h"
 #include "candid_serialize.h"
```

## icpp/ic/candid/candid_deserialize.cpp

```diff
@@ -198,14 +198,19 @@
       if (opcode_found == CandidOpcode().Record) {
         CandidTypeRecord *p_wire =
             get_if<CandidTypeRecord>(type_table.get_candidType_ptr());
         CandidTypeRecord *p_expected = get_if<CandidTypeRecord>(&m_A[i]);
 
         // Trap if type table does not match the wire
         p_expected->check_type_table(p_wire);
+      } else if (opcode_found == CandidOpcode().Variant) {
+        CandidTypeVariant *p_wire =
+            get_if<CandidTypeVariant>(type_table.get_candidType_ptr());
+        CandidTypeVariant *p_expected = get_if<CandidTypeVariant>(&m_A[i]);
+        p_expected->check_type_table(p_wire);
       } else if (opcode_found == CandidOpcode().Vec ||
                  opcode_found == CandidOpcode().Opt) {
 
         int content_opcode_found =
             std::visit([](auto &&c) { return c.get_content_type_opcode(); },
                        *type_table.get_candidType_ptr());
         int content_opcode_expected = std::visit(
```

## icpp/ic/candid/candid_opcode.cpp

```diff
@@ -98,14 +98,16 @@
     msg.append(
         "ERROR: NOT SUPPORTED FOR OPT. (use candid_opt_type_from_opcode)");
     msg.append("       datatype = " + std::to_string(opcode));
     msg.append("      " + std::string(__func__));
     IC_API::trap(msg);
   } else if (opcode == Record) {
     c = CandidTypeRecord();
+  } else if (opcode == Variant) {
+    c = CandidTypeVariant();
   } else {
     std::string msg;
     msg.append("ERROR: NOT YET IMPLEMENTED FOR THIS OPCODE.");
     msg.append("       datatype = " + std::to_string(opcode));
     msg.append("      " + std::string(__func__));
     IC_API::trap(msg);
   }
```

## icpp/ic/candid/candid_type_empty.h

```diff
@@ -9,13 +9,14 @@
   // Constructors
   CandidTypeEmpty();
 
   // Destructor
   ~CandidTypeEmpty();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::string get_v() { return "EMPTY_VALUE"; }
 
 protected:
   void set_datatype();
   void encode_I();
   void encode_M();
 };
```

## icpp/ic/candid/candid_type_float32.cpp

```diff
@@ -2,34 +2,79 @@
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
 CandidTypeFloat32::CandidTypeFloat32() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  float v = 0.0;
+  initialize(v);
 }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeFloat32::CandidTypeFloat32(float *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const float v = const_cast<float &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeFloat32::CandidTypeFloat32(const float v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeFloat32::~CandidTypeFloat32() {}
 
-void CandidTypeFloat32::initialize(const float &v) {}
+// Initialize things
+void CandidTypeFloat32::initialize(const float &v) {
+  if (sizeof(v) != 4) {
+    IC_API::trap(
+        "ERROR: The type float is not 4 bytes. \nThis is not yet supported.\n" +
+        std::string(__func__));
+  }
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeFloat32::set_pv(float *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeFloat32::set_pv(float *v) { m_pv = v; }
 
-void CandidTypeFloat32::set_datatype() {}
+void CandidTypeFloat32::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Float32;
+  m_datatype_hex = OpcodeHex().Float32;
+  m_datatype_textual = OpcodeTextual().Float32;
+}
 
-void CandidTypeFloat32::encode_I() {}
+void CandidTypeFloat32::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeFloat32::encode_M() {}
+void CandidTypeFloat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(z : float<N>) = f<N>(z)
+  m_M.append_float_ieee754(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeFloat32::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_float_ieee754(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeFloat32";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_float64.cpp

```diff
@@ -2,34 +2,79 @@
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
 CandidTypeFloat64::CandidTypeFloat64() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  double v = 0.0;
+  initialize(v);
 }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeFloat64::CandidTypeFloat64(double *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const double v = const_cast<double &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeFloat64::CandidTypeFloat64(const double v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeFloat64::~CandidTypeFloat64() {}
 
-void CandidTypeFloat64::initialize(const double &v) {}
+// Initialize things
+void CandidTypeFloat64::initialize(const double &v) {
+  if (sizeof(v) != 8) {
+    IC_API::trap(
+        "ERROR: The type double is not 8 bytes. \nThis is not yet supported.\n" +
+        std::string(__func__));
+  }
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeFloat64::set_pv(double *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeFloat64::set_pv(double *v) { m_pv = v; }
 
-void CandidTypeFloat64::set_datatype() {}
+void CandidTypeFloat64::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Float64;
+  m_datatype_hex = OpcodeHex().Float64;
+  m_datatype_textual = OpcodeTextual().Float64;
+}
 
-void CandidTypeFloat64::encode_I() {}
+void CandidTypeFloat64::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeFloat64::encode_M() {}
+void CandidTypeFloat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(z : float<N>) = f<N>(z)
+  m_M.append_float_ieee754(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeFloat64::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_float_ieee754(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeFloat64";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_int16.cpp

```diff
@@ -1,35 +1,72 @@
 // The class for the Primitive Candid Type: int16
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeInt16::CandidTypeInt16() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeInt16::CandidTypeInt16() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeInt16::CandidTypeInt16(int16_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const int16_t v = const_cast<int16_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeInt16::CandidTypeInt16(const int16_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeInt16::~CandidTypeInt16() {}
 
-void CandidTypeInt16::initialize(const int16_t &v) {}
+// Initialize things
+void CandidTypeInt16::initialize(const int16_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeInt16::set_pv(int16_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeInt16::set_pv(int16_t *v) { m_pv = v; }
 
-void CandidTypeInt16::set_datatype() {}
+void CandidTypeInt16::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Int16;
+  m_datatype_hex = OpcodeHex().Int16;
+  m_datatype_textual = OpcodeTextual().Int16;
+}
 
-void CandidTypeInt16::encode_I() {}
+void CandidTypeInt16::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeInt16::encode_M() {}
+void CandidTypeInt16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeInt16::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
+
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeInt16";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_int32.cpp

```diff
@@ -1,37 +1,72 @@
 // The class for the Primitive Candid Type: int32
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeInt32::CandidTypeInt32() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeInt32::CandidTypeInt32() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeInt32::CandidTypeInt32(int32_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const int32_t v = const_cast<int32_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeInt32::CandidTypeInt32(const int32_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-  ;
+
+  initialize(v);
 }
 
 CandidTypeInt32::~CandidTypeInt32() {}
 
-void CandidTypeInt32::initialize(const int32_t &v) {}
+// Initialize things
+void CandidTypeInt32::initialize(const int32_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeInt32::set_pv(int32_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeInt32::set_pv(int32_t *v) { m_pv = v; }
 
-void CandidTypeInt32::set_datatype() {}
+void CandidTypeInt32::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Int32;
+  m_datatype_hex = OpcodeHex().Int32;
+  m_datatype_textual = OpcodeTextual().Int32;
+}
 
-void CandidTypeInt32::encode_I() {}
+void CandidTypeInt32::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeInt32::encode_M() {}
+void CandidTypeInt32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeInt32::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
 
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeInt32";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_int64.cpp

```diff
@@ -1,35 +1,72 @@
 // The class for the Primitive Candid Type: int64
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeInt64::CandidTypeInt64() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeInt64::CandidTypeInt64() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeInt64::CandidTypeInt64(int64_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const int64_t v = const_cast<int64_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeInt64::CandidTypeInt64(const int64_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeInt64::~CandidTypeInt64() {}
 
-void CandidTypeInt64::initialize(const int64_t &v) {}
+// Initialize things
+void CandidTypeInt64::initialize(const int64_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeInt64::set_pv(int64_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeInt64::set_pv(int64_t *v) { m_pv = v; }
 
-void CandidTypeInt64::set_datatype() {}
+void CandidTypeInt64::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Int64;
+  m_datatype_hex = OpcodeHex().Int64;
+  m_datatype_textual = OpcodeTextual().Int64;
+}
 
-void CandidTypeInt64::encode_I() {}
+void CandidTypeInt64::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeInt64::encode_M() {}
+void CandidTypeInt64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeInt64::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
+
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeInt64";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_int8.cpp

```diff
@@ -1,34 +1,72 @@
 // The class for the Primitive Candid Type: int8
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeInt8::CandidTypeInt8() : CandidTypePrim() { Pro().exit_if_not_pro(); }
+CandidTypeInt8::CandidTypeInt8() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeInt8::CandidTypeInt8(int8_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const int8_t v = const_cast<int8_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeInt8::CandidTypeInt8(const int8_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeInt8::~CandidTypeInt8() {}
 
-void CandidTypeInt8::initialize(const int8_t &v) {}
+// Initialize things
+void CandidTypeInt8::initialize(const int8_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeInt8::set_pv(int8_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeInt8::set_pv(int8_t *v) { m_pv = v; }
 
-void CandidTypeInt8::set_datatype() {}
+void CandidTypeInt8::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Int8;
+  m_datatype_hex = OpcodeHex().Int8;
+  m_datatype_textual = OpcodeTextual().Int8;
+}
 
-void CandidTypeInt8::encode_I() {}
+void CandidTypeInt8::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeInt8::encode_M() {}
+void CandidTypeInt8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeInt8::decode_M(VecBytes B, __uint128_t &offset,
                               std::string &parse_error) {
 
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeInt8";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_nat.cpp

```diff
@@ -1,33 +1,72 @@
 // The class for the Primitive Candid Type: nat
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeNat::CandidTypeNat() : CandidTypePrim() { Pro().exit_if_not_pro(); }
+CandidTypeNat::CandidTypeNat() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeNat::CandidTypeNat(__uint128_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const __uint128_t v = const_cast<__uint128_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeNat::CandidTypeNat(const __uint128_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeNat::~CandidTypeNat() {}
 
-void CandidTypeNat::initialize(const __uint128_t &v) {}
+// Initialize things
+void CandidTypeNat::initialize(const __uint128_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
+// pointer to data in caller, for storing decoded value
 void CandidTypeNat::set_pv(__uint128_t *v) { m_pv = v; }
 
-void CandidTypeNat::set_datatype() {}
+void CandidTypeNat::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Nat;
+  m_datatype_hex = OpcodeHex().Nat;
+  m_datatype_textual = OpcodeTextual().Nat;
+}
 
-void CandidTypeNat::encode_I() {}
+void CandidTypeNat::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeNat::encode_M() {}
+void CandidTypeNat::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : nat)      = leb128(n)
+  m_M.append_uleb128(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeNat::decode_M(VecBytes B, __uint128_t &offset,
                              std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  if (B.parse_uleb128(offset, m_v, numbytes, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeNat";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_nat16.cpp

```diff
@@ -1,35 +1,71 @@
 // The class for the Primitive Candid Type: nat16
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeNat16::CandidTypeNat16() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeNat16::CandidTypeNat16() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeNat16::CandidTypeNat16(uint16_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const uint16_t v = const_cast<uint16_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeNat16::CandidTypeNat16(const uint16_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeNat16::~CandidTypeNat16() {}
 
-void CandidTypeNat16::initialize(const uint16_t &v) {}
+// Initialize things
+void CandidTypeNat16::initialize(const uint16_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
+// pointer to data in caller, for storing decoded value
 void CandidTypeNat16::set_pv(uint16_t *v) { m_pv = v; }
 
-void CandidTypeNat16::set_datatype() {}
+void CandidTypeNat16::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Nat16;
+  m_datatype_hex = OpcodeHex().Nat16;
+  m_datatype_textual = OpcodeTextual().Nat16;
+}
 
-void CandidTypeNat16::encode_I() {}
+void CandidTypeNat16::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeNat16::encode_M() {}
+void CandidTypeNat16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeNat16::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeNat16";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_nat32.cpp

```diff
@@ -1,35 +1,71 @@
 // The class for the Primitive Candid Type: nat32
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeNat32::CandidTypeNat32() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeNat32::CandidTypeNat32() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeNat32::CandidTypeNat32(uint32_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const uint32_t v = const_cast<uint32_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeNat32::CandidTypeNat32(const uint32_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeNat32::~CandidTypeNat32() {}
 
-void CandidTypeNat32::initialize(const uint32_t &v) {}
+// Initialize things
+void CandidTypeNat32::initialize(const uint32_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
+// pointer to data in caller, for storing decoded value
 void CandidTypeNat32::set_pv(uint32_t *v) { m_pv = v; }
 
-void CandidTypeNat32::set_datatype() {}
+void CandidTypeNat32::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Nat32;
+  m_datatype_hex = OpcodeHex().Nat32;
+  m_datatype_textual = OpcodeTextual().Nat32;
+}
 
-void CandidTypeNat32::encode_I() {}
+void CandidTypeNat32::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeNat32::encode_M() {}
+void CandidTypeNat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeNat32::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeNat32";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_nat64.cpp

```diff
@@ -1,35 +1,71 @@
 // The class for the Primitive Candid Type: nat64
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeNat64::CandidTypeNat64() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeNat64::CandidTypeNat64() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeNat64::CandidTypeNat64(uint64_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const uint64_t v = const_cast<uint64_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeNat64::CandidTypeNat64(const uint64_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeNat64::~CandidTypeNat64() {}
 
-void CandidTypeNat64::initialize(const uint64_t &v) {}
+// Initialize things
+void CandidTypeNat64::initialize(const uint64_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeNat64::set_pv(uint64_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeNat64::set_pv(uint64_t *v) { m_pv = v; }
 
-void CandidTypeNat64::set_datatype() {}
+void CandidTypeNat64::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Nat64;
+  m_datatype_hex = OpcodeHex().Nat64;
+  m_datatype_textual = OpcodeTextual().Nat64;
+}
 
-void CandidTypeNat64::encode_I() {}
+void CandidTypeNat64::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeNat64::encode_M() {}
+void CandidTypeNat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeNat64::decode_M(VecBytes B, __uint128_t &offset,
                                std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeNat64";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_nat8.cpp

```diff
@@ -1,33 +1,71 @@
 // The class for the Primitive Candid Type: nat8
 
 #include "candid.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
-CandidTypeNat8::CandidTypeNat8() : CandidTypePrim() { Pro().exit_if_not_pro(); }
+CandidTypeNat8::CandidTypeNat8() : CandidTypePrim() { initialize(0); }
 
+// This constructor allows for setting the value during Deserialization
 CandidTypeNat8::CandidTypeNat8(uint8_t *p_v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_pv(p_v);
+
+  const uint8_t v = const_cast<uint8_t &>(*p_v);
+  initialize(v);
 }
 
+// This constructor is only for encoding
 CandidTypeNat8::CandidTypeNat8(const uint8_t v) : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  initialize(v);
 }
 
 CandidTypeNat8::~CandidTypeNat8() {}
 
-void CandidTypeNat8::initialize(const uint8_t &v) {}
+// Initialize things
+void CandidTypeNat8::initialize(const uint8_t &v) {
+  m_v = v;
+  set_datatype();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeNat8::set_pv(uint8_t *v) {}
+// pointer to data in caller, for storing decoded value
+void CandidTypeNat8::set_pv(uint8_t *v) { m_pv = v; }
 
-void CandidTypeNat8::set_datatype() {}
+void CandidTypeNat8::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Nat8;
+  m_datatype_hex = OpcodeHex().Nat8;
+  m_datatype_textual = OpcodeTextual().Nat8;
+}
 
-void CandidTypeNat8::encode_I() {}
+void CandidTypeNat8::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeNat8::encode_M() {}
+void CandidTypeNat8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  m_M.append_int_fixed_width(m_v);
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeNat8::decode_M(VecBytes B, __uint128_t &offset,
                               std::string &parse_error) {
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  if (B.parse_int_fixed_width(offset, m_v, parse_error)) {
+    std::string to_be_parsed = "Value for CandidTypeNat8";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_null.h

```diff
@@ -8,12 +8,14 @@
 public:
   // Constructors
   CandidTypeNull();
 
   // Destructor
   ~CandidTypeNull();
 
+  std::string get_v() { return "NULL_VALUE"; }
+
 protected:
   void set_datatype();
   void encode_I();
   void encode_M();
 };
```

## icpp/ic/candid/candid_type_opt_base.cpp

```diff
@@ -4,25 +4,61 @@
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 #include "pro.h"
 
-CandidTypeOptBase::CandidTypeOptBase() : CandidTypeBase() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeOptBase::CandidTypeOptBase() : CandidTypeBase() {}
 
 CandidTypeOptBase::~CandidTypeOptBase() {}
 
-void CandidTypeOptBase::initialize() {}
+// Initialize things
+void CandidTypeOptBase::initialize() {
+  set_datatype();
+  set_content_type();
+  encode_T();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeOptBase::set_datatype() {}
+void CandidTypeOptBase::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Opt;
+  m_datatype_hex = OpcodeHex().Opt;
+  m_datatype_textual = OpcodeTextual().Opt;
+}
 
-void CandidTypeOptBase::encode_T() {}
+// build the type table encoding
+void CandidTypeOptBase::encode_T() {
+  m_T.append_byte((std::byte)m_datatype_hex);
+  m_T.append_byte((std::byte)m_content_type_hex);
+}
 
+// Decode the type table, starting at & updating offset
 bool CandidTypeOptBase::decode_T(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  __uint128_t len = B.size() - offset;
+
+  // The opcode for content type
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  __int128_t content_type;
+  __uint128_t numbytes;
+  if (B.parse_sleb128(offset, content_type, numbytes, parse_error)) {
+    std::string to_be_parsed = "Type table: a Opt's content type";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_content_type_opcode = int(content_type);
   return false;
 }
 
-void CandidTypeOptBase::encode_I() {}
+// For opts, we set the Opcode, but note that it is not used during serialization.
+// At serialization time, we use the index in the overall type table.
+//
+// Encode the datatype
+// https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+// For <constype>: the negative Opcode
+void CandidTypeOptBase::encode_I() {
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
```

## icpp/ic/candid/candid_type_opt_bool.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptBool::CandidTypeOptBool() : CandidTypeOptBase() {}
+CandidTypeOptBool::CandidTypeOptBool() : CandidTypeOptBase() {
+  std::optional<bool> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptBool::CandidTypeOptBool(std::optional<bool> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<bool> v = const_cast<std::optional<bool> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptBool::CandidTypeOptBool(const std::optional<bool> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptBool::~CandidTypeOptBool() {}
 
-void CandidTypeOptBool::set_content_type() {}
-
-void CandidTypeOptBool::encode_M() {}
+void CandidTypeOptBool::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Bool;
+  m_content_type_hex = OpcodeHex().Bool;
+  m_content_type_textual = OpcodeTextual().Bool;
+}
+
+void CandidTypeOptBool::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_uleb128(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptBool::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    offset_start = offset;
+    parse_error = "";
+    CandidTypeBool c{}; // dummy so we can use it's decode_M
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeBool";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = c.get_v();
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_bool.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptBool(std::optional<bool> *p_v);
 
   // Destructor
   ~CandidTypeOptBool();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<bool> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<bool> *v) { m_pv = v; }
   void set_v(const std::optional<bool> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_float32.cpp

```diff
@@ -5,27 +5,86 @@
 
 #include <cassert>
 
 #include "ic_api.h"
 
 CandidTypeOptFloat32::CandidTypeOptFloat32() : CandidTypeOptBase() {
   std::optional<float> v;
+  set_v(v);
+  initialize();
 }
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptFloat32::CandidTypeOptFloat32(std::optional<float> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<float> v = const_cast<std::optional<float> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptFloat32::CandidTypeOptFloat32(const std::optional<float> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptFloat32::~CandidTypeOptFloat32() {}
 
-void CandidTypeOptFloat32::set_content_type() {}
+void CandidTypeOptFloat32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Float32;
+  m_content_type_hex = OpcodeHex().Float32;
+  m_content_type_textual = OpcodeTextual().Float32;
+}
 
-void CandidTypeOptFloat32::encode_M() {}
+void CandidTypeOptFloat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_float_ieee754(m_v.value());
+  }
+}
 
 // Decode the values, starting at & updating offset
 bool CandidTypeOptFloat32::decode_M(VecBytes B, __uint128_t &offset,
                                     std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    float v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_float_ieee754(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeFloat32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
 
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_float32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptFloat32(std::optional<float> *p_v);
 
   // Destructor
   ~CandidTypeOptFloat32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<float> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<float> *v) { m_pv = v; }
   void set_v(const std::optional<float> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_float64.cpp

```diff
@@ -5,25 +5,86 @@
 
 #include <cassert>
 
 #include "ic_api.h"
 
 CandidTypeOptFloat64::CandidTypeOptFloat64() : CandidTypeOptBase() {
   std::optional<double> v;
+  set_v(v);
+  initialize();
 }
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptFloat64::CandidTypeOptFloat64(std::optional<double> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<double> v = const_cast<std::optional<double> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptFloat64::CandidTypeOptFloat64(const std::optional<double> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptFloat64::~CandidTypeOptFloat64() {}
 
-void CandidTypeOptFloat64::set_content_type() {}
+void CandidTypeOptFloat64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Float64;
+  m_content_type_hex = OpcodeHex().Float64;
+  m_content_type_textual = OpcodeTextual().Float64;
+}
 
-void CandidTypeOptFloat64::encode_M() {}
+void CandidTypeOptFloat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_float_ieee754(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptFloat64::decode_M(VecBytes B, __uint128_t &offset,
                                     std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    double v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_float_ieee754(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeFloat64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_float64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptFloat64(std::optional<double> *p_v);
 
   // Destructor
   ~CandidTypeOptFloat64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<double> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<double> *v) { m_pv = v; }
   void set_v(const std::optional<double> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_int.cpp

```diff
@@ -3,25 +3,90 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptInt::CandidTypeOptInt() : CandidTypeOptBase() {}
+CandidTypeOptInt::CandidTypeOptInt() : CandidTypeOptBase() {
+  std::optional<__int128_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptInt::CandidTypeOptInt(std::optional<__int128_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<__int128_t> v =
+      const_cast<std::optional<__int128_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptInt::CandidTypeOptInt(const std::optional<__int128_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptInt::~CandidTypeOptInt() {}
 
-void CandidTypeOptInt::set_content_type() {}
-
-void CandidTypeOptInt::encode_M() {}
+void CandidTypeOptInt::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int;
+  m_content_type_hex = OpcodeHex().Int;
+  m_content_type_textual = OpcodeTextual().Int;
+}
+
+void CandidTypeOptInt::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_sleb128(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptInt::decode_M(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    __int128_t v;
+    offset_start = offset;
+    __uint128_t numbytes;
+    parse_error = "";
+    if (B.parse_sleb128(offset, v, numbytes, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeInt";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_int.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptInt(std::optional<__int128_t> *p_v);
 
   // Destructor
   ~CandidTypeOptInt();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<__int128_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<__int128_t> *v) { m_pv = v; }
   void set_v(const std::optional<__int128_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_int16.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptInt16::CandidTypeOptInt16() : CandidTypeOptBase() {}
+CandidTypeOptInt16::CandidTypeOptInt16() : CandidTypeOptBase() {
+  std::optional<int16_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptInt16::CandidTypeOptInt16(std::optional<int16_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<int16_t> v = const_cast<std::optional<int16_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptInt16::CandidTypeOptInt16(const std::optional<int16_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptInt16::~CandidTypeOptInt16() {}
 
-void CandidTypeOptInt16::set_content_type() {}
-
-void CandidTypeOptInt16::encode_M() {}
+void CandidTypeOptInt16::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int16;
+  m_content_type_hex = OpcodeHex().Int16;
+  m_content_type_textual = OpcodeTextual().Int16;
+}
+
+void CandidTypeOptInt16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptInt16::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    int16_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeInt16";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_int16.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptInt16(std::optional<int16_t> *p_v);
 
   // Destructor
   ~CandidTypeOptInt16();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<int16_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<int16_t> *v) { m_pv = v; }
   void set_v(const std::optional<int16_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_int32.cpp

```diff
@@ -3,26 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptInt32::CandidTypeOptInt32() : CandidTypeOptBase() {}
+CandidTypeOptInt32::CandidTypeOptInt32() : CandidTypeOptBase() {
+  std::optional<int32_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptInt32::CandidTypeOptInt32(std::optional<int32_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<int32_t> v = const_cast<std::optional<int32_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptInt32::CandidTypeOptInt32(const std::optional<int32_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptInt32::~CandidTypeOptInt32() {}
 
-void CandidTypeOptInt32::set_content_type() {}
-
-void CandidTypeOptInt32::encode_M() {}
+void CandidTypeOptInt32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int32;
+  m_content_type_hex = OpcodeHex().Int32;
+  m_content_type_textual = OpcodeTextual().Int32;
+}
+
+void CandidTypeOptInt32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
 // Decode the values, starting at & updating offset
 bool CandidTypeOptInt32::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    int32_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeInt32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_int32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptInt32(std::optional<int32_t> *p_v);
 
   // Destructor
   ~CandidTypeOptInt32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<int32_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<int32_t> *v) { m_pv = v; }
   void set_v(const std::optional<int32_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_int64.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptInt64::CandidTypeOptInt64() : CandidTypeOptBase() {}
+CandidTypeOptInt64::CandidTypeOptInt64() : CandidTypeOptBase() {
+  std::optional<int64_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptInt64::CandidTypeOptInt64(std::optional<int64_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<int64_t> v = const_cast<std::optional<int64_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptInt64::CandidTypeOptInt64(const std::optional<int64_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptInt64::~CandidTypeOptInt64() {}
 
-void CandidTypeOptInt64::set_content_type() {}
-
-void CandidTypeOptInt64::encode_M() {}
+void CandidTypeOptInt64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int64;
+  m_content_type_hex = OpcodeHex().Int64;
+  m_content_type_textual = OpcodeTextual().Int64;
+}
+
+void CandidTypeOptInt64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptInt64::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    int64_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeInt64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_int64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptInt64(std::optional<int64_t> *p_v);
 
   // Destructor
   ~CandidTypeOptInt64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<int64_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<int64_t> *v) { m_pv = v; }
   void set_v(const std::optional<int64_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_int8.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptInt8::CandidTypeOptInt8() : CandidTypeOptBase() {}
+CandidTypeOptInt8::CandidTypeOptInt8() : CandidTypeOptBase() {
+  std::optional<int8_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptInt8::CandidTypeOptInt8(std::optional<int8_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<int8_t> v = const_cast<std::optional<int8_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptInt8::CandidTypeOptInt8(const std::optional<int8_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptInt8::~CandidTypeOptInt8() {}
 
-void CandidTypeOptInt8::set_content_type() {}
-
-void CandidTypeOptInt8::encode_M() {}
+void CandidTypeOptInt8::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int8;
+  m_content_type_hex = OpcodeHex().Int8;
+  m_content_type_textual = OpcodeTextual().Int8;
+}
+
+void CandidTypeOptInt8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptInt8::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    int8_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeInt8";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_int8.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptInt8(std::optional<int8_t> *p_v);
 
   // Destructor
   ~CandidTypeOptInt8();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<int8_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<int8_t> *v) { m_pv = v; }
   void set_v(const std::optional<int8_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_nat.cpp

```diff
@@ -3,25 +3,90 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptNat::CandidTypeOptNat() : CandidTypeOptBase() {}
+CandidTypeOptNat::CandidTypeOptNat() : CandidTypeOptBase() {
+  std::optional<__uint128_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptNat::CandidTypeOptNat(std::optional<__uint128_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<__uint128_t> v =
+      const_cast<std::optional<__uint128_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptNat::CandidTypeOptNat(const std::optional<__uint128_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptNat::~CandidTypeOptNat() {}
 
-void CandidTypeOptNat::set_content_type() {}
-
-void CandidTypeOptNat::encode_M() {}
+void CandidTypeOptNat::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat;
+  m_content_type_hex = OpcodeHex().Nat;
+  m_content_type_textual = OpcodeTextual().Nat;
+}
+
+void CandidTypeOptNat::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_uleb128(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptNat::decode_M(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    __uint128_t v;
+    offset_start = offset;
+    __uint128_t numbytes;
+    parse_error = "";
+    if (B.parse_uleb128(offset, v, numbytes, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeNat";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_nat.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptNat(std::optional<__uint128_t> *p_v);
 
   // Destructor
   ~CandidTypeOptNat();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<__uint128_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<__uint128_t> *v) { m_pv = v; }
   void set_v(const std::optional<__uint128_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_nat16.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptNat16::CandidTypeOptNat16() : CandidTypeOptBase() {}
+CandidTypeOptNat16::CandidTypeOptNat16() : CandidTypeOptBase() {
+  std::optional<uint16_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptNat16::CandidTypeOptNat16(std::optional<uint16_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<uint16_t> v = const_cast<std::optional<uint16_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptNat16::CandidTypeOptNat16(const std::optional<uint16_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptNat16::~CandidTypeOptNat16() {}
 
-void CandidTypeOptNat16::set_content_type() {}
-
-void CandidTypeOptNat16::encode_M() {}
+void CandidTypeOptNat16::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat16;
+  m_content_type_hex = OpcodeHex().Nat16;
+  m_content_type_textual = OpcodeTextual().Nat16;
+}
+
+void CandidTypeOptNat16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptNat16::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    uint16_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeNat16";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_nat16.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptNat16(std::optional<uint16_t> *p_v);
 
   // Destructor
   ~CandidTypeOptNat16();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<uint16_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<uint16_t> *v) { m_pv = v; }
   void set_v(const std::optional<uint16_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_nat32.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptNat32::CandidTypeOptNat32() : CandidTypeOptBase() {}
+CandidTypeOptNat32::CandidTypeOptNat32() : CandidTypeOptBase() {
+  std::optional<uint32_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptNat32::CandidTypeOptNat32(std::optional<uint32_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<uint32_t> v = const_cast<std::optional<uint32_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptNat32::CandidTypeOptNat32(const std::optional<uint32_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptNat32::~CandidTypeOptNat32() {}
 
-void CandidTypeOptNat32::set_content_type() {}
-
-void CandidTypeOptNat32::encode_M() {}
+void CandidTypeOptNat32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat32;
+  m_content_type_hex = OpcodeHex().Nat32;
+  m_content_type_textual = OpcodeTextual().Nat32;
+}
+
+void CandidTypeOptNat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptNat32::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    uint32_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeNat32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_nat32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptNat32(std::optional<uint32_t> *p_v);
 
   // Destructor
   ~CandidTypeOptNat32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<uint32_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<uint32_t> *v) { m_pv = v; }
   void set_v(const std::optional<uint32_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_nat64.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptNat64::CandidTypeOptNat64() : CandidTypeOptBase() {}
+CandidTypeOptNat64::CandidTypeOptNat64() : CandidTypeOptBase() {
+  std::optional<uint64_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptNat64::CandidTypeOptNat64(std::optional<uint64_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<uint64_t> v = const_cast<std::optional<uint64_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptNat64::CandidTypeOptNat64(const std::optional<uint64_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptNat64::~CandidTypeOptNat64() {}
 
-void CandidTypeOptNat64::set_content_type() {}
-
-void CandidTypeOptNat64::encode_M() {}
+void CandidTypeOptNat64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat64;
+  m_content_type_hex = OpcodeHex().Nat64;
+  m_content_type_textual = OpcodeTextual().Nat64;
+}
+
+void CandidTypeOptNat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptNat64::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    uint64_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeNat64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_nat64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptNat64(std::optional<uint64_t> *p_v);
 
   // Destructor
   ~CandidTypeOptNat64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<uint64_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<uint64_t> *v) { m_pv = v; }
   void set_v(const std::optional<uint64_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_nat8.cpp

```diff
@@ -3,25 +3,88 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptNat8::CandidTypeOptNat8() : CandidTypeOptBase() {}
+CandidTypeOptNat8::CandidTypeOptNat8() : CandidTypeOptBase() {
+  std::optional<uint8_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptNat8::CandidTypeOptNat8(std::optional<uint8_t> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<uint8_t> v = const_cast<std::optional<uint8_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptNat8::CandidTypeOptNat8(const std::optional<uint8_t> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptNat8::~CandidTypeOptNat8() {}
 
-void CandidTypeOptNat8::set_content_type() {}
-
-void CandidTypeOptNat8::encode_M() {}
+void CandidTypeOptNat8::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat8;
+  m_content_type_hex = OpcodeHex().Nat8;
+  m_content_type_textual = OpcodeTextual().Nat8;
+}
+
+void CandidTypeOptNat8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+    m_M.append_int_fixed_width(m_v.value());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeOptNat8::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    uint8_t v;
+    offset_start = offset;
+    parse_error = "";
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeNat8";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = v;
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_nat8.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptNat8(std::optional<uint8_t> *p_v);
 
   // Destructor
   ~CandidTypeOptNat8();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<uint8_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<uint8_t> *v) { m_pv = v; }
   void set_v(const std::optional<uint8_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_principal.cpp

```diff
@@ -3,27 +3,94 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptPrincipal::CandidTypeOptPrincipal() : CandidTypeOptBase() {}
+CandidTypeOptPrincipal::CandidTypeOptPrincipal() : CandidTypeOptBase() {
+  std::optional<std::string> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptPrincipal::CandidTypeOptPrincipal(std::optional<std::string> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
 
+  const std::optional<std::string> v =
+      const_cast<std::optional<std::string> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeOptPrincipal::CandidTypeOptPrincipal(
     const std::optional<std::string> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptPrincipal::~CandidTypeOptPrincipal() {}
 
-void CandidTypeOptPrincipal::set_content_type() {}
-
-void CandidTypeOptPrincipal::encode_M() {}
+void CandidTypeOptPrincipal::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Principal;
+  m_content_type_hex = OpcodeHex().Principal;
+  m_content_type_textual = OpcodeTextual().Principal;
+}
+
+void CandidTypeOptPrincipal::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+
+    std::string s = m_v.value();
+    CandidTypePrincipal c{s};
+    VecBytes m = c.get_M();
+    m_M.append_bytes(m.vec_uint8_t().data(), m.size());
+  }
+}
 
 // Decode the values, starting at & updating offset
 bool CandidTypeOptPrincipal::decode_M(VecBytes B, __uint128_t &offset,
                                       std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    offset_start = offset;
+    parse_error = "";
+    CandidTypePrincipal c{}; // dummy so we can use it's decode_M
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypePrincipal";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = c.get_v();
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_principal.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptPrincipal(std::optional<std::string> *p_v);
 
   // Destructor
   ~CandidTypeOptPrincipal();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<std::string> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<std::string> *v) { m_pv = v; }
   void set_v(const std::optional<std::string> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_opt_text.cpp

```diff
@@ -3,27 +3,97 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeOptText::CandidTypeOptText() : CandidTypeOptBase() {}
+CandidTypeOptText::CandidTypeOptText() : CandidTypeOptBase() {
+  std::optional<std::string> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeOptText::CandidTypeOptText(std::optional<std::string> *p_v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_pv(p_v);
+
+  const std::optional<std::string> v =
+      const_cast<std::optional<std::string> &>(*p_v);
+  set_v(v);
+  initialize();
+}
 
 // These constructors are only for encoding
 CandidTypeOptText::CandidTypeOptText(const std::optional<std::string> v)
-    : CandidTypeOptBase() {}
+    : CandidTypeOptBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeOptText::~CandidTypeOptText() {}
 
-void CandidTypeOptText::set_content_type() {}
-
-void CandidTypeOptText::encode_M() {}
+void CandidTypeOptText::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Text;
+  m_content_type_hex = OpcodeHex().Text;
+  m_content_type_textual = OpcodeTextual().Text;
+}
+
+void CandidTypeOptText::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  if (!m_v.has_value()) {
+    m_M.append_int_fixed_width(uint8_t{0});
+  } else {
+    m_M.append_int_fixed_width(uint8_t{1});
+
+    std::string s = m_v.value();
+    // encoded size of string - leb128(|utf8(t)|)
+    m_M.append_uleb128(__uint128_t(s.size()));
+
+    // encoded string - i8*(utf8(t))
+    for (char const &c : s) {
+      m_M.append_byte((std::byte)c);
+    }
+  }
+}
 
 // Decode the values, starting at & updating offset
 bool CandidTypeOptText::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(null : opt <datatype>) = i8(0)
+  // M(?v   : opt <datatype>) = i8(1) M(v : <datatype>)
+
+  // get tag of opt - i8(0)
+  // this will also work if there is a null on the wire.
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  uint8_t tag;
+  if (B.parse_int_fixed_width(offset, tag, parse_error)) {
+    std::string to_be_parsed = "Opt tag.";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+  if (tag == 1) {
+    offset_start = offset;
+    parse_error = "";
+    CandidTypeText c{}; // dummy so we can use it's decode_M
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Opt: Value for CandidTypeText";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v = c.get_v();
+
+  } else if (tag != 0) {
+    IC_API::trap("ERROR: tag in Opt coming from wire is not 0 or 1");
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_opt_text.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeOptText(std::optional<std::string> *p_v);
 
   // Destructor
   ~CandidTypeOptText();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::optional<std::string> get_v() { return m_v; }
 
 protected:
   void set_pv(std::optional<std::string> *v) { m_pv = v; }
   void set_v(const std::optional<std::string> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_record.cpp

```diff
@@ -7,40 +7,294 @@
 #include "ic_api.h"
 
 #include <algorithm>
 #include <cassert>
 #include <utility>
 
 CandidTypeRecord::CandidTypeRecord() : CandidTypeBase() {
-  Pro().exit_if_not_pro();
+
+  set_datatype();
+  encode_T();
+  encode_I();
+  encode_M();
 }
 
 CandidTypeRecord::~CandidTypeRecord() {}
 
-void CandidTypeRecord::set_datatype() {}
+void CandidTypeRecord::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Record;
+  m_datatype_hex = OpcodeHex().Record;
+  m_datatype_textual = OpcodeTextual().Record;
+}
 
-void CandidTypeRecord::append(uint32_t field_id, CandidType field) {}
+// Tuple notation with uint32_t field_id
+void CandidTypeRecord::append(uint32_t field_id, CandidType field) {
+  std::string s = "";
+  _append(field_id, s, field);
+}
 
-void CandidTypeRecord::append(std::string field_name, CandidType field) {}
+// Record notation with string name -> hash name into uint32_t field_id
+void CandidTypeRecord::append(std::string field_name, CandidType field) {
+  uint32_t field_id = idl_hash(field_name);
+  _append(field_id, field_name, field);
+}
 
-void CandidTypeRecord::append(CandidType field) {}
+// Tuple notation without field_id -> generate sequential uint32_t field_id
+void CandidTypeRecord::append(CandidType field) {
+  if (m_fields.size() == 0) {
+    uint32_t field_id = 0;
+    append(field_id, field);
+  }
+
+  if (std::in_range<std::uint32_t>(m_field_ids.back() + 1)) {
+    uint32_t field_id = m_field_ids.back() + 1;
+    append(field_id, field);
+  } else {
+    std::string msg;
+    msg.append("ERROR: field_id outside range of uint32_t\n");
+    msg.append("       id of previous field in record: " +
+               std::to_string(m_field_ids.back()) + "\n");
+    msg.append(
+        "       because no field_id was specified for current field, we want to increase it by 1");
+    IC_API::trap(msg);
+  }
+}
 
 void CandidTypeRecord::_append(uint32_t field_id, std::string field_name,
-                               CandidType field) {}
+                               CandidType field) {
+  // Check if field with identical hash already exists
+  auto iter = std::find(begin(m_field_ids), end(m_field_ids), field_id);
+  if (iter != end(m_field_ids)) {
+    auto i = std::distance(begin(m_field_ids), iter);
+    std::string msg;
+    msg.append("ERROR: record already has a field with the same field_id.\n");
+    msg.append("       field id (hash): " + std::to_string(field_id) + "\n");
+    msg.append("       field name 1   : " + m_field_names[i] + "\n");
+    msg.append("       field name 2   : " + field_name + "\n");
+    IC_API::trap(msg);
+  }
+
+  // Add the field
+  m_field_ids.push_back(field_id);
+  m_field_names.push_back(field_name);
+  int datatype =
+      std::visit([](auto &&c) { return c.get_datatype_opcode(); }, field);
+  m_field_datatypes.push_back(datatype);
+  m_fields.push_back(field);
+
+  // Sort by field_id (hash)
+  for (std::size_t i = 0; i < m_field_ids.size(); ++i) {
+    for (std::size_t j = i + 1; j < m_field_ids.size(); ++j) {
+      if (m_field_ids[i] > m_field_ids[j]) {
+        auto temp_field_id = std::move(m_field_ids[i]);
+        m_field_ids[i] = std::move(m_field_ids[j]);
+        m_field_ids[j] = std::move(temp_field_id);
+
+        auto temp_field_name = std::move(m_field_names[i]);
+        m_field_names[i] = std::move(m_field_names[j]);
+        m_field_names[j] = std::move(temp_field_name);
+
+        auto temp_field = std::move(m_fields[i]);
+        m_fields[i] = std::move(m_fields[j]);
+        m_fields[j] = std::move(temp_field);
+
+        auto temp_field_datatype = std::move(m_field_datatypes[i]);
+        m_field_datatypes[i] = std::move(m_field_datatypes[j]);
+        m_field_datatypes[j] = std::move(temp_field_datatype);
+      }
+    }
+  }
+
+  encode_T();
+  encode_M();
+}
 
-void CandidTypeRecord::encode_T() {}
+// (re-)build the type table encoding
+void CandidTypeRecord::encode_T() {
+  m_T.clear();
+
+  m_T.append_byte((std::byte)m_datatype_hex);
+  m_T.append_uleb128(__uint128_t(m_fields.size()));
+  for (size_t i = 0; i < m_fields.size(); ++i) {
+    // id or hash of the record field, append without packing into a fixed width
+    m_T.append_uleb128(__uint128_t(m_field_ids[i]));
+
+    // data type of the record field
+    VecBytes I = std::visit([](auto &&c) { return c.get_I(); }, m_fields[i]);
+    for (std::byte b : I.vec()) {
+      m_T.append_byte(b);
+    }
+  }
+}
 
+// Decode the type table, starting at & updating offset
 bool CandidTypeRecord::decode_T(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  m_field_ids.clear();
+  m_field_names.clear();
+  m_fields.clear();
+  m_field_datatypes.clear();
+
+  __uint128_t num_fields;
+  __uint128_t numbytes;
+  if (B.parse_uleb128(offset, num_fields, numbytes, parse_error)) {
+    return true;
+  }
+
+  for (size_t i = 0; i < num_fields; ++i) {
+    // id or hash of the record field
+    __uint128_t field_id;
+    __uint128_t numbytes;
+    if (B.parse_uleb128(offset, field_id, numbytes, parse_error)) {
+      return true;
+    }
+    m_field_ids.push_back(field_id);
+    m_field_names.push_back("");
+
+    // Get the datatype of the type table
+    __uint128_t offset_start = offset;
+    std::string parse_error;
+    __int128_t datatype;
+    numbytes = 0;
+    if (B.parse_sleb128(offset, datatype, numbytes, parse_error)) {
+      std::string to_be_parsed = "Type table: datatype";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_field_datatypes.push_back(int(datatype));
+
+    // Create a CandidType instance for the field
+    CandidType c;
+    if (int(datatype) == CandidOpcode().Vec) {
+      // for a Vec, the typetable is simple the datatype of it's content
+      offset_start = offset;
+      parse_error = "";
+      __int128_t content_opcode;
+      if (B.parse_sleb128(offset, content_opcode, numbytes, parse_error)) {
+        std::string to_be_parsed =
+            "Type table: a record field of type Vec -> the Vec's content type";
+        CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                                 to_be_parsed, parse_error);
+      }
+      CandidOpcode().candid_type_vec_from_opcode(c, content_opcode);
+    } else if (int(datatype) == CandidOpcode().Opt) {
+      // for an Opt, the typetable is simple the datatype of it's content
+      offset_start = offset;
+      parse_error = "";
+      __int128_t content_opcode;
+      if (B.parse_sleb128(offset, content_opcode, numbytes, parse_error)) {
+        std::string to_be_parsed =
+            "Type table: a record field of type Opt -> the Opt's content type";
+        CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                                 to_be_parsed, parse_error);
+      }
+      CandidOpcode().candid_type_opt_from_opcode(c, content_opcode);
+    } else {
+      // Decode type table using the CandidType variant's decode_T method.
+      CandidOpcode().candid_type_from_opcode(c, datatype);
+      parse_error = "";
+      if (std::visit(
+              [&](auto &&c) { return c.decode_T(B, offset, parse_error); },
+              c)) {
+        std::string to_be_parsed = "Type table: record field";
+        CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                                 to_be_parsed, parse_error);
+      }
+    }
+    // Store the CandidType in m_fields vector
+    m_fields.push_back(c);
+  }
   return false;
 }
 
-void CandidTypeRecord::encode_I() {}
+// For records, we set the Opcode, but note that it is not used during serialization.
+// At serialization time, we use the index in the overall type table.
+//
+// Encode the datatype
+// https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+// For <constype>: the negative Opcode
+void CandidTypeRecord::encode_I() {
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeRecord::encode_M() {}
+// (re-)build the value encoding
+void CandidTypeRecord::encode_M() {
+  m_M.clear();
+
+  for (CandidType field : m_fields) {
+    VecBytes M = std::visit([](auto &&c) { return c.get_M(); }, field);
+    for (std::byte b : M.vec()) {
+      m_M.append_byte(b);
+    }
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeRecord::decode_M(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  for (size_t i = 0; i < m_fields.size(); ++i) {
+    if (m_field_datatypes_wire[i] == CandidOpcode().Null) {
+      // There is no value to decode
+      continue;
+    }
+    int datatype = m_field_datatypes[i];
+    if (CandidOpcode().is_primtype(datatype)) {
+      parse_error = "";
+      __uint128_t offset_start = offset;
+      if (std::visit(
+              [&](auto &&c) { return c.decode_M(B, offset, parse_error); },
+              m_fields[i])) {
+        std::string to_be_parsed = "Value for a Record field";
+        CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                                 to_be_parsed, parse_error);
+      }
+    } else {
+      IC_API::trap(
+          "TODO: Implement decode for non primitive type as a record field, using recursion " +
+          std::to_string(datatype) + std::string(__func__));
+    }
+  }
+
   return false;
 }
 
-void CandidTypeRecord::check_type_table(const CandidTypeRecord *p_from_wire) {}
+// Traps if the type table does not match the type table on the wire
+void CandidTypeRecord::check_type_table(const CandidTypeRecord *p_from_wire) {
+  m_field_datatypes_wire.clear();
+  for (size_t i = 0; i < m_fields.size(); ++i) {
+    // id or hash of the record field
+    uint32_t id = m_field_ids[i];
+    uint32_t id_wire = p_from_wire->m_field_ids[i];
+    if (id != id_wire) {
+      std::string msg;
+      msg.append("ERROR: the hashed id for the Record field at index " +
+                 std::to_string(i) + " is wrong on the wire.\n");
+      msg.append("       expected value of the hashed id: " +
+                 std::to_string(id) + " (" + m_field_names[i] + ")" + "\n");
+      msg.append("       found on wire  : " + std::to_string(id_wire) + "\n");
+      IC_API::trap(msg);
+    }
+
+    int datatype = m_field_datatypes[i];
+    int datatype_wire = p_from_wire->m_field_datatypes[i];
+    m_field_datatypes_wire.push_back(
+        datatype_wire); // save it for use in decode_M
+
+    if (datatype != datatype_wire) {
+      if (datatype_wire == CandidOpcode().Null &&
+          datatype == CandidOpcode().Opt) {
+        // This is ok. A null is passed for an Opt
+      } else {
+        std::string msg;
+        msg.append("ERROR: the datatype for the Record field at index " +
+                   std::to_string(i) + " is wrong on the wire.\n");
+        msg.append("       expected datatype: " + std::to_string(datatype) +
+                   " (" + CandidOpcode().name_from_opcode(datatype) + ")" +
+                   "\n");
+        msg.append("       type on wire : " + std::to_string(datatype_wire) +
+                   " (" + CandidOpcode().name_from_opcode(datatype_wire) + ")" +
+                   "\n");
+        IC_API::trap(msg);
+      }
+    }
+  }
+}
```

## icpp/ic/candid/candid_type_record.h

```diff
@@ -16,14 +16,17 @@
 
   void append(uint32_t field_id, CandidType field);
   void append(std::string field_name, CandidType field);
   void append(CandidType field);
 
   bool decode_T(VecBytes B, __uint128_t &offset, std::string &parse_error);
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<std::string> get_v() { return m_field_names; }
+  std::vector<uint32_t> get_field_ids() { return m_field_ids; }
+  std::vector<std::string> get_field_names() { return m_field_names; }
 
   void check_type_table(const CandidTypeRecord *p_from_wire);
 
 protected:
   void _append(uint32_t field_id, std::string field_name, CandidType field);
 
   void set_datatype();
```

## icpp/ic/candid/candid_type_reserved.cpp

```diff
@@ -3,22 +3,39 @@
 #include "candid.h"
 #include "ic_api.h"
 
 #include "candid_opcode.h"
 #include "pro.h"
 
 CandidTypeReserved::CandidTypeReserved() : CandidTypePrim() {
-  Pro().exit_if_not_pro();
+
+  set_datatype();
+  encode_I();
+  encode_M();
 }
 
 CandidTypeReserved::~CandidTypeReserved() {}
 
-void CandidTypeReserved::set_datatype() {}
+void CandidTypeReserved::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Reserved;
+  m_datatype_hex = OpcodeHex().Reserved;
+  m_datatype_textual = OpcodeTextual().Reserved;
+}
 
-void CandidTypeReserved::encode_I() {}
+void CandidTypeReserved::encode_I() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+  // For <primtype>: the negative Opcode
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
 
-void CandidTypeReserved::encode_M() {}
+void CandidTypeReserved::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // To be ignored
+  m_M.clear();
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeReserved::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // To be ignored
   return false;
 }
```

## icpp/ic/candid/candid_type_reserved.h

```diff
@@ -8,13 +8,14 @@
   // Constructors
   CandidTypeReserved();
 
   // Destructor
   ~CandidTypeReserved();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::string get_v() { return "RESERVED_VALUE"; }
 
 protected:
   void set_datatype();
   void encode_I();
   void encode_M();
 };
```

## icpp/ic/candid/candid_type_vec_base.cpp

```diff
@@ -4,25 +4,61 @@
 #include "candid_opcode.h"
 #include "pro.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecBase::CandidTypeVecBase() : CandidTypeBase() {
-  Pro().exit_if_not_pro();
-}
+CandidTypeVecBase::CandidTypeVecBase() : CandidTypeBase() {}
 
 CandidTypeVecBase::~CandidTypeVecBase() {}
 
-void CandidTypeVecBase::initialize() {}
+// Initialize things
+void CandidTypeVecBase::initialize() {
+  set_datatype();
+  set_content_type();
+  encode_T();
+  encode_I();
+  encode_M();
+}
 
-void CandidTypeVecBase::set_datatype() {}
+void CandidTypeVecBase::set_datatype() {
+  m_datatype_opcode = CandidOpcode().Vec;
+  m_datatype_hex = OpcodeHex().Vec;
+  m_datatype_textual = OpcodeTextual().Vec;
+}
 
-void CandidTypeVecBase::encode_T() {}
+// build the type table encoding
+void CandidTypeVecBase::encode_T() {
+  m_T.append_byte((std::byte)m_datatype_hex);
+  m_T.append_byte((std::byte)m_content_type_hex);
+}
 
+// Decode the type table, starting at & updating offset
 bool CandidTypeVecBase::decode_T(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  __uint128_t len = B.size() - offset;
+
+  // The opcode for content type
+  __uint128_t offset_start = offset;
+  parse_error = "";
+  __int128_t content_type;
+  __uint128_t numbytes;
+  if (B.parse_sleb128(offset, content_type, numbytes, parse_error)) {
+    std::string to_be_parsed = "Type table: a Vec's content type";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_content_type_opcode = int(content_type);
   return false;
 }
 
-void CandidTypeVecBase::encode_I() {}
+// For vecs, we set the Opcode, but note that it is not used during serialization.
+// At serialization time, we use the index in the overall type table.
+//
+// Encode the datatype
+// https://github.com/dfinity/candid/blob/master/spec/Candid.md#types
+// For <constype>: the negative Opcode
+void CandidTypeVecBase::encode_I() {
+  m_I.append_byte((std::byte)m_datatype_hex);
+}
```

## icpp/ic/candid/candid_type_vec_bool.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecBool::CandidTypeVecBool() : CandidTypeVecBase() {}
+CandidTypeVecBool::CandidTypeVecBool() : CandidTypeVecBase() {
+  std::vector<bool> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecBool::CandidTypeVecBool(std::vector<bool> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<bool> v = const_cast<std::vector<bool> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecBool::CandidTypeVecBool(const std::vector<bool> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecBool::~CandidTypeVecBool() {}
 
-void CandidTypeVecBool::set_content_type() {}
-
-void CandidTypeVecBool::encode_M() {}
+void CandidTypeVecBool::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Bool;
+  m_content_type_hex = OpcodeHex().Bool;
+  m_content_type_textual = OpcodeTextual().Bool;
+}
+
+void CandidTypeVecBool::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(b : bool)     = i8(if b then 1 else 0)
+  for (bool const &c : m_v) {
+    m_M.append_uleb128(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecBool::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  offset_start = offset;
+  parse_error = "";
+  CandidTypeBool c{}; // dummy so we can use it's decode_M
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeBool";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(c.get_v());
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_bool.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecBool(std::vector<bool> *p_v);
 
   // Destructor
   ~CandidTypeVecBool();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<bool> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<bool> *v) { m_pv = v; }
   void set_v(const std::vector<bool> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_float32.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecFloat32::CandidTypeVecFloat32() : CandidTypeVecBase() {}
+CandidTypeVecFloat32::CandidTypeVecFloat32() : CandidTypeVecBase() {
+  std::vector<float> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecFloat32::CandidTypeVecFloat32(std::vector<float> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<float> v = const_cast<std::vector<float> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecFloat32::CandidTypeVecFloat32(const std::vector<float> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecFloat32::~CandidTypeVecFloat32() {}
 
-void CandidTypeVecFloat32::set_content_type() {}
-
-void CandidTypeVecFloat32::encode_M() {}
+void CandidTypeVecFloat32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Float32;
+  m_content_type_hex = OpcodeHex().Float32;
+  m_content_type_textual = OpcodeTextual().Float32;
+}
+
+void CandidTypeVecFloat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(z : float<N>) = f<N>(z)
+  for (float const &c : m_v) {
+    m_M.append_float_ieee754(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecFloat32::decode_M(VecBytes B, __uint128_t &offset,
                                     std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  float v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_float_ieee754(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeFloat32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_float32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecFloat32(std::vector<float> *p_v);
 
   // Destructor
   ~CandidTypeVecFloat32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<float> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<float> *v) { m_pv = v; }
   void set_v(const std::vector<float> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_float64.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecFloat64::CandidTypeVecFloat64() : CandidTypeVecBase() {}
+CandidTypeVecFloat64::CandidTypeVecFloat64() : CandidTypeVecBase() {
+  std::vector<double> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecFloat64::CandidTypeVecFloat64(std::vector<double> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<double> v = const_cast<std::vector<double> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecFloat64::CandidTypeVecFloat64(const std::vector<double> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecFloat64::~CandidTypeVecFloat64() {}
 
-void CandidTypeVecFloat64::set_content_type() {}
-
-void CandidTypeVecFloat64::encode_M() {}
+void CandidTypeVecFloat64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Float64;
+  m_content_type_hex = OpcodeHex().Float64;
+  m_content_type_textual = OpcodeTextual().Float64;
+}
+
+void CandidTypeVecFloat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(z : float<N>) = f<N>(z)
+  for (double const &c : m_v) {
+    m_M.append_float_ieee754(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecFloat64::decode_M(VecBytes B, __uint128_t &offset,
                                     std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  double v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_float_ieee754(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeFloat64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_float64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecFloat64(std::vector<double> *p_v);
 
   // Destructor
   ~CandidTypeVecFloat64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<double> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<double> *v) { m_pv = v; }
   void set_v(const std::vector<double> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_int.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecInt::CandidTypeVecInt() : CandidTypeVecBase() {}
+CandidTypeVecInt::CandidTypeVecInt() : CandidTypeVecBase() {
+  std::vector<__int128_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecInt::CandidTypeVecInt(std::vector<__int128_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<__int128_t> v = const_cast<std::vector<__int128_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecInt::CandidTypeVecInt(const std::vector<__int128_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecInt::~CandidTypeVecInt() {}
 
-void CandidTypeVecInt::set_content_type() {}
-
-void CandidTypeVecInt::encode_M() {}
+void CandidTypeVecInt::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int;
+  m_content_type_hex = OpcodeHex().Int;
+  m_content_type_textual = OpcodeTextual().Int;
+}
+
+void CandidTypeVecInt::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(i : int)      = sleb128(i)
+  for (__int128_t const &c : m_v) {
+    m_M.append_sleb128(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecInt::decode_M(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  __int128_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_sleb128(offset, v, numbytes, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeInt";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_int.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecInt(std::vector<__int128_t> *p_v);
 
   // Destructor
   ~CandidTypeVecInt();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<__int128_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<__int128_t> *v) { m_pv = v; }
   void set_v(const std::vector<__int128_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_int16.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecInt16::CandidTypeVecInt16() : CandidTypeVecBase() {}
+CandidTypeVecInt16::CandidTypeVecInt16() : CandidTypeVecBase() {
+  std::vector<int16_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecInt16::CandidTypeVecInt16(std::vector<int16_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<int16_t> v = const_cast<std::vector<int16_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecInt16::CandidTypeVecInt16(const std::vector<int16_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecInt16::~CandidTypeVecInt16() {}
 
-void CandidTypeVecInt16::set_content_type() {}
-
-void CandidTypeVecInt16::encode_M() {}
+void CandidTypeVecInt16::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int16;
+  m_content_type_hex = OpcodeHex().Int16;
+  m_content_type_textual = OpcodeTextual().Int16;
+}
+
+void CandidTypeVecInt16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  for (int16_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecInt16::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  int16_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeInt16";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_int16.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecInt16(std::vector<int16_t> *p_v);
 
   // Destructor
   ~CandidTypeVecInt16();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<int16_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<int16_t> *v) { m_pv = v; }
   void set_v(const std::vector<int16_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_int32.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecInt32::CandidTypeVecInt32() : CandidTypeVecBase() {}
+CandidTypeVecInt32::CandidTypeVecInt32() : CandidTypeVecBase() {
+  std::vector<int32_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecInt32::CandidTypeVecInt32(std::vector<int32_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<int32_t> v = const_cast<std::vector<int32_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecInt32::CandidTypeVecInt32(const std::vector<int32_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecInt32::~CandidTypeVecInt32() {}
 
-void CandidTypeVecInt32::set_content_type() {}
-
-void CandidTypeVecInt32::encode_M() {}
+void CandidTypeVecInt32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int32;
+  m_content_type_hex = OpcodeHex().Int32;
+  m_content_type_textual = OpcodeTextual().Int32;
+}
+
+void CandidTypeVecInt32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  for (int32_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecInt32::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  int32_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeInt32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_int32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecInt32(std::vector<int32_t> *p_v);
 
   // Destructor
   ~CandidTypeVecInt32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<int32_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<int32_t> *v) { m_pv = v; }
   void set_v(const std::vector<int32_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_int64.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecInt64::CandidTypeVecInt64() : CandidTypeVecBase() {}
+CandidTypeVecInt64::CandidTypeVecInt64() : CandidTypeVecBase() {
+  std::vector<int64_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecInt64::CandidTypeVecInt64(std::vector<int64_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<int64_t> v = const_cast<std::vector<int64_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecInt64::CandidTypeVecInt64(const std::vector<int64_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecInt64::~CandidTypeVecInt64() {}
 
-void CandidTypeVecInt64::set_content_type() {}
-
-void CandidTypeVecInt64::encode_M() {}
+void CandidTypeVecInt64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int64;
+  m_content_type_hex = OpcodeHex().Int64;
+  m_content_type_textual = OpcodeTextual().Int64;
+}
+
+void CandidTypeVecInt64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  for (int64_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecInt64::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  int64_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeInt64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_int64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecInt64(std::vector<int64_t> *p_v);
 
   // Destructor
   ~CandidTypeVecInt64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<int64_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<int64_t> *v) { m_pv = v; }
   void set_v(const std::vector<int64_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_int8.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecInt8::CandidTypeVecInt8() : CandidTypeVecBase() {}
+CandidTypeVecInt8::CandidTypeVecInt8() : CandidTypeVecBase() {
+  std::vector<int8_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecInt8::CandidTypeVecInt8(std::vector<int8_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<int8_t> v = const_cast<std::vector<int8_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecInt8::CandidTypeVecInt8(const std::vector<int8_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecInt8::~CandidTypeVecInt8() {}
 
-void CandidTypeVecInt8::set_content_type() {}
-
-void CandidTypeVecInt8::encode_M() {}
+void CandidTypeVecInt8::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Int8;
+  m_content_type_hex = OpcodeHex().Int8;
+  m_content_type_textual = OpcodeTextual().Int8;
+}
+
+void CandidTypeVecInt8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(n : int<N>)   = i<N>(signed_N^-1(i))    (Litte Endian)
+  for (int8_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecInt8::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  int8_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeInt8";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_int8.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecInt8(std::vector<int8_t> *p_v);
 
   // Destructor
   ~CandidTypeVecInt8();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<int8_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<int8_t> *v) { m_pv = v; }
   void set_v(const std::vector<int8_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_nat.cpp

```diff
@@ -3,25 +3,85 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecNat::CandidTypeVecNat() : CandidTypeVecBase() {}
+CandidTypeVecNat::CandidTypeVecNat() : CandidTypeVecBase() {
+  std::vector<__uint128_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecNat::CandidTypeVecNat(std::vector<__uint128_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<__uint128_t> v =
+      const_cast<std::vector<__uint128_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecNat::CandidTypeVecNat(const std::vector<__uint128_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecNat::~CandidTypeVecNat() {}
 
-void CandidTypeVecNat::set_content_type() {}
-
-void CandidTypeVecNat::encode_M() {}
+void CandidTypeVecNat::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat;
+  m_content_type_hex = OpcodeHex().Nat;
+  m_content_type_textual = OpcodeTextual().Nat;
+}
+
+void CandidTypeVecNat::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // Nat:             - M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  for (__uint128_t const &c : m_v) {
+    m_M.append_uleb128(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecNat::decode_M(VecBytes B, __uint128_t &offset,
                                 std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  __uint128_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_uleb128(offset, v, numbytes, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeNat";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_nat.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecNat(std::vector<__uint128_t> *p_v);
 
   // Destructor
   ~CandidTypeVecNat();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<__uint128_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<__uint128_t> *v) { m_pv = v; }
   void set_v(const std::vector<__uint128_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_nat16.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecNat16::CandidTypeVecNat16() : CandidTypeVecBase() {}
+CandidTypeVecNat16::CandidTypeVecNat16() : CandidTypeVecBase() {
+  std::vector<uint16_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecNat16::CandidTypeVecNat16(std::vector<uint16_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<uint16_t> v = const_cast<std::vector<uint16_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecNat16::CandidTypeVecNat16(const std::vector<uint16_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecNat16::~CandidTypeVecNat16() {}
 
-void CandidTypeVecNat16::set_content_type() {}
-
-void CandidTypeVecNat16::encode_M() {}
+void CandidTypeVecNat16::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat16;
+  m_content_type_hex = OpcodeHex().Nat16;
+  m_content_type_textual = OpcodeTextual().Nat16;
+}
+
+void CandidTypeVecNat16::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // Nat16:             - M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  for (uint16_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecNat16::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  uint16_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeNat16";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_nat16.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecNat16(std::vector<uint16_t> *p_v);
 
   // Destructor
   ~CandidTypeVecNat16();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<uint16_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<uint16_t> *v) { m_pv = v; }
   void set_v(const std::vector<uint16_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_nat32.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecNat32::CandidTypeVecNat32() : CandidTypeVecBase() {}
+CandidTypeVecNat32::CandidTypeVecNat32() : CandidTypeVecBase() {
+  std::vector<uint32_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecNat32::CandidTypeVecNat32(std::vector<uint32_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<uint32_t> v = const_cast<std::vector<uint32_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecNat32::CandidTypeVecNat32(const std::vector<uint32_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecNat32::~CandidTypeVecNat32() {}
 
-void CandidTypeVecNat32::set_content_type() {}
-
-void CandidTypeVecNat32::encode_M() {}
+void CandidTypeVecNat32::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat32;
+  m_content_type_hex = OpcodeHex().Nat32;
+  m_content_type_textual = OpcodeTextual().Nat32;
+}
+
+void CandidTypeVecNat32::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // Nat32:             - M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  for (uint32_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecNat32::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  uint32_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeNat32";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_nat32.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecNat32(std::vector<uint32_t> *p_v);
 
   // Destructor
   ~CandidTypeVecNat32();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<uint32_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<uint32_t> *v) { m_pv = v; }
   void set_v(const std::vector<uint32_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_nat64.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecNat64::CandidTypeVecNat64() : CandidTypeVecBase() {}
+CandidTypeVecNat64::CandidTypeVecNat64() : CandidTypeVecBase() {
+  std::vector<uint64_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecNat64::CandidTypeVecNat64(std::vector<uint64_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<uint64_t> v = const_cast<std::vector<uint64_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecNat64::CandidTypeVecNat64(const std::vector<uint64_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecNat64::~CandidTypeVecNat64() {}
 
-void CandidTypeVecNat64::set_content_type() {}
-
-void CandidTypeVecNat64::encode_M() {}
+void CandidTypeVecNat64::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat64;
+  m_content_type_hex = OpcodeHex().Nat64;
+  m_content_type_textual = OpcodeTextual().Nat64;
+}
+
+void CandidTypeVecNat64::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // Nat64:             - M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  for (uint64_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecNat64::decode_M(VecBytes B, __uint128_t &offset,
                                   std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  uint64_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeNat64";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_nat64.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecNat64(std::vector<uint64_t> *p_v);
 
   // Destructor
   ~CandidTypeVecNat64();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<uint64_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<uint64_t> *v) { m_pv = v; }
   void set_v(const std::vector<uint64_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_nat8.cpp

```diff
@@ -3,25 +3,84 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecNat8::CandidTypeVecNat8() : CandidTypeVecBase() {}
+CandidTypeVecNat8::CandidTypeVecNat8() : CandidTypeVecBase() {
+  std::vector<uint8_t> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecNat8::CandidTypeVecNat8(std::vector<uint8_t> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<uint8_t> v = const_cast<std::vector<uint8_t> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecNat8::CandidTypeVecNat8(const std::vector<uint8_t> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecNat8::~CandidTypeVecNat8() {}
 
-void CandidTypeVecNat8::set_content_type() {}
-
-void CandidTypeVecNat8::encode_M() {}
+void CandidTypeVecNat8::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Nat8;
+  m_content_type_hex = OpcodeHex().Nat8;
+  m_content_type_textual = OpcodeTextual().Nat8;
+}
+
+void CandidTypeVecNat8::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // Nat8:             - M(n : nat<N>)   = i<N>(n)    (Litte Endian)
+  for (uint8_t const &c : m_v) {
+    m_M.append_int_fixed_width(c);
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecNat8::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  uint8_t v;
+  offset_start = offset;
+  parse_error = "";
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (B.parse_int_fixed_width(offset, v, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeNat8";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(v);
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_nat8.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecNat8(std::vector<uint8_t> *p_v);
 
   // Destructor
   ~CandidTypeVecNat8();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<uint8_t> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<uint8_t> *v) { m_pv = v; }
   void set_v(const std::vector<uint8_t> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_principal.cpp

```diff
@@ -3,25 +3,86 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecPrincipal::CandidTypeVecPrincipal() : CandidTypeVecBase() {}
+CandidTypeVecPrincipal::CandidTypeVecPrincipal() : CandidTypeVecBase() {
+  std::vector<std::string> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecPrincipal::CandidTypeVecPrincipal(std::vector<std::string> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<std::string> v =
+      const_cast<std::vector<std::string> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecPrincipal::CandidTypeVecPrincipal(const std::vector<std::string> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecPrincipal::~CandidTypeVecPrincipal() {}
 
-void CandidTypeVecPrincipal::set_content_type() {}
-
-void CandidTypeVecPrincipal::encode_M() {}
+void CandidTypeVecPrincipal::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Principal;
+  m_content_type_hex = OpcodeHex().Principal;
+  m_content_type_textual = OpcodeTextual().Principal;
+}
+
+void CandidTypeVecPrincipal::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  for (std::string const &s : m_v) {
+    CandidTypePrincipal c{s};
+    VecBytes m = c.get_M();
+    m_M.append_bytes(m.vec_uint8_t().data(), m.size());
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecPrincipal::decode_M(VecBytes B, __uint128_t &offset,
                                       std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  offset_start = offset;
+  parse_error = "";
+  CandidTypePrincipal c{""}; // dummy so we can use it's decode_M
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypePrincipal";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(c.get_v());
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_principal.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecPrincipal(std::vector<std::string> *p_v);
 
   // Destructor
   ~CandidTypeVecPrincipal();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<std::string> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<std::string> *v) { m_pv = v; }
   void set_v(const std::vector<std::string> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## icpp/ic/candid/candid_type_vec_text.cpp

```diff
@@ -3,25 +3,91 @@
 #include "candid.h"
 #include "candid_opcode.h"
 
 #include <cassert>
 
 #include "ic_api.h"
 
-CandidTypeVecText::CandidTypeVecText() : CandidTypeVecBase() {}
+CandidTypeVecText::CandidTypeVecText() : CandidTypeVecBase() {
+  std::vector<std::string> v;
+  set_v(v);
+  initialize();
+}
 
+// These constructors allows for setting the value during Deserialization
 CandidTypeVecText::CandidTypeVecText(std::vector<std::string> *p_v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_pv(p_v);
 
+  const std::vector<std::string> v =
+      const_cast<std::vector<std::string> &>(*p_v);
+  set_v(v);
+  initialize();
+}
+
+// These constructors are only for encoding
 CandidTypeVecText::CandidTypeVecText(const std::vector<std::string> v)
-    : CandidTypeVecBase() {}
+    : CandidTypeVecBase() {
+  set_v(v);
+  initialize();
+}
 
 CandidTypeVecText::~CandidTypeVecText() {}
 
-void CandidTypeVecText::set_content_type() {}
-
-void CandidTypeVecText::encode_M() {}
+void CandidTypeVecText::set_content_type() {
+  m_content_type_opcode = CandidOpcode().Text;
+  m_content_type_hex = OpcodeHex().Text;
+  m_content_type_textual = OpcodeTextual().Text;
+}
+
+void CandidTypeVecText::encode_M() {
+  // https://github.com/dfinity/candid/blob/master/spec/Candid.md#memory
+  // M(v^N  : vec <datatype>) = leb128(N) M(v : <datatype>)^N
+
+  // encoded size of vec - leb128(N)
+  m_M.append_uleb128(__uint128_t(m_v.size()));
+
+  // encoded vec values - M(v : <datatype>)^N
+  // M(t : text)     = leb128(|utf8(t)|) i8*(utf8(t))
+  for (std::string const &s : m_v) {
+    // encoded size of string - leb128(|utf8(t)|)
+    m_M.append_uleb128(__uint128_t(s.size()));
+
+    // encoded string - i8*(utf8(t))
+    for (char const &c : s) {
+      m_M.append_byte((std::byte)c);
+    }
+  }
+}
 
+// Decode the values, starting at & updating offset
 bool CandidTypeVecText::decode_M(VecBytes B, __uint128_t &offset,
                                  std::string &parse_error) {
+  // get size of vec - leb128(N)
+  __uint128_t offset_start = offset;
+  __uint128_t numbytes;
+  parse_error = "";
+  __uint128_t size_vec;
+  if (B.parse_uleb128(offset, size_vec, numbytes, parse_error)) {
+    std::string to_be_parsed = "Size of vec- leb128(N)";
+    CandidDeserialize::trap_with_parse_error(offset_start, offset, to_be_parsed,
+                                             parse_error);
+  }
+
+  m_v.clear();
+  offset_start = offset;
+  parse_error = "";
+  CandidTypeText c{""}; // dummy so we can use it's decode_M
+  for (size_t i = 0; i < size_vec; ++i) {
+    if (c.decode_M(B, offset, parse_error)) {
+      std::string to_be_parsed = "Vec: Value for CandidTypeText";
+      CandidDeserialize::trap_with_parse_error(offset_start, offset,
+                                               to_be_parsed, parse_error);
+    }
+    m_v.push_back(c.get_v());
+  }
+
+  // Fill the user's data placeholder, if a pointer was provided
+  if (m_pv) *m_pv = m_v;
+
   return false;
 }
```

## icpp/ic/candid/candid_type_vec_text.h

```diff
@@ -14,14 +14,15 @@
 
   CandidTypeVecText(std::vector<std::string> *p_v);
 
   // Destructor
   ~CandidTypeVecText();
 
   bool decode_M(VecBytes B, __uint128_t &offset, std::string &parse_error);
+  std::vector<std::string> get_v() { return m_v; }
 
 protected:
   void set_pv(std::vector<std::string> *v) { m_pv = v; }
   void set_v(const std::vector<std::string> &v) { m_v = v; }
   void set_content_type();
   void encode_M();
```

## Comparing `icpp_free-2.1.0.dist-info/LICENSE` & `icpp_free-2.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `icpp_free-2.1.0.dist-info/METADATA` & `icpp_free-2.2.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: icpp-free
-Version: 2.1.0
+Version: 2.2.0
 Summary: A development platform for C++ smart contracts of the Internet Computer
 Home-page: https://docs.icpp.world/
 Author: icppWorld
 Author-email: icpp@icpp.world
 License: Freemium
 Keywords: Internet Computer,C++,Smart Contracts,blockchain
 Classifier: Development Status :: 4 - Beta
@@ -31,23 +31,25 @@
 Requires-Dist: twine ; extra == 'dev'
 Requires-Dist: mkdocs ; extra == 'dev'
 Requires-Dist: types-requests ; extra == 'dev'
 
 [![icpp-free](https://github.com/icppWorld/icpp-pro/actions/workflows/cicd.yml/badge.svg)](https://github.com/icppWorld/icpp-pro/actions/workflows/cicd.yml)
 # icpp-free
 
-The free (lite) version of icpp-pro.
-
 A development platform for C++ smart contracts of the  [Internet Computer](https://internetcomputer.org/):
 
 - Develop, debug, test, deploy & smoke-test
 - Full Candid support. 
 - Linux, Mac and Windows.
 
-For licensing of icpp-pro, support contracts or consulting services, contact us at [icpp@icpp.world](mailto:icpp@icpp.world).
+You can develop & deploy any C++ Smart Contracts with `icpp-free` since it supports compilation to WebAssembly for the IC and it includes the full Candid API.
+
+To speed up your development velocity or establish a world-class testing environment, get `icpp-pro`.
+
+For licensing, support contracts or consulting services, contact us at [icpp@icpp.world](mailto:icpp@icpp.world).
 
 ## Compare icpp-free with icpp-pro
 See [docs: capability table](https://docs.icpp.world).
 
 ## Installation
```

## Comparing `icpp_free-2.1.0.dist-info/RECORD` & `icpp_free-2.2.0.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -3,151 +3,153 @@
 icpp/callbacks.py,sha256=0pXSxX2WFgvelftoyU3vVY9ya98h5U7aiOobLopqkMM,925
 icpp/commands_build_native.py,sha256=RRMXSjC7UDVuwOEojKy4X55CmQOff3PChK4zvnKBrio,711
 icpp/commands_build_wasm.py,sha256=yipu2thiuCuijdSY49Ig5KM4omwZEs4QMRgLeVBUcM0,4919
 icpp/commands_get.py,sha256=UpriQcUxFU_ahs2Niq7tDwo5d8ZArDo9NcuuYEg1xo0,1122
 icpp/commands_init.py,sha256=gL5AsNL3DqEpla9v2GVHimp7ILAWSKoZBzjbJC7G7rs,753
 icpp/commands_install_wasi_sdk.py,sha256=TRY3p9jzMhhp1G_CMqrUroh4kzQx1SF3tfselmHENg4,3584
 icpp/config_default.py,sha256=1R_F7pl7l1v9Xu1sUY0LyvTCjVu8RN3M3J7UJoHiqZI,5138
-icpp/conftest_base.py,sha256=GYlO6yPelsQFussnNBxfqs2swDRvaHXtWmh9hKSXxfM,1191
+icpp/conftest_base.py,sha256=2EqlWqxPn9954aXWwM5jr7vO6XAg6lCEniPo8UJlL7I,2306
 icpp/decorators.py,sha256=Tylu_db1W5KjfKC6nlknMfrBx_kaskksLjmIxx-18Jw,2892
 icpp/icpp_toml.py,sha256=4azeRkGyKRx7p3bin7U99NcR2zoboCyt7Ftut3HHS6A,3776
 icpp/pro.py,sha256=zI8Fz5k4csaNvRVNQegfzHrpE_LeX8WEjjyh4Nv9i6I,733
 icpp/py.typed,sha256=ZYhofmNLSj2zLe3tuB6mCBQnkX7Hw-vARfbOds4MQJI,98
-icpp/run_shell_cmd.py,sha256=EBFNA9KVGo7JigarlbeHkp3qjnHxR-WjUZAo93iB4w0,4475
-icpp/smoketest.py,sha256=rWKArfSOjczjeNvsfojvmEtuTuzOLnP8r4Yj_O8zBvM,1254
-icpp/version.py,sha256=h4AiIbsWsf7jIoYEx19AK7qjP6zvHGmGmy4bRVLs7Fg,322
+icpp/run_shell_cmd.py,sha256=km76SFWq1RgEojH3llp1Na1hP0gSNCKIBsv82bcvphk,5280
+icpp/smoketest.py,sha256=K75faRhG2JbicjDWeS5_Mr_v32vsZOXoWCYgq2hr1tg,1307
+icpp/version.py,sha256=rw9EUvid4J5cbsItAB7Xg48W8ZrjXjVJtxZ48LaZJfs,322
 icpp/version_wasi_sdk.py,sha256=XruElxEMxITxIbuH2HyHuSIrTLvQu-dNhIeZwliLv7s,272
 icpp/canisters/greet/README.md,sha256=4_7TnftpGy_nmsBWYxonMxPOp0ZlaAy-RSxG-Um-LTQ,92
 icpp/canisters/greet/dfx.json,sha256=YJgIaBigJY2m6AHAFkmpNVpiGOAUfacBWMubaGa91is,269
 icpp/canisters/greet/icpp.toml,sha256=xwT4N36kEaCxE_rg2hUY5C4Q5g8dj49VrDv5Z9Rp8SA,474
 icpp/canisters/greet/native/main.cpp,sha256=yQ4tQoFb40XWt7gt9WZDGdLmMjUpZumWAEiNyPMUgn8,2086
 icpp/canisters/greet/native/main.h,sha256=qj3nmZR11yCboge20KemBOjCnnJcUatHW6ubLIEOqF8,162
 icpp/canisters/greet/src/greet.cpp,sha256=xwAV8R9AkBwi5zwjUygqlwG0cqtVYoqt1gPPzDf-QXU,3197
 icpp/canisters/greet/src/greet.did,sha256=kanHTyY5e2_eaSgoE65cTDVil2E-PMn7afzNE4xPCKE,494
 icpp/canisters/greet/src/greet.h,sha256=ExZx5HlZliXGevcHA5qkh2jxJQOWWeGioKP7QlDoNRI,379
 icpp/canisters/greet/test/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 icpp/canisters/greet/test/conftest.py,sha256=wQiN001FDSVpOFqFA6jjZg_oRyY1E0yH4vm-1wwMS2k,298
-icpp/canisters/greet/test/test_apis.py,sha256=PCs4MB4kbaH5SxVU1zSekdkDWuR6WlMIG_ugxwyMpcs,2531
-icpp/ic/candid/candid.h,sha256=tb0QeKX9E_00ZVXT3zh0mrm43vrExYx9JjChNQguoaQ,6302
+icpp/canisters/greet/test/test_apis.py,sha256=rRuHXe3o91Joaw7D-C5HLuW4-atR4-Xd8I98fGMcdw0,2500
+icpp/ic/candid/candid.h,sha256=m_k2beHp9Z0gVPxsT_xsfRavHEtygVb9u2M6N27PwBY,6153
 icpp/ic/candid/candid_assert.cpp,sha256=LHSXEFaAGNFtbQwf8LyNzfGhrdf2C0CcRH63oiyJgmw,986
 icpp/ic/candid/candid_assert.h,sha256=f1jK0IRGVi1ANb2DGCSiq5H94-xXZ2y0XTiLfSoW0ks,335
-icpp/ic/candid/candid_deserialize.cpp,sha256=eQ-fDCIMaB4V20x2pMjCf1NFDkVC0iRZBvAAOZqF4LM,13739
+icpp/ic/candid/candid_deserialize.cpp,sha256=N2s7Y94L6uv4EMw3ur3yGR_dKYxU5_N3y2TMkAatI5Y,14028
 icpp/ic/candid/candid_deserialize.h,sha256=mPibIVNA7iO_0v0Uav7WvThMqkJXcNd1zaXYWVI8SBA,1392
-icpp/ic/candid/candid_opcode.cpp,sha256=LBlowAZ-yCUjjXhKO8RikEw1k9pxOOiaqOY1Ff1QGEY,6958
+icpp/ic/candid/candid_opcode.cpp,sha256=h6Hobj3s9zPAC4BjZK-MPsKIKAFDReR4uPBaJ8bh3s0,7021
 icpp/ic/candid/candid_opcode.h,sha256=39o9_8A8B0Az74mDSMKN4TP8dI5o6szIB4c-NfZOctw,2878
 icpp/ic/candid/candid_serialize.cpp,sha256=42xaGSW76jT-MfXF9LnuK1BwJ8khyG4028cSEZLpUho,4328
 icpp/ic/candid/candid_serialize.h,sha256=OY9xYnizo7bho_IXCqw-faTCEfiHAiUC7ZLDsyvpu0Q,1000
 icpp/ic/candid/candid_type_base.cpp,sha256=K2ujQYYoVnyHYJcBFYmRTn_J30IxPJDfuZNmYUhIflQ,1761
 icpp/ic/candid/candid_type_base.h,sha256=xmGYLpamy6ewM6lkgV95u6jmK5UkZQkfs8M6ZHMYI7c,1976
 icpp/ic/candid/candid_type_bool.cpp,sha256=OswCkPGNWx3ZgGL-e0a12Tv6n0tir-zoclmObrksYLY,2048
 icpp/ic/candid/candid_type_bool.h,sha256=sLaj2wgfmGJ9TsB4nY-B5emlyuZq6AGfR8EXXcUWufQ,552
 icpp/ic/candid/candid_type_empty.cpp,sha256=oC99oWvtz-bUFGqZG5yreG8XxXlbsD9mvj3bM02p5IU,1126
-icpp/ic/candid/candid_type_empty.h,sha256=3_CjsayWgOB7TPONo6oZxeZhmpgeuOMM7MfNE6wRubg,372
-icpp/ic/candid/candid_type_float32.cpp,sha256=d2XRKGXTUrUhqVg5KXJo_C4V2lXGUV3lrRY_GyF-ivA,821
+icpp/ic/candid/candid_type_empty.h,sha256=NtXXwNVzIKFIyz28Eyj1oXTpXOD7in2c49xY0TE5O8k,420
+icpp/ic/candid/candid_type_float32.cpp,sha256=hOwPuevdsF54SEYKzYMBQBi3AsrS23idze-um9olst8,2187
 icpp/ic/candid/candid_type_float32.h,sha256=q6s2ec2Z_fWYk_1qWxrlYujITw15CfDydW7wEPtzFTE,577
-icpp/ic/candid/candid_type_float64.cpp,sha256=97SnyFGIYJ2M1POCSiFD7jNnr3FA5lSUaJOi9taZXbs,825
+icpp/ic/candid/candid_type_float64.cpp,sha256=3GZ5a014xE3_RxXMj3krZbCvtEOy8yl2NNA2PEMxjjI,2195
 icpp/ic/candid/candid_type_float64.h,sha256=2vq74ApgjWv_z6WJJVK0jm8w5ahMUr4X2paI0eRB1gs,584
 icpp/ic/candid/candid_type_int.cpp,sha256=4aypidaF7kS7vqbh-hH1DMPXKuYKnatPNbQBckhQVWU,1966
 icpp/ic/candid/candid_type_int.h,sha256=mmufPGoGTunMmkIsYT3LEQ1TT3APZYh1UVC0uifLkuA,589
-icpp/ic/candid/candid_type_int16.cpp,sha256=-OKKT7OsCFxChfRnAtRWTGXBdIZMhlfWyHVDSNk_Oh8,797
+icpp/ic/candid/candid_type_int16.cpp,sha256=n4lZE3-SPEIhooGpx9VYEPqmYwrbp-aUCVkPu-bauIk,2016
 icpp/ic/candid/candid_type_int16.h,sha256=EPpJkEbM-9pT6A39608C5PUghBFJfayN81OPzH2mJXw,579
-icpp/ic/candid/candid_type_int32.cpp,sha256=fFkL9gEsMNy1RwCHpp0M7pU15iR-Fj9IWQOeB8j25r0,802
+icpp/ic/candid/candid_type_int32.cpp,sha256=h4wERc6Rem4HTdTQOW0Fm9dHzsh-J8FuasV9dKbmWhA,2016
 icpp/ic/candid/candid_type_int32.h,sha256=fNO23cdiPNCda0fDuisWC3_4Yt3byu6uYn_7jl9olkk,579
-icpp/ic/candid/candid_type_int64.cpp,sha256=eInhJKORbr5oppn8gfx_dn2cPmcJsSg_3WJO7nOIQFo,797
+icpp/ic/candid/candid_type_int64.cpp,sha256=rDJG-3wAkdjmeG_C_TGOQjZaqKhH8OTwRll7IUr3AyE,2016
 icpp/ic/candid/candid_type_int64.h,sha256=d55CIptZo2fv45BFMl7LRTmMLeh3tWI6P9NG5LWIbaU,579
-icpp/ic/candid/candid_type_int8.cpp,sha256=h4RBwx5C9WkikmWUmhADxlXj3h7Y_WxfXF7ZHzpaqP8,776
+icpp/ic/candid/candid_type_int8.cpp,sha256=ZLY6s2hqrFRtV86fSONYSpHC5u0Wpnp0DguGVM2sWkY,1990
 icpp/ic/candid/candid_type_int8.h,sha256=VlKpZhzRVQpeZ8YP0JnVd79rZQXXGtJU7VSNTz93AZo,566
-icpp/ic/candid/candid_type_nat.cpp,sha256=K6pQruAGEbxMYWdiTM9GW6RQVfmNbxx6kQey5M1FtX8,790
+icpp/ic/candid/candid_type_nat.cpp,sha256=sCEysX-xFChCBX5qxgUO3yNBbJ_TkmTFy1J0VsHOZMw,1988
 icpp/ic/candid/candid_type_nat.h,sha256=dgMk04rpYqOIzKg0Jn3urnkQpb90egDLSCXUAxEZRVw,595
-icpp/ic/candid/candid_type_nat16.cpp,sha256=t-H9hBfaYtOE9l4QQgPy7_y-gtdYakIHOoZ5K_ON2xE,812
+icpp/ic/candid/candid_type_nat16.cpp,sha256=Hm0M1s8e4yojGL0w6DlpquccnzahiCvtg5WUuCUUe2w,2008
 icpp/ic/candid/candid_type_nat16.h,sha256=YiZHSKwZSe198irC9rWtkuZWGcpal-a9M7zoJW0nZtA,586
-icpp/ic/candid/candid_type_nat32.cpp,sha256=39-QAfI05KcnowXkli0KyTK_udI_SumYVcccGVYPJ-A,812
+icpp/ic/candid/candid_type_nat32.cpp,sha256=tN9w_g2egoudR6FTywXR-KNu220uRkNCNn_K0X9pC-Q,2008
 icpp/ic/candid/candid_type_nat32.h,sha256=fTzwDPtQeno7xpMy5UVoRZSAhbZlf-SFYDmuPacHoIo,586
-icpp/ic/candid/candid_type_nat64.cpp,sha256=7K64K_IdFufHa5LASTNQ-rFQm9cXhyX8rwZDab6w7fg,801
+icpp/ic/candid/candid_type_nat64.cpp,sha256=r1hvcrfPfwQJjbHFrlntWiFRX00IKkWpCTBG49iCHmM,2008
 icpp/ic/candid/candid_type_nat64.h,sha256=Pid9VT3YN7or3cQp5tYJW-FtJgYr0V3Q6B1AAtr96X8,586
-icpp/ic/candid/candid_type_nat8.cpp,sha256=HeLMjPPstkFZkX8h9q6VIGCMgQdFvcdiAl7v038tQ8Y,779
+icpp/ic/candid/candid_type_nat8.cpp,sha256=Fh5yycvdPKPK2coZKNZQJscFxc1GijpD956gATtTXaE,1982
 icpp/ic/candid/candid_type_nat8.h,sha256=QjStTtEzaTD2EtiBoIZMu-THh4K7q61i88XMkXwEv_4,573
 icpp/ic/candid/candid_type_null.cpp,sha256=j5MEYR_tGSYqAPLKb90o_i7sfdxY-dXwTfcMeTErHWI,786
-icpp/ic/candid/candid_type_null.h,sha256=Ijsa9wj_nDairh4QxFykwB_YrBM2HnOVd__5JddlmXE,291
-icpp/ic/candid/candid_type_opt_base.cpp,sha256=aOtMUvW7gXP2rScSuG_SZ7YHMCrKXbygfpsLrQ3_VDQ,591
+icpp/ic/candid/candid_type_null.h,sha256=Hss6rcBMxyT2GMrPWO-yoHkiDCQqI3CAj6VIo52slhE,339
+icpp/ic/candid/candid_type_opt_base.cpp,sha256=BBS77AkaXqKVeS7tl3MddwqDJ3vbgAcCoDO_K733DLQ,1819
 icpp/ic/candid/candid_type_opt_base.h,sha256=klzX_Un4arWO1AKBBC-uIuSQMeBY6ZGmkZBYw0FElQQ,412
-icpp/ic/candid/candid_type_opt_bool.cpp,sha256=AAJ6VWMXA59BGvkaPcuxF7sfs3luo4eMGLZErHSE_8o,656
-icpp/ic/candid/candid_type_opt_bool.h,sha256=34adYlg9_TMyQkEjmtj0ZZYBPvg1Ndx3xDcVlGCpzlA,646
-icpp/ic/candid/candid_type_opt_float32.cpp,sha256=kLh3cykJ5HyuQI9U8wsWxf_Mbhwahju6PTcYIPmJksQ,774
-icpp/ic/candid/candid_type_opt_float32.h,sha256=rtcNU86pvN8-D95V0yeHhEplPBaDr2XO69NdCsRQBA4,667
-icpp/ic/candid/candid_type_opt_float64.cpp,sha256=xO1dI_L5lkY8GR0-KIrRW4Auvr5gTLLiHqRZ2t3MRV4,724
-icpp/ic/candid/candid_type_opt_float64.h,sha256=6eVuoX2J90VvkGV5uvUdXeoftG4m9NBAnk6UgSnjmLM,673
-icpp/ic/candid/candid_type_opt_int.cpp,sha256=PkQ7uWpw2EoXRSgOVoIS3UVTc7BPj21jsPYY4upfuNA,656
-icpp/ic/candid/candid_type_opt_int.h,sha256=aPaX9BPcb-VMFfrjJOkUkqFJ2mJQQsFYQQr_HabqqKQ,677
-icpp/ic/candid/candid_type_opt_int16.cpp,sha256=4dMakUntPps2lCy5ubnQ3q0LYL5W78I1IklV1BF0Mt0,674
-icpp/ic/candid/candid_type_opt_int16.h,sha256=mp2ga37ydZMMLgpVrgGuiHWUqA7lH4AZ1gwomeYEZFY,669
-icpp/ic/candid/candid_type_opt_int32.cpp,sha256=I2jo1AvvgVLM6Ft6nuzcxmdVSEQEt-TjoT7JubT0r_o,726
-icpp/ic/candid/candid_type_opt_int32.h,sha256=jJRzoCdU-FGJ8eAYn59IXGr-W1dTO4E7M_xECCYDbtU,669
-icpp/ic/candid/candid_type_opt_int64.cpp,sha256=k-NkcixQjf-JRFi26TS9nJR7X_WQhLieUPD7lBTxy_o,674
-icpp/ic/candid/candid_type_opt_int64.h,sha256=I7yjx08eCrMgC6Qn7ragUxyluchus3EoxiNnv-U3LzU,669
-icpp/ic/candid/candid_type_opt_int8.cpp,sha256=cv9Xt2G75gJToB12y0Nw2LZLvaZBpxsrwrJ8fBFkToY,660
-icpp/ic/candid/candid_type_opt_int8.h,sha256=GJ0BxubZbQJIlfzr8Rx6f4frxXKOyPODNcm5wg55ed4,658
-icpp/ic/candid/candid_type_opt_nat.cpp,sha256=h32cC_f2c4R_HbyETYzEGP_lXS9-DpoTWhftCOMC3sU,658
-icpp/ic/candid/candid_type_opt_nat.h,sha256=uC5EhoMEK_oNGT8zXghjj0b_BxnHDEmNjBHza_EBvEk,683
-icpp/ic/candid/candid_type_opt_nat16.cpp,sha256=uqfDKu58tyocZXYtr7dBuHrZJhstJgS9yWPZhWJtnfU,676
-icpp/ic/candid/candid_type_opt_nat16.h,sha256=3rcZ0Tp6-qlte7Unri8x49-Lpf0EX8-dKk5KZ8Ct9ic,675
-icpp/ic/candid/candid_type_opt_nat32.cpp,sha256=hmkDGpDdV3xd25qJGohgyFsHF8MYgBCYGIoFY7rXbps,676
-icpp/ic/candid/candid_type_opt_nat32.h,sha256=QoBiXDGRNbIiKumiQ-d9CFBmAOi8tRVb35gNjdTwGGY,675
-icpp/ic/candid/candid_type_opt_nat64.cpp,sha256=N2fwmurGFzR9yoBlztm-qh1ioBBGNmtigMfm3dUjR08,676
-icpp/ic/candid/candid_type_opt_nat64.h,sha256=p78N_GeAvMnc8ywXh476yrIaeLdXIkd4iJVzI6laYQI,675
-icpp/ic/candid/candid_type_opt_nat8.cpp,sha256=L_NwtUFATShLvQuodx3HpgEkTxARCeFmsWZgzr90VX8,662
-icpp/ic/candid/candid_type_opt_nat8.h,sha256=juLKHSk58hxe0SYJElNgxqbdC9vT5h1PavBg9E6KZ-I,664
-icpp/ic/candid/candid_type_opt_principal.cpp,sha256=06DnMZeiAyLYKMfY2RngvoIPt9r4V_1SPyCUBZYE5ms,787
-icpp/ic/candid/candid_type_opt_principal.h,sha256=BD4PPa-1S2iZ0VK2P1oaP7N4L1TU68OFqwaQ97SCgjM,713
-icpp/ic/candid/candid_type_opt_text.cpp,sha256=NQZNV1VYBuI9eLdBvm-I0FDDeQAMmOxdzN32J5p6cn8,766
-icpp/ic/candid/candid_type_opt_text.h,sha256=h72Al08DqRG_Nd7F-5oVVsXo5sUa19AUcq21iSZ9Bmk,688
+icpp/ic/candid/candid_type_opt_bool.cpp,sha256=QBEjSg2xZ_VDbFDPQxEH7NCBDuBYdUpJ9BFaKia6doc,2674
+icpp/ic/candid/candid_type_opt_bool.h,sha256=isfd4sFNE0FYwSauqb-xscCdanlRKCaD6QakllrOZPI,692
+icpp/ic/candid/candid_type_opt_float32.cpp,sha256=ehtqLeQEVqhQ5qT3BUYlbjmMuIVqUTrdfGGvox2eaQQ,2688
+icpp/ic/candid/candid_type_opt_float32.h,sha256=31vZv0BimrFzzkbqLrbIQ3zw-VsI7FWSloyNQx3pFN0,714
+icpp/ic/candid/candid_type_opt_float64.cpp,sha256=Pej1jHI_7yJQrOf02RkZMEbZHss6MXXp-HTsKOpsP80,2694
+icpp/ic/candid/candid_type_opt_float64.h,sha256=JYDhWuRqhs9gnmHRSALfVOodJYDQwgAM2bCDMqYIwho,721
+icpp/ic/candid/candid_type_opt_int.cpp,sha256=mBlyGAAOxXKgyMdI9ffI_Qj31hIoN__rLVsil8Tgb2k,2684
+icpp/ic/candid/candid_type_opt_int.h,sha256=mld7MzusDQk4gAAM7NfdIijawFQ7b9Iz8IK7AfM2PnA,729
+icpp/ic/candid/candid_type_opt_int16.cpp,sha256=6wBEww_F-YS8dtzgVADc8t913cZWVEk9-3phjjkXlNE,2672
+icpp/ic/candid/candid_type_opt_int16.h,sha256=Dg0MHLYriXfDH9W7qEIEeyjpe6sKDFd5w6DtRCKb-V4,718
+icpp/ic/candid/candid_type_opt_int32.cpp,sha256=AHanjV5ifet4idz2hDt6kSh13fz6HrreMojGICCDpc4,2672
+icpp/ic/candid/candid_type_opt_int32.h,sha256=pGM0dx8cbNjpHP63McNvdVPACDei-S0DrT2cFd4J3iQ,718
+icpp/ic/candid/candid_type_opt_int64.cpp,sha256=iv_UGlQs-UmmOnImM_WQxuarAWDaN4neCbKv0aMf3Y0,2672
+icpp/ic/candid/candid_type_opt_int64.h,sha256=hJcEflhYcm0CCfNSaJr41wCurSRHTmwU6DWIgrBOeyM,718
+icpp/ic/candid/candid_type_opt_int8.cpp,sha256=jzTV1QMVMSf_0zqPY-9xp9a_Rrrzunl5196_sPN_-E8,2650
+icpp/ic/candid/candid_type_opt_int8.h,sha256=011HFPLZNUyC6MvZfwhP1PN-Nmc3bUToRaqY4n2-47c,706
+icpp/ic/candid/candid_type_opt_nat.cpp,sha256=GrQwmQxq-syosGY99743RNDa8NL0Xi6y_MtegZImB9o,2690
+icpp/ic/candid/candid_type_opt_nat.h,sha256=nbpZxd626ieyCLvv1zNVvyDd1eea1BdnWN28mFzmgt4,736
+icpp/ic/candid/candid_type_opt_nat16.cpp,sha256=Hv5NyWwaBI5nnjgXxc6VdtZOrkKErVx71slB-5t5hCA,2678
+icpp/ic/candid/candid_type_opt_nat16.h,sha256=nQX55-uXf3qxqnKktJVALN8snLYERdwSRrDNPzyMjB0,725
+icpp/ic/candid/candid_type_opt_nat32.cpp,sha256=ZJs6datQYal_fpdre3bEbqc8_sW4QlLJt353oghuvig,2678
+icpp/ic/candid/candid_type_opt_nat32.h,sha256=rVX6WfVite31QWZyZ5T1EYpfAxYQZoZRcyQuUuKY8A4,725
+icpp/ic/candid/candid_type_opt_nat64.cpp,sha256=RZIpDecsLk_QfeMXoKcJhLqMDeqR6cUrDa8CYegSiv4,2678
+icpp/ic/candid/candid_type_opt_nat64.h,sha256=-spBanh7T_A5JAzc_HvIH2tHaB_nWI-9jZGmnsMKkiU,725
+icpp/ic/candid/candid_type_opt_nat8.cpp,sha256=C12dsU28Ubk6nceNxJxHfBIrXl95LooOfsJBHAcwkDg,2656
+icpp/ic/candid/candid_type_opt_nat8.h,sha256=kE5_DBdfm4WoAJlRubwF6CS5qQNHEGjvgoqRl5A4K1Q,713
+icpp/ic/candid/candid_type_opt_principal.cpp,sha256=h1mGSrUt4HuY7rcgJN4Pzxm-MUYb627biAL-fy0NVzQ,2916
+icpp/ic/candid/candid_type_opt_principal.h,sha256=I5VCwhc3yCO4EhJrBHfozUNyjXypD-8VTo85GZIyM_A,766
+icpp/ic/candid/candid_type_opt_text.cpp,sha256=D-8OM7t_avexb3M8nGSxsW_81EcXimKonUnjsmRHqSA,2920
+icpp/ic/candid/candid_type_opt_text.h,sha256=h0Ho0z9xXCAu0p8I_nTbzzq1qvjuojpVi6sypHzctxA,741
 icpp/ic/candid/candid_type_prim.cpp,sha256=-DOK_w670MHSZBLq_b8L-kI-QqXl7-MjyHcHfPCrUV8,148
 icpp/ic/candid/candid_type_prim.h,sha256=70cVRF2qkzCNFFmBFy6dh4WnEU3Rx7YnNh2kD0PYTHU,484
 icpp/ic/candid/candid_type_principal.cpp,sha256=j1_bE37AdNSJ0ufyHbqQaPLisWNTF93HHDlXVRpHY28,9545
 icpp/ic/candid/candid_type_principal.h,sha256=g-QTEaryQVFqAIUkNRuLot6UrKkTrbGyq-ym39VOL4s,1692
-icpp/ic/candid/candid_type_record.cpp,sha256=AvNTQp3EWb5mc6BnsbYNejsuJXlyjMsCvz2Wnsu2iwk,1168
-icpp/ic/candid/candid_type_record.h,sha256=ZkVr0N040rylZyQV-wF_7EWeHna7Tv4eHyX6jWdxroU,1010
-icpp/ic/candid/candid_type_reserved.cpp,sha256=HYI6Yhy_6gz-6DknU7rnhX83ZuKvltz39V-M8FSLE4Y,548
-icpp/ic/candid/candid_type_reserved.h,sha256=NieFcAve3DN5ODFhinF9lFev0BwcnFZ-TNVGrcZ3Aws,383
+icpp/ic/candid/candid_type_record.cpp,sha256=veuqsjjX4RXn9DMwXgT7SKb1m4ak3cDWtcGbTPzt9zk,10646
+icpp/ic/candid/candid_type_record.h,sha256=MeqycC5tLaU0_ZKNYJnAXu0ORO5srSnVfBnZQOig40s,1206
+icpp/ic/candid/candid_type_reserved.cpp,sha256=9GSHw2AG2o2zPLi2YpVStRErXNvn_tPvjUYh6twMNM0,1045
+icpp/ic/candid/candid_type_reserved.h,sha256=h1-24Et_kz6H6po9q31XxwgRFxaqjRsYa_gXtuh-UeA,434
 icpp/ic/candid/candid_type_table.cpp,sha256=xY96PMiDwCPhhOsIQuLnyX_t1-2yDJgEQPbql1J8Z6k,2579
 icpp/ic/candid/candid_type_table.h,sha256=6ZGjPHe9B2I4kPrcg50Qy5GaR18zs3WEnEMJwfpCaHk,676
 icpp/ic/candid/candid_type_text.cpp,sha256=TwBwcDdV5yL69r1I13nbM4thsgEYxuM1GwetRLZUZYg,2861
 icpp/ic/candid/candid_type_text.h,sha256=BUqyHeLYa1Cfyk4RkOb3IBPDrjo8Y5XxWTRIVJbyzAg,655
-icpp/ic/candid/candid_type_vec_base.cpp,sha256=M9QvAkgTHyPkKoiC_KZmGJ5aldcJgqvYyy_Bnv1eibE,591
+icpp/ic/candid/candid_type_variant.cpp,sha256=VY-Ed-aA_g-wFWsWpzl5c0sjncin-yACiBgqVny9yvw,11536
+icpp/ic/candid/candid_type_variant.h,sha256=y59QCbhXDPO97FhDg9YBZ9-rQtJd7Tw4mn45jy_Jw44,1570
+icpp/ic/candid/candid_type_vec_base.cpp,sha256=wXXoKLTE-p1mD6wMQKX6gSDcFtxyMC9CGjXWyJuyQLg,1819
 icpp/ic/candid/candid_type_vec_base.h,sha256=uCzlTmQalqYp_DTgZT75YA7r9kzowRLVKXdSxeT3RUs,412
-icpp/ic/candid/candid_type_vec_bool.cpp,sha256=-wlXD7spb5B97D7mwSwJ5uwUee1tl91o5gyvsNEVDvk,652
-icpp/ic/candid/candid_type_vec_bool.h,sha256=xvhCzBhmkOniFlhlrnb44zpgqDLO2AYW_HkNmzxRTK8,634
-icpp/ic/candid/candid_type_vec_float32.cpp,sha256=-MHTcY2Z5hIUB_mQ-XxS4BKtrtbeCqtq5u3oEZy8fnA,690
-icpp/ic/candid/candid_type_vec_float32.h,sha256=yEEqc3clG3YRKFX9vHZdF0cxSTpn4mO3I7ddi7t83rM,655
-icpp/ic/candid/candid_type_vec_float64.cpp,sha256=flfNU0AEXFUB6CRPOPHm8u5olgLoFchf0xns-jmzjQE,692
-icpp/ic/candid/candid_type_vec_float64.h,sha256=z6Svr50MUbXopgxz6ZJ6QvPgidmFyj0WmUE_ZgaPDd4,661
-icpp/ic/candid/candid_type_vec_int.cpp,sha256=LNZg8buGM2EyV0-ZJxWKQYb-G8ApdCfkweSuAjrBMnk,652
-icpp/ic/candid/candid_type_vec_int.h,sha256=jqRqc-0xQqDxtLVXI15FacUzw-O6BK7xvkn8olx7XSI,665
-icpp/ic/candid/candid_type_vec_int16.cpp,sha256=veeQ50Qhp0Z6FLH6vNMzBfH09xsib5jy86f5JdFEEO4,670
-icpp/ic/candid/candid_type_vec_int16.h,sha256=LTeU5M7EUGGu5s0rVjhnHrQo1_5yoXull08dghegH84,657
-icpp/ic/candid/candid_type_vec_int32.cpp,sha256=mMD_B05-MNXrnr0JwfwLSbKn4Pe7GlNU5LK8wZvdntY,670
-icpp/ic/candid/candid_type_vec_int32.h,sha256=wifudP73o1AjoGdeByEUgktvgqkLgI-zBZjEG8iE9Vg,657
-icpp/ic/candid/candid_type_vec_int64.cpp,sha256=AIwBwRDvbEaj09SHCZRghdwltfVR5-Vr6PHkyIKE6U4,670
-icpp/ic/candid/candid_type_vec_int64.h,sha256=7JcdKq9JMR3l49Mmdl5aroBdTAvTL6bc0-EtFuMuyX0,657
-icpp/ic/candid/candid_type_vec_int8.cpp,sha256=jq9TlAAmUoT3W0-xsoi6sWGSY3239ACU97VaT1Zrh3g,656
-icpp/ic/candid/candid_type_vec_int8.h,sha256=UxjOrp6iPGOzzA4McV6eQ6DG9_DplKGcD51uAJaNk6o,646
-icpp/ic/candid/candid_type_vec_nat.cpp,sha256=G8TaMwkjI2SlFb3muhsJLx-pb8OHndVn0X3aJdMPsyA,654
-icpp/ic/candid/candid_type_vec_nat.h,sha256=-_4Lv01PcS-e4SE_mXxCOr6ZFgL6uQPUQBiBAulCfiM,671
-icpp/ic/candid/candid_type_vec_nat16.cpp,sha256=F0QcPiAOISaT6DZEHZpEEtAfkG8UcdH2VEy968k6y2Q,672
-icpp/ic/candid/candid_type_vec_nat16.h,sha256=o76MONweYANNlDHbhwPkJRKZ-RUEcyKAiDFhbfJUkDg,663
-icpp/ic/candid/candid_type_vec_nat32.cpp,sha256=N0am-eB5_rT3Bqn3SgIpgDabfpm2elB9CfF-e_Eqw4o,672
-icpp/ic/candid/candid_type_vec_nat32.h,sha256=b8euPWzqM67kE4H7R1DWKtY_BMigUJo2z9CQ95bqw94,663
-icpp/ic/candid/candid_type_vec_nat64.cpp,sha256=r8OcJc9IBlMvFmSoXkDVoM55LTV8GhbYa9Ypty1BzeE,672
-icpp/ic/candid/candid_type_vec_nat64.h,sha256=YVVei1kNqIRTXqm2gr26r1ffopDSSDQa6H6BA6ygGV8,663
-icpp/ic/candid/candid_type_vec_nat8.cpp,sha256=kj8BZZ9zeZn8TkhOo2Pr0mm-z8ol3LHmhyODsFmbfFg,658
-icpp/ic/candid/candid_type_vec_nat8.h,sha256=w_0bRQWdabxTSSiLyOg3AsKobUomdl0Ukpw37fPWqeI,652
-icpp/ic/candid/candid_type_vec_principal.cpp,sha256=W9O1fW_tdgn50GDM2vEJkcMM3-3hnN2WheLG_nHsZkU,726
-icpp/ic/candid/candid_type_vec_principal.h,sha256=nAQ7a6TDcpr5Ygv3ocV-zIms3iyf2l1au0H49ERLdxs,701
-icpp/ic/candid/candid_type_vec_text.cpp,sha256=hjF0Br5o3yaU6QKwsiPjsJsOS57grT8gKkN2nbzT7zA,666
-icpp/ic/candid/candid_type_vec_text.h,sha256=cshqYXAUWEXzFSr90Nxx7_afkKFEwVOASXLuIeRZb4Q,676
+icpp/ic/candid/candid_type_vec_bool.cpp,sha256=PEVwAN7K-KOgKANM4WThAdugMyVpU-MN7qQ3VxEbbFo,2485
+icpp/ic/candid/candid_type_vec_bool.h,sha256=-W61LAss3kghDUfNEpGckMJ9bIwAvl4XiAe_C_e1cy8,678
+icpp/ic/candid/candid_type_vec_float32.cpp,sha256=O-iPMIzDxOgyxhA9QcvwEEkBeldhkUkJYTINPor5rZ4,2485
+icpp/ic/candid/candid_type_vec_float32.h,sha256=QsHp-amYoSNzXy33pi7gfbKG8ZgF_GmnPxNKLubAU7E,700
+icpp/ic/candid/candid_type_vec_float64.cpp,sha256=0UkFB5lbBL9u4Bni9ini9svTfYUZAWckz4808tjolso,2492
+icpp/ic/candid/candid_type_vec_float64.h,sha256=YK4ZqykeLPiDrk5XhIRiALOJOjqSnvwUdRPrRwK1B7k,707
+icpp/ic/candid/candid_type_vec_int.cpp,sha256=X-affAmF504d8DGQcbk6obufzssIxyQTIK0mvxsU6Uk,2457
+icpp/ic/candid/candid_type_vec_int.h,sha256=3Q9W7YkPUSyTrIzuX-94X96sYQ8-SKYCLmGWzkmtSIg,715
+icpp/ic/candid/candid_type_vec_int16.cpp,sha256=eqc44Fszn8XUwTFCFBtjf2zFaP3rwZ8zKZ97Us1zDEA,2502
+icpp/ic/candid/candid_type_vec_int16.h,sha256=MUF5VbM9T3siHRj9IcYEF9Yzl7SM6H1xOJEOwbQ2oYk,704
+icpp/ic/candid/candid_type_vec_int32.cpp,sha256=SNOicrBkTZ8RcslHk6ZTLR5Hhun3rBbsnLG7J0Vr8Gk,2502
+icpp/ic/candid/candid_type_vec_int32.h,sha256=Ii1Y1hzS6QtJ5DBkaNPsc0HJNqiSLSlmCZe8bkHI8VA,704
+icpp/ic/candid/candid_type_vec_int64.cpp,sha256=OObsIqNMx5Nz_18jBkPrC4SR95eNbplDSyjTg5IlKvo,2502
+icpp/ic/candid/candid_type_vec_int64.h,sha256=RjzJ0PSYR9YsTVRCZKvtDlfnrqAYSUuIO6tTTyRagmA,704
+icpp/ic/candid/candid_type_vec_int8.cpp,sha256=aP6qEV_WjrJl8Dm_rqxCKXuBIPaXZvNCrAbtloikmtY,2479
+icpp/ic/candid/candid_type_vec_int8.h,sha256=dz3LvfrYTMy8ZkmGPTk2y0iIgBy1_FjqXSRFBRK8nkw,692
+icpp/ic/candid/candid_type_vec_nat.cpp,sha256=b0q6UjillOc9SbUzD68yoMLO02q29plKGtFMHv2BZdk,2504
+icpp/ic/candid/candid_type_vec_nat.h,sha256=-lQotSea14_5b7_SwXjogA1I5VrkWprkj2H2KfIaOjs,722
+icpp/ic/candid/candid_type_vec_nat16.cpp,sha256=F7cRndAkRT4djTO3kDf5_4sZcqYoP_cotNbGEkvRM6I,2517
+icpp/ic/candid/candid_type_vec_nat16.h,sha256=YDDRZ1-NMZCL5GtMWkx5JbzMsRmSvFiv9mWpFm4N9Pk,711
+icpp/ic/candid/candid_type_vec_nat32.cpp,sha256=Bw8iJCuFqj6-vrKGh5LhJg1vgVAqAR7ZjEdMhcitmhE,2517
+icpp/ic/candid/candid_type_vec_nat32.h,sha256=xlxqzOhVzcmBD5bgx--fAD-txn5S_gSptn-0nJZtKt0,711
+icpp/ic/candid/candid_type_vec_nat64.cpp,sha256=O8J3YVuPFfMRc8-oXnpMVp49Gs47evoxXSv4Me9jZ9g,2517
+icpp/ic/candid/candid_type_vec_nat64.h,sha256=NQ_k7bgY0wqeOWjdWRUMWtCR6djQlxs6YSh0adXSa4s,711
+icpp/ic/candid/candid_type_vec_nat8.cpp,sha256=uAgQqDX7kRAFAOoIhxV-rV4SqI23_kBL-iNjKB4H9Z4,2493
+icpp/ic/candid/candid_type_vec_nat8.h,sha256=YEmcUtu9haitkH5v5LBITdlC5rKtdnKApyRJCedCERs,699
+icpp/ic/candid/candid_type_vec_principal.cpp,sha256=F5uVlqp-C7D04YkeYGkntSYBonv3Jl0WtvXbfsieloU,2661
+icpp/ic/candid/candid_type_vec_principal.h,sha256=GR0onfJgIQH111bKTbWAG4Gc2zEa-apqnT5LqXSPFi0,752
+icpp/ic/candid/candid_type_vec_text.cpp,sha256=L396cIT4UancQv0g3ZTnLXOtbP3giRJCIuU4yi-qlVo,2724
+icpp/ic/candid/candid_type_vec_text.h,sha256=ay0FBn6xyIO-WSZzBchlubLYzaH1D2YZkwlzTFl4ox0,727
 icpp/ic/candid/vec_bytes.cpp,sha256=CSdFC0N1jiq6vnijeF72Fo2zVA5m1qpkexf7N69XGuc,15762
 icpp/ic/candid/vec_bytes.h,sha256=aQH3CZUI058VidHSqUvcwPXjLdU4mvItTAqM7Gg11Gk,7834
 icpp/ic/ic0/ic0.h,sha256=Kp0YetTZj7yzQDXQtwSW1tKD2ZxIUvxXrSP51SUIZ2E,3407
 icpp/ic/ic0mock/global.h,sha256=iLBQbjovKsiEEHH8DlUR9yrKbpg6pVpG-lEkWhTLN5k,110
 icpp/ic/ic0mock/ic0.cpp,sha256=DkCvN8Lp1-6BOiAe9-PKfdCUoB6-O4m3QMbo89o5LLQ,3270
 icpp/ic/ic0mock/ic0.h,sha256=LIwEeVZVfiXet4pxs9Ot3rPfhg1CtoYVIxPayVxNufY,2091
 icpp/ic/ic0mock/mock_ic.cpp,sha256=SW5_QJ1DaafDcACvw5Y9kMti47AlBv43gUhdObc1vx0,1372
@@ -188,13 +190,13 @@
 icpp/ic/vendors/hash-library/crc32.h,sha256=lG9w03MUpmdeR-bru4e9yJwbvqXLWqYR48tERwL2tXM,1736
 icpp/ic/vendors/hash-library/readme.md,sha256=TISl0NHkS8RLxNyylJJQCDyNiH5-nWixii_pPRqk5Y8,1758
 icpp/ic/wasi_sdk_traps/__wasilibc_initialize_environ.c,sha256=wK61MY-YDkEBG8qIbV-NfUVCCaEQI3AR2GdEhE2z7h8,1370
 icpp/ic/wasi_sdk_traps/ic_trap.c,sha256=YMpQZaaYomfXWU5CqJnCLtYtVvrYNzTWbvwN1slGtbc,327
 icpp/ic/wasi_sdk_traps/ic_trap.h,sha256=XI8GZ_O5sOMpHd3PefoXR_69a1PoFM1Xsbrhl-b3Te4,70
 icpp/ic/wasi_sdk_traps/posix.c,sha256=50eo_D16Zx9HizqKa5Beie_WOinUayo73dIXA7Gs8SU,3717
 icpp/ic/wasi_sdk_traps/unreachable.c,sha256=ogAfGACShCP_my_Up--vgUrAP9X_tPE5U_N1AJsLGMw,7527
-icpp_free-2.1.0.dist-info/LICENSE,sha256=951fAgXYy6YePgpTPC2RI47NRbB-93NVxlnEYaWPYUY,983
-icpp_free-2.1.0.dist-info/METADATA,sha256=gmmTuCuNQ12BUZQ-wj1C1Uhfa2JVS1rfZUBqR4DXoy0,2077
-icpp_free-2.1.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-icpp_free-2.1.0.dist-info/entry_points.txt,sha256=TQp3Ak8BiWuu54ZQg6JgcoUle5WojECMzYYL9AXSW6E,44
-icpp_free-2.1.0.dist-info/top_level.txt,sha256=-18t6pp4U_1wjW3LmJN2N7O-rpg6U7Ly1X53MpUk9pA,5
-icpp_free-2.1.0.dist-info/RECORD,,
+icpp_free-2.2.0.dist-info/LICENSE,sha256=951fAgXYy6YePgpTPC2RI47NRbB-93NVxlnEYaWPYUY,983
+icpp_free-2.2.0.dist-info/METADATA,sha256=UZiMUs9txRBEnVYtWYWUgi5lABOTO5EqpdqYbWfRk-8,2290
+icpp_free-2.2.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+icpp_free-2.2.0.dist-info/entry_points.txt,sha256=TQp3Ak8BiWuu54ZQg6JgcoUle5WojECMzYYL9AXSW6E,44
+icpp_free-2.2.0.dist-info/top_level.txt,sha256=-18t6pp4U_1wjW3LmJN2N7O-rpg6U7Ly1X53MpUk9pA,5
+icpp_free-2.2.0.dist-info/RECORD,,
```

