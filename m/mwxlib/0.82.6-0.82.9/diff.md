# Comparing `tmp/mwxlib-0.82.6-py3-none-any.whl.zip` & `tmp/mwxlib-0.82.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 161453 bytes, number of entries: 22
+Zip file size: 161722 bytes, number of entries: 22
 -rw-rw-rw-  2.0 fat     2520 b- defN 23-May-02 16:40 mwx/__init__.py
 -rw-rw-rw-  2.0 fat    43445 b- defN 23-May-02 17:15 mwx/controls.py
--rw-rw-rw-  2.0 fat    72385 b- defN 23-May-02 16:41 mwx/framework.py
--rw-rw-rw-  2.0 fat    69473 b- defN 23-May-02 13:37 mwx/graphman.py
+-rw-rw-rw-  2.0 fat    73526 b- defN 23-May-11 06:06 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69631 b- defN 23-May-10 07:23 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    46248 b- defN 23-Feb-21 08:49 mwx/images.py
 -rw-rw-rw-  2.0 fat    36004 b- defN 23-Apr-27 09:45 mwx/matplot2.py
--rw-rw-rw-  2.0 fat    67727 b- defN 23-Apr-27 09:45 mwx/matplot2g.py
+-rw-rw-rw-  2.0 fat    67652 b- defN 23-May-10 07:23 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    27606 b- defN 23-Apr-27 09:45 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   138263 b- defN 23-May-02 13:36 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    36924 b- defN 23-May-02 16:40 mwx/utilus.py
+-rw-rw-rw-  2.0 fat   138196 b- defN 23-May-11 06:06 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    36924 b- defN 23-May-07 16:44 mwx/utilus.py
 -rw-rw-rw-  2.0 fat    11335 b- defN 23-May-02 13:35 mwx/wxmon.py
--rw-rw-rw-  2.0 fat    19668 b- defN 23-Apr-28 08:56 mwx/wxpdb.py
+-rw-rw-rw-  2.0 fat    19672 b- defN 23-May-10 05:12 mwx/wxpdb.py
 -rw-rw-rw-  2.0 fat     5246 b- defN 23-Mar-25 12:54 mwx/wxwil.py
 -rw-rw-rw-  2.0 fat     7416 b- defN 23-Apr-29 16:25 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
 -rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-27 09:45 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1609 b- defN 23-May-02 17:20 mwxlib-0.82.6.dist-info/RECORD
-22 files, 612621 bytes uncompressed, 158951 bytes compressed:  74.1%
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-May-11 10:26 mwxlib-0.82.9.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-May-11 10:26 mwxlib-0.82.9.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-11 10:26 mwxlib-0.82.9.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-May-11 10:26 mwxlib-0.82.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-May-11 10:26 mwxlib-0.82.9.dist-info/RECORD
+22 files, 613782 bytes uncompressed, 159220 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.82.6.dist-info/LICENSE
+Filename: mwxlib-0.82.9.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.82.6.dist-info/METADATA
+Filename: mwxlib-0.82.9.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.82.6.dist-info/WHEEL
+Filename: mwxlib-0.82.9.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.82.6.dist-info/top_level.txt
+Filename: mwxlib-0.82.9.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.82.6.dist-info/RECORD
+Filename: mwxlib-0.82.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.82.6"
+__version__ = "0.82.9"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -1045,14 +1045,38 @@
         
         self._mgr.Update()
         
         self.Unbind(wx.EVT_CLOSE)
         self.Bind(wx.EVT_CLOSE, self.OnClose)
         self.Bind(wx.EVT_SHOW, self.OnShow)
         
+        self.__autoload = True
+        
+        def on_activate(evt):
+            evt.Skip()
+            if not evt.Active:
+                ## Reset autoload when active focus going outside.
+                self.__autoload = True
+            elif evt.GetActivationReason() == evt.Reason_Mouse\
+              and self.__autoload:
+                ## Check all buffers that need to be loaded.
+                for book in self.get_all_pages(type(self.Log)):
+                    for buf in book.all_buffers:
+                        if buf.need_buffer_load:
+                            if wx.MessageBox( # Confirm load.
+                                    "The file has been modified externally.\n\n"
+                                    "The contents of the buffer will be overwritten.\n"
+                                    "Continue loading?",
+                                    "Load {!r}".format(buf.name),
+                                    style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
+                                self.__autoload = False # Don't ask any more.
+                                return
+                            book.load_file(buf)
+        self.Bind(wx.EVT_ACTIVATE, on_activate)
+        
         self.findDlg = None
         self.findData = wx.FindReplaceData(wx.FR_DOWN | wx.FR_MATCHCASE)
         
         self.Bind(wx.EVT_FIND, self.OnFindNext)
         self.Bind(wx.EVT_FIND_NEXT, self.OnFindNext)
         self.Bind(wx.EVT_FIND_CLOSE, self.OnFindClose)
         
@@ -1062,14 +1086,15 @@
         
         self.timer = wx.Timer(self)
         self.timer.Start(1000)
         
         def on_timer(evt):
             if self.indicator.Value not in (1, 3):
                 self.indicator.blink(500)
+            evt.Skip()
         self.Bind(wx.EVT_TIMER, on_timer)
         
         def on_size(evt):
             rect = self.statusbar.GetFieldRect(1)
             self.indicator.Position = (-44+rect.x, 2+rect.y)
             evt.Skip()
         self.Bind(wx.EVT_SIZE, on_size)
@@ -1147,82 +1172,78 @@
         self.Init()
     
     SESSION_FILE = get_rootpath(".debrc")
     SCRATCH_FILE = get_rootpath("scratch.py")
     LOGGING_FILE = get_rootpath("deb-logging.log")
     HISTORY_FILE = get_rootpath("deb-history.log")
     
-    def load_session(self, rc=None):
+    def load_session(self, rc=None, flush=True):
         """Load session from file."""
         if not rc:
             with wx.FileDialog(self, 'Load session',
                     wildcard="Session file (*.debrc)|*.debrc",
                     style=wx.FD_OPEN|wx.FD_FILE_MUST_EXIST|wx.FD_CHANGE_DIR) as dlg:
                 if dlg.ShowModal() != wx.ID_OK:
                     return
                 rc = dlg.Path
-        ## flush
-        for book in self.get_pages(type(self.Log)):
-            book.remove_all_buffers()
+        
+        if flush:
+            for book in self.get_all_pages(type(self.Log)):
+                book.remove_all_buffers()
         
         self.SESSION_FILE = os.path.abspath(rc)
         try:
             scratch = self.Scratch.default_buffer
             if not scratch or scratch.mtdelta is not None:
                 scratch = self.Scratch.new_buffer()
             scratch.LoadFile(self.SCRATCH_FILE)
-            
+        except FileNotFoundError as e:
+            print(e)
+        try:
             with open(self.SESSION_FILE, encoding='utf-8', newline='') as i:
                 exec(i.read())
-            
         except Exception:
-            traceback.print_exc()
-            print("- Failed to load session")
+            pass
     
     def save_session_as(self):
         """Save session as a new file."""
         with wx.FileDialog(self, "Save session as",
                 defaultFile=self.SESSION_FILE or '',
                 wildcard="Session file (*.debrc)|*.debrc",
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 self.SESSION_FILE = dlg.Path
                 self.save_session()
     
     def save_session(self):
         """Save session to file."""
-        try:
-            scratch = self.Scratch.default_buffer
-            if scratch and scratch.mtdelta is None:
-                scratch.SaveFile(self.SCRATCH_FILE)
+        scratch = self.Scratch.default_buffer
+        if scratch and scratch.mtdelta is None:
+            scratch.SaveFile(self.SCRATCH_FILE)
+        
+        with open(self.SESSION_FILE, 'w', encoding='utf-8', newline='') as o:
+            o.write("#! Session file (This file is generated automatically)\n")
             
-            with open(self.SESSION_FILE, 'w', encoding='utf-8', newline='') as o:
-                o.write("#! Session file (This file is generated automatically)\n")
-                
-                for book in self.get_pages(type(self.Log)):
-                    for buf in book.all_buffers:
-                        if buf.mtdelta is not None:
-                            o.write("self._load_file({!r}, {!r}, {})\n"
-                                    .format(book.Name, buf.filename, buf.markline+1))
-                o.write('\n'.join((
-                    "self.SetSize({})".format(self.Size),
-                    "self.SetPosition({})".format(self.Position),
-                    "self.ghost.SetSelection({})".format(self.ghost.Selection),
-                    "self.watcher.SetSelection({})".format(self.watcher.Selection),
-                    "self._mgr.LoadPerspective({!r})".format(self._mgr.SavePerspective()),
-                    "self.ghost.loadPerspective({!r})".format(self.ghost.savePerspective()),
-                    "self.watcher.loadPerspective({!r})".format(self.watcher.savePerspective()),
-                    ## "self._mgr.GetPane('ghost').FloatingPosition(self.Position)",
-                    ## "self._mgr.GetPane('watcher').FloatingPosition(self.Position)",
-                    "self._mgr.Update()",
-                    ""
-                )))
-        except Exception:
-            traceback.print_exc()
-            print("- Failed to save session")
+            for book in self.get_all_pages(type(self.Log)):
+                for buf in book.all_buffers:
+                    if buf.mtdelta is not None:
+                        o.write("self._load_file({!r}, {!r}, {})\n"
+                                .format(book.Name, buf.filename, buf.markline+1))
+            o.write('\n'.join((
+                "self.SetSize({})".format(self.Size),
+                "self.SetPosition({})".format(self.Position),
+                "self.ghost.SetSelection({})".format(self.ghost.Selection),
+                "self.watcher.SetSelection({})".format(self.watcher.Selection),
+                "self._mgr.LoadPerspective({!r})".format(self._mgr.SavePerspective()),
+                "self.ghost.loadPerspective({!r})".format(self.ghost.savePerspective()),
+                "self.watcher.loadPerspective({!r})".format(self.watcher.savePerspective()),
+                ## "self._mgr.GetPane('ghost').FloatingPosition(self.Position)",
+                ## "self._mgr.GetPane('watcher').FloatingPosition(self.Position)",
+                "self._mgr.Update()\n",
+            )))
     
     def _load_file(self, bookname, filename, lineno):
         try:
             book = getattr(self, bookname)
             book.load_file(filename, lineno)
         except Exception:
             pass
@@ -1243,15 +1264,15 @@
                 self.History.default_buffer.SaveFile(self.HISTORY_FILE)
         finally:
             self._mgr.UnInit()
             return MiniFrame.Destroy(self)
     
     def OnClose(self, evt):
         if self.debugger.busy:
-            if wx.MessageBox(
+            if wx.MessageBox( # Confirm debugger close.
                     "The debugger is running.\n\n"
                     "Enter [q]uit to exit before closing.\n"
                     "Continue closing?",
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.message("The close has been canceled.")
                 evt.Veto()
                 return
@@ -1260,21 +1281,20 @@
             return
         
         if self.debugger.tracing:
             wx.MessageBox("The debugger ends tracing.\n\n"
                           "The trace pointer will be cleared.")
             self.debugger.unwatch() # cf. [pointer_unset] stop_trace
         
-        ## Confirm close
-        for book in self.get_pages(type(self.Log)):
+        for book in self.get_all_pages(type(self.Log)):
             for buf in book.all_buffers:
                 if buf.need_buffer_save:
                     self.popup_window(book)
                     buf.SetFocus()
-                    if wx.MessageBox(
+                    if wx.MessageBox( # Confirm close.
                             "You are closing unsaved content.\n\n"
                             "Changes to the content will be discarded.\n"
                             "Continue closing?",
                             "Close {!r}".format(buf.name),
                             style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                         self.message("The close has been canceled.")
                         evt.Veto()
@@ -1445,15 +1465,15 @@
         m = re.match("(.*?):([0-9]+)", obj)
         if m:
             filename, ln = m.groups()
             lineno = int(ln)
         else:
             filename = obj
             lineno = 0
-        book = next((x for x in self.get_pages(type(self.Log))
+        book = next((x for x in self.get_all_pages(type(self.Log))
                              if x.find_buffer(filename)), self.Log)
         self.popup_window(book, focus=focus)
         return book.load_file(filename, lineno)
     
     def info(self, obj):
         self.rootshell.info(obj)
     
@@ -1644,15 +1664,15 @@
             buf.write(text)
         ## Set a marker on the current line.
         if noerr is not None:
             buf.add_marker(buf.cline, 1 if noerr else 2) # 1:white 2:red-arrow
     
     def other_window(self, p=1, mod=True):
         "Move focus to other window"
-        pages = [x for x in self.get_pages() if x.IsShownOnScreen()]
+        pages = [x for x in self.get_all_pages() if x.IsShownOnScreen()]
         wnd = wx.Window.FindFocus()
         while wnd:
             if wnd in pages:
                 j = pages.index(wnd) + p
                 if mod:
                     j %= len(pages)
                 pages[j].SetFocus()
@@ -1681,19 +1701,21 @@
         if j != -1:
             self.console.DeletePage(j) # Destroy the window
     
     ## --------------------------------
     ## Attributes for notebook pages
     ## --------------------------------
     
-    def get_pages(self, type=None):
+    def get_all_pages(self, type=None):
         """Yields all pages of the specified type in the notebooks."""
         yield from self.console.get_pages(type)
         yield from self.ghost.get_pages(type)
     
+    get_pages = get_all_pages # for backward compatibility
+    
     @property
     def current_shell(self):
         """Currently selected shell or rootshell."""
         return self.console.CurrentPage
     
     ## --------------------------------
     ## Find text dialog
```

## mwx/graphman.py

```diff
@@ -867,33 +867,36 @@
             else:
                 name = '' # to return a dummy pane
         return self._mgr.GetPane(name)
     
     def show_pane(self, name, show=True):
         """Show named pane or notebook pane."""
         pane = self.get_pane(name)
+        plug = self.get_plug(name)
         if not pane.IsOk():
             return
         
-        ## Set graph and output size be as half & half.
+        ## Set the graph and output window sizes to half & half.
         if name == "output" or name is self.output:
             w, h = self.graph.GetClientSize()
             pane.best_size = (w//2, h) # ドッキング時に再計算される
         
-        ## [M-menu] Reload plugin (ret: None if succeeded).
-        if wx.GetKeyState(wx.WXK_ALT):
-            self.reload_plug(name)
-            pane = self.get_pane(name)
-            show = True
-        
-        ## [S-menu] Reset floating position of a stray window.
-        if wx.GetKeyState(wx.WXK_SHIFT):
-            pane.floating_pos = wx.GetMousePosition()
-            pane.Float()
-            show = True
+        ## Force Layer windows to show.
+        if _isLayer(plug):
+            ## [M-menu] Reload plugin (ret: None if succeeded).
+            if wx.GetKeyState(wx.WXK_ALT):
+                self.reload_plug(name)
+                pane = self.get_pane(name)
+                show = True
+            
+            ## [S-menu] Reset floating position of a stray window.
+            if wx.GetKeyState(wx.WXK_SHIFT):
+                pane.floating_pos = wx.GetMousePosition()
+                pane.Float()
+                show = True
         
         self._show_pane(name, show)
         self._mgr.Update()
     
     def _show_pane(self, name, show=True):
         """Show named pane window (internal use only)."""
         pane = self.get_pane(name)
```

## mwx/matplot2g.py

```diff
@@ -422,18 +422,17 @@
             None : {
                   'frame_shown' : [ None ], # show
                  'frame_hidden' : [ None ], # show
                  'frame_loaded' : [ None ], # load
                 'frame_removed' : [ None ], # del[] ! event arg is indices, not frames.
                'frame_selected' : [ None ], # = focus_set
              'frame_deselected' : [ None ], # = focus_kill
-               'frame_modified' : [ None ], # set[],load,roi, (frame.update_buffer)
-               #'frame_updated' : [ None ], # unit,name,ratio (frame.update_extent)
-                'frame_updated' : [ None, _F(self.writeln) ],
-                'frame_cmapped' : [ None ], # cmap
+               'frame_modified' : [ None, _F(self.writeln) ], # set[],load,roi  => update_buffer
+                'frame_updated' : [ None, _F(self.writeln) ], # unit,name,ratio => update_extent
+                'frame_cmapped' : [ None, _F(self.writeln) ], # cmap
                     'line_draw' : [ None ],
                    'line_drawn' : [ None, draw_idle ],
                     'line_move' : [ None ],
                    'line_moved' : [ None, draw_idle ],
                  'line_removed' : [ None, draw_idle ],
                     'mark_draw' : [ None ],
                    'mark_drawn' : [ None, draw_idle ],
@@ -872,16 +871,15 @@
     
     def update_markup_ratio(self, r):
         """Modify markup objects position."""
         if self.Selector.size: self.Selector *= r
         if self.Markers.size: self.Markers *= r
         if self.Region.size: self.Region *= r
         self.draw()
-        self.writeln()
-        
+    
     def kill_buffer(self):
         if self.buffer is not None:
             del self.buffer
     
     def kill_buffer_all(self):
         del self[:]
     
@@ -927,15 +925,14 @@
         return ''
     
     def set_cmap(self, name):
         if self.frame:
             self.frame.set_cmap(name)
             self.handler('frame_cmapped', self.frame)
             self.draw()
-            self.writeln()
     
     def invert_cmap(self):
         if self.frame:
             name = self.frame.get_cmap().name
             self.set_cmap(name + "_r" if name[-2:] != "_r" else name[:-2])
     
     def trace_point(self, x, y, type=None):
```

## mwx/nutshell.py

```diff
@@ -112,59 +112,51 @@
                 'S-tab pressed' : (0, self.on_outdent_line),
                   ## 'C-/ pressed' : (0, ), # cf. C-a home
                   ## 'C-\ pressed' : (0, ), # cf. C-e end
                   'C-; pressed' : (0, _F(self.comment_out_line)),
                 'C-S-; pressed' : (0, _F(self.comment_out_line)),
                   'C-: pressed' : (0, _F(self.uncomment_line)),
                 'C-S-: pressed' : (0, _F(self.uncomment_line)),
-              'Lbutton pressed' : (0, lambda v: click_fork(v, 'Lclick')),
-              'Rbutton pressed' : (0, lambda v: click_fork(v, 'Rclick')),
-              'Mbutton pressed' : (0, lambda v: click_fork(v, 'Mclick')),
-             'Lbutton dblclick' : (0, lambda v: click_fork(v, 'dblclick')),
-                'margin_Lclick' : (0, self.on_margin_click),
-              'margin_dblclick' : (0, self.on_margin_dblclick),
                  'select_itext' : (10, self.filter_text, self.on_itext_enter),
-                  'select_line' : (100, self.on_linesel_begin, skip),
+                  'select_line' : (100, self.on_linesel_begin),
             },
             10 : {
                          'quit' : (0, self.on_itext_exit),
                     '* pressed' : (0, self.on_itext_exit),
                    'up pressed' : (10, skip),
                  'down pressed' : (10, skip),
                 'enter pressed' : (0, self.on_itext_selection),
             },
             100 : {
-                       'motion' : (100, self.on_linesel_motion, skip),
-                 'capture_lost' : (0, self.on_linesel_end, skip),
-             'Lbutton released' : (0, self.on_linesel_end, skip),
+                       'motion' : (100, self.on_linesel_motion),
+                 'capture_lost' : (0, self.on_linesel_end),
+             'Lbutton released' : (0, self.on_linesel_end),
             },
         })
         
-        def click_fork(v, click):
-            if self.__margin is not None:
-                v.Margin = self.__margin # Add info to event object. OK ??
-                self.handler(f"margin_{click}", v)
-            v.Skip()
         self.__margin = None
         
         def on_motion(v):
             self._window_handler('motion', v)
             x, y = v.Position
             w = 0
             for m in range(4):
                 w += self.GetMarginWidth(m)
                 if x < w:
                     self.__margin = m # current margin under mouse
-                    return
-            self.__margin = None
+                    break
+            else:
+                self.__margin = None
             v.Skip()
         self.Bind(wx.EVT_MOTION, on_motion)
         
-        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST,
-                  lambda v: self._window_handler('capture_lost', v))
+        def on_capture_lost(v):
+            self._window_handler('capture_lost', v)
+            v.Skip()
+        self.Bind(wx.EVT_MOUSE_CAPTURE_LOST, on_capture_lost)
         
         ## cf. wx.py.editwindow.EditWindow.OnUpdateUI => Check for brace matching
         self.Bind(stc.EVT_STC_UPDATEUI,
                   lambda v: self.match_paren()) # no skip
         
         def eof(evt):
             p = evt.Position
@@ -720,36 +712,30 @@
     def OnMarginClick(self, evt): #<wx._stc.StyledTextEvent>
         lc = self.LineFromPosition(evt.Position)
         level = self.GetFoldLevel(lc) ^ stc.STC_FOLDLEVELBASE
         ## `level` indicates indent-level number
         ##                 & indent-header (stc.STC_FOLDLEVELHEADERFLAG)
         if level and evt.Margin == 2:
             self.toggle_fold(lc)
+        else:
+            self.handler('select_line', evt)
     
     def OnMarginRClick(self, evt): #<wx._stc.StyledTextEvent>
         """Popup context menu."""
         def _Icon(key):
             return wx.ArtProvider.GetBitmap(key, size=(16,16))
         
         Menu.Popup(self, [
             (wx.ID_DOWN, "&Fold ALL", _Icon(wx.ART_MINUS),
                 lambda v: self.FoldAll(0)),
                 
             (wx.ID_UP, "&Expand ALL", _Icon(wx.ART_PLUS),
                 lambda v: self.FoldAll(1)),
         ])
     
-    def on_margin_click(self, evt): #<wx._core.MouseEvent>
-        if evt.Margin < 2:
-            self.handler('select_line', evt)
-    
-    def on_margin_dblclick(self, evt): #<wx._core.MouseEvent>
-        if evt.Margin < 2:
-            self.FoldAll(0)
-    
     def toggle_fold(self, lc):
         """Similar to ToggleFold, but the top header containing
         the specified line switches between expanded and contracted.
         """
         while 1:
             la = self.GetFoldParent(lc) # get folding root
             if la == -1:
@@ -771,46 +757,52 @@
         while 1:
             level = self.GetFoldLevel(le) ^ stc.STC_FOLDLEVELBASE
             if level == 0 or level == stc.STC_FOLDLEVELHEADERFLAG:
                 break
             le += 1
         return lc, le
     
-    def on_linesel_begin(self, evt): #<wx._core.MouseEvent>
-        ## p = evt.Position
-        p = self.PositionFromPoint(evt.Position)
+    def on_linesel_begin(self, evt):
+        """Called when a line of text selection begins."""
+        p = evt.Position #<wx._stc.StyledTextEvent>
         self.goto_char(p)
         self.cpos = q = self.eol
-        self.CaptureMouse()
         lc = self.LineFromPosition(p)
         if not self.GetFoldExpanded(lc): # Select more lines hidden if folded.
             self.CharRightExtend()
             q = self.cpos
             if q == self.TextLength:
                 q -= 1
         self.__anchors = [p, q]
+        if 1:
+            self.CaptureMouse()
     
-    def on_linesel_motion(self, evt): #<wx._core.MouseEvent>
-        p = self.PositionFromPoint(evt.Position)
+    def on_linesel_motion(self, evt):
+        """Called when a line of text selection is changing."""
+        p = self.PositionFromPoint(evt.Position) #<wx._core.MouseEvent>
         po, qo = self.__anchors
-        if p >= po:
-            lc = self.LineFromPosition(p)
-            text = self.GetLine(lc)
-            self.cpos = p + len(text)
-            self.anchor = po
-            if not self.GetFoldExpanded(lc): # Select more lines hidden if folded.
-                self.CharRightExtend()
-                self.__anchors[1] = self.cpos
+        if self.__margin:
+            if p >= po:
+                lc = self.LineFromPosition(p)
+                text = self.GetLine(lc)
+                self.cpos = p + len(text)
+                self.anchor = po
+                if not self.GetFoldExpanded(lc): # Select more lines hidden if folded.
+                    self.CharRightExtend()
+                    self.__anchors[1] = self.cpos
+            else:
+                self.cpos = p
+                self.anchor = qo
         else:
             self.cpos = p
-            self.anchor = qo
+            self.anchor = po if p >= po else qo
         self.EnsureCaretVisible()
     
     def on_linesel_end(self, evt):
-        del self.__anchors
+        """Called when a line of text selection ends."""
         if self.HasCapture():
             self.ReleaseMouse()
     
     ## --------------------------------
     ## Preferences / Appearance
     ## --------------------------------
     
@@ -1061,14 +1053,15 @@
         while 1:
             pos = raw.find(word, pos+1)
             if pos < 0:
                 break
             yield pos
     
     def filter_text(self, text=None):
+        """Show indicators for the selected text."""
         self.__itextlines = []
         for i in range(2):
             self.SetIndicatorCurrent(i)
             self.IndicatorClearRange(0, self.TextLength)
         if text is None:
             text = self.topic_at_caret
         if not text:
@@ -1085,30 +1078,33 @@
         self.message("{}: {} found".format(text, len(lines)))
         try:
             self.TopLevelParent.findData.FindString = text
         except AttributeError:
             pass
     
     def on_itext_enter(self, evt):
+        """Called when entering filter_text mode."""
         if not self.__itextlines:
             self.handler('quit', evt)
             return
         def _format(ln):
             return "{:4d} {}".format(ln+1, self.GetLine(ln).rstrip())
         self.AutoCompSetSeparator(ord('\n'))
         self.AutoCompShow(0, '\n'.join(map(_format, self.__itextlines))) # cf. gen_autocomp
         self.AutoCompSelect("{:4d}".format(self.cline+1))
         self.Bind(stc.EVT_STC_AUTOCOMP_SELECTION, self.on_itext_selection)
     
     def on_itext_exit(self, evt):
+        """Called when exiting filter_text mode."""
         if self.AutoCompActive():
             self.AutoCompCancel()
         self.Unbind(stc.EVT_STC_AUTOCOMP_SELECTION, handler=self.on_itext_selection)
     
     def on_itext_selection(self, evt):
+        """Called when filter_text is selected."""
         i = self.AutoCompGetCurrent()
         if i == -1:
             evt.Skip()
             return
         line = self.__itextlines[i]
         self.EnsureVisible(line) # expand if folded
         self.goto_line(line)
@@ -1459,14 +1455,26 @@
         f = self.filename
         if f and os.path.isfile(f):
             return os.path.getmtime(f) - self.__mtime
         elif f and re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", f):
             return -1
     
     @property
+    def caption_prefix(self):
+        if self.mtdelta is not None:
+            prefix = ''
+            if self.IsModified():
+                prefix += '*'
+            if self.mtdelta > 0:
+                prefix += '!'
+            elif self.mtdelta < 0:
+                prefix += '%'
+            return prefix + ' ' if prefix else ''
+    
+    @property
     def need_buffer_save(self):
         """Returns whether the buffer should be saved.
         The file has been modified internally.
         """
         return self.mtdelta is not None and self.IsModified()
     
     @property
@@ -1552,31 +1560,30 @@
     def OnUpdate(self, evt): #<wx._stc.StyledTextEvent>
         if evt.Updated & (stc.STC_UPDATE_SELECTION | stc.STC_UPDATE_CONTENT):
             self.trace_position()
             self.handler('stc_updated', evt)
         evt.Skip()
     
     def OnSavePointLeft(self, evt):
-        if self.mtdelta is not None:
-            prefix = '* ' if self.mtdelta == 0 else '*! '
-            self.parent.handler('buffer_caps', self, prefix + self.name)
+        prefix = self.caption_prefix
+        if prefix is not None:
+            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
         evt.Skip()
     
     def OnSavePointReached(self, evt):
-        if self.mtdelta is not None:
-            prefix = '' if self.mtdelta == 0 else '! '
-            self.parent.handler('buffer_caps', self, prefix + self.name)
+        prefix = self.caption_prefix
+        if prefix is not None:
+            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
         evt.Skip()
     
     def on_activated(self, buf):
         """Called when the buffer is activated."""
-        if self.mtdelta is not None and self.mtdelta > 0:
-            prefix = '! ' if not buf.IsModified() else '*! '
-            self.parent.handler('buffer_caps', self, prefix + self.name)
-            self.message("{!r} has been modified externally.".format(self.filename))
+        prefix = self.caption_prefix
+        if prefix is not None:
+            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
         self.trace_position()
     
     def on_inactivated(self, buf):
         """Called when the buffer is inactivated."""
         pass
     
     def on_enter_escmap(self, evt):
@@ -1762,21 +1769,21 @@
         
         self.make_keymap('C-x')
         self.make_keymap('C-c')
         
         self.handler.update({ # DNA<EditorBook>
             None : {
                    'buffer_new' : [ None, dispatch, ],
-                  'buffer_caps' : [ None, dispatch, self.set_caption ],
                  'buffer_saved' : [ None, dispatch, self.set_caption ],
                 'buffer_loaded' : [ None, dispatch, self.set_caption ],
                'buffer_removed' : [ None, dispatch, ],
              'buffer_activated' : [ None, dispatch, self.on_activated ],
            'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
           'buffer_filename_set' : [ None, dispatch, ],
+        'buffer_caption_prefix' : [ None, dispatch, self.set_caption ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
                     '* pressed' : (0, skip),
                    '* released' : (0, skip),
                  'M-up pressed' : (0, _F(self.previous_buffer)),
@@ -1786,36 +1793,35 @@
             },
         })
     
     def OnPageClose(self, evt): #<wx._aui.AuiNotebookEvent>
         nb = evt.EventObject
         buf = nb.all_buffers[evt.Selection]
         if buf.need_buffer_save:
-            if wx.MessageBox(
+            if wx.MessageBox( # Confirm close.
                     "You are closing unsaved content.\n\n"
-                    "Changes to the content will be discarded.\n"
+                    "The changes will be discarded.\n"
                     "Continue closing?",
                     "Close {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The close has been canceled.")
                 evt.Veto()
                 return
         evt.Skip()
     
     def OnPageClosed(self, evt): #<wx._aui.AuiNotebookEvent>
         if self.PageCount == 0:
             self.new_buffer()
         evt.Skip()
     
     def set_caption(self, buf, caption=None):
-        caption = caption or buf.name
         ## if wx.VERSION >= (4,1,0):
         try:
             _p, tab, idx = self.FindTab(buf)
-            tab.GetPage(idx).caption = caption
+            tab.GetPage(idx).caption = caption or buf.name
             tab.Refresh()
         except AttributeError:
             pass
     
     def set_attributes(self, buf=None, **kwargs):
         """Sets attributes and defaultBufferStyle
         that apply to all buffers contained in the EditorBook.
@@ -1943,16 +1949,16 @@
     wildcards = [
         "PY files (*.py)|*.py",
         "ALL files (*.*)|*.*",
     ]
     
     def load_url(self, url, *args, **kwargs):
         import requests
-        if wx.MessageBox(
-                "You are loadint URL contents.\n\n"
+        if wx.MessageBox( # Confirm URL load.
+                "You are loading URL contents.\n\n"
                f"{url!r}\n"
                 "Continue loading?",
                 "Load URL",
                 style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
             self.post_message("The load has been canceled.")
             return None
         try:
@@ -1983,17 +1989,17 @@
         return False
     
     def load_file(self, filename, lineno=0):
         """Load a file into an existing or new buffer.
         """
         buf = self.find_buffer(filename) or self.create_buffer(filename)
         if buf.need_buffer_save:
-            if wx.MessageBox(
+            if wx.MessageBox( # Confirm load.
                     "You are leaving unsaved content.\n\n"
-                    "Changes to the content will be discarded.\n"
+                    "The changes will be discarded.\n"
                     "Continue loading?",
                     "Load {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The load has been canceled.")
                 return None
         try:
             self.Freeze()
@@ -2013,15 +2019,15 @@
     
     def save_file(self, filename, buf=None):
         """Save the current buffer to a file.
         """
         buf = buf or self.buffer
         if buf.need_buffer_load:
             self.swap_page(buf)
-            if wx.MessageBox(
+            if wx.MessageBox( # Confirm save.
                     "The file has been modified externally.\n\n"
                     "The contents of the file will be overwritten.\n"
                     "Continue saving?",
                     "Save {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The save has been canceled.")
                 return None
@@ -2064,15 +2070,15 @@
         with wx.FileDialog(self, "Save buffer as",
                 defaultFile=name,
                 wildcard='|'.join(self.wildcards),
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 return self.save_file(dlg.Path, buf)
     
-    save_as_buffer = save_buffer_as # backward compatibility
+    save_as_buffer = save_buffer_as # for backward compatibility
     
     def save_all_buffers(self):
         for buf in self.all_buffers:
             if buf.need_buffer_save:
                 self.save_buffer(buf)
     
     def open_buffer(self):
@@ -2084,30 +2090,30 @@
                 for f in dlg.Paths:
                     self.load_file(f)
     
     def kill_buffer(self, buf=None):
         """Confirm the close with the dialog."""
         buf = buf or self.buffer
         if buf.need_buffer_save:
-            if wx.MessageBox(
+            if wx.MessageBox( # Confirm close.
                     "You are closing unsaved content.\n\n"
-                    "Changes to the content will be discarded.\n"
+                    "The changes will be discarded.\n"
                     "Continue closing?",
                     "Close {!r}".format(buf.name),
                     style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                 self.post_message("The close has been canceled.")
                 return None
         wx.CallAfter(self.remove_buffer, buf)
     
     def kill_all_buffers(self):
         for buf in self.all_buffers:
             if buf.need_buffer_save:
-                if wx.MessageBox(
+                if wx.MessageBox( # Confirm close.
                         "You are closing unsaved content.\n\n"
-                        "Changes to the content will be discarded.\n"
+                        "The changes will be discarded.\n"
                         "Continue closing?",
                         "Close {!r}".format(buf.name),
                         style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                     self.post_message("The close has been canceled.")
                     return None
         wx.CallAfter(self.remove_all_buffers)
```

## mwx/utilus.py

```diff
@@ -690,15 +690,15 @@
                     a = '' if not actions else ('=> ' + actions),
                     c = '*' if self.__prev_state != self.__state else ' '))
         
         elif v > 3: # state is None
             transaction = self[None].get(pattern) or []
             actions = ', '.join(typename(a, qualp=0) for a in transaction[1:])
             if actions or v > 4:
-                self.log("  -- None {0!r} {a}".format(
+                self.log(" --> None {0!r} {a}".format(
                     self.__event,
                     a = '' if not actions else ('=> ' + actions)))
         
         if v > 7: # max verbose level puts all args
             self.log("\t:", args)
             self.log("\t:", kwargs)
```

## mwx/wxpdb.py

```diff
@@ -289,15 +289,15 @@
     ## Actions for handler
     ## --------------------------------
     
     def find_editor(self, f):
         """Find parent editor which has the specified f:object,
         where `f` can be filename or code object.
         """
-        for editor in self.parent.get_pages(type(self.editor)):
+        for editor in self.parent.get_all_pages(type(self.editor)):
             buf = editor.find_buffer(f)
             if buf:
                 editor.swap_page(buf)
                 return editor
     
     def on_debug_begin(self, frame):
         """Called before set_trace.
```

## Comparing `mwxlib-0.82.6.dist-info/LICENSE` & `mwxlib-0.82.9.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.82.6.dist-info/METADATA` & `mwxlib-0.82.9.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.82.6
+Version: 0.82.9
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.82.6.dist-info/RECORD` & `mwxlib-0.82.9.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 mwx/__init__.py,sha256=bSRdncjfSCKycMFQVnagOi9R2vUCC5snGkjea7jqPgU,2520
 mwx/controls.py,sha256=7hnSimA3bKDgTct29l6Hqpq7BCKqCeOjZJ6JQ1xjh7I,43445
-mwx/framework.py,sha256=weYv1Fp2uaHrwGtJlSC9Ztf9Fe8_l3RZJFK8dOTapn0,72385
-mwx/graphman.py,sha256=krThovLXvlp1OmoIpgkmiBPEa0JQH3U3o154jzAVMvU,69473
+mwx/framework.py,sha256=yQvaa4_fN1LERo8bnn5opTI7cdXTqegp8S1kiGFLBWU,73526
+mwx/graphman.py,sha256=AY5uDOwuguJdCi_7CHBHxuuO8p3AuXtdY-meIY-caIU,69631
 mwx/images.py,sha256=9e8X7OpJ6Z3fF3ez17P_qk2D1NMO10-lN8TCtulAqT0,46248
 mwx/matplot2.py,sha256=mzctMUk00m-tvs268PTwdLln7G3NCl6J-5zFzJkfsVI,36004
-mwx/matplot2g.py,sha256=RllnIIgfveFqeFGclNLPWhstAuH1OFWR_l06ifJEq-4,67727
+mwx/matplot2g.py,sha256=0ysXo-mnluvaikIq2d9FiF8MM07Nzxx3ILpUkIXsPnQ,67652
 mwx/matplot2lg.py,sha256=h_aFij_7ksG2DXuYCaGmjtlcl122vZnwbMTv21Mprcg,27606
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=uZKw9RccADLyiKq9Y2IMCBhRw0JM2Uq_NufKwyy-91Q,138263
-mwx/utilus.py,sha256=s6yyRNyKQEXj3D7eVxOVCgr8pqAHOJs909_P33MzgMY,36924
+mwx/nutshell.py,sha256=foEdUYR4Am4P1rP2kHJ6fQoNNG-l73uPaPlp-kHQw3g,138196
+mwx/utilus.py,sha256=yl0pVbi1f-Nj02GchztVS-kA2bx0WGAb-JgyD32pacE,36924
 mwx/wxmon.py,sha256=L2Q9n2zaSAWruUcBWw9lPpe-NIshoD3LR9o_sRqNENo,11335
-mwx/wxpdb.py,sha256=1fPWkPCB9u9YQnTI-oq9WOs7cgOsLyzur7vFZHWg7Ng,19668
+mwx/wxpdb.py,sha256=-_T83x48tKnMAkY3yEkmxezuFlL66e0CVineMc-62BE,19672
 mwx/wxwil.py,sha256=BUfEF0Nc1E-mVC3Vdz6k1E-2s5J0PO6qEzRQ6lfyePI,5246
 mwx/wxwit.py,sha256=-Dy09jCdKHNSbiFCFR3xM92_4PacdSRlPBZcLXIUeVo,7416
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.82.6.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.82.6.dist-info/METADATA,sha256=BKg5oQr_kNsNb-4NU9ICNULNa0Ra-F3AQk4CW6rzP4s,1893
-mwxlib-0.82.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwxlib-0.82.6.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.82.6.dist-info/RECORD,,
+mwxlib-0.82.9.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.82.9.dist-info/METADATA,sha256=Umk0q9wWnWtdnmK9S1YdnLhamkYqa3E_qGxifyR60yA,1893
+mwxlib-0.82.9.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwxlib-0.82.9.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.82.9.dist-info/RECORD,,
```

