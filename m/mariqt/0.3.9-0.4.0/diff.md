# Comparing `tmp/mariqt-0.3.9-py3-none-any.whl.zip` & `tmp/mariqt-0.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,29 @@
-Zip file size: 221408 bytes, number of entries: 33
--rw-r--r--  2.0 unx     5876 b- defN 22-Dec-21 19:20 mariqt/converters.py
--rw-r--r--  2.0 unx    11025 b- defN 22-Dec-21 19:20 mariqt/core.py
--rw-r--r--  2.0 unx     8485 b- defN 22-Dec-21 19:20 mariqt/directories.py
--rw-r--r--  2.0 unx      465 b- defN 22-Dec-21 19:20 mariqt/equipment.py
--rw-r--r--  2.0 unx    16138 b- defN 22-Dec-21 19:20 mariqt/files.py
--rw-r--r--  2.0 unx    25991 b- defN 22-Dec-21 19:20 mariqt/geo.py
--rw-r--r--  2.0 unx    23173 b- defN 22-Dec-21 19:20 mariqt/image.py
--rw-r--r--  2.0 unx     3064 b- defN 22-Dec-21 19:20 mariqt/misc.py
--rw-r--r--  2.0 unx    38424 b- defN 22-Dec-21 19:20 mariqt/navigation.py
--rw-r--r--  2.0 unx     7348 b- defN 22-Dec-21 19:20 mariqt/provenance.py
--rw-r--r--  2.0 unx    22316 b- defN 22-Dec-21 19:20 mariqt/reports.py
--rw-r--r--  2.0 unx     4294 b- defN 22-Dec-21 19:20 mariqt/settings.py
--rw-r--r--  2.0 unx    13672 b- defN 22-Dec-21 19:20 mariqt/tests.py
--rw-r--r--  2.0 unx    30636 b- defN 22-Dec-21 19:20 mariqt/variables.py
--rw-r--r--  2.0 unx       20 b- defN 22-Dec-21 19:20 mariqt/version.py
--rw-r--r--  2.0 unx    48812 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/notebookWidgets.py
--rw-rw-rw-  2.0 unx     1520 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/icons/checkbox-circle-line_gray.png
--rw-rw-rw-  2.0 unx     1525 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/icons/checkbox-circle-line_green.png
--rw-rw-rw-  2.0 unx     1502 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/icons/error-warning-line_gray.png
--rw-rw-rw-  2.0 unx     1513 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/icons/error-warning-line_orange.png
--rw-rw-rw-  2.0 unx     1470 b- defN 22-Dec-21 19:20 mariqt/for_notebooks/icons/error-warning-line_red.png
--rw-r--r--  2.0 unx    12135 b- defN 22-Dec-21 19:20 mariqt/sources/dship.py
--rw-r--r--  2.0 unx     4586 b- defN 22-Dec-21 19:20 mariqt/sources/dship_settings.py
--rw-r--r--  2.0 unx     1988 b- defN 22-Dec-21 19:20 mariqt/sources/elements.py
--rw-r--r--  2.0 unx    90711 b- defN 22-Dec-21 19:20 mariqt/sources/ifdo.py
--rw-r--r--  2.0 unx     5533 b- defN 22-Dec-21 19:20 mariqt/sources/ofop.py
--rw-r--r--  2.0 unx   650149 b- defN 22-Dec-21 19:20 mariqt/sources/svgs.py
--rw-r--r--  2.0 unx     3728 b- defN 22-Dec-21 19:20 mariqt/sources/underway.py
--rw-rw-rw-  2.0 unx    35140 b- defN 22-Dec-21 19:21 mariqt-0.3.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     1087 b- defN 22-Dec-21 19:21 mariqt-0.3.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Dec-21 19:21 mariqt-0.3.9.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 22-Dec-21 19:21 mariqt-0.3.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2732 b- defN 22-Dec-21 19:21 mariqt-0.3.9.dist-info/RECORD
-33 files, 1075157 bytes uncompressed, 217080 bytes compressed:  79.8%
+Zip file size: 207376 bytes, number of entries: 27
+-rw-r--r--  2.0 unx     5876 b- defN 23-May-10 11:01 mariqt/converters.py
+-rw-r--r--  2.0 unx    12316 b- defN 23-May-10 11:01 mariqt/core.py
+-rw-r--r--  2.0 unx     8485 b- defN 23-May-10 11:01 mariqt/directories.py
+-rw-r--r--  2.0 unx      465 b- defN 23-May-10 11:01 mariqt/equipment.py
+-rw-r--r--  2.0 unx    16541 b- defN 23-May-10 11:01 mariqt/files.py
+-rw-r--r--  2.0 unx    27845 b- defN 23-May-10 11:01 mariqt/geo.py
+-rw-r--r--  2.0 unx    23283 b- defN 23-May-10 11:01 mariqt/image.py
+-rw-r--r--  2.0 unx     3064 b- defN 23-May-10 11:01 mariqt/misc.py
+-rw-r--r--  2.0 unx    40059 b- defN 23-May-10 11:01 mariqt/navigation.py
+-rw-r--r--  2.0 unx     7345 b- defN 23-May-10 11:01 mariqt/provenance.py
+-rw-r--r--  2.0 unx    22316 b- defN 23-May-10 11:01 mariqt/reports.py
+-rw-r--r--  2.0 unx     4294 b- defN 23-May-10 11:01 mariqt/settings.py
+-rw-r--r--  2.0 unx    13762 b- defN 23-May-10 11:01 mariqt/tests.py
+-rw-r--r--  2.0 unx    30040 b- defN 23-May-10 11:01 mariqt/variables.py
+-rw-r--r--  2.0 unx       21 b- defN 23-May-10 11:01 mariqt/version.py
+-rw-r--r--  2.0 unx    12135 b- defN 23-May-10 11:01 mariqt/sources/dship.py
+-rw-r--r--  2.0 unx     4586 b- defN 23-May-10 11:01 mariqt/sources/dship_settings.py
+-rw-r--r--  2.0 unx     2177 b- defN 23-May-10 11:01 mariqt/sources/elements.py
+-rw-r--r--  2.0 unx   102939 b- defN 23-May-10 11:01 mariqt/sources/ifdo.py
+-rw-r--r--  2.0 unx     5533 b- defN 23-May-10 11:01 mariqt/sources/ofop.py
+-rw-r--r--  2.0 unx   650149 b- defN 23-May-10 11:01 mariqt/sources/svgs.py
+-rw-r--r--  2.0 unx     3728 b- defN 23-May-10 11:01 mariqt/sources/underway.py
+-rw-rw-rw-  2.0 unx    35140 b- defN 23-May-10 11:02 mariqt-0.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1108 b- defN 23-May-10 11:02 mariqt-0.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-10 11:02 mariqt-0.4.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-May-10 11:02 mariqt-0.4.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2075 b- defN 23-May-10 11:02 mariqt-0.4.0.dist-info/RECORD
+27 files, 1035381 bytes uncompressed, 204134 bytes compressed:  80.3%
```

## zipnote {}

```diff
@@ -39,32 +39,14 @@
 
 Filename: mariqt/variables.py
 Comment: 
 
 Filename: mariqt/version.py
 Comment: 
 
-Filename: mariqt/for_notebooks/notebookWidgets.py
-Comment: 
-
-Filename: mariqt/for_notebooks/icons/checkbox-circle-line_gray.png
-Comment: 
-
-Filename: mariqt/for_notebooks/icons/checkbox-circle-line_green.png
-Comment: 
-
-Filename: mariqt/for_notebooks/icons/error-warning-line_gray.png
-Comment: 
-
-Filename: mariqt/for_notebooks/icons/error-warning-line_orange.png
-Comment: 
-
-Filename: mariqt/for_notebooks/icons/error-warning-line_red.png
-Comment: 
-
 Filename: mariqt/sources/dship.py
 Comment: 
 
 Filename: mariqt/sources/dship_settings.py
 Comment: 
 
 Filename: mariqt/sources/elements.py
@@ -78,23 +60,23 @@
 
 Filename: mariqt/sources/svgs.py
 Comment: 
 
 Filename: mariqt/sources/underway.py
 Comment: 
 
-Filename: mariqt-0.3.9.dist-info/LICENSE
+Filename: mariqt-0.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: mariqt-0.3.9.dist-info/METADATA
+Filename: mariqt-0.4.0.dist-info/METADATA
 Comment: 
 
-Filename: mariqt-0.3.9.dist-info/WHEEL
+Filename: mariqt-0.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: mariqt-0.3.9.dist-info/top_level.txt
+Filename: mariqt-0.4.0.dist-info/top_level.txt
 Comment: 
 
-Filename: mariqt-0.3.9.dist-info/RECORD
+Filename: mariqt-0.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mariqt/core.py

```diff
@@ -1,14 +1,16 @@
 import os
 import uuid
 import hashlib
 import datetime
 import threading
 import time
 import ast
+import gc
+import copy
 
 import mariqt.variables as miqtv
 
 
 def assertExists(path):
 	""" Asserts that a file/folder exists and otherwise terminates the program"""
 	if not os.path.exists(path):
@@ -111,18 +113,21 @@
 			dt = datetime.datetime.strptime(dt_str,miqtv.date_formats['mariqt_files']+"%z")
 		except:
 			raise Exception("can not parse time from file name " + fileName)
 	return dt
 
 
 def recursivelyUpdateDicts(oldDict:dict, newDict:dict, mutuallyExclusives:list=[]):
-	""" Recursively updates oldDict with newDict """
+	""" Recursively updates oldDict with newDict.
+		Merges item entries with identical image-datetime.
+	 	Item entries without image-datetime will get image default (start) datetime.
+		Item lists will be sorted by image-datetime. """
 	log = []
 	for newItem in newDict:
-		# special case for updating video items which may contain of a list of dicts, each with a different timestamp which have to be checked and them get updated
+		# special case for updating video items which may contain of a list of dicts, each with a different timestamp which have to be checked and then get updated
 		try:
 			# both items are not lists
 			if newDict[newItem]['image-datetime'] != oldDict[newItem]['image-datetime']:
 				oldDict[newItem] = [oldDict[newItem]] # will be handled in bellow
 		except:
 			# TODO write to log?
 			pass
@@ -195,35 +200,35 @@
 				toExclude = [e for e in mutuallyExclusive if e != newItem]
 				for exclude in toExclude:
 					if exclude in oldDict:
 						oldDict[exclude] = ""
 						log.append("Removed field " + exclude + " since mutually exclusive to added field " + newItem)
 	return log
 
-def recursivelyRemoveEmptyFields(oldObj,contente2beRemoved = ""):
+def recursivelyRemoveEmptyFields(oldObj,content2beRemoved = ""):
 	""" Return a dict/list in which all fields in all levels of oldObj that have empty string values are removed """
 
 	if isinstance(oldObj,dict):
-		newDict =  {k: v for k, v in oldObj.items() if v != contente2beRemoved and __isNotEmptyDict(v)}
+		newDict =  {k: v for k, v in oldObj.items() if v != content2beRemoved and __isNotEmptyDict(v)}
 		newEmptyDicts = []
 		for item in newDict:
 			if isinstance(newDict[item],dict) or isinstance(newDict[item],list):
-				newDict[item] = recursivelyRemoveEmptyFields(newDict[item],contente2beRemoved)
+				newDict[item] = recursivelyRemoveEmptyFields(newDict[item],content2beRemoved)
 				if newDict[item] == {} or newDict[item] == []:
 					newEmptyDicts.append(item)
 		for item in newEmptyDicts:
 			del newDict[item]
 		return newDict
 
 	elif isinstance(oldObj,list):
-		newList =  [v for v in oldObj if v != contente2beRemoved and __isNotEmptyDict(v)]
+		newList =  [v for v in oldObj if v != content2beRemoved and __isNotEmptyDict(v)]
 		newEmptyList = []
 		for i in range(len(newList)):
 			if isinstance(newList[i],list) or isinstance(newList[i],dict):
-				newList[i] = recursivelyRemoveEmptyFields(newList[i],contente2beRemoved)
+				newList[i] = recursivelyRemoveEmptyFields(newList[i],content2beRemoved)
 				if newList[i] == [] or newList[i] == {}:
 					newEmptyList.append(newList[i])
 		for item in newEmptyList:
 			newList.remove(item)
 		return newList
 	else:
 		raise Exception("Must be dict or list",oldObj)
@@ -249,21 +254,52 @@
 				except Exception:
 					pass
 			elif isinstance(obj[i],list) or isinstance(obj[i],dict):
 				recursiveEval(obj[i])
 	else:
 		raise Exception("Must be dict or list ",obj)
 
+
+def recursiveMakeNoneDictFieldsEmptyStr(d:dict):
+	""" Recursively replace all dict values which are not dicts them selfs with empty strings  """
+	for key,val in d.items():
+		if not isinstance(val,dict):
+			d[key] = ""
+		else:
+			recursiveMakeNoneDictFieldsEmptyStr(val)
+
+
 def __isNotEmptyDict(obj):
 	if isinstance(obj,dict) and not obj:
 		return False 
 	if isinstance(obj,list) and obj == []:
 		return False
 	return True
 
+
+def findCommonDictElements(dict1:dict,dict2:dict):
+	""" Recursively looks for common elements and returns copy of common part """
+	common = {}
+
+	if  dict1 == dict2:
+		return copy.deepcopy(dict1)
+	elif not isinstance(dict1,dict) and not isinstance(dict2,dict) and dict1 != dict2:
+		return common 
+	else:
+		commonKeys = list(set(list(dict1.keys())).intersection(dict2.keys()))
+		for key in commonKeys:
+			d1v = dict1[key]
+			d2v = dict2[key]
+			ret = findCommonDictElements(d1v,d2v)
+			if ret != {}:
+				common[key] = ret
+
+	return common
+
+
 def reformatImageDateTimeStr(data,format=miqtv.date_formats["mariqt"]):
 	""" reformats data or any field 'image-datetime' within data to MarIQT standard time string format. Throws exception if unsuccessfull """
 	if isinstance(data,list):
 		for item in data:
 			if isinstance(item,dict) or isinstance(item,list):
 				reformatImageDateTimeStr(item,format)
 	elif isinstance(data,dict):
@@ -303,14 +339,15 @@
 				dots +=  "."
 			else:
 				dots = ""
 			print(msg + dots + "   ", end="\r", flush=True)
 			time.sleep(dotsInteval)
 
 	def stop(self):
+		""" should be called when exception is thrown """
 		if not miqtv.getGlobalVerbose():
 			return
 		if not self.myThread.is_alive():
 			return
 		self.myThread.do_run = False
 		self.myThread.join()
 		print("".join([" "]*(len(self.msg)+4)), end="\r", flush=True) 
@@ -345,9 +382,18 @@
 		print("".join([" "]*(len(self.msg)+ 2*len(str(self.N)) + 10 )), end="\r", flush=True) # clear line
 		time.sleep(0.5)
 		print("".join([" "]*(len(self.msg)+ 2*len(str(self.N)) + 10 )), end="\r", flush=True) # clear line
 
 
 class IfdoException(Exception):
 	""" Exception type purely related to iFDO issues """
-	pass
+	
+	def __init__(self, *args):
+		super().__init__(args)
+
+	def __str__(self):
+		# stop PrintLoadingMsg if its still running
+		for obj in gc.get_objects():
+			if isinstance(obj, PrintLoadingMsg):
+				obj.stop()
+		return super().__str__()
```

## mariqt/files.py

```diff
@@ -65,31 +65,31 @@
 			for s in search:
 				if s in file.lower():
 					ret.append(path+file)
 					break
 	return ret
 
 
-def browseForFiles(path:str,extensions:list = [],recursive=True,skipConfigFiles=True):
+def browseForFiles(path:str,extensions:list = [],recursive=True,skipConfigFiles=True,ignoreSubDirs:list = []):
 	""" Returns list of files (with path) found in path and its subfolders if recursive True. If extensions is not empty only files machting those are returned"""
 
 	ret = []
 	if not os.path.exists(path):
 		raise Exception(path, "does not exist")
 	if path[-1] != "/" and path[-1] != "\\":
 		path += "/"
 	files = os.listdir(path)
 	for file in files:
 
 		if skipConfigFiles and file[0] == ".":
 			continue
 
 		# Recurse into subfolders
-		if recursive and os.path.isdir(path+file):
-			ret.extend(browseForFiles(path+file+"/",extensions,recursive,skipConfigFiles))
+		if recursive and os.path.isdir(path+file) and file not in ignoreSubDirs:
+			ret.extend(browseForFiles(path+file+"/",extensions,recursive,skipConfigFiles,ignoreSubDirs))
 
 		elif os.path.isfile(path+file):
 			if len(extensions) > 0:
 				file_ext = os.path.splitext(file)[1].replace(".","").lower()
 				if file_ext in extensions:
 					ret.append(path+file)
 			else:
@@ -539,8 +539,18 @@
 	if add_utc:
 		time_str += "+0000"
 		date_format += "%z"
 	try:
 		timestamp = int(datetime.datetime.strptime(time_str, date_format).timestamp() * 1000)
 	except Exception as e:
 		raise Exception("Could not create datetime from",time_str,"with format",date_format)
-	return timestamp
+	return timestamp
+
+
+def extendFileName(fileName:str, extension:str):
+	""" adds extension to fileName before .<ext>  """
+	return ".".join(fileName.split(".")[0:-1]) + extension + '.' + fileName.split(".")[-1]
+
+
+def changeFileExtension(fileName:str, extension:str):
+	""" replaces files .<ext> """
+	return ".".join(fileName.split(".")[0:-1] + [extension])
```

## mariqt/geo.py

```diff
@@ -2,16 +2,17 @@
 import math
 import mariqt.core as miqtc
 from abc import ABC, abstractmethod
 import cmath
 import numpy as np
 import pymap3d
 import copy
-from pyproj import Proj
+import utm
 import statistics
+import json
 
 import mariqt.variables as miqtv
 
 class NumDataTimeStamped(ABC):
 	""" Abstract class for data in form of a dict with UNIX timestamps in milliseconds as key """
 	@abstractmethod
 	def interpolateAtTime(self,utc:int,sorted_time_points:list = [] ,startIndex:int = 0):
@@ -26,14 +27,19 @@
 	def __init__(self,utc:int,lat:float,lon:float,dep:float=0,hgt:float=-1,uncert:float=-1):
 		self.lat = lat
 		self.lon = lon
 		self.utc = utc
 		self.dep = dep
 		self.hgt = hgt
 		self.uncert = uncert
+		# utm 
+		self.east = None
+		self.north = None
+		self.zone = None
+		self.Nhemis = None # is northern hemisphere 
 
 	def dateTime(self):
 		return datetime.datetime.utcfromtimestamp(self.utc / 1000)
 
 	def __str__(self) -> str:
 		return "utc: " + str(self.dateTime()) + ", lat: " + str(self.lat) + ", lon: " + str(self.lon) + ", dep: " + str(self.dep) + ", hgt: " + str(self.hgt) + ", uncert: " + str(self.uncert)
 
@@ -43,14 +49,17 @@
 		return False
 
 	def cotainsNoneValuesInRequiredFields(self):
 		if self.lat is None or self.lon is None or self.dep is None:
 			return True
 		return False
 
+	def calculateUTM(self):
+		self.east,self.north,self.zone,self.Nhemis = latLon2utm(self.lat,self.lon)
+
 class Positions(NumDataTimeStamped):
 	""" A class that holds several 4.5D Positions in the form of a dictionary with UNIX timestamps in milliseconds as keys and containing (x,y,z,d,h) tuples. Decorator pattern of a dictionary"""
 
 	def __init__(self,positions=None):
 		if positions is None:
 			positions = {}
 		self.positions = positions
@@ -213,47 +222,92 @@
 				uncert_not_zero = True
 			prev_lat = self.positions[utc].lat
 			prev_lon = self.positions[utc].lon
 			prev_dep = self.positions[utc].dep
 			prev_hgt = self.positions[utc].hgt
 		return lat_identical,lon_identical,dep_identical,hgt_identical,dep_not_zero,hgt_not_zero,uncert_not_zero
 
-	def write2File(self,file):
+	def calculateUTM(self):
+		for utc in self.positions:
+			self.positions[utc].calculateUTM()
+
+	def write2File(self,file,ignoreUTM=False):
 		""" Writes positions to tab separated file """
 
 		# Check whether depth and height are set
 		lat_identical, lon_identical, dep_identical, hgt_identical, dep_not_zero, hgt_not_zero,uncert_not_zero = self.checkPositionsContent()
 
+		# check UTM
+		hasUTM = False
+		if not ignoreUTM:
+			for utc in self.positions:
+				if not self.positions[utc].east is None:
+					hasUTM = True
+					break
+
 		# Write to navigation txt file
 		# header
 		res = open(file, "w")
 		res.write(miqtv.col_header['mariqt']['utc'])
 		res.write("\t"+miqtv.col_header['mariqt']['lat'])
 		res.write("\t"+miqtv.col_header['mariqt']['lon'])
 		if dep_not_zero:
 			res.write("\t"+miqtv.col_header['mariqt']['dep'])
 		if hgt_not_zero:
 			res.write("\t"+miqtv.col_header['mariqt']['hgt'])
 		if uncert_not_zero:
 			res.write("\t"+miqtv.col_header['mariqt']['uncert'])
+		if hasUTM:
+			res.write("\t"+'easting'+"\t"+'northing'+"\t"+'zone'+"\t"+'isNorthernHemisphere')
 		res.write("\n")
 		# data lines
 		for utc in self.positions:
 			res.write(datetime.datetime.fromtimestamp(utc / 1000,tz=datetime.timezone.utc).strftime(miqtv.date_formats['mariqt'])) 
 			res.write("\t"+str(self.positions[utc].lat))
 			res.write("\t"+str(self.positions[utc].lon))
 			if dep_not_zero:
 				res.write("\t"+str(self.positions[utc].dep))
 			if hgt_not_zero:
 				res.write("\t"+str(self.positions[utc].hgt))
 			if uncert_not_zero:
 				res.write("\t"+str(self.positions[utc].uncert))
+			if hasUTM:
+				res.write("\t"+str(self.positions[utc].east)+"\t"+str(self.positions[utc].north)+"\t"+str(self.positions[utc].zone)+"\t"+str(self.positions[utc].Nhemis))
 			res.write("\n")
 		res.close()
 
+
+	def toGeoJson(self, collectionName:str):
+		""" returns geojson dict """
+		lat_identical, lon_identical, dep_identical, hgt_identical, dep_not_zero, hgt_not_zero,uncert_not_zero = self.checkPositionsContent()
+		geojson = {'type': 'FeatureCollection', 'name': collectionName, 'features': []}
+		for utc in self.positions:
+			if dep_not_zero:
+				geometry =  {'type': "Point", 'coordinates': 
+								[self.positions[utc].lon, self.positions[utc].lat, self.positions[utc].dep]
+							}
+			else:
+				geometry =  {'type': "Point", 'coordinates': 
+								[self.positions[utc].lon, self.positions[utc].lat]
+							}
+			if True in [math.isnan(x) for x in geometry['coordinates']]:
+				continue
+
+			geojson['features'].append({'type': 'Feature', 'properties': {'id': datetime.datetime.fromtimestamp(utc / 1000,tz=datetime.timezone.utc).strftime(miqtv.date_formats['mariqt'])}, 'geometry': geometry })
+
+		return geojson
+
+
+	def toGeoJsonFile(self, collectionName:str, file:str):
+		""" writes to geojson file """
+		o = open(file,"w", errors="ignore", encoding='utf-8')
+		json.dump(self.toGeoJson(collectionName), o, ensure_ascii=False, indent=4)
+		o.close()
+
+
 class Attitude:
 	""" A class defining an attitude, encoded by a utc time (unix in milliseconds) and yaw, pitch, roll in degrees which are by default 0."""
 	def __init__(self,utc:int,yaw:float=0,pitch:float=0,roll:float=0):
 		self.utc = utc
 		try:
 			self.yaw = float(yaw)
 		except Exception as ex:
@@ -579,15 +633,19 @@
 	""" adds and offest in vehicle coordinates to an original lat,lon,depth(downward positive) position (wgs84) and returns new lat,lon,depth position. 
 		Angles in degrees, offsets in meters """
 
 	# get offest in NED
 	offest_xyz = np.array([offset_x,offset_y,offest_z])
 	offset_NED = R_YawPitchRoll(yaw,pitch,roll).dot(offest_xyz)
 
-	ell = pymap3d.Ellipsoid("wgs84")
+	try:
+		ell = pymap3d.Ellipsoid.from_name("wgs84")
+	except AttributeError:
+		# pymap3d 2.x support
+		ell = pymap3d.Ellipsoid("wgs84")
 	lat_lon_h_new =  pymap3d.ned2geodetic(offset_NED[0], offset_NED[1], offset_NED[2],orig_lat,orig_lon,-orig_depth,ell=ell)
 	lat_new = lat_lon_h_new[0]
 	lon_new = lat_lon_h_new[1]
 	depth_new = -lat_lon_h_new[2]
 
 	return lat_new,lon_new,depth_new
 
@@ -645,23 +703,20 @@
 	#wldExt[-1] = 'w'
 
 	return imagefilename[0:extPontIndex] + '.' + wldExt
 
 
 def latLon2utm(lat:float,lon:float, ellps='WGS84'):
 	""" returns easting,norting,zone:int,isNortherHemisphere:bool """
-	e2u_zone=int(divmod(lon, 6)[0])+31
-	e2u_conv=Proj(proj='utm', zone=e2u_zone, ellps=ellps)
-	utmx, utmy=e2u_conv(lon, lat)
-	#Add offset if the point in the southern hemisphere
+	utmx, utmy, zone, zl_2 = utm.from_latlon(lat,lon)
 	isNortherHemisphere = True
 	if lat<0:
-		utmy=utmy+10000000
 		isNortherHemisphere = False
-	return utmx,utmy,e2u_zone,isNortherHemisphere
+	return utmx,utmy,zone,isNortherHemisphere
+
 
 def median2D(x_:list,y_:list,maxIteratinos = 1000,TerminationTolerance = 0.000001):
 	""" Calculates geometric median. Returns [median_x,median_y],terminationCriterion"""
 	if len(x_) != len(y_):
 		raise Exception("median2D: x and y must have the same dimensions")
 	if len(x_) == 1:
 		return [x_[0],y_[0]], "only one point, nothing to smooth"
```

## mariqt/image.py

```diff
@@ -69,15 +69,16 @@
 		return True
 	except FileNotFoundError:
 		return False
 
 
 def getVideoUUID(path):
 	""" For multiple photos per directory getImageUUIDsForFolder() is much faster.
-		Uses exiftool to query an video file for a UUID in its metadata (-identifier) or for mkv uses mkvinfo and 'Segment UID'. Returns an empty string if there is no UUID encoded in the file."""
+		Uses exiftool to query an video file for a UUID in its metadata (-identifier) or for mkv uses mkvinfo and 'Segment UID'. 
+		Returns tuple parsed_uuid, completeMessage. parsed_uuid is an empty string if there is no UUID encoded in the file. """
 	
 	if not os.path.exists(path):
 		raise Exception("file " + path + " not found!")
 
 	ext = path.split('.')[-1]
 	if ext.casefold() != 'mkv':
 
@@ -140,15 +141,16 @@
 	segmentUID_end = all.find('\n',segmentUID_id_matches[0])
 	segmentUIDstr = all[segmentUID_id_matches[0]+len(segmentUID_id):segmentUID_end].replace(" 0x","").replace(" ","").strip()
 	return segmentUIDstr, all
 
 
 def getPhotoUUID(path):
 	""" For multiple files per directory getImageUUIDsForFolder() is much faster.
-		ses exiftool to query an image file for a UUID in its metadata. Returns an empty string if there is no UUID encoded in the file."""
+		uses exiftool to query an image file for a UUID in its metadata. 
+		Returns tuple parsed_uuid, completeMessage. parsed_uuid is an empty string if there is no UUID encoded in the file."""
 	if not os.path.exists(path):
 		raise Exception("file " + path + " not found!")
 	command = [miqtv.exiftool_path+"exiftool", "-imageuniqueid", path]
 	try:
 		result = subprocess.run(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
 	except FileNotFoundError:
 		print("Error: exiftool not found at " + miqtv.exiftool_path +". Install with e.g. apt-get install exiftool")
```

## mariqt/navigation.py

```diff
@@ -90,15 +90,15 @@
 		lineNr += 1
 	return attitude_data, msg
 
 
 def runAutomatedCuration(nav_data,params:dict,setNone=False,splineTo1sec=True):
 	""" Runs all steps required for an automated curation of the navigation data."""
 
-	if nav_data.len() < 50:
+	if nav_data.len() < 10:
 		return False, "ERROR: Very few positions (" + str(nav_data.len()) + "). Skipping.", {}
 
 	log = []
 	nav_data_curated = copy.deepcopy(nav_data)
 
 	# Remove duplicate position values
 	depthSeparate = False
@@ -402,15 +402,14 @@
 			if not setNone:
 				positions.remUTC(utc)
 			else:
 				if lateral_speed > max_lateral_speed:
 					positions.positions[utc].lat = None
 					positions.positions[utc].lon = None
 				if vertical_speed > max_vertical_speed:
-					print("set None")
 					positions.positions[utc].dep = None
 			time_removals += 1
 			continue
 
 		pre_utc = utc
 		pre_lat = lat
 		pre_lon = lon
@@ -998,30 +997,40 @@
 			"features": [
 				{ "type": "Feature",
 				"properties": { "id": 0 },
 				"geometry": { "type": type, "coordinates": coordinates } }]}
 	json.dump(gj, o, ensure_ascii=False, indent=4)
 
 
-def writePositionsToTabFile(o,positions:miqtg.Positions,header_format:str,with_depth:bool = False,with_height:bool = False,with_uncert = False,attitudes:miqtg.Attitudes=None):
+def writePositionsToTabFile(o,positions:miqtg.Positions,header_format:str,with_depth:bool = False,with_height:bool = False,with_uncert = False,attitudes:miqtg.Attitudes=None,ignoreUTM=False):
 	""" Write a tab separated ascii file of the positions. You can specify which column headers shall be used for the various output types defined in definitions.py
 		Optionally also attitudes can be written. They must have the same utc timestamps as the positions and will have the default headers. """
 
+	# check UTM
+	hasUTM = False
+	if not ignoreUTM:
+		for utc in positions.positions:
+			if not positions[utc].east is None:
+				hasUTM = True
+				break
+
 	# Construct output file header
 	if header_format not in miqtv.pos_header:
 		raise ValueError("Output type "+ header_format + " not implemented")
 	new_header = ""
 	for col in miqtv.pos_header[header_format]:
 		if col == "dep" and not with_depth:
 			continue
 		elif col == "hgt" and not with_height:
 			continue
 		elif col == "uncert" and not with_uncert:
 			continue
 		new_header += miqtv.pos_header[header_format][col] + "\t"
+	if hasUTM:
+		new_header += 'easting'+"\t"+'northing'+"\t"+'zone'+"\t"+'isNorthernHemisphere'+ "\t"
 	if not attitudes is None:
 		for col in miqtv.att_header["mariqt"]:
 			new_header += miqtv.att_header["mariqt"][col] + "\t"
 	o.write(new_header.strip() + "\n")
 
 	date_format = miqtv.date_formats['pangaea']
 	if header_format in miqtv.date_formats:
@@ -1034,14 +1043,16 @@
 		if with_height:
 			if not positions[utc].hgt is None:
 				line += "\t"+str(round(positions[utc].hgt,2))
 			else:
 				line += "\t"+str(positions[utc].hgt)
 		if with_uncert:
 			line += "\t"+str(round(positions[utc].uncert,2))
+		if hasUTM:
+			line += "\t"+str(round(positions[utc].east,2))+"\t"+str(round(positions[utc].north,2))+"\t"+str(positions[utc].zone)+"\t"+str(positions[utc].Nhemis)
 		if not attitudes is None:
 			if not attitudes[utc].yaw is None:
 				line +=  "\t"+str(round(attitudes[utc].yaw,1))
 			else:
 				line += "\t"+str(attitudes[utc].yaw)
 			if not attitudes[utc].pitch is None:
 				line +=  "\t"+str(round(attitudes[utc].pitch,1))
@@ -1064,14 +1075,15 @@
 				maxDepth = positions[utc].dep
 				maxDepthTime = utc
 		maxDepthTimeStr = ""
 		if maxDepthTime != 0:
 			maxDepthTimeStr = datetime.datetime.fromtimestamp(maxDepthTime / 1000,tz=datetime.timezone.utc)
 
 		# get positions in window
+		"""
 		time_points = list(positions.keys())
 		time_points.sort()
 		timePointsInWindow, start_index = getPositionsInTimeRange(time_points,maxDepthTime - (windowHalfSeconds * 1000 -1), maxDepthTime + (windowHalfSeconds+1) * 1000, 0)
 		timesBefore = 0
 		timesAfter = 0
 		for utc in timePointsInWindow:
 			if utc < maxDepthTime:
@@ -1085,8 +1097,37 @@
 			x.append(positions[utc].lat)
 			y.append(positions[utc].lon)
 		median,terminationCriterion = miqtg.median2D(x,y,maxIteratinos = 1000,TerminationTolerance = 0.0000001)
 		#print(terminationCriterion)
 		medianPos = copy.deepcopy(positions[maxDepthTime])
 		medianPos.lat = median[0]
 		medianPos.lon = median[1]
-		return medianPos, maxDepth, maxDepthTimeStr
+		"""
+		medianPos = getSmoothedPositionAtDateTime(positions,maxDepthTime / 1000.0,windowHalfSeconds,nrPointsBeforeAfter)
+		return medianPos, maxDepth, maxDepthTimeStr
+
+def getSmoothedPositionAtDateTime(positions,timePointUnixSec,windowHalfSeconds:int,nrPointsBeforeAfter=[]):
+	""" returns median position at time point """
+	timePointUnixMSec = timePointUnixSec * 1000
+	# get positions in window
+	time_points = list(positions.keys())
+	time_points.sort()
+	timePointsInWindow, start_index = getPositionsInTimeRange(time_points,timePointUnixMSec - (windowHalfSeconds * 1000 -1), timePointUnixMSec + (windowHalfSeconds+1) * 1000, 0)
+	timesBefore = 0
+	timesAfter = 0
+	for utc in timePointsInWindow:
+		if utc < timePointUnixMSec:
+			timesBefore += 1
+		if utc > timePointUnixMSec:
+			timesAfter += 1
+	nrPointsBeforeAfter.append(timesBefore)
+	nrPointsBeforeAfter.append(timesAfter)
+	x,y = [],[]
+	for utc in timePointsInWindow:
+		x.append(positions[utc].lat)
+		y.append(positions[utc].lon)
+	median,terminationCriterion = miqtg.median2D(x,y,maxIteratinos = 1000,TerminationTolerance = 0.0000001)
+	#print(terminationCriterion)
+	medianPos, past_nearest_index = positions.interpolateAtTime(timePointUnixMSec)
+	medianPos.lat = median[0]
+	medianPos.lon = median[1]
+	return medianPos
```

## mariqt/provenance.py

```diff
@@ -79,15 +79,15 @@
 		with open(prev_provenance) as file:
 
 			file_name = os.path.basename(prev_provenance)
 			file_content = file.read()
 			file_mtime = datetime.datetime.fromtimestamp(os.path.getmtime(prev_provenance),tz=datetime.timezone.utc)
 
 			try:
-				tmp_prov = yaml.load(file_content,  Loader=yaml.FullLoader)
+				tmp_prov = yaml.load(file_content,  Loader=yaml.CLoader)
 				if not 'provenance' in tmp_prov:
 					# This is a yaml file but not in the expected mariqt provenance style
 					self.prov.append({'executable':{'name':file_name},'log':file_content,'time':file_mtime.strftime(miqtv.date_formats['mariqt'])})
 				else:
 					# This is a mariqt provenance file, just copy its entire content
 					for tp in tmp_prov['provenance']:
 						self.prov.append(tp)
```

## mariqt/tests.py

```diff
@@ -117,87 +117,87 @@
 	return [True, ""]
 
 
 def isValidiFDOField(field,value,fieldDefinition=miqtv.ifdo_fields):
 	""" Tries to parse value to field's dataType and throws exception if it does not succeed """
 	
 	if 'valid' in fieldDefinition[field] and value not in fieldDefinition[field]['valid']:
-		raise miqtc.IfdoException(field+": value \"" + value + "\" not in " + str(fieldDefinition[field]['valid']))
+		raise miqtc.IfdoException(field+": value \"" + str(value) + "\" not in " + str(fieldDefinition[field]['valid']))
 	elif field in ['image-filename']:
 		if not isValidImageName(value)[0]:
-			raise miqtc.IfdoException('Invalid item name',value,isValidImageName(value)[1])
+			raise miqtc.IfdoException('Invalid item name',str(value),isValidImageName(value)[1])
 	elif field in ['image-datetime']:
 		try:
 			format = miqtv.date_formats['mariqt']
 			datetime.datetime.strptime(value,format)
 		except:
-			raise miqtc.IfdoException('Invalid datetime value',value, "does not match format:",format)
+			raise miqtc.IfdoException('Invalid datetime value',str(value), "does not match format:",format)
 	
 	elif field in ['image-longitude']:
 		try:
 			value = float(value)
 		except:
-			raise miqtc.IfdoException(field,'value is not a float',value)
+			raise miqtc.IfdoException(field,'value is not a float',str(value))
 		if value < -180 or value > 180:
-			raise miqtc.IfdoException(field,'value is out of bounds',value)
+			raise miqtc.IfdoException(field,'value is out of bounds',str(value))
 	elif field in ['image-latitude']:
 		try:
 			value = float(value)
 		except:
-			raise miqtc.IfdoException(field,'value is not a float',value)
+			raise miqtc.IfdoException(field,'value is not a float',str(value))
 		if value < -90 or value > 90:
-			raise miqtc.IfdoException(field,'value is out of bounds',value)
+			raise miqtc.IfdoException(field,'value is out of bounds',str(value))
 	elif field in ['image-depth']:
 		try:
 			value = float(value)
 		except:
-			raise miqtc.IfdoException(field,'value is not a float',value)
+			raise miqtc.IfdoException(field,'value is not a float',str(value))
 		if value < -1: # it can happen that pressure sensors measure small negative depth at surface
-			raise miqtc.IfdoException(field,'value is out of bounds',value)
+			raise miqtc.IfdoException(field,'value is out of bounds',str(value))
 	elif field in ['image-altitude']:
 		try:
 			value = float(value)
 		except:
-			raise miqtc.IfdoException(field,'value is not a float',value)
+			raise miqtc.IfdoException(field,'value is not a float',str(value))
 		if value < 0:
-			raise miqtc.IfdoException(field,'value is out of bounds',value)
+			raise miqtc.IfdoException(field,'value is out of bounds',str(value))
 	elif field in ['image-abstract']:
 		if len(value) < 500 or len(value) > 2000:
 			raise miqtc.IfdoException("Length of the abstract ("+ str(len(value)) +") is too long (max. 2000 chars) or too short (min 500 chars)")
 	elif field in ['image-pi']:
 		msg = []
 		if not isValidPerson(value,msg):
-			raise miqtc.IfdoException("Not a valid person description for the pi: "+msg[0],value)
+			raise miqtc.IfdoException("Not a valid person description for the pi: "+msg[0],str(value))
 	elif field in ['image-creators']:
 		for p in value:
 			msg = []
 			if not isValidPerson(p,msg):
-				raise miqtc.IfdoException("Not a valid person description for one of the creators: "+msg[0],value)
+				raise miqtc.IfdoException("Not a valid person description for one of the creators: "+msg[0],str(value))
 	elif field in ['image-coordinate-uncertainty-meters']:
 		try:
 			value = float(value)
 		except:
-			raise miqtc.IfdoException(field,'value is not a float',value)
+			raise miqtc.IfdoException(field,'value is not a float',str(value))
 		if value < 0:
-			raise miqtc.IfdoException(field,'value is out of bounds',value)
+			raise miqtc.IfdoException(field,'value is out of bounds',str(value))
 	elif field in fieldDefinition:
 		if 'dataType' in fieldDefinition[field]:
 			if fieldDefinition[field]['dataType'] == miqtv.dataTypes.float:
 				try:
 					value = float(value)
 				except:
-					raise miqtc.IfdoException(field,'value is not a float',value)
+					raise miqtc.IfdoException(field,'value is not a float',str(value))
 			if fieldDefinition[field]['dataType'] == miqtv.dataTypes.int:
 				try:
 					value = int(value)
 				except:
-					raise miqtc.IfdoException(field,'value is not a float',value)
+					raise miqtc.IfdoException(field,'value is not a float',str(value))
 			elif fieldDefinition[field]['dataType'] == miqtv.dataTypes.uuid:
 				if not miqtc.is_valid_uuid(value):
-					raise miqtc.IfdoException(field,"invalid uuid 4:",value)
+					raise miqtc.IfdoException(field,"invalid uuid 4:",str(value))
 	else:
 		print("Unknown field \"" + field + "\"")
 	
 	return value
 
 
 def isValidiFDOItem(item:dict,header:dict,reqFields:dict=miqtv.ifdo_item_core_fields):
```

## mariqt/variables.py

```diff
@@ -136,15 +136,15 @@
 				'exif':{	'img':'SourceFile',
 							'uuid':'imageuniqueid'}
 }
 
 photo_types = ['jpg','png','bmp','raw','jpeg','tif']
 video_types = ['mp4','mov','avi','mts','mkv','wmv']
 image_types = photo_types + video_types
-unsupportedFileTypes = ["mts"]
+unsupportedFileTypes = ["mts",'bmp','raw']
 
 equipment_types = ['CAM','HYA','ENV','NAV','SAM','PFM']
 
 colors = ['#94B242','#24589B','#DCB734','#E7753B','#A0BAAC','#CAD9A0','#82C9EB','#E9DCA6','#ED9A72','#D0DDD6','#EFF5E4','#E6F5FB','#F7F1DC','#F9DED2','#E8EEEB']
 color_names = {'entity':'#94B242','process':'#24589B','infrastructure':'#DCB734','missing':'#ED9A72','error':'#E7753B','green':'#94B242','light_green':'#EFF5E4','blue':'#24589B','light_blue':'#E6F5FB','yellow':'#DCB734','light_yellow':'#F7F1DC','red':'#E7753B','light_red':'#F9DED2','grey':'#A0BAAC','light_grey':'#E8EEEB','mid_green':'#CAD9A0','mid_blue':'#82C9EB','mid_yellow':'#E9DCA6','mid_red':'#ED9A72','mid_grey':'#D0DDD6','dark_grey':'#6D7F77',}
 
 
@@ -294,24 +294,14 @@
 	'image-curation-protocol':{'comment': 'A description of the image and metadata curation steps and results', 'dataType': dataTypes.text},
 }
 
 ifdo_coreFields = {**ifdo_header_core_fields, **ifdo_item_core_fields}
 ifdo_fields =  {**ifdo_coreFields, **ifdo_content_fields, **ifdo_capture_fields}
 
 
-
-# icons for iFDO creation wizard notebook to retrieve them centrally from pip package
-myPath = os.path.dirname(__file__)
-icon_check = open(myPath + "/for_notebooks/icons/checkbox-circle-line_green.png", "rb").read()
-icon_checkDisabled = open(myPath + "/for_notebooks/icons/checkbox-circle-line_gray.png", "rb").read()
-icon_error = open(myPath + "/for_notebooks/icons/error-warning-line_red.png", "rb").read()
-icon_errorDisabled = open(myPath + "/for_notebooks/icons/error-warning-line_gray.png", "rb").read()
-icon_warning = open(myPath + "/for_notebooks/icons/error-warning-line_orange.png", "rb").read()
-
-
 # exiftool path in case its not in PATH
 global exiftool_path
 exiftool_path = ""
 def setExiftoolPath(exiftool_path_:str):
 	""" Sets the basepath for Exiftool if its not in PATH """
 	global exiftool_path
 	exiftool_path = exiftool_path_
```

## mariqt/version.py

```diff
@@ -1 +1,2 @@
-__version__='0.3.9'
+__version__='0.4.0'
+
```

## mariqt/sources/elements.py

```diff
@@ -1,7 +1,10 @@
+"""" This code might be DEPRECATED, consider RATHER USING the Elements Medialib Toolbox (https://codebase.helmholtz.cloud/datahub/marehub/ag-videosimages/elements-medialib-toolbox)   """
+
+
 from elements_sdk import StorageApi, MediaLibraryApi
 
 
 def getWorkspaceIDsForProduction(api:StorageApi,production_id:int):
 	""" Returns a list of all workspaces in the production given by the production.ID.
 		Formatted as a list of dicts ([{'name':workspace.name,'id':workspace.ID,'path':workspace.path},...])  """
```

## mariqt/sources/ifdo.py

```diff
@@ -1,19 +1,20 @@
 """ This class provides functionalities to create, read and adapt iFDO files"""
 
 from math import pi
+import math
 import yaml
 import os
 import json
 import numpy as np
 import ast
 import copy
 import datetime
 from pprint import pprint
-
+from deepdiff import DeepDiff
 import time
 
 import mariqt.core as miqtc
 import mariqt.directories as miqtd
 import mariqt.files as miqtf
 import mariqt.variables as miqtv
 import mariqt.image as miqti
@@ -37,48 +38,50 @@
             return False
 
 def findField(ifdo_dict,keys):
         """ Looks for  keys ("key" or [key1,key2]) in ifdo_dict and returns its value or an empty string if key not found"""
         if not isinstance(keys, list):
             keys = [keys]
 
-        fail = False
-        startingPoints = [ifdo_dict]
-        if miqtv.image_set_header_key in ifdo_dict:
-            startingPoints.append(ifdo_dict[miqtv.image_set_header_key])
-        if miqtv.image_set_items_key in ifdo_dict:
-            startingPoints.append(ifdo_dict[miqtv.image_set_items_key])
-        for startingPoint in startingPoints:
-
-            currentLevel = startingPoint
-            for key in keys:
-                if key in currentLevel and not isinstance(currentLevel, str):
-                    lastVal = currentLevel[key]
-                    currentLevel = currentLevel[key]
-                    fail = False
-                else:
-                    fail = True
-            if not fail:
-                return lastVal
+        ar = ifdo_dict
+        for k in keys:
+            if k in ar:
+                ar = ar[k]
+            else:
+                try:
+                    k = int(k)
+                    if not isinstance(ar,list) or len(ar) < k:
+                        raise ValueError("Index",k,"out of bounds",len(ar))
+                except:
+                    return ""
+                ar = ar[k]
+        return ar
 
-        return ""
 
-    
 class iFDO_Reader:
     " Provides convenient functions for reading data from iFDO files "
 
     def __init__(self, iFDOfile:str):
         " Provides convenient functions for reading data from iFDO files "
         
         self.iFDOfile = iFDOfile
         o = open(self.iFDOfile, 'r')
-        self.ifdo = yaml.load(o,  Loader=yaml.FullLoader)
+        self.ifdo = yaml.load(o,  Loader=yaml.CLoader)
         o.close()
 
 
+    def __getitem__(self, keys):
+        """ Returns copy of checked ifdo set or item field value, also considerng default values from header.
+            Use keys as e.g. '<item>:<key>:...'. Can be used for header fields as well as item fields.
+            Item index can be leglected, in case of video a dict {<image-datatime>:<value>,...} is returned.
+            Raises IfdoException if item does not exist. """
+        keys = keys.split(':')
+        return iFDO._iFDO__getFieldValue(self.ifdo,keys)
+
+
     def getImagesPositions(self,image_types=miqtv.image_types):
         """ Returns images first position(s) 
             @return: {'imageName': [{'lat': value, 'lon': value, 'datetime': value}]}, image-coordinate-reference-system """
         
         retDict = {}
         retRefsys = self.ifdo[miqtv.image_set_header_key]['image-coordinate-reference-system']
 
@@ -248,15 +251,15 @@
         try:
             depth0 = self.__getItemDefaultValue(item,'image-depth')
             if depth0 < 0:
                 underwaterImage = False
         except miqtc.IfdoException:
             pass
         try:
-            alt0 = self.__getItemDefaultValue(item, 'image-altitude')
+            alt0 = self[item+'0:image-altitude'] #self.__getItemDefaultValue(item, 'image-altitude')
             if alt0 > 0:
                 underwaterImage = False
         except miqtc.IfdoException:
             pass
 
         # add correction factor for flat port
         if domePort is None and underwaterImage:
@@ -376,32 +379,17 @@
 
         return scaleFkt
 
 
     def __getItemDefaultValue(self,item:str,fieldName:str):
         """ returns item values (first entry in case of videos). Throws mariqt.core.IfdoException if field not found. """
 
-        itemVal = self.ifdo[miqtv.image_set_items_key][item]
-
-        headerVal = None
-        try:
-            headerVal = self.ifdo[miqtv.image_set_header_key][fieldName]
-        except KeyError:
-            pass
-
-        if not isinstance(itemVal,list):
-            itemVal = [itemVal]
-        try:
-            ret = itemVal[0][fieldName]
-        except KeyError:
-            ret = headerVal
-
-        if ret is None:
+        ret = self[":".join([item,'0',fieldName])]
+        if ret == "":
            raise miqtc.IfdoException("Error: Field {0} neither found in item {1} nor header".format(fieldName,item))
-
         return ret
 
 
     def __getItemLatLon(self,item:str,headerValLat,headerValLon):
         """ returns {'lat': value, 'lon': value, 'datetime': value} of list of those """
 
         itemVal = self.ifdo[miqtv.image_set_items_key][item]
@@ -443,59 +431,63 @@
         except KeyError:
             lon = headerValLon
             if lon is None:
                 raise Exception("Error: Field {0} neither found in item {1} nor header".format('image-longitude',itemVal))
         return {'lat':lat,'lon':lon,'datetime':datetime}
 
 
-def iFDOFromFile(iFDOfile:str,handle_prefix='20.500.12085/ee277578-a911-484d-a515-9c781d79aa91',provenance = None,verbose=True,startEmpty=False,writeTmpProvFile=True):
+def iFDOFromFile(iFDOfile:str,handle_prefix='20.500.12085',provenance = None,verbose=True,startEmpty=False,writeTmpProvFile=True,image_broker_uuid="ee277578-a911-484d-a515-9c781d79aa91"):
     """ Convenience function to create an iFDO object directly form an existing iFDO file. Tries to infer image files location from 'image-local-path'. Returns iFDO object. 
         - iFDOfile: string path to load an explicit iFDO file.
         - handle_prefix: string prefix of the handle server. Default: the one for Geomar.
         - provenance: mariqt.provencance.Provenance object to track data provenance. Default: a new provenance object is created in the 'protocol' subfolder.
         - verbose: bool whether to print out information. Processing is faster if verbose is False. Default: True.
         - startEmpty: bool whether it's accepted that there are not images yet in 'dir'. Default: False.
-        - writeTmpProvFile: bool whether to write a temporary provenance file during the iFDO creation process which will be replaced by a final one in the end. Default: True"""
+        - writeTmpProvFile: bool whether to write a temporary provenance file during the iFDO creation process which will be replaced by a final one in the end. Default: True
+        - image_broker_uuid: uuid of image broker to create image handles as https://hdl.handle.net/<handle_prefix>/<image_broker_uuid>@<image-uuid> """
     reader = iFDO_Reader(iFDOfile)
     imagesDir = miqtc.toUnixPath(os.path.normpath(miqtc.toUnixPath(reader.getImageDirectory())))
     baseDir = miqtc.toUnixPath(os.path.commonpath([iFDOfile,imagesDir]))
     imageDataTypeFolder = [e for e in imagesDir.replace(baseDir,"").split("/") if e != ""][0]
     if imageDataTypeFolder not in miqtd.Dir.dt.__members__:
         raise miqtc.IfdoException("Images are not located in a valid data type directory (raw, intermediate, processed, ...) in the same project as iFDO file.")
     imagesDataTypeDir = os.path.join(baseDir,imageDataTypeFolder)
     dirObj = miqtd.Dir("",imagesDataTypeDir, create=False, with_gear=False)
-    return iFDO(dir=dirObj,handle_prefix=handle_prefix,provenance=provenance,verbose=verbose,startEmpty=startEmpty,writeTmpProvFile=writeTmpProvFile)
+    return iFDO(dir=dirObj,handle_prefix=handle_prefix,provenance=provenance,verbose=verbose,startEmpty=startEmpty,writeTmpProvFile=writeTmpProvFile,iFDOfile=iFDOfile,image_broker_uuid=image_broker_uuid)
 
 
 class iFDO:
     " Class for creating and editing iFDO.yaml files "
 
-    def __init__(self, dir:miqtd.Dir=None, handle_prefix='20.500.12085/ee277578-a911-484d-a515-9c781d79aa91',provenance = None,verbose=True,startEmpty=False,writeTmpProvFile=True,iFDOfile=None):
+    def __init__(self, dir:miqtd.Dir, handle_prefix='20.500.12085',provenance = None,verbose=True,startEmpty=False,writeTmpProvFile=True,iFDOfile=None,image_broker_uuid="ee277578-a911-484d-a515-9c781d79aa91"):
         """ Creates an iFOD object. Requires a valid directory containing image data or/and and iFDO file and a handle prefix if it's not the Geomar one. Loads directory's iFDO file if it exists already.
             - dir: mariqt.directories.Dir object pointing to a valid data type directory (raw, intermediate, processed, ...) containing the image data.
             - handle_prefix: string prefix of the handle server. Default: the one for Geomar.
             - provenance: mariqt.provencance.Provenance object to track data provenance. Default: a new provenance object is created in the 'protocol' subfolder.
             - verbose: bool whether to print out information. Default: True.
             - startEmpty: bool whether it's accepted that there are not images yet in 'dir'. Default: False.
             - writeTmpProvFile: bool whether to write a temporary provenance file during the iFDO creation process which will be replaced by a final one in the end. Default: True
-            - iFDOfile: string path to load an explicit iFDO file. If not provided a matching iFDO file (if it already exists) will be loaded from the 'products' subdirectory. Default: None """
+            - iFDOfile: string path to load an explicit iFDO file. If not provided a matching iFDO file (if it already exists) will be loaded from the 'products' subdirectory. Default: None 
+            - image_broker_uuid: uuid of image broker to create image handles as https://hdl.handle.net/<handle_prefix>/<image_broker_uuid>@<image-uuid> """
 
         # check that at dir or iFDOfile provided
         if dir is None and iFDOfile is None:
             raise miqtc.IfdoException("Neither dir nor iFDOfile provided for iFDO.")
 
         self.dir = dir
         self.imagesDir = dir.totype()
         self.dir.createTypeFolder()
         self.handle_prefix = "https://hdl.handle.net/" + handle_prefix
+        self.image_handle_prefix = self.handle_prefix + "/" + image_broker_uuid
 
         self.imageSetHeaderKey = miqtv.image_set_header_key
         self.imageSetItemsKey = miqtv.image_set_items_key
         self.ifdo_tmp = {self.imageSetHeaderKey: {},
                          self.imageSetItemsKey: {}}
+        self.ifdo_parsed = None
         self.ifdo_checked = copy.deepcopy(self.ifdo_tmp)  # to be set by createiFDO() only!
         self.__allUUIDsChecked = False
         self.reqNavFields = ['image-longitude','image-latitude','image-coordinate-uncertainty-meters',['image-depth','image-altitude']]
         self.prov = provenance
         if provenance == None:
             tmpFilePath = ""
             if writeTmpProvFile:
@@ -517,15 +509,15 @@
         loadediFDO = False
         if not iFDOfile is None:
             iFDOfile_ = iFDOfile
             self.setiFDOFileName(iFDOfile_)
             if not os.path.isfile(iFDOfile_):
                 raise miqtc.IfdoException("iFDO file not found: " + iFDOfile_)
         else:
-            iFDOfile_ = self.dir.to(self.dir.dt.products)+self.constructiFDOfileName(self.dir.event(),self.dir.sensor())
+            iFDOfile_ = self.dir.to(self.dir.dt.products)+self.constructiFDOfileName(self.dir.project(),self.dir.event(),self.dir.sensor())
 
         self._imagesInImagesDir = miqti.browseForImageFiles(self.imagesDir)
         self._imagesInImagesDirSortedList = [file for file in self._imagesInImagesDir]
         self._imagesInImagesDirSortedList.sort()
         self._imageNamesImagesDir = [os.path.basename(file) for file in self._imagesInImagesDir]
 
         if len(self._imagesInImagesDir) == 0 and not startEmpty:
@@ -559,14 +551,15 @@
         else:
             try:
                 path = self.dir.to(self.dir.dt.products)
                 for file_ in os.listdir(path):
                     if file_[-10::] == "_iFDO.yaml" and self.readiFDOfile(path+file_):
                         loadediFDO = True
                         iFDOfile_ = path+file_
+                        break
             except FileNotFoundError:
                 pass        
 
         if loadediFDO:
             self.setiFDOFileName(iFDOfile_)
         self.tryAutoSetHeaderFields()
         self.setHeaderImageLocalPathField()
@@ -577,15 +570,16 @@
         if not os.path.exists(file):
             return False
 
         s = miqtc.PrintLoadingMsg("Loading iFDO file")
         try:
             # 'document.yaml' contains a single YAML document.
             o = open(file, 'r')
-            self.ifdo_tmp = yaml.load(o,  Loader=yaml.FullLoader)
+            self.ifdo_tmp = yaml.load(o,  Loader=yaml.CLoader)
+            self.ifdo_parsed = copy.deepcopy(self.ifdo_tmp)
             o.close()
             s.stop()
             self.prov.addPreviousProvenance(self.prov.getLastProvenanceFile(self.dir.to(self.dir.dt.protocol),self.prov.executable))
         except Exception as e:
             self.prov.log(str(e.args))
             return False
         s.stop()
@@ -606,16 +600,20 @@
 
         # check iFDO version
         readVersion = "v.1.0.0" # did not have the 'image-set-ifdo-version' field yet
         try: 
             readVersion = self.findTmpField('image-set-ifdo-version')
         except KeyError:
             pass
-        if readVersion.strip() != miqtv.iFDO_version:
+        intReadVersion = int(readVersion.strip().replace('.','').replace('v','').replace('a',''))
+        intThisVersion = int(miqtv.iFDO_version.strip().replace('.','').replace('v','').replace('a',''))
+        if intReadVersion < intThisVersion:
             self.prov.log("Loaded iFDO has version " + readVersion + " and will be updated to version " + miqtv.iFDO_version)
+        if intReadVersion > intThisVersion:
+            self.prov.log("CAUTION: Loaded iFDO has version " + readVersion + " is ahead of version used here: " + miqtv.iFDO_version)
 
         # for sooooome reason this fixes a hickup of the prog in createiFDO()
         prog = miqtc.PrintKnownProgressMsg("foo", 1,modulo=1)
         prog.clear()
         try:
             self.convertToDefaultDateTimeFormat(self.ifdo_tmp)
         except Exception as ex:
@@ -639,70 +637,242 @@
         s = miqtc.PrintLoadingMsg("Writing iFDO file")
 
         # check fields again if changed since last check (createiFDO)
         if self.ifdo_tmp != self.ifdo_checked:
             self.createiFDO(self.ifdo_tmp[self.imageSetHeaderKey], miqti.createImageItemsListFromImageItemsDict(self.ifdo_tmp[self.imageSetItemsKey]))
         else:
             self.logMissingFields() # is also done in createiFDO
-        iFDO_path = self.getiFDOFileName()
+        iFDO_path = self.getiFDOFileName(overwrite=True)
 
         o = open(iFDO_path, "w")
         yaml.dump(self.ifdo_checked, o, default_style=None, default_flow_style=None, allow_unicode=True, width=float("inf"))
         o.close()
+
+        """
+        # for iFDO version > 2.0
+        # puts everything in one line
+        with open(iFDO_path.replace("yaml","json"), 'w') as fp:
+            json.dump(self.ifdo_checked, fp)
+
+        # convert dictionary to JSON string
+        json_data = json.dumps(self.ifdo_checked, indent = 4)
+
+        # write the JSON string to a file
+        with open(iFDO_path.replace("yaml","json"), 'w') as f:
+            f.write(json_data)
+        """
+
+        # log changes
+        if not self.ifdo_parsed is None:
+            ifdo_update = DeepDiff(self.ifdo_parsed,self.ifdo_checked)
+            #pprint(ifdo_update)
+            if ifdo_update != {}:
+                self.prov.log("iFDO updated")
+                self.prov.log(str(ifdo_update),dontShow=True)
         self.prov.log("Wrote iFDO to file " + iFDO_path)
         self.prov.write(self.dir.to(self.dir.dt.protocol))
         s.stop()
 
 
     def setiFDOFileName(self,iFDOfile:str):
         """ Set the current iFDO file name with path. Set to "" in order to get default name and location. """
         self.iFDOfile_ = iFDOfile
         self.iFDOfile_ = self.getiFDOFileName() # construct default name if empty
         if miqtc.assertSlash(os.path.dirname(self.iFDOfile_)) != miqtc.assertSlash(self.dir.to(self.dir.dt.products)):
             self.prov.log("Caution! iFDO file path is not in 'products' sub folder as recommended. Consider resetting with setiFDOFileName(). " + iFDOfile)
         try:
             event = self.findTmpField('image-event')
             sensor = self.findTmpField('image-sensor')
-        except KeyError:
+        except miqtc.IfdoException:
             event = self.dir.event()
             sensor = self.dir.sensor()
 
         iFDOfileName = os.path.basename(self.iFDOfile_)
         if not event in iFDOfileName or not sensor in iFDOfileName:
             self.prov.log("Caution! iFDO file name does not contain project, event and sensor name as recommended. Consider resetting with setiFDOFileName(). " + iFDOfile)
 
 
-    def getiFDOFileName(self):
-        """ Returns the current iFDO file's name with path. If not set yet it returns the one accoring to the recommended naming scheme. """
-        if self.iFDOfile_ == "":
-            event = self.findTmpField('image-event')
-            sensor = self.findTmpField('image-sensor')
-            self.iFDOfile_ = self.dir.to(self.dir.dt.products)+ self.constructiFDOfileName(event,sensor)
+    def getiFDOFileName(self,overwrite=False):
+        """ Returns the current iFDO file's name with path. If not set yet or overwrite==True it returns the one matching image-set-name. """
+        if self.iFDOfile_ == "" or overwrite:
+            self.iFDOfile_ = os.path.join(self.dir.to(self.dir.dt.products), self.findTmpField('image-set-name') + '_iFDO.yaml')
         return self.iFDOfile_
 
 
     @staticmethod
-    def constructiFDOfileName(event:str,sensor:str):
-        """ Set iFDO file name to  """
-        return event + '_'+ sensor + '_iFDO.yaml' # TODO include dataType?
+    def constructImageSetName(project:str,event:str,sensor:str):
+        """ returns <project>_<event>_<sensor>, with short version of <sensor> (only id), preventing potential doubling of <project>  """
+        sensor_short = iFDO.getShortEquipmentID(sensor)
+        if len(event) > len(project) and event[0:len(project)] == project:
+            image_set_name_ = event + "_" + sensor_short
+        else:
+            image_set_name_ = project + "_" + event + "_" + sensor_short
+        return image_set_name_ # TODO include dataType?
+
+
+    @staticmethod
+    def getShortEquipmentID(equipmentID:str):
+        """ returns equipment id without potentiall long <name> part, i.e.: <owner>_<type>-<type index[_<subtype>] """
+        return '_'.join(equipmentID.split('_')[0:3])
+
+    @staticmethod
+    def constructiFDOfileName(project:str,event:str,sensor:str):
+        """ returns <constructImageSetName()>_iFDO.yaml """
+        return iFDO.constructImageSetName(project,event,sensor) + '_iFDO.yaml' 
+
+    
+    @staticmethod
+    def __getFieldValue(ifdo:dict,keys:list):
+        """ returns copy of set or item field value, also considerng default values from header.
+            Use keys as e.g. [<item>,<key>,..]. Can be used for header fields as well as item fields.
+            Item index can be leglected, in case of video a dict {<image-datatime>:<value>,...} is returned.
+            Raises IfdoException if keys do not exist. """
+
+        if not miqtv.image_set_items_key in ifdo or not miqtv.image_set_header_key in ifdo:
+            raise miqtc.IfdoException("Invalid ifdo dict, missing items or header key: " + str(ifdo))
+        
+        if not isinstance(keys,list):
+            keys = [keys]
+
+        # remove header or item prefixes if there
+        if keys[0] == miqtv.image_set_items_key or keys[0] == miqtv.image_set_header_key:
+            keys = keys[1::]
+
+        header = ifdo[miqtv.image_set_header_key]
+        items = ifdo[miqtv.image_set_items_key]
+        # look for default value
+        for skippedInHeader in range(len(keys)):
+            defaultVal = findField(header,keys[skippedInHeader::])
+            if defaultVal != "":
+                break
+
+        ## look for item value
+        # header only value, don't check in items
+        if findField(items,keys[0:1]) == "" and skippedInHeader == 0:
+            ret = defaultVal
+            if ret == "":
+                raise miqtc.IfdoException("key does not exist:" + str(keys))
+        else:
+            # if first key not found in items, i.e. is not a image name, and first key is not a header key:
+            if findField(items,keys[0:1]) == "" and skippedInHeader != 0:
+                raise miqtc.IfdoException("item does not exist:" + str(keys[0:1]))
+
+            # check if index provided
+            indexProvided = True
+            if len(keys) > 1:
+                try:
+                    index = int(keys[1])
+                except Exception:
+                    indexProvided = False
+            elif len(keys) == 1:
+                indexProvided = False
+                
+            imageItemTimePoints = items[keys[0]]
+
+            if indexProvided:
+                # if key is whole image add all values from header
+                if len(keys) == 2:
+                    defaultVal = header
+                # add default from index 0
+                if len(keys) > 1 and index != 0:
+                    keys_0 = copy.deepcopy(keys)
+                    keys_0[1] = 0
+                    ret_0 = iFDO.__getItemValue(items,keys_0,skippedInHeader,defaultVal)
+                    if isinstance(ret_0,dict):
+                        defaultVal = {**defaultVal,**ret_0}
+                ret = iFDO.__getItemValue(items,keys,skippedInHeader,defaultVal)
+            
+            else:
+                # if key is whole image add all values from header
+                if len(keys) == 1:
+                    defaultVal = header
+
+                # picture -> just one entry, insert index 0
+                if len(imageItemTimePoints) == 1:
+                    keys = keys[0:1] + [0] + keys[1::]
+                    ret = iFDO.__getItemValue(items,keys,skippedInHeader,defaultVal)
+                    
+                # video -> return values for each time stamp
+                else:
+                    ret = {}
+                    for i in range(len(imageItemTimePoints)):
+                        timePointData = imageItemTimePoints[i]
+                        keys_i = keys[0:1] + [i] + keys[1::]
+                        ret[timePointData['image-datetime']] = iFDO.__getItemValue(items,keys_i,skippedInHeader,defaultVal)
+                        # remove image-datetime if there
+                        if isinstance(ret[timePointData['image-datetime']],dict) and 'image-datetime' in ret[timePointData['image-datetime']]:
+                            del ret[timePointData['image-datetime']]['image-datetime']
+                        # video defaults
+                        if i == 0:
+                            if isinstance(ret[timePointData['image-datetime']],dict):
+                                defaultVal = {**defaultVal,**ret[timePointData['image-datetime']]}
+                            else:
+                                defaultVal = ret[timePointData['image-datetime']]
+
+                        i += 1
+
+        if isinstance(ret,dict) or isinstance(ret,list):
+            ret = copy.deepcopy(ret)
+        if ret == "" or ret == {}:
+            raise miqtc.IfdoException("keys do not exist:" + str(keys))
+        return ret
+
+
+    @staticmethod
+    def __getItemValue(items,keys,skippedInHeader,defaultVal):
+        
+        # in case item is not a list (should not be possible)
+        if not isinstance(items[keys[0]],list):
+            items[keys[0]] = [items[keys[0]]]
+
+        itemValue = findField(items,keys)
+
+        if itemValue == "":
+            ret = defaultVal
+        # in case of dicts joint header and item fields
+        elif isinstance(itemValue,dict) and defaultVal != "":
+            if not isinstance(defaultVal,dict):
+                raise miqtc.IfdoException("Item field is dict but default value in header is not: " + str(keys))
+            ret = {**defaultVal,**itemValue}
+        else:
+            ret = itemValue
+        return ret
 
 
     def __str__(self) -> str:
         """ Prints current iFDO file """
         return yaml.dump(self.ifdo_checked, default_style=None, default_flow_style=None, allow_unicode=True, width=float("inf"))
 
 
     def __getitem__(self, keys):
-        """ Returns field entry of checked ifdo fields """
-        return findField(self.ifdo_checked,keys)
+        """ Returns copy of checked ifdo set or item field value, also considerng default values from header.
+            Use keys as e.g. '<item>:<key>:...'. Can be used for header fields as well as item fields.
+            Item index can be leglected, in case of video a dict {<image-datatime>:<value>,...} is returned.
+            Raises IfdoException if item does not exist. """
+        keys = keys.split(':')
+        return self.__getFieldValue(self.ifdo_checked,keys)
 
 
     def findTmpField(self,keys):
-        """ Returns field entry of temporary unchecked ifdo fields """
-        return findField(self.ifdo_tmp,keys)
+        """ Returns copy of temporary unchecked ifdo set or item field value, also considerng default values from header.
+            Use keys as e.g. '<item>:<key>:...'. Can be used for header fields as well as item fields.
+            Item index can be leglected, in case of video a dict {<image-datatime>:<value>,...} is returned.
+            Raises IfdoException if item does not exist. """
+        keys = keys.split(':')
+        return self.__getFieldValue(self.ifdo_tmp,keys)
+    
+
+    def findTmpField2(self,keys):
+        """ Same as findTmpField instead of raising exception it return empty string. """
+        keys = keys.split(':')
+        try:
+            ret = self.__getFieldValue(self.ifdo_tmp,keys)
+        except miqtc.IfdoException:
+            ret = ""
+        return ret
 
 
     def setiFDOHeaderFields(self, header: dict):
         """ Clears current header fields und sets provided field values. For updating existing ones use updateiFDOHeaderFields() """
         self.ifdo_tmp[self.imageSetHeaderKey] = {}
         if self.imageSetHeaderKey in header:
             header = header[self.imageSetHeaderKey]
@@ -719,35 +889,46 @@
         log = miqtc.recursivelyUpdateDicts(self.ifdo_tmp[self.imageSetHeaderKey], header, miqtv.ifdo_mutually_exclusive_fields)
         self.prov.log(log,dontShow=True)
 
 
     def tryAutoSetHeaderFields(self):
         """ Sets certain header fields e.g. from directory if they are not set yet """
 
-        if self.findTmpField('image-sensor') == "":
+        if self.findTmpField2('image-sensor') == "":
             self.ifdo_tmp[self.imageSetHeaderKey]['image-sensor'] = self.dir.sensor()
         elif self.findTmpField('image-sensor') != self.dir.sensor():
             self.prov.log("Caution: 'image-sensor' "+ self.findTmpField('image-sensor')+ " differs from sensor parsed from directory: " + self.dir.sensor())
 
-        if self.findTmpField('image-event') == "":
+        if self.findTmpField2('image-event') == "":
             self.ifdo_tmp[self.imageSetHeaderKey]['image-event'] = self.dir.event()
         elif self.findTmpField('image-event') != self.dir.event():
             self.prov.log("Caution: 'image-event' " + self.findTmpField('image-event') + " differs from event parsed from directory: " + self.dir.event())
 
-        if self.findTmpField('image-project') == "":
+        if self.findTmpField2('image-project') == "":
             self.ifdo_tmp[self.imageSetHeaderKey]['image-project'] = self.dir.project()
         elif self.findTmpField('image-project') != self.dir.project():
             self.prov.log("Caution: 'image-project' " + self.findTmpField('image-project') + " differs from project parsed from directory: " + self.dir.project())
 
+        if self.findTmpField2('image-platform') == "" and self.dir.gear() != "":
+            self.ifdo_tmp[self.imageSetHeaderKey]['image-platform'] = self.dir.gear()
+
         if not 'image-set-uuid' in self.ifdo_tmp[self.imageSetHeaderKey]:
             self.ifdo_tmp[self.imageSetHeaderKey]['image-set-uuid'] = str(miqtc.uuid4())
         if not 'image-set-handle' in self.ifdo_tmp[self.imageSetHeaderKey]:
-            self.ifdo_tmp[self.imageSetHeaderKey]['image-set-handle'] = self.handle_prefix + "@" + self.findTmpField('image-set-uuid')
-        if not 'image-set-name' in self.ifdo_tmp[self.imageSetHeaderKey]:
-            self.ifdo_tmp[self.imageSetHeaderKey]['image-set-name'] = self.findTmpField("image-project") + " " + self.dir.event() + " " + self.dir.sensor()
+            self.ifdo_tmp[self.imageSetHeaderKey]['image-set-handle'] = self.handle_prefix + "/" + self.findTmpField('image-set-uuid')
+        if not 'image-set-name' in self.ifdo_tmp[self.imageSetHeaderKey] or self.findTmpField2('image-set-name') == "":
+            # construct as <project>_<event>_<sensor>
+            project_ = self.findTmpField2("image-project")
+            event_ = self.findTmpField2("image-event")
+            if event_ == "":
+                event_ = self.dir.event()
+            sensor_ = self.findTmpField2("image-sensor")
+            if sensor_ == "":
+                sensor_ = self.dir.sensor()
+            self.ifdo_tmp[self.imageSetHeaderKey]['image-set-name'] = iFDO.constructImageSetName(project_,event_,sensor_)
 
         # set version
         self.ifdo_tmp[self.imageSetHeaderKey]['image-set-ifdo-version'] = miqtv.iFDO_version
 
 
     def setHeaderImageLocalPathField(self):
         """ Sets header field 'image-local-path' from image dir """
@@ -783,26 +964,31 @@
         for img in remove:
             del item_data[img]
 
         # add image-url
         for img in item_data:
             if isinstance(item_data[img],list): # item is already a list (video) but parsed data is not, i.e. parsed data refers to whole video (time independent), i.e. write to first entry
                 uuid = findField(item_data[img][0],'image-uuid')
-                item_data[img][0]['image-url'] = self.handle_prefix + '@' + uuid
+                if uuid == "":
+                    print(item_data[img])
+                    raise miqtc.IfdoException("uuid not found (a)")
+                item_data[img][0]['image-handle'] = self.image_handle_prefix + '@' + uuid
             else:
                 uuid = findField(item_data[img],'image-uuid')
-                item_data[img]['image-url'] = self.handle_prefix + '@' + uuid
+                if uuid == "":
+                    raise miqtc.IfdoException("uuid not found (b)")
+                item_data[img]['image-handle'] = self.image_handle_prefix + '@' + uuid
 
         # create yaml and check fields for validity
         # item_data contains field image-filename, which which will not be stored as an item field in iFOD but as the item name itself
         return self.updateiFDO(self.ifdo_tmp[self.imageSetHeaderKey], item_data.values())
 
 
     def createCaptureAndContentFields(self):
-        """ Fills the iFOD caputre and content fieds from provided data fields """
+        """ Fills the iFDO caputre and content fieds from provided data fields """
 
         req = self.nonCoreFieldIntermediateItemInfoFiles
 
         item_data = {}
         for r in req:
             if os.path.exists(r.fileName):
                 self.praseItemDataFromFile(item_data,r.fileName,r.separator,r.header)
@@ -1369,15 +1555,15 @@
         if (offset_x!=0 or offset_y!=0 or offset_z!=0) and 'yaw' in nav_header and 'pitch' in nav_header and 'roll' in nav_header:
             compensatOffsets = True
 
         # check if for missing fields there are const values in header
         const_values = {}
         for navField in miqtv.pos_header['mariqt']:
             respectiveHeaderField = miqtv.col_header["mariqt"][navField]
-            if navField not in nav_header and (respectiveHeaderField in self.ifdo_tmp[self.imageSetHeaderKey] and self.findTmpField(respectiveHeaderField) != ""): 
+            if navField not in nav_header and (respectiveHeaderField in self.ifdo_tmp[self.imageSetHeaderKey] and self.findTmpField2(respectiveHeaderField) != ""): 
                 const_values[navField] = self.findTmpField(respectiveHeaderField)
 
         # Load navigation data
         nav_data, parseMsg = miqtn.readAllPositionsFromFilePath(nav_path, nav_header, date_format,col_separator=col_separator,const_values=const_values)
         if parseMsg != "":
             self.prov.log(parseMsg,dontShow=True)
             returnMsg = "\n" + parseMsg
@@ -1498,25 +1684,29 @@
                         geometry =  {'type': "Point", 'coordinates': 
                                         [float(image_dts[file][0].lon), float(image_dts[file][0].lat), float(image_dts[file][0].dep)]
                                     }
                     else:
                         geometry =  {'type': "Point", 'coordinates': 
                                         [float(image_dts[file][0].lon), float(image_dts[file][0].lat)]
                                     }
+                    if True in [math.isnan(x) for x in geometry['coordinates']]:
+                        continue
 
                 # video
                 else:
                     if dep_not_zero:
                         geometry =  {'type': "MultiPoint", 'coordinates':
                                         [[float(d.lon), float(d.lat), float(d.dep)] for d in image_dts[file]]
                                     }
                     else:
                         geometry =  {'type': "MultiPoint", 'coordinates':
                                         [[float(d.lon), float(d.lat)] for d in image_dts[file]]
                                     }
+                    if True in [math.isnan(x) for x in [item for sublist in geometry['coordinates'] for item in sublist]]:
+                        continue
 
                 geojson['features'].append({'type': 'Feature', 'properties': {'id': file}, 'geometry': geometry })
                 
             o = open(self.get_int_nav_file().replace(".txt", ".geojson"),
                      "w", errors="ignore", encoding='utf-8')
             json.dump(geojson, o, ensure_ascii=False, indent=4)
             o.close()
@@ -1652,71 +1842,129 @@
         return copy.deepcopy(self._imagesInImagesDirSortedList)
 
 
     def parseItemDatafromTabFileData(self, items: dict, file: str, cols: list, optional: list = []):
         """ parses data from columns in cols and writes info to items. Column 'image-filename' must be in file and does not need to be passed in cols. 
             File must be tab separated and columns names must equal item field names"""
         tmp_data = miqtf.tabFileData(file, cols+['image-filename']+optional, key_col='image-filename', optional=optional,convert=True)
-        self.writeParsedDataToItems(tmp_data,items)
+        self.writeParsedDataToItems(tmp_data,items,self.ifdo_tmp[miqtv.image_set_header_key])
 
 
     def praseItemDataFromFile(self,items:dict,file:str,separator:str,header:dict):
         """ parses data from from file to items. header dict must be of structure: {<item-field-name>:<column-name>}
             and must contain entry 'image-filename' """
         if not 'image-filename' in header:
             raise Exception("header does not contain 'image-filename'")
         
         tmp_data = miqtf.tabFileData(file, header,col_separator=separator, key_col='image-filename',convert=True)
-        self.writeParsedDataToItems(tmp_data,items)
+        self.writeParsedDataToItems(tmp_data,items,self.ifdo_tmp[miqtv.image_set_header_key])
+
 
+    def writeParsedDataToItems(self,data:dict,items:dict,header:dict):
+
+        # eval strings as dict or list
+        miqtc.recursiveEval(data)
+
+        # potentailly remove const data from items and put in header
+        self.extractConstDataValues(data,header)
 
-    def writeParsedDataToItems(self,data:dict,items:dict):
         for img in data:
             
             if img not in items:
                 items[img] = {}
             # remove potential None entries
-            data[img] = miqtc.recursivelyRemoveEmptyFields(data[img],contente2beRemoved=None)
+            data[img] = miqtc.recursivelyRemoveEmptyFields(data[img],content2beRemoved=None)
 
             if isinstance(data[img],list):
                 if not isinstance(items[img],list):
                     if items[img] == {}:
                         items[img] = []
                     else:
                         items[img] = [items[img]]
                 for v in data[img]:
-
                     v['image-filename'] = img
                     items[img].append(v)
             else:
                 for v in data[img]: # works if data[img] is dict
 
-                    # check if data represents a dict
-                    try:
-                        val = ast.literal_eval(data[img][v])
-                    except Exception:
-                        val = data[img][v]
+                    val = data[img][v]
                     if isinstance(items[img],list): # item is already a list (video) but parsed data is not, i.e. parsed data refers to whole video (time independent), i.e. write to first entry
                         if not val is None:
                             items[img][0][v] = val
                     else:
                         if not val is None:
                             items[img][v] = val
                 if isinstance(items[img],list): # item is already a list (video) but parsed data is not, i.e. parsed data refers to whole video (time independent), i.e. write to first entry
                         items[img][0]['image-filename'] = img
                 else:
                     items[img]['image-filename'] = img
 
 
+    @staticmethod
+    def extractConstDataValues(data:dict,header:dict):
+        """ Removes fields that are constant for all entries from data dict and put them in header dict. 
+            Each entry of data must be a dict with the same set of keys. """
+    
+        fieldsToIgnore = ['image-datetime']
+        constData = {}
+        firstImage = True
+        for image,image_data in data.items():
+            
+            if not isinstance(image_data,list):
+                image_data = [image_data]
+
+            if not firstImage and constData == {}:
+                break
+            
+            firstTimePoint = True
+            for image_tp_data in image_data:
+                # very first data for comparison
+                if firstImage and firstTimePoint:
+                    constData = copy.deepcopy(image_tp_data)
+                    for field in fieldsToIgnore:
+                        if field in constData:
+                            del constData[field]
+                    firstTimePoint = False
+                    continue
+
+                constData = miqtc.findCommonDictElements(image_tp_data,constData)
+
+            firstImage = False
+
+        # TODO check within image times -> to image default. (tricky since we don't have the dafault index here. Only a subset might be update here)
+        # check within image items -> header
+        headerUpdate = copy.deepcopy(constData)
+        headerUpdatedTest = copy.deepcopy(header)
+        miqtc.recursivelyUpdateDicts(headerUpdatedTest,headerUpdate)
+        updateDiff = DeepDiff(header,headerUpdatedTest)
+        # check if headerUpdate would overwrite anything from current header (should not happen), if so dont remove from items
+        if not 'values_changed' in updateDiff and not 'type_changes' in updateDiff and not 'dictionary_item_removed' in updateDiff:
+            header.clear()
+            header.update(headerUpdatedTest)
+
+            # remove const values from data
+            miqtc.recursiveMakeNoneDictFieldsEmptyStr(constData)
+            for image,image_data in data.items():
+                if not isinstance(image_data,list):
+                    image_data = [image_data]
+                for image_tp_data in image_data:
+                    miqtc.recursivelyUpdateDicts(image_tp_data,constData)          
+
+        else:
+            pass
+            # TODO log?
+     
+
     def intermediateNavFileExists(self):
         if os.path.exists(self.get_int_nav_file()):
             return True
         else:
             return False
 
+
     def allNavFieldsInHeader(self):
         for field in self.reqNavFields:
             # multiple options
             if isinstance(field,list):
                 valid = False
                 for subfield in field:
                     if self.headerFieldFilled(subfield):
@@ -1727,15 +1975,15 @@
             # single option
             else:
                 if not self.headerFieldFilled(field):
                     return False
         return True
 
     def headerFieldFilled(self,field:str):
-        if self.findTmpField(field) == "":
+        if self.findTmpField2(field) == "":
             return False
         return True
 
     def convertToDefaultDateTimeFormat(self,ifdo):
         """ Checks if all items' 'image-datetime' fields match default datetime format or a custom one defined in 'image-datetime-format'
             and converts to default format. Throws exception if datetime cannot be parsed """
         customDateTimeFormatFound = False
@@ -1800,15 +2048,15 @@
                 'optional': [miqtv.col_header['mariqt']['lon'], miqtv.col_header['mariqt']['lat'],miqtv.col_header['mariqt']['dep'], miqtv.col_header['mariqt']['alt'], miqtv.col_header['mariqt']['hgt'], miqtv.col_header['mariqt']['uncert']]},
         }
 
         self.nonCoreFieldIntermediateItemInfoFiles = []
 
     def __get_int_file_prefix(self):
         """ depends on 'image-event' and 'image-sensor' so it can change during upate """
-        return os.path.join(self.dir.to(self.dir.dt.intermediate), self.findTmpField('image-event')+"_"+self.findTmpField('image-sensor'))
+        return os.path.join(self.dir.to(self.dir.dt.intermediate), self.findTmpField('image-set-name'))
 
     def get_int_hash_file(self):
         return self.__get_int_file_prefix() + self.intermediateFilesDef_core['hashes']['suffix']
 
     def get_int_uuid_file(self):
         return self.__get_int_file_prefix() + self.intermediateFilesDef_core['uuids']['suffix']
```

## Comparing `mariqt-0.3.9.dist-info/LICENSE` & `mariqt-0.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mariqt-0.3.9.dist-info/METADATA` & `mariqt-0.4.0.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 Metadata-Version: 2.1
 Name: mariqt
-Version: 0.3.9
+Version: 0.4.0
 Summary: The MareHub & Marine Imaging Community Image QA/QC and curation toolbox
 Author: Timm Schoening
 Author-email: tschoening@geomar.de
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
 License-File: LICENSE
 Requires-Dist: requests
 Requires-Dist: numpy
 Requires-Dist: pyyaml
 Requires-Dist: pymap3d
-Requires-Dist: pyproj
+Requires-Dist: utm
 Requires-Dist: markdown
 Requires-Dist: python-xmp-toolkit
+Requires-Dist: deepdiff
 
 We strive to make marine image data FAIR. We develop FDOs for images to establish a common language for marine imagery, we develop best-practice operating procedures for handling marine images and we develop the MarIQT software to apply the iFDOs and procedures to marine imagery. MarIQT stands for Image Quality control / quality assurance and curation Tools (IQT) conceptualised and developed by the MareHub working group on Videos/Images (part of the DataHub, a research data manangement initiative by the Helmholtz association).
```

