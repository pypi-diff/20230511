# Comparing `tmp/sanpy-ephys-0.1.13.tar.gz` & `tmp/sanpy-ephys-0.1.6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "sanpy-ephys-0.1.13.tar", last modified: Thu May 11 04:12:51 2023, max compression
+gzip compressed data, was "sanpy-ephys-0.1.6.tar", last modified: Sat Apr  1 23:45:57 2023, max compression
```

## Comparing `sanpy-ephys-0.1.13.tar` & `sanpy-ephys-0.1.6.tar`

### file list

```diff
@@ -1,86 +1,90 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/
--rw-r--r--   0 runner    (1001) docker     (123)    35148 2023-05-11 03:59:05.000000 sanpy-ephys-0.1.13/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     4157 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2939 2023-05-11 03:59:05.000000 sanpy-ephys-0.1.13/README.md
--rw-r--r--   0 runner    (1001) docker     (123)       89 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.358989 sanpy-ephys-0.1.13/sanpy/
--rw-r--r--   0 runner    (1001) docker     (123)      562 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8932 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/_util.py
--rw-r--r--   0 runner    (1001) docker     (123)    55297 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/analysisDir.py
--rw-r--r--   0 runner    (1001) docker     (123)    16422 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/analysisPlot.py
--rw-r--r--   0 runner    (1001) docker     (123)     6291 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/analysisUtil.py
--rw-r--r--   0 runner    (1001) docker     (123)    11692 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/atfStim.py
--rw-r--r--   0 runner    (1001) docker     (123)    15015 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bAbfText.py
--rw-r--r--   0 runner    (1001) docker     (123)    27549 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bAnalysisResults.py
--rw-r--r--   0 runner    (1001) docker     (123)     8267 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bAnalysisStim.py
--rw-r--r--   0 runner    (1001) docker     (123)    14444 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bAnalysisUtil.py
--rw-r--r--   0 runner    (1001) docker     (123)    95987 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bAnalysis_.py
--rw-r--r--   0 runner    (1001) docker     (123)    41511 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bDetection.py
--rw-r--r--   0 runner    (1001) docker     (123)    28747 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/bExport.py
--rw-r--r--   0 runner    (1001) docker     (123)    29830 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/detectionUtils.py
--rw-r--r--   0 runner    (1001) docker     (123)     3546 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/epochAnalysis.py
--rw-r--r--   0 runner    (1001) docker     (123)    36339 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fftUtils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.362989 sanpy-ephys-0.1.13/sanpy/fileloaders/
--rw-r--r--   0 runner    (1001) docker     (123)      341 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4417 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/epochTable.py
--rw-r--r--   0 runner    (1001) docker     (123)     6061 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_abf.py
--rw-r--r--   0 runner    (1001) docker     (123)     2871 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_atf.py
--rw-r--r--   0 runner    (1001) docker     (123)    17371 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     2557 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_csv.py
--rw-r--r--   0 runner    (1001) docker     (123)     1641 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_tif.py
--rw-r--r--   0 runner    (1001) docker     (123)     4368 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/h5Util.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.366989 sanpy-ephys-0.1.13/sanpy/interface/
--rw-r--r--   0 runner    (1001) docker     (123)      842 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   124920 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bDetectionWidget.py
--rw-r--r--   0 runner    (1001) docker     (123)     1375 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bDialog.py
--rw-r--r--   0 runner    (1001) docker     (123)     5216 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bErrorTable.py
--rw-r--r--   0 runner    (1001) docker     (123)    41078 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bExportWidget.py
--rw-r--r--   0 runner    (1001) docker     (123)    25473 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bFileTable.py
--rw-r--r--   0 runner    (1001) docker     (123)    29484 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bKymographWidget.py
--rw-r--r--   0 runner    (1001) docker     (123)    12253 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bPlugins.py
--rw-r--r--   0 runner    (1001) docker     (123)    95076 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bScatterPlotWidget2.py
--rw-r--r--   0 runner    (1001) docker     (123)    19081 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/bTableView.py
--rw-r--r--   0 runner    (1001) docker     (123)     3005 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/fileListWidget.py
--rw-r--r--   0 runner    (1001) docker     (123)    24094 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/kymographPlugin2.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/sanpy/interface/plugins/
--rw-r--r--   0 runner    (1001) docker     (123)     1178 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3464 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/basePlotTool.py
--rw-r--r--   0 runner    (1001) docker     (123)    22889 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/detectionParams.py
--rw-r--r--   0 runner    (1001) docker     (123)     3381 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/exportTrace.py
--rw-r--r--   0 runner    (1001) docker     (123)    57601 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/fftPlugin.py
--rw-r--r--   0 runner    (1001) docker     (123)    21325 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/plotFi.py
--rw-r--r--   0 runner    (1001) docker     (123)    10438 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/plotRecording.py
--rw-r--r--   0 runner    (1001) docker     (123)    55882 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/plotScatter.py
--rw-r--r--   0 runner    (1001) docker     (123)      517 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/plotTool.py
--rw-r--r--   0 runner    (1001) docker     (123)     1560 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/plotToolPool.py
--rw-r--r--   0 runner    (1001) docker     (123)     1326 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/sanpyLog.py
--rw-r--r--   0 runner    (1001) docker     (123)    39789 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/sanpyPlugin.py
--rw-r--r--   0 runner    (1001) docker     (123)     7915 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/setSpikeStat.py
--rw-r--r--   0 runner    (1001) docker     (123)    28941 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/spikeClips.py
--rw-r--r--   0 runner    (1001) docker     (123)    32446 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/stimGen.py
--rw-r--r--   0 runner    (1001) docker     (123)     6577 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/plugins/summarizeResults.py
--rw-r--r--   0 runner    (1001) docker     (123)     9299 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/preferences.py
--rw-r--r--   0 runner    (1001) docker     (123)    54643 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/interface/sanpy_app.py
--rw-r--r--   0 runner    (1001) docker     (123)    25774 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/kymAnalysis.py
--rw-r--r--   0 runner    (1001) docker     (123)     4065 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/sanpyLogger.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/sanpy/scatterwidget/
--rw-r--r--   0 runner    (1001) docker     (123)       64 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/scatterwidget/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    84842 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/scatterwidget/bScatterPlotWidget2.py
--rw-r--r--   0 runner    (1001) docker     (123)     3661 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/scatterwidget/statlist.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/sanpy/user_analysis/
--rw-r--r--   0 runner    (1001) docker     (123)       34 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/user_analysis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9050 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/user_analysis/baseUserAnalysis.py
--rw-r--r--   0 runner    (1001) docker     (123)      554 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/sanpy/version.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     4157 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2216 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       57 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (123)      345 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        6 2023-05-11 04:12:51.000000 sanpy-ephys-0.1.13/sanpy_ephys.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     4208 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-11 04:12:51.370989 sanpy-ephys-0.1.13/tests/
--rw-r--r--   0 runner    (1001) docker     (123)     1585 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/tests/test_analysis.py
--rw-r--r--   0 runner    (1001) docker     (123)     1832 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/tests/test_analysisDir.py
--rw-r--r--   0 runner    (1001) docker     (123)     3184 2023-05-11 03:59:06.000000 sanpy-ephys-0.1.13/tests/test_fileLoader.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.477754 sanpy-ephys-0.1.6/
+-rw-r--r--   0 runner    (1001) docker     (123)    35148 2023-04-01 23:45:38.000000 sanpy-ephys-0.1.6/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      359 2023-04-01 23:45:57.477754 sanpy-ephys-0.1.6/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)       89 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.469754 sanpy-ephys-0.1.6/sanpy/
+-rw-r--r--   0 runner    (1001) docker     (123)      528 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10404 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/_util.py
+-rw-r--r--   0 runner    (1001) docker     (123)    54168 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/analysisDir.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16554 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/analysisPlot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6160 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/analysisUtil.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10353 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/atfStim.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14995 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bAbfText.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27489 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bAnalysisResults.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6792 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bAnalysisStim.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14274 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bAnalysisUtil.py
+-rw-r--r--   0 runner    (1001) docker     (123)    89031 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bAnalysis_.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40842 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bDetection.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26394 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/bExport.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25390 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/detectionUtils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3629 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/epochAnalysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31209 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fftUtils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.469754 sanpy-ephys-0.1.6/sanpy/fileloaders/
+-rw-r--r--   0 runner    (1001) docker     (123)      341 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4470 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/epochTable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5709 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_abf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2820 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_atf.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17259 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2315 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_csv.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1656 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_tif.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4411 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/h5Util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.473754 sanpy-ephys-0.1.6/sanpy/interface/
+-rw-r--r--   0 runner    (1001) docker     (123)      832 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)   115681 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bDetectionWidget.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1265 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bDialog.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4002 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bErrorTable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40974 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bExportWidget.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25195 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bFileTable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29369 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bKymographWidget.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12227 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bPlugins.py
+-rw-r--r--   0 runner    (1001) docker     (123)    92017 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bScatterPlotWidget2.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18982 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/bTableView.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3025 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/fileListWidget.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23830 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/kymographPlugin2.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.473754 sanpy-ephys-0.1.6/sanpy/interface/plugins/
+-rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2628 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/analysisSummary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3349 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/basePlotTool.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2141 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/detectionErrors.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22369 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/detectionParams.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/exportTrace.py
+-rw-r--r--   0 runner    (1001) docker     (123)    56626 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/fftPlugin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1800 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/kymographPlugin.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21186 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/plotFi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10208 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/plotRecording.py
+-rw-r--r--   0 runner    (1001) docker     (123)    38901 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/plotScatter.py
+-rw-r--r--   0 runner    (1001) docker     (123)      514 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/plotTool.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1561 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/plotToolPool.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3892 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/resultsTable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3671 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/resultsTable2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1324 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/sanpyLog.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39352 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/sanpyPlugin.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7608 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/setSpikeStat.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28256 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/spikeClips.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32186 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/stimGen.py
+-rw-r--r--   0 runner    (1001) docker     (123)    41175 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/plugins/stimGen2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9466 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/preferences.py
+-rw-r--r--   0 runner    (1001) docker     (123)    47868 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/interface/sanpy_app.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26046 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/kymAnalysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4052 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/sanpyLogger.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.473754 sanpy-ephys-0.1.6/sanpy/scatterwidget/
+-rw-r--r--   0 runner    (1001) docker     (123)       64 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/scatterwidget/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    81961 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/scatterwidget/bScatterPlotWidget2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3408 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/scatterwidget/statlist.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.473754 sanpy-ephys-0.1.6/sanpy/user_analysis/
+-rw-r--r--   0 runner    (1001) docker     (123)       33 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/user_analysis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9037 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/user_analysis/baseUserAnalysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)      489 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/sanpy/version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.477754 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)      359 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2408 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       57 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      320 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        6 2023-04-01 23:45:57.000000 sanpy-ephys-0.1.6/sanpy_ephys.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-01 23:45:57.477754 sanpy-ephys-0.1.6/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2165 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-01 23:45:57.477754 sanpy-ephys-0.1.6/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     1585 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/tests/test_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1788 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/tests/test_analysisDir.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3184 2023-04-01 23:45:39.000000 sanpy-ephys-0.1.6/tests/test_fileLoader.py
```

### Comparing `sanpy-ephys-0.1.13/LICENSE` & `sanpy-ephys-0.1.6/LICENSE`

 * *Files identical despite different names*

### Comparing `sanpy-ephys-0.1.13/sanpy/__init__.py` & `sanpy-ephys-0.1.6/sanpy/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 from .bAnalysisResults import *
 
 from .bAbfText import bAbfText
 from .bExport import bExport
 
 from .version import analysisVersion
 from .version import interfaceVersion
-from .version import __version__
 
 from .bDetection import bDetection
 
 from .kymAnalysis import kymAnalysis
 from ._util import _loadLineScanHeader
 
-from .fileloaders import *
+from .fileloaders import *
```

### Comparing `sanpy-ephys-0.1.13/sanpy/_util.py` & `sanpy-ephys-0.1.6/sanpy/_util.py`

 * *Files 24% similar despite different names*

```diff
@@ -3,181 +3,208 @@
 import importlib
 import pathlib
 import shutil
 from typing import List, Union
 import uuid
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 def getNewUuid():
-    return "t" + str(uuid.uuid4()).replace("-", "_")
-
+    return 't' + str(uuid.uuid4()).replace('-', '_')
 
 def getBundledDir():
     """Get the working directory where user preferences are save.
 
     This will be source code folder when running from source,
       will be a more freeform folder when running as a frozen app/exe
     """
-    if getattr(sys, "frozen", False):
+    if getattr(sys, 'frozen', False):
         # we are running in a bundle (frozen)
         bundle_dir = sys._MEIPASS
     else:
         # we are running in a normal Python environment
-        bundle_dir = os.path.dirname(os.path.abspath(__file__))
+        bundle_dir = os.path.dirname(os.path.abspath(__file__))    
     return bundle_dir
 
-
-def _module_from_file(module_name: str, file_path: str):
+def _module_from_file(module_name : str, file_path : str):
     """
-
+    
     Args:
         module_name: Is like sanpy.interface.plugins.onePluginFile
         file_path: Full path to onePluginFile source code (onePluginFile.py)
     """
     spec = importlib.util.spec_from_file_location(module_name, file_path)
     module = importlib.util.module_from_spec(spec)
     spec.loader.exec_module(module)
     return module
 
-
 def addUserPath():
     """Make <user>/Documents/SanPy folder and add it to the Python sys.path
-
+    
     Returns:
         True: If we made the folder (first time SanPy is running)
     """
-
-    logger.info("")
+    
+    logger.info('')
 
     madeUserFolder = _makeSanPyFolders()  # make <user>/Documents/SanPy if necc
-
+            
     userSanPyFolder = _getUserSanPyFolder()
 
     # if userSanPyFolder in sys.path:
     #     sys.path.remove(userSanPyFolder)
 
     if not userSanPyFolder in sys.path:
-        logger.info(f"Adding to sys.path: {userSanPyFolder}")
+        logger.info(f'Adding to sys.path: {userSanPyFolder}')
         sys.path.append(userSanPyFolder)
 
-    logger.info("sys.path is now:")
+    logger.info('sys.path is now:')
     for path in sys.path:
-        logger.info(f"    {path}")
+        logger.info(f'    {path}')
 
     return madeUserFolder
-
-
+    
 def _getUserDocumentsFolder():
-    """Get <user>/Documents folder."""
+    """Get <user>/Documents folder.
+    """
     userPath = pathlib.Path.home()
-    userDocumentsFolder = os.path.join(userPath, "Documents")
+    userDocumentsFolder = os.path.join(userPath, 'Documents')
     if not os.path.isdir(userDocumentsFolder):
         logger.error(f'Did not find path "{userDocumentsFolder}"')
         logger.error(f'   Using "{userPath}"')
         return userPath
     else:
         return userDocumentsFolder
 
-
 def _getUserSanPyFolder():
-    """Get <user>/Documents/SanPy folder."""
+    """Get <user>/Documents/SanPy folder.
+    """
     userDocumentsFolder = _getUserDocumentsFolder()
-    sanpyFolder = os.path.join(userDocumentsFolder, "SanPy-User-Files")
+    sanpyFolder = os.path.join(userDocumentsFolder, 'SanPy')
     return sanpyFolder
 
-
-def _old_getUserFolder(folder: str) -> str:
+def old_getUserFolder(folder : str) -> str:
     userSanPyFolder = _getUserSanPyFolder()
-    if folder == "plugins":
-        theFolder = os.path.join(userSanPyFolder, "plugins")
-    elif folder == "analysis":
-        theFolder = os.path.join(userSanPyFolder, "analysis")
-    elif folder == "preferences":
-        theFolder = os.path.join(userSanPyFolder, "preferences")
+    if folder == 'plugins':
+        theFolder = os.path.join(userSanPyFolder, 'plugins')
+    elif folder == 'analysis':
+        theFolder = os.path.join(userSanPyFolder, 'analysis')
+    elif folder == 'preferences':
+        theFolder = os.path.join(userSanPyFolder, 'preferences')
     else:
         logger.error(f'did not understand folder: "{folder}"')
         return None
     return theFolder
 
-
 def _getUserFileLoaderFolder():
     userSanPyFolder = _getUserSanPyFolder()
-    fileLoaderFolder = os.path.join(userSanPyFolder, "file loaders")
+    fileLoaderFolder = os.path.join(userSanPyFolder, 'file loaders')
     return fileLoaderFolder
 
-
 def _getUserPluginFolder():
     userSanPyFolder = _getUserSanPyFolder()
-    userPluginFolder = os.path.join(userSanPyFolder, "plugins")
+    userPluginFolder = os.path.join(userSanPyFolder, 'plugins')
     return userPluginFolder
 
-
 def _getUserDetectionFolder():
     """Folder of saved user detection presets.
-
+    
     Each is a json file.
     """
     userSanPyFolder = _getUserSanPyFolder()
-    userDetectionFolder = os.path.join(userSanPyFolder, "detection")
+    userDetectionFolder = os.path.join(userSanPyFolder, 'detection')
     return userDetectionFolder
 
-
 def _getUserAnalysisFolder():
-    """Folder of custom user analysis code."""
+    """Folder of custom user analysis code.
+    """
     userAnalysisFolder = _getUserSanPyFolder()
-    userAnalysisFolder = os.path.join(userAnalysisFolder, "analysis")
+    userAnalysisFolder = os.path.join(userAnalysisFolder, 'analysis')
     return userAnalysisFolder
 
-
 def _getUserPreferencesFolder():
-    """Folder of SanPy app preferences and logs (user does not modify this."""
+    """Folder of SanPy app preferences and logs (user does not modify this.
+    """
     userPreferencesFolder = _getUserSanPyFolder()
-    userPreferencesFolder = os.path.join(userPreferencesFolder, "preferences")
+    userPreferencesFolder = os.path.join(userPreferencesFolder, 'preferences')
     return userPreferencesFolder
 
-
-def pprint(d: dict):
-    for k, v in d.items():
-        print(f"  {k}: {v}")
-
+def pprint(d : dict):
+    for k,v in d.items():
+        print(f'  {k}: {v}')
 
 def _makeSanPyFolders():
-    """Make <user>/Documents/SanPy-User-Files folder .
+    """Make <user>/Documents/SanPy folder .
 
     If no Documents folder then make SanPy folder directly in <user> path.
     """
     userDocumentsFolder = _getUserDocumentsFolder()
 
     madeUserFolder = False
-
-    # main <user>/Documents/SanPy folder
+    
+    # main <user>/DOcuments/SanPy folder
     sanpyFolder = _getUserSanPyFolder()
     if not os.path.isdir(sanpyFolder):
         # first time run
-        logger.info(f'Making <user>/SanPy-User-Files folder "{sanpyFolder}"')
+        logger.info(f'Making <user>/SanPy folder "{sanpyFolder}"')
         madeUserFolder = True
         #
         # copy entire xxx into <user>/Documents/SanPy
         _bundDir = getBundledDir()
-        _srcPath = pathlib.Path(_bundDir) / "_userFiles" / "SanPy-User-Files"
+        _srcPath = pathlib.Path(_bundDir) / '_userFiles' / 'SanPy'
         _dstPath = pathlib.Path(sanpyFolder)
-        logger.info(f"    copying folder tree to <user>/Documents/SanPy-User-Folder")
-        logger.info(f"    _srcPath:{_srcPath}")
-        logger.info(f"    _dstPath:{_dstPath}")
+        logger.info(f'    copying folder tree to <user>/Documents/SanPy folder')
+        logger.info(f'    _srcPath:{_srcPath}')
+        logger.info(f'    _dstPath:{_dstPath}')
         shutil.copytree(_srcPath, _dstPath)
     else:
         # already exists, make sure we have all sub-folders that are expected
         pass
 
     return madeUserFolder
 
+    '''
+    # SanPyapplication preferences
+    preferencesFolder = _getUserPreferencesFolder()
+    if not os.path.isdir(preferencesFolder):
+        logger.info(f'Making user preferences folder "{preferencesFolder}"')
+        os.mkdir(preferencesFolder)
+    
+    # to save detection parameters json
+    detectionFolder = os.path.join(sanpyFolder, 'detection')
+    if not os.path.isdir(detectionFolder):
+        logger.info(f'Making user detection folder "{detectionFolder}"')
+        os.mkdir(detectionFolder)
+
+    # to hold custom .py plugins
+    pluginFolder = _getUserPluginFolder()  # os.path.join(sanpyFolder, 'plugins')
+    if not os.path.isdir(pluginFolder):
+        # TODO: add __init__.py
+        logger.info(f'Making user plugin folder "{pluginFolder}"')
+        os.mkdir(pluginFolder)
+
+    # to hold custom .py analysis
+    analysisFolder = _getUserAnalysisFolder()
+    if not os.path.isdir(detectionFolder):
+        # TODO: add __init__.py
+        logger.info(f'Making user analysis folder "{analysisFolder}"')
+        os.mkdir(analysisFolder)
+        # copy from _userFiles into this folder
+        # _bundDir = getBundledDir()
+        # _srcPath = pathlib.Path(self._bundDir) / tmpHdfFile
+        # shutil.copyfile(hdfFilePath,tmpHdfPath)
+    '''
+
+# def _module_from_file(module_name, file_path):
+# 	spec = importlib.util.spec_from_file_location(module_name, file_path)
+# 	module = importlib.util.module_from_spec(spec)
+# 	spec.loader.exec_module(module)
+# 	return module
+
 def _loadLineScanHeader(path):
     """
     path: full path to tif
 
     we will load and parse coresponding .txt file
 
     returns dict:
@@ -189,90 +216,90 @@
     # "X Dimension"	"138, 0.0 - 57.176 [um], 0.414 [um/pixel]"
     # "T Dimension"	"1, 0.000 - 35.496 [s], Interval FreeRun"
     # "Image Size(Unit Converted)"	"57.176 [um] * 35500.000 [ms]"
 
     # 20220606, adding
     # "Image Size"	"294 * 1000 [pixel]"
 
-    txtFile = os.path.splitext(path)[0] + ".txt"
+    txtFile = os.path.splitext(path)[0] + '.txt'
 
     if not os.path.isfile(txtFile):
-        logger.error(f"did not find file:{txtFile}")
+        logger.error(f'did not find file:{txtFile}')
         return None
 
-    theRet = {"tif": path}
+    theRet = {'tif': path}
 
     # tif shape is (lines, pixels)
-    # theRet['numLines'] = self.tif.shape[1]
-    # theRet['numLines'] = tifData.shape[0]
+    #theRet['numLines'] = self.tif.shape[1]
+    #theRet['numLines'] = tifData.shape[0]
 
     gotImageSize = False
 
-    with open(txtFile, "r") as fp:
+    with open(txtFile, 'r') as fp:
         lines = fp.readlines()
         for line in lines:
             line = line.strip()
             if line.startswith('"X Dimension"'):
                 line = line.replace('"', "")
-                line = line.replace(",", "")
-                # print('loadLineScanHeader:', line)
+                line = line.replace(',', "")
+                #print('loadLineScanHeader:', line)
                 # 2 number of pixels in line
                 # 5 um length of line
                 # 7 um/pixel
                 splitLine = line.split()
                 for idx, split in enumerate(splitLine):
-                    # print('  ', idx, split)
+                    #print('  ', idx, split)
                     if idx == 2:
                         numPixels = int(split)
-                        theRet["numPixels"] = numPixels
+                        theRet['numPixels'] = numPixels
                     elif idx == 5:
                         umLength = float(split)
-                        theRet["umLength"] = umLength
+                        theRet['umLength'] = umLength
                     elif idx == 7:
                         umPerPixel = float(split)
-                        theRet["umPerPixel"] = umPerPixel
+                        theRet['umPerPixel'] = umPerPixel
 
             elif line.startswith('"T Dimension"'):
                 # "T Dimension"	"1, 0.000 - 35.496 [s], Interval FreeRun"
                 line = line.replace('"', "")
-                line = line.replace(",", "")
-                # print('loadLineScanHeader:', line)
+                line = line.replace(',', "")
+                #print('loadLineScanHeader:', line)
                 # 5 total duration of image acquisition (seconds)
                 splitLine = line.split()
                 for idx, split in enumerate(splitLine):
-                    # print('  ', idx, split)
+                    #print('  ', idx, split)
                     if idx == 5:
                         totalSeconds = float(split)
-                        theRet["totalSeconds"] = totalSeconds
+                        theRet['totalSeconds'] = totalSeconds
 
-                        # theRet['secondsPerLine'] =
+                        #theRet['secondsPerLine'] =
 
             # order in file will matter, there are multiple "Image Size" lines
             # we want the first
             # "Image Size"	"294 * 1000 [pixel]"
             elif line.startswith('"Image Size"'):
                 if line.startswith('"Image Size(Unit Converted)"'):
                     continue
                 if gotImageSize:
                     continue
                 gotImageSize = True
                 line = line.replace('"', "")
-                line = line.replace(",", "")
-                splitLine = line.split("\t")  # yes, a FREAKING tab !!!!
+                line = line.replace(',', "")
+                splitLine = line.split('\t')  # yes, a FREAKING tab !!!!
                 splitLine = splitLine[1]
                 splitLine2 = splitLine.split()
-                # print('splitLine2:', splitLine2)
+                #print('splitLine2:', splitLine2)
 
-                theRet["numLines"] = int(splitLine2[2])
+                theRet['numLines'] = int(splitLine2[2])
 
-            # elif line.startswith('"Image Size(Unit Converted)"'):
-            # 	print('loadLineScanHeader:', line)
+            #elif line.startswith('"Image Size(Unit Converted)"'):
+            #	print('loadLineScanHeader:', line)
 
     # tif shape is (lines, pixels)
-    shape = (theRet["numLines"], theRet["numPixels"])
-    # theRet['shape'] = self.tif.shape
-    # theRet['shape'] = tifData.shape
-    theRet["shape"] = shape
-    theRet["secondsPerLine"] = theRet["totalSeconds"] / theRet["shape"][0]
-    theRet["linesPerSecond"] = 1 / theRet["secondsPerLine"]
+    shape = (theRet['numLines'], theRet['numPixels'])
+    #theRet['shape'] = self.tif.shape
+    #theRet['shape'] = tifData.shape
+    theRet['shape'] = shape
+    theRet['secondsPerLine'] = theRet['totalSeconds'] / theRet['shape'][0]
+    theRet['linesPerSecond'] = 1 / theRet['secondsPerLine']
     #
     return theRet
```

### Comparing `sanpy-ephys-0.1.13/sanpy/analysisDir.py` & `sanpy-ephys-0.1.6/sanpy/analysisDir.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,210 +10,199 @@
 from typing import List, Union, Optional
 
 import numpy as np
 import pandas as pd
 import requests, io  # too load from the web
 
 # for old code that was compressing hdf5 files
-# from subprocess import call # to call ptrepack (might fail on windows???)
-# from pprint import pprint
-# import tables.scripts.ptrepack  # to save compressed .h5 file
-# import shutil
+#from subprocess import call # to call ptrepack (might fail on windows???)
+#from pprint import pprint
+#import tables.scripts.ptrepack  # to save compressed .h5 file
+#import shutil
 
 import sanpy
 import sanpy.h5Util
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 # Turn off pandas save h5 performance warnnig
 # see: https://github.com/pandas-dev/pandas/issues/3622
-# /home/cudmore/Sites/SanPy/sanpy/analysisDir.py:478: PerformanceWarning:
-# your performance may suffer as PyTables will pickle object types that it cannot
-# map directly to c-types [inferred_type->mixed-integer,key->block0_values] [items->Index(['detectionClass', '_isAnalyzed', '_dataPointsPerMs', '_sweepList',
+#/home/cudmore/Sites/SanPy/sanpy/analysisDir.py:478: PerformanceWarning:
+#your performance may suffer as PyTables will pickle object types that it cannot
+#map directly to c-types [inferred_type->mixed-integer,key->block0_values] [items->Index(['detectionClass', '_isAnalyzed', '_dataPointsPerMs', '_sweepList',
 import warnings
-
-warnings.filterwarnings("ignore", category=pd.io.pytables.PerformanceWarning)
+warnings.filterwarnings('ignore',category=pd.io.pytables.PerformanceWarning)
 
 _sanpyColumns = {
     #'Idx': {
     #    #'type': int,
     #    'type': float,
     #    'isEditable': False,
-    # },
-    "L": {
+    #},
+    'L': {
         # loaded
-        "type": str,
-        "isEditable": False,
+        'type': str,
+        'isEditable': False,
     },
-    "A": {
+    'A': {
         # analyzed
-        "type": str,
-        "isEditable": False,
+        'type': str,
+        'isEditable': False,
     },
-    "S": {
+    'S': {
         # saved
-        "type": str,
-        "isEditable": False,
+        'type': str,
+        'isEditable': False,
     },
-    "N": {
+    'N': {
         # number of spikes
-        "type": int,
-        "isEditable": False,
-    },
-    "E": {
-        # number of errors
-        "type": int,
-        "isEditable": False,
+        'type': int,
+        'isEditable': False,
     },
     # 'I': {
     #     # include
     #     # problems with isinstance(bool), just using string
     #     'type': bool,
     #     'isEditable': True,
     # },
-    "File": {
-        "type": str,
-        "isEditable": False,
-    },
-    "Dur(s)": {
-        "type": float,
-        "isEditable": False,
-    },
-    "Channels": {  # For Thianne
-        "type": int,
-        "isEditable": False,
-    },
-    "Sweeps": {
-        "type": int,
-        "isEditable": False,
-    },
-    "Epochs": {  # For Thianne
-        "type": int,
-        "isEditable": False,
-    },
-    "kHz": {
-        "type": float,
-        "isEditable": False,
-    },
-    "Mode": {
-        "type": str,
-        "isEditable": False,
-    },
-    "Start(s)": {
-        "type": float,
-        "isEditable": False,
-    },
-    "Stop(s)": {
-        "type": float,
-        "isEditable": False,
-    },
-    "dvdtThreshold": {
-        "type": float,
-        "isEditable": True,
-    },
-    "mvThreshold": {
-        "type": float,
-        "isEditable": True,
-    },
-    "Cell Type": {
-        "type": str,
-        "isEditable": True,
-    },
-    "Sex": {
-        "type": str,
-        "isEditable": True,
-    },
-    "Condition": {
-        "type": str,
-        "isEditable": True,
-    },
-    "Notes": {
-        "type": str,
-        "isEditable": True,
+    'File': {
+        'type': str,
+        'isEditable': False,
+    },
+    'Dur(s)': {
+        'type': float,
+        'isEditable': False,
+    },
+    'Channels': {  # For Thianne
+        'type': int,
+        'isEditable': False,
+    },
+    'Sweeps': {  
+        'type': int,
+        'isEditable': False,
+    },
+    'Epochs': {  # For Thianne
+        'type': int,
+        'isEditable': False,
+    },
+    'kHz': {
+        'type': float,
+        'isEditable': False,
+    },
+    'Mode': {
+        'type': str,
+        'isEditable': False,
+    },
+    'Start(s)': {
+        'type': float,
+        'isEditable': False,
+    },
+    'Stop(s)': {
+        'type': float,
+        'isEditable': False,
+    },
+    'dvdtThreshold': {
+        'type': float,
+        'isEditable': True,
+    },
+    'mvThreshold': {
+        'type': float,
+        'isEditable': True,
+    },
+    'Cell Type': {
+        'type': str,
+        'isEditable': True,
+    },
+    'Sex': {
+        'type': str,
+        'isEditable': True,
+    },
+    'Condition': {
+        'type': str,
+        'isEditable': True,
+    },
+    'Notes': {
+        'type': str,
+        'isEditable': True,
     },
     # kymograph interface
-    "kLeft": {
-        "type": int,
-        "isEditable": False,
-    },
-    "kTop": {
-        "type": int,
-        "isEditable": False,
-    },
-    "kRight": {
-        "type": int,
-        "isEditable": False,
-    },
-    "kBottom": {
-        "type": int,
-        "isEditable": False,
-    },
-    "relPath": {
-        "type": str,
-        "isEditable": False,
-    },
-    "uuid": {
-        "type": str,
-        "isEditable": False,
+    'kLeft': {
+        'type': int,
+        'isEditable': False,
+    },
+    'kTop': {
+        'type': int,
+        'isEditable': False,
+    },
+    'kRight': {
+        'type': int,
+        'isEditable': False,
+    },
+    'kBottom': {
+        'type': int,
+        'isEditable': False,
+    },
+    'relPath': {
+        'type': str,
+        'isEditable': False,
+    },
+    'uuid': {
+        'type': str,
+        'isEditable': False,
     },
+
 }
 
 
 """
 Columns to use in display in file table (pyqt, dash, vue).
 We require type so we can edit with QAbstractTableModel.
 Critical for qt interface to allow easy editing of values while preserving type
 """
 
-
-def _fixRelPath(folderPath, dfTable: pd.DataFrame, fileList: List[str]):
+def _fixRelPath(folderPath, dfTable : pd.DataFrame, fileList : List[str]):
     """
     Was not assigning relPath on initial load (no hd5 file).
 
     We need a path relative to location of loaded folder.
     This allows a folder of files and analysis to be moved (to a different machine)
     """
-
+    
     # print('fileList:', fileList)
     # pprint(dfTable[['File', 'relPath']])
-
+    
     # if dfTable is None:
     #     logger.error('no dfTable')
 
     n = len(dfTable)
 
-    logger.info(f"Checking path for {n} file(s)")
+    logger.info(f'Checking path for {n} file(s)')
 
     for rowIdx in range(n):
-        file = dfTable.loc[rowIdx, "File"]
-        relPath = dfTable.loc[rowIdx, "relPath"]
-
+        file = dfTable.loc[rowIdx, 'File']
+        relPath = dfTable.loc[rowIdx, 'relPath']
+        
         # 20220422 why was this here?
-        # if relPath:
+        #if relPath:
         #    continue
-
-        # print(rowIdx, file, relPath)
+        
+        #print(rowIdx, file, relPath)
         for filePath in fileList:
             if filePath.find(file) != -1:
-                logger.info(
-                    f"    _fixRelPath() file idx {rowIdx} file:{file} now has relPath:{filePath}"
-                )
-                dfTable.loc[rowIdx, "relPath"] = filePath
-
+                logger.info(f'    _fixRelPath() file idx {rowIdx} file:{file} now has relPath:{filePath}')
+                dfTable.loc[rowIdx, 'relPath'] = filePath
 
 def old_h5_printKey(hdfPath):
-    logger.info(f"hdfPath: {hdfPath} has keys:")
-    with pd.HDFStore(hdfPath, mode="r") as store:
+    logger.info(f'hdfPath: {hdfPath} has keys:')
+    with pd.HDFStore(hdfPath, mode='r') as store:
         for key in store.keys():
-            logger.info(f"    {key}")
+            logger.info(f'    {key}')
 
-
-class bAnalysisDirWeb:
+class bAnalysisDirWeb():
     """
     Load a directory of .abf from the web (for now from GitHub).
 
     Will etend this to Box, Dropbox, other?.
     """
 
     def __init__(self, cloudDict):
@@ -224,15 +213,16 @@
                     'path': 'data'
                     }
         """
         self._cloudDict = cloudDict
         self.loadFolder()
 
     def loadFolder(self):
-        """Load using cloudDict"""
+        """Load using cloudDict
+        """
 
         """
         # use ['download_url'] to download abf file (no byte conversion)
         response[0] = {
             name : 171116sh_0018.abf
             path : data/171116sh_0018.abf
             sha : 5f3322b08d86458bf7ac8b5c12564933142ffd17
@@ -242,136 +232,134 @@
             git_url : https://api.github.com/repos/cudmore/SanPy/git/blobs/5f3322b08d86458bf7ac8b5c12564933142ffd17
             download_url : https://raw.githubusercontent.com/cudmore/SanPy/master/data/171116sh_0018.abf
             type : file
             _links : {'self': 'https://api.github.com/repos/cudmore/SanPy/contents/data/171116sh_0018.abf?ref=master', 'git': 'https://api.github.com/repos/cudmore/SanPy/git/blobs/5f3322b08d86458bf7ac8b5c12564933142ffd17', 'html': 'https://github.com/cudmore/SanPy/blob/master/data/171116sh_0018.abf'}
         }
         """
 
-        owner = self._cloudDict["owner"]
-        repo_name = self._cloudDict["repo_name"]
-        path = self._cloudDict["path"]
-        url = f"https://api.github.com/repos/{owner}/{repo_name}/contents/{path}"
+        owner = self._cloudDict['owner']
+        repo_name = self._cloudDict['repo_name']
+        path = self._cloudDict['path']
+        url = f'https://api.github.com/repos/{owner}/{repo_name}/contents/{path}'
 
         # response is a list of dict
         response = requests.get(url).json()
-        # print('response:', type(response))
+        #print('response:', type(response))
 
         for idx, item in enumerate(response):
-            if not item["name"].endswith(".abf"):
+            if not item['name'].endswith('.abf'):
                 continue
             print(idx)
             # use item['git_url']
-            for k, v in item.items():
-                print("  ", k, ":", v)
+            for k,v in item.items():
+                print('  ', k, ':', v)
 
         #
         # test load
-        download_url = response[1]["download_url"]
+        download_url = response[1]['download_url']
         content = requests.get(download_url).content
 
         fileLikeObject = io.BytesIO(content)
         ba = sanpy.bAnalysis(byteStream=fileLikeObject)
-        # print(ba._abf)
-        # print(ba.api_getHeader())
+        #print(ba._abf)
+        #print(ba.api_getHeader())
         ba.spikeDetect()
         print(ba.numSpikes)
 
-
-class analysisDir:
+class analysisDir():
     """
     Class to manage a list of files loaded from a folder.
     """
 
     sanpyColumns = _sanpyColumns
     """Dict of dict of column names and bookkeeping info.
     """
 
-    theseFileTypes = [".abf", ".atf", ".csv", ".tif"]
+    theseFileTypes = ['.abf', '.atf', '.csv', '.tif']
     """File types to load.
     """
 
-    def __init__(
-        self,
-        path: str = None,
-        myApp=None,
-        autoLoad: bool = False,
-        folderDepth: Optional[int] = None,
-    ):
+    def __init__(self,
+                    path : str = None,
+                    myApp = None,
+                    autoLoad : bool = False,
+                    folderDepth : Optional[int] = None
+                    ):
         """Load and manage a list of files in a folder path.
-
+        
         Use this as the main pandasModel for file list myTableView.
 
         TODO: extend to link to folder in cloud (start with box and/or github)
 
         Args:
             path (str): Path to folder
             myApp (sanpy.interface.sanpy_app): Optional
             autoLoad (bool):
-            folderDepth (int):
+            folderDepth (int): 
             #cloudDict (dict): To load from cloud, for now  just github
 
         Notes:
             - Some functions are so self can mimic a pandas dataframe used by pandasModel.
                 (shape, loc, loc_setter, iloc, iLoc_setter, columns, append, drop, sort_values, copy)
         """
-        self.path: str = path
-        self.myApp = myApp  # used to signal on building initial db
+        self.path : str = path
+        self.myApp = myApp # used to signal on building initial db
         self.autoLoad = autoLoad  # not used
 
         self.folderDepth = folderDepth  # specify int
 
         self._isDirty = False
 
         self._poolDf = None
         """See pool_ functions"""
 
         # keys are full path to file, if from cloud, key is 'cloud/<filename>'
         # holds bAnalysisObjects
         # needs to be a list so we can have files more than one
-        # self.fileList = [] #OrderedDict()
+        #self.fileList = [] #OrderedDict()
 
         # TODO: refactor, we are not using the csv parth of this, just the filename
         # name of database file created/loaded from folder path
-        self.dbFile = "sanpy_recording_db.csv"
+        self.dbFile = 'sanpy_recording_db.csv'
 
         self._df = None
-        # if autoLoad:
+        #if autoLoad:
         if 1:
             self._df = self.loadHdf()
             if self._df is None:
                 self._df = self.loadFolder(loadData=autoLoad)  # only used if no h5 file
                 self._updateLoadedAnalyzed()
 
         # self._df = self.loadFolder(loadData=autoLoad)
 
         #
         self._checkColumns()
         self._updateLoadedAnalyzed()
 
-        """
+        '''
         logger.warning('remember: temporary fix with _fixRelPath()\n')
         tmpFileList = self.getFileList()
         _fixRelPath(self.path, self._df, tmpFileList)
-        """
+        '''
 
     def __iter__(self):
         self._iterIdx = 0
         return self
 
     def __next__(self):
         if self._iterIdx < self.numFiles:
-            x = self._df.loc[self._iterIdx]["_ba"]
+            x = self._df.loc[self._iterIdx]['_ba']
             self._iterIdx += 1
             return x
         else:
             raise StopIteration
 
     def __str__(self):
-        totalDurSec = self._df["Dur(s)"].sum()
-        theStr = f"analysisDir Num Files: {len(self)} Total Dur(s): {totalDurSec}"
+        totalDurSec = self._df['Dur(s)'].sum()
+        theStr = f'analysisDir Num Files: {len(self)} Total Dur(s): {totalDurSec}'
         return theStr
 
     @property
     def isDirty(self):
         return self._isDirty
 
     def __len__(self):
@@ -383,27 +371,27 @@
 
     @property
     def shape(self):
         """
         Can't just return shape of _df, columns (like 'ba') may have been added
         Number of columns is based on self.columns
         """
-        # return self._df.shape
+        #return self._df.shape
         numRows = self._df.shape[0]
         numCols = len(self.columns)
         return (numRows, numCols)
 
     @property
     def loc(self):
         """Mimic pandas df.loc[]"""
         return self._df.loc
 
     @loc.setter
     def loc_setter(self, rowIdx, colStr, value):
-        self._df.loc[rowIdx, colStr] = value
+        self._df.loc[rowIdx,colStr] = value
 
     @property
     def iloc(self):
         # mimic pandas df.iloc[]
         return self._df.iloc
 
     @iloc.setter
@@ -417,59 +405,59 @@
         return self._df.at
 
     @at.setter
     def at_setter(self, rowIdx, colStr, value):
         self._df.at[rowIdx, colStr] = value
         self._isDirty = True
 
-    """
+    '''
     @property
     def iat(self):
         # mimic pandas df.iat[]
         return self._df.iat
 
     @iat.setter
     def iat_setter(self, rowIdx, colStr, value):
         self._df.iat[rowIdx, colStr] = value
         self._isDirty = True
-    """
+    '''
 
     @property
     def index(self):
         return self._df.index
 
     @property
     def columns(self):
         # return list of column names
         return list(self.sanpyColumns.keys())
 
     def copy(self):
         return self._df.copy()
 
     def sort_values(self, Ncol, order):
-        logger.info(f"sorting by column {self.columns[Ncol]} with order:{order}")
+        logger.info(f'sorting by column {self.columns[Ncol]} with order:{order}')
         self._df = self._df.sort_values(self.columns[Ncol], ascending=not order)
-        # print(self._df)
+        #print(self._df)
 
     @property
     def columnsDict(self):
         return self.sanpyColumns
 
     def columnIsEditable(self, colName):
-        return self.sanpyColumns[colName]["isEditable"]
+        return self.sanpyColumns[colName]['isEditable']
 
     def columnIsCheckBox(self, colName):
         """All bool columns are checkbox
 
         TODO: problems with using type=bool and isinstance(). Kust using str 'bool'
         """
-        type = self.sanpyColumns[colName]["type"]
-        # isBool = isinstance(type, bool)
-        isBool = type == "bool"
-        # logger.info(f'{colName} {type(type)}, type:{type} {isBool}')
+        type = self.sanpyColumns[colName]['type']
+        #isBool = isinstance(type, bool)
+        isBool = type == 'bool'
+        #logger.info(f'{colName} {type(type)}, type:{type} {isBool}')
         return isBool
 
     def getDataFrame(self):
         """Get the underlying pandas DataFrame."""
         return self._df
 
     @property
@@ -478,450 +466,437 @@
         return len(self._df)
 
     def copyToClipboard(self):
         """
         TODO: Is this used or is copy to clipboard in pandas model?
         """
         if self.getDataFrame() is not None:
-            self.getDataFrame().to_clipboard(sep="\t", index=False)
-            logger.info("Copied to clipboard")
+            self.getDataFrame().to_clipboard(sep='\t', index=False)
+            logger.info('Copied to clipboard')
 
     def old_saveDatabase(self):
-        """save dbFile .csv and hdf .gzip"""
+        """ save dbFile .csv and hdf .gzip"""
         dbPath = os.path.join(self.path, self.dbFile)
         if self.getDataFrame() is not None:
             #
             logger.info(f'Saving "{dbPath}"')
             self.getDataFrame().to_csv(dbPath, index=False)
             self._isDirty = False
 
             #
-            """
+            '''
             hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
             hdfPath = os.path.join(self.path, hdfFile)
             logger.info(f'Saving "{hdfPath}"')
             #hdfStore = pd.HDFStore(hdfPath)
             start = time.time()
             complevel = 9
             complib = 'blosc:blosclz'
             with pd.HDFStore(hdfPath, mode='w', complevel=complevel, complib=complib) as hdfStore:
                 hdfStore['df'] = self.getDataFrame()  # save it
             stop = time.time()
             logger.info(f'Saving took {round(stop-start,2)} seconds')
-            """
+            '''
 
     def old_getFrozenPath(self):
-        if getattr(sys, "frozen", False):
+        if getattr(sys, 'frozen', False):
             # running in a bundle (frozen)
             myPath = sys._MEIPASS
         else:
             # running in a normal Python environment
-            # myPath = os.path.dirname(os.path.abspath(__file__))
+            #myPath = os.path.dirname(os.path.abspath(__file__))
             myPath = pathlib.Path(__file__).parent.absolute()
         return myPath
 
     def old_rebuildHdf(self):
         #
         # rebuild the file to remove old changes and reduce size
-        tmpHdfFile = os.path.splitext(self.dbFile)[0] + "_tmp.h5"
-        # tmpHdfPath = os.path.join(self.path, tmpHdfFile)
+        tmpHdfFile = os.path.splitext(self.dbFile)[0] + '_tmp.h5'
+        #tmpHdfPath = os.path.join(self.path, tmpHdfFile)
         tmpHdfPath = pathlib.Path(self.path) / tmpHdfFile
 
-        hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
-        # hdfPath = os.path.join(self.path, hdfFile)
+        hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
+        #hdfPath = os.path.join(self.path, hdfFile)
         hdfPath = pathlib.Path(self.path) / hdfFile
-        logger.info(f"Rebuilding h5 to {hdfPath}")
-
+        logger.info(f'Rebuilding h5 to {hdfPath}')
+        
         # can't pass sys.argv a 'PosixPath' from pathlib.Path, needs to be a string
         tmpHdfPath = str(tmpHdfPath)
         hdfPath = str(hdfPath)
-
+        
         # when calling ptrepack, we need trailing ':' on each src/dst path
         # without this Windows fails to find the file
-        _tmpHdfPath = tmpHdfPath + ":"
-        _hdfPath = hdfPath + ":"
-
+        _tmpHdfPath = tmpHdfPath + ':'
+        _hdfPath = hdfPath + ':'
+        
         # The first item is normally the command line command name (not used)
         sys.argv = ["", "--overwrite", "--chunkshape=auto", _tmpHdfPath, _hdfPath]
 
-        logger.info("running tables.scripts.ptrepack.main()")
-        logger.info(f"sys.argv: {sys.argv}")
+        logger.info('running tables.scripts.ptrepack.main()')
+        logger.info(f'sys.argv: {sys.argv}')
         try:
+            
             tables.scripts.ptrepack.main()  # noqa
 
             # delete the temporary (large file)
-            logger.info(f"Deleting tmp file: {tmpHdfPath}")
+            logger.info(f'Deleting tmp file: {tmpHdfPath}')
             os.remove(tmpHdfPath)
 
-            self.signalApp(
-                f"Saved compressed folder analysis with tables.scripts.ptrepack.main()"
-            )
+            self.signalApp(f'Saved compressed folder analysis with tables.scripts.ptrepack.main()')
 
-        except FileNotFoundError as e:
-            logger.error("tables.scripts.ptrepack.main() failed ... file was not saved")
+        except(FileNotFoundError) as e:
+            logger.error('tables.scripts.ptrepack.main() failed ... file was not saved')
             logger.error(e)
-            self.signalApp(f"ERROR in tables.scripts.ptrepack.main(): {e}")
+            self.signalApp(f'ERROR in tables.scripts.ptrepack.main(): {e}')
 
     def _not_used_save(self):
-        """Save all analysis as csv."""
-        logger.info("")
+        """Save all analysis as csv.
+        """
+        logger.info('')
         for ba in self:
             if ba is not None:
                 # save detection and analysis to json
                 # ba.saveAnalysis(forceSave=True)
-
+                
                 # save analysis to csv
                 ba.saveAnalysis_tocsv()
 
     def old_getTmpHdfFile(self):
         """Get temporary h5 file to write to.
-
+        
         We will always then compress with _rebuildHdf.
         """
-        logger.info("")
-
-        tmpHdfFile = os.path.splitext(self.dbFile)[0] + "_tmp.h5"
+        logger.info('')
+        
+        tmpHdfFile = os.path.splitext(self.dbFile)[0] + '_tmp.h5'
         tmpHdfPath = pathlib.Path(self.path) / tmpHdfFile
 
         # the compressed version from the last save
-        hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
+        hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
         hdfFilePath = pathlib.Path(self.path) / hdfFile
-
-        # hdfMode = 'w'
+        
+        #hdfMode = 'w'
         if os.path.isfile(hdfFilePath):
-            logger.info(f"    copying existing hdf file to tmp ")
-            logger.info(f"    hdfFilePath {hdfFilePath}")
-            logger.info(f"    tmpHdfPath {tmpHdfPath}")
-            shutil.copyfile(hdfFilePath, tmpHdfPath)  # noqa
+            logger.info(f'    copying existing hdf file to tmp ')
+            logger.info(f'    hdfFilePath {hdfFilePath}')
+            logger.info(f'    tmpHdfPath {tmpHdfPath}')
+            shutil.copyfile(hdfFilePath,tmpHdfPath)  # noqa
         else:
             pass
             # compressed file does not exist, just use tmp path
             # print('   does not exist:', hdfFilePath)
 
         return tmpHdfPath
 
     def getPathFromRelPath(self, relPath):
-        """Get full path to file (usually an abf file."""
-        if relPath.startswith("/"):
+        """Get full path to file (usually an abf file.
+        """
+        if relPath.startswith('/'):
             relPath = relPath[1:]
-
+        
         fullFilePath = os.path.join(self.path, relPath)
-
-        """
+        
+        '''
         print('xxx', self.path)
         print('xxx', relPath)
         print('xxx', fullFilePath)
-        """
+        '''
 
         return fullFilePath
 
     def saveHdf(self):
         """
         Save file table and any number of loaded and analyzed bAnalysis.
 
         Set file table 'uuid' column when we actually save a bAnalysis
 
         Important: Order matters
                 (1) Save bAnalysis first, it updates uuid in file table.
                 (2) Save file table with updated uuid
-        """
+                """
         start = time.time()
 
         df = self.getDataFrame()
 
         # the compressed version from the last save
-        hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
+        hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
         hdfFilePath = pathlib.Path(self.path) / hdfFile
-
-        logger.info(f"Saving db (will be compressed) {hdfFilePath}")
+        
+        logger.info(f'Saving db (will be compressed) {hdfFilePath}')
 
         # save each bAnalysis
         for row in range(len(df)):
-            ba = df.at[row, "_ba"]
+            ba = df.at[row, '_ba']
             if ba is not None:
                 didSave = ba._saveHdf_pytables(hdfFilePath)
                 if didSave:
                     # we are now saved into h5 file, remember uuid to load
-                    # print('xxx SETTING dir uuid')
-                    df.at[row, "uuid"] = ba.uuid
+                    #print('xxx SETTING dir uuid')
+                    df.at[row, 'uuid'] = ba.uuid
 
         # rebuild (L, A, S) columns
         self._updateLoadedAnalyzed()
 
         #
         # save file database
-        logger.info(f"    saving file db with {len(df)} rows")
+        logger.info(f'    saving file db with {len(df)} rows')
         print(df)
 
         dbKey = os.path.splitext(self.dbFile)[0]
-        df = df.drop("_ba", axis=1)  # don't ever save _ba, use it for runtime
+        df = df.drop('_ba', axis=1)  # don't ever save _ba, use it for runtime
 
-        # hdfStore[dbKey] = df  # save it
+        #hdfStore[dbKey] = df  # save it
         df.to_hdf(hdfFilePath, dbKey)
 
         #
         self._isDirty = False  # if true, prompt to save on quit
 
         # rebuild the file to remove old changes and reduce size
-        # self._rebuildHdf()
+        #self._rebuildHdf()
         sanpy.h5Util._repackHdf(hdfFilePath)
 
-        # list the keys in the file
+        # lis the keys in the file
         sanpy.h5Util.listKeys(hdfFilePath)
 
         stop = time.time()
-        logger.info(f"Saving took {round(stop-start,2)} seconds")
+        logger.info(f'Saving took {round(stop-start,2)} seconds')
 
     def loadHdf(self, path=None):
         """
         Load the database key from an h5 file.
-
+        
         We do not load analy anlysis until user clicks on row, see loadOneAnalysis()
         """
         if path is None:
             path = self.path
         self.path = path
 
         df = None
-        hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
+        hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
         hdfPath = pathlib.Path(self.path) / hdfFile
         if not hdfPath.is_file():
             return
 
-        logger.info(f"Loading existing folder h5 file {hdfPath}")
+        logger.info(f'Loading existing folder h5 file {hdfPath}')
         sanpy.h5Util.listKeys(hdfPath)
 
         _start = time.time()
         dbKey = os.path.splitext(self.dbFile)[0]
 
         try:
             df = pd.read_hdf(hdfPath, dbKey)
-        except KeyError as e:
+        except (KeyError) as e:
             # file is corrupt !!!
             logger.error(f'    Load h5 failed, did not find dbKey:"{dbKey}" {e}')
 
         if df is not None:
             # _ba is for runtime, assign after loading from either (abf or h5)
-            df["_ba"] = None
+            df['_ba'] = None
 
-            logger.info("    loaded db df")
+            logger.info('    loaded db df')
             logger.info(f"{df[['File', 'uuid']]}")
-
+            
             # do not load anything until user clicks rows, see loadOneAnalysis()
 
             _stop = time.time()
-            logger.info(f"Loading took {round(_stop-_start,2)} seconds")
+            logger.info(f'Loading took {round(_stop-_start,2)} seconds')
         #
         return df
 
     def loadOneAnalysis(self, path, uuid=None, allowAutoLoad=True, verbose=True):
-        """Load one bAnalysis either from original file path or uuid of h5 file.
+        """
+        Load one bAnalysis either from original file path or uuid of h5 file.
 
         If from h5, we still need to reload sweeps !!!
         They are binary and fast, saving to h5 (in this case) is slow.
         """
         if verbose:
             logger.info(f'path:"{path}" uuid:"{uuid}" allowAutoLoad:"{allowAutoLoad}"')
 
         hdfPath = self._getHdfFile()
-
+        
         # grab the fileLoaderDict from our app
         # if it is None then bAnalysis will load this (from disk)
         if self.myApp is not None:
             _fileLoaderDict = self.myApp.getFileLoaderDict()
         else:
             _fileLoaderDict = None
 
         ba = None
         if uuid is not None and uuid:
             # load from h5
             if verbose:
-                logger.info(f"    Retreiving uuid from hdf file {uuid}")
+                logger.info(f'    Retreiving uuid from hdf file {uuid}')
 
             # load from abf
             ba = sanpy.bAnalysis(path, fileLoaderDict=_fileLoaderDict, verbose=verbose)
-
+            
             # load analysis from h5 file, will fail if uuid is not in file
             ba._loadHdf_pytables(hdfPath, uuid)
 
         if allowAutoLoad and ba is None:
             # load from path
             ba = sanpy.bAnalysis(path, fileLoaderDict=_fileLoaderDict, verbose=verbose)
             if verbose:
-                logger.info(f"    Loaded ba from path {path} and now ba:{ba}")
+                logger.info(f'    Loaded ba from path {path} and now ba:{ba}')
         #
         return ba
 
     def _getHdfFile(self):
-        hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
+        hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
         hdfPath = os.path.join(self.path, hdfFile)
         return hdfPath
 
     def _deleteFromHdf(self, uuid):
         """Delete uuid from h5 file.
-
+        
         Each bAnalysis detection get a unique uuid.
         """
         if uuid is None or not uuid:
             return
-        logger.info(f"deleting from h5 file uuid:{uuid}")
+        logger.info(f'deleting from h5 file uuid:{uuid}')
 
-        _hdfFile = os.path.splitext(self.dbFile)[0] + ".h5"
+        _hdfFile = os.path.splitext(self.dbFile)[0] + '.h5'
         hdfPath = pathlib.Path(self.path) / _hdfFile
 
-        # tmpHdfPath = self._getTmpHdfFile()
+        #tmpHdfPath = self._getTmpHdfFile()
 
         removed = False
         with pd.HDFStore(hdfPath) as hdfStore:
             try:
                 hdfStore.remove(uuid)
                 removed = True
-            except KeyError:
-                logger.error(f"Did not find uuid {uuid} in h5 file {hdfPath}")
+            except (KeyError):
+                logger.error(f'Did not find uuid {uuid} in h5 file {hdfPath}')
 
         #
         if removed:
             # will rebuild on next save
-            # self._rebuildHdf()
+            #self._rebuildHdf()
             self._updateLoadedAnalyzed()
             self._isDirty = True  # if true, prompt to save on quit
 
     def loadFolder(self, path=None, loadData=False):
         """
         Parse a folder and load all (abf, csv, ...). Only called if no h5 file.
 
         TODO: get rid of loading database from .csv (it is replaced by .h5 file)
         TODO: extend the logic to load from cloud (after we were instantiated)
         """
-        logger.info("Loading folder from scratch (no hdf file)")
+        logger.info('Loading folder from scratch (no hdf file)')
 
         start = time.time()
         if path is None:
             path = self.path
         self.path = path
 
         loadedDatabase = False
 
         # load an existing folder db or create a new one
         # abb 20220612 turned off loading from self.dbFile .csv file
         dbPath = os.path.join(path, self.dbFile)
         if 0 and os.path.isfile(dbPath):
             # load from .csv
-            logger.info(f"Loading existing folder db: {dbPath}")
+            logger.info(f'Loading existing folder db: {dbPath}')
             df = pd.read_csv(dbPath, header=0, index_col=False)
-            # df["Idx"] = pd.to_numeric(df["Idx"])
+            #df["Idx"] = pd.to_numeric(df["Idx"])
             df = self._setColumnType(df)
             loadedDatabase = True
-            # logger.info(f'  shape is {df.shape}')
+            #logger.info(f'  shape is {df.shape}')
         else:
-            # logger.info(f'No existing db file, making {dbPath}')
-            logger.info(f"No existing db file, making default dataframe")
+            #logger.info(f'No existing db file, making {dbPath}')
+            logger.info(f'No existing db file, making default dataframe')
             df = pd.DataFrame(columns=self.sanpyColumns.keys())
             df = self._setColumnType(df)
 
         if loadedDatabase:
             # check columns with sanpyColumns
             loadedColumns = df.columns
             for col in loadedColumns:
                 if not col in self.sanpyColumns.keys():
-                    logger.error(
-                        f'error: bAnalysisDir did not find loaded col: "{col}" in sanpyColumns.keys()'
-                    )
+                    logger.error(f'error: bAnalysisDir did not find loaded col: "{col}" in sanpyColumns.keys()')
             for col in self.sanpyColumns.keys():
                 if not col in loadedColumns:
-                    logger.error(
-                        f'error: bAnalysisDir did not find sanpyColumns.keys() col: "{col}" in loadedColumns'
-                    )
+                    logger.error(f'error: bAnalysisDir did not find sanpyColumns.keys() col: "{col}" in loadedColumns')
 
         if loadedDatabase:
             # seach existing db for missing abf files
             pass
         else:
             # get list of all abf/csv/tif files
             fileList = self.getFileList(path)
             _numFilesToLoad = len(fileList)
             start = time.time()
             # build new db dataframe
             listOfDict = []
             for rowIdx, fullFilePath in enumerate(fileList):
-                self.signalApp(
-                    f'Loading file {rowIdx+1} of {_numFilesToLoad} "{fullFilePath}"'
-                )
+                self.signalApp(f'Loading file {rowIdx+1} of {_numFilesToLoad} "{fullFilePath}"')
 
                 # rowDict is what we are showing in the file table
                 # abb debug vue, set loadData=True
                 # loads bAnalysis
                 ba, rowDict = self.getFileRow(fullFilePath, loadData=loadData)
 
-                if rowDict is None:
-                    logger.warning(f'error loading file {fullFilePath}')
-                    continue
-                
                 # TODO: calculating time, remove this
                 # This is 2x faster than loading from pandas gzip ???
-                # dDict = sanpy.bAnalysis.getDefaultDetection()
-                # dDict['dvdtThreshold'] = 2
-                # ba.spikeDetect(dDict)
+                #dDict = sanpy.bAnalysis.getDefaultDetection()
+                #dDict['dvdtThreshold'] = 2
+                #ba.spikeDetect(dDict)
 
                 # as we parse the folder, don't load ALL files (will run out of memory)
                 if loadData:
-                    rowDict["_ba"] = ba
+                    rowDict['_ba'] = ba
                 else:
-                    rowDict["_ba"] = None  # ba
+                    rowDict['_ba'] = None  # ba
 
                 # do not assign uuid until bAnalysis is saved in h5 file
-                # rowDict['uuid'] = ''
+                #rowDict['uuid'] = ''
 
                 # 20230313 moved into getFileRow()
                 # relPath = fullFilePath.replace(path, '')
                 # if relPath.startswith('/'):
                 #     # so we can use os.path.join()
                 #     relPath = relPath[1:]
                 # rowDict['relPath'] = relPath
 
-                # logger.info(f'    row:{rowIdx} relPath:{relPath} fullFilePath:{fullFilePath}')
+                #logger.info(f'    row:{rowIdx} relPath:{relPath} fullFilePath:{fullFilePath}')
 
                 listOfDict.append(rowDict)
 
             stop = time.time()
-            logger.info(f"Load took {round(stop-start,3)} seconds.")
+            logger.info(f'Load took {round(stop-start,3)} seconds.')
 
             #
             df = pd.DataFrame(listOfDict)
-            # print('=== built new db df:')
-            # print(df)
+            #print('=== built new db df:')
+            #print(df)
             df = self._setColumnType(df)
         #
 
         # expand each to into self.fileList
-        # df['_ba'] = None
+        #df['_ba'] = None
 
         stop = time.time()
-        logger.info(f"Load took {round(stop-start,2)} seconds.")
+        logger.info(f'Load took {round(stop-start,2)} seconds.')
         return df
 
     def _checkColumns(self):
-        """Check columns in loaded vs sanpyColumns (and vica versa).
-        """
+        """Check columns in loaded vs sanpyColumns (and vica versa"""
         if self._df is None:
             return
         loadedColumns = self._df.columns
         for col in loadedColumns:
             if not col in self.sanpyColumns.keys():
                 # loaded has unexpected column, leave it
-                logger.info(
-                    f'did not find loaded col: "{col}" in sanpyColumns.keys() ... ignore it'
-                )
+                logger.error(f'error: bAnalysisDir did not find loaded col: "{col}" in sanpyColumns.keys()')
         for col in self.sanpyColumns.keys():
             if not col in loadedColumns:
                 # loaded is missing expected, add it
-                logger.info(
-                    f'did not find sanpyColumns.keys() col: "{col}" in loadedColumns ... adding col'
-                )
-                self._df[col] = ""
+                logger.error(f'error: bAnalysisDir did not find sanpyColumns.keys() col: "{col}" in loadedColumns')
+                self._df[col] = ''
 
     def _updateLoadedAnalyzed(self, theRowIdx=None):
         """Refresh Loaded (L) and Analyzed (A) columns.
 
         Arguments:
             theRowIdx (int): Update just one row
 
@@ -929,240 +904,229 @@
         """
         if self._df is None:
             return
         for rowIdx in range(len(self._df)):
             if theRowIdx is not None and theRowIdx != rowIdx:
                 continue
 
-            ba = self._df.loc[rowIdx, "_ba"]  # Can be None
+            ba = self._df.loc[rowIdx, '_ba']  # Can be None
 
-            # uuid = self._df.at[rowIdx, 'uuid']
+            #uuid = self._df.at[rowIdx, 'uuid']
             #
             # loaded
             if self.isLoaded(rowIdx):
-                theChar = "\u2022"  # FILLED BULLET
-            # elif uuid:
+                theChar = '\u2022'  # FILLED BULLET
+            #elif uuid:
             #    #theChar = '\u25CB'  # open circle
             #    theChar = '\u25e6'  # white bullet
             else:
-                theChar = ""
-            # self._df.iloc[rowIdx, loadedCol] = theChar
-            self._df.loc[rowIdx, "L"] = theChar
+                theChar = ''
+            #self._df.iloc[rowIdx, loadedCol] = theChar
+            self._df.loc[rowIdx, 'L'] = theChar
             #
             # analyzed
             if self.isAnalyzed(rowIdx):
-                theChar = "\u2022"  # FILLED BULLET
-                self._df.loc[rowIdx, "N"] = ba.numSpikes
-                _numErrors = ba.numErrors
-                if _numErrors is None:
-                    _numErrors = ''
-                logger.warning(f'setting E to _numErrors {_numErrors}')
-                self._df.loc[rowIdx, "E"] = _numErrors
-            # elif uuid:
+                theChar = '\u2022'  # FILLED BULLET
+                self._df.loc[rowIdx, 'N'] = ba.numSpikes
+            #elif uuid:
             #    #theChar = '\u25CB'
             #    theChar = '\u25e6'  # white bullet
             else:
-                theChar = ""
-                self._df.loc[rowIdx, "A"] = ""
-            # self._df.iloc[rowIdx, analyzedCol] = theChar
-            self._df.loc[rowIdx, "A"] = theChar
+                theChar = ''
+                self._df.loc[rowIdx, 'A'] = ''
+            #self._df.iloc[rowIdx, analyzedCol] = theChar
+            self._df.loc[rowIdx, 'A'] = theChar
             #
             # saved
             if self.isSaved(rowIdx):
-                theChar = "\u2022"  # FILLED BULLET
+                theChar = '\u2022'  # FILLED BULLET
             else:
-                theChar = ""
-            # self._df.iloc[rowIdx, savedCol] = theChar
-            self._df.loc[rowIdx, "S"] = theChar
+                theChar = ''
+            #self._df.iloc[rowIdx, savedCol] = theChar
+            self._df.loc[rowIdx, 'S'] = theChar
             #
             # start(s) and stop(s) from ba detectionDict
             if self.isAnalyzed(rowIdx):
                 # set table to values we just detected with
-                startSec = ba.getDetectionDict()["startSeconds"]
-                stopSec = ba.getDetectionDict()["stopSeconds"]
-                self._df.loc[rowIdx, "Start(s)"] = startSec
-                self._df.loc[rowIdx, "Stop(s)"] = stopSec
-
-                dvdtThreshold = ba.getDetectionDict()["dvdtThreshold"]
-                mvThreshold = ba.getDetectionDict()["mvThreshold"]
-                self._df.loc[rowIdx, "dvdtThreshold"] = dvdtThreshold
-                self._df.loc[rowIdx, "mvThreshold"] = mvThreshold
+                startSec = ba.getDetectionDict()['startSeconds']
+                stopSec = ba.getDetectionDict()['stopSeconds']
+                self._df.loc[rowIdx, 'Start(s)'] = startSec
+                self._df.loc[rowIdx, 'Stop(s)'] = stopSec
+
+                dvdtThreshold = ba.getDetectionDict()['dvdtThreshold']
+                mvThreshold = ba.getDetectionDict()['mvThreshold']
+                self._df.loc[rowIdx, 'dvdtThreshold'] = dvdtThreshold
+                self._df.loc[rowIdx, 'mvThreshold'] = mvThreshold
 
                 #
                 # TODO: remove start of ba._path that corresponds to our current folder path
                 # will allow our save db to be modular
-
+                
                 # relPth should usually be filled in ???
-                """
+                '''
                 relPath = self.getPathFromRelPath(ba._path)
                 self._df.loc[rowIdx, 'relPath'] = relPath
-                """
-
+                '''
+                
                 # logger.info('maybe put back in')
                 # print(f'    self._df.loc[rowIdx, "relPath"] is "{self._df.loc[rowIdx, "relPath"]}"')
 
             # kymograph interface
-            # if ba is not None and ba.isKymograph():
+            #if ba is not None and ba.isKymograph():
             # if ba is not None and isinstance(ba, sanpy.fileloaders.fileLoader_tif):
             if ba is not None and ba.fileLoader.isKymograph():
                 kRect = ba.fileLoader.getKymographRect()
 
-                # print(kRect)
-                # sys.exit(1)
+                #print(kRect)
+                #sys.exit(1)
 
                 if kRect is None:
-                    logger.error(f"Got None kymograph rect")
+                    logger.error(f'Got None kymograph rect')
                 else:
-                    self._df.loc[rowIdx, "kLeft"] = kRect[0]
-                    self._df.loc[rowIdx, "kTop"] = kRect[1]
-                    self._df.loc[rowIdx, "kRight"] = kRect[2]
-                    self._df.loc[rowIdx, "kBottom"] = kRect[3]
+                    self._df.loc[rowIdx, 'kLeft'] = kRect[0]
+                    self._df.loc[rowIdx, 'kTop'] = kRect[1]
+                    self._df.loc[rowIdx, 'kRight'] = kRect[2]
+                    self._df.loc[rowIdx, 'kBottom'] = kRect[3]
                 #
                 # TODO: remove start of ba._path that corresponds to our current folder path
                 # will allow our save db to be modular
-                # self._df.loc[rowIdx, 'path'] = ba._path
+                #self._df.loc[rowIdx, 'path'] = ba._path
 
-    """
+    '''
     def setCellValue(self, rowIdx, colStr, value):
         self._df.loc[rowIdx, colStr] = value
-    """
+    '''
 
     def isLoaded(self, rowIdx):
-        isLoaded = self._df.loc[rowIdx, "_ba"] is not None
+        isLoaded = self._df.loc[rowIdx, '_ba'] is not None
         return isLoaded
 
     def isAnalyzed(self, rowIdx):
         isAnalyzed = False
-        ba = self._df.loc[rowIdx, "_ba"]
-        # print('isAnalyzed()', rowIdx, ba)
-        # if ba is not None:
-        # print('qqq', rowIdx, ba, type(ba))
+        ba = self._df.loc[rowIdx, '_ba']
+        #print('isAnalyzed()', rowIdx, ba)
+        #if ba is not None:
+        #print('qqq', rowIdx, ba, type(ba))
         # sanpy.bAnalysis_.bAnalysis
         # if isinstance(ba, sanpy.bAnalysis):
         if ba is not None:
             isAnalyzed = ba.isAnalyzed()
         return isAnalyzed
 
     def analysisIsDirty(self, rowIdx):
-        """Analysis is dirty when there has been detection but not saved to h5."""
+        """Analysis is dirty when there has been detection but not saved to h5.
+        """
         isDirty = False
-        ba = self._df.loc[rowIdx, "_ba"]
+        ba = self._df.loc[rowIdx, '_ba']
         if isinstance(ba, sanpy.bAnalysis):
             isDirty = ba.isDirty()
         return isDirty
 
     def hasDirty(self):
-        """Return true if any bAnalysis in list has been analyzed but not saved (e.g. is dirty)"""
+        """Return true if any bAnalysis in list has been analyzed but not saved (e.g. is dirty)
+        """
         haveDirty = False
         numRows = len(self._df)
         for rowIdx in range(numRows):
             if self.analysisIsDirty(rowIdx):
                 haveDirty = True
 
         return haveDirty
 
     def isSaved(self, rowIdx):
-        uuid = self._df.at[rowIdx, "uuid"]
+        uuid = self._df.at[rowIdx, 'uuid']
         return len(uuid) > 0
 
     def getAnalysis(self, rowIdx, allowAutoLoad=True, verbose=True) -> sanpy.bAnalysis:
         """Get bAnalysis object, will load if necc.
 
         Args:
             rowIdx (int): Row index from table, corresponds to row in self._df
             allowAutoLoad (bool)
         Return:
             bAnalysis
         """
-        file = self._df.loc[rowIdx, "File"]
-        ba = self._df.loc[rowIdx, "_ba"]
-        uuid = self._df.loc[
-            rowIdx, "uuid"
-        ]  # if we have a uuid bAnalysis is saved in h5f
-        # filePath = os.path.join(self.path, file)
-        # logger.info(f'Found _ba in file db with ba:"{ba}" {type(ba)}')
-        # logger.info(f'rowIdx: {rowIdx} ba:{ba}')
+        file = self._df.loc[rowIdx, 'File']
+        ba = self._df.loc[rowIdx, '_ba']
+        uuid = self._df.loc[rowIdx, 'uuid']  # if we have a uuid bAnalysis is saved in h5f
+        #filePath = os.path.join(self.path, file)
+        #logger.info(f'Found _ba in file db with ba:"{ba}" {type(ba)}')
+        #logger.info(f'rowIdx: {rowIdx} ba:{ba}')
 
-        if ba is None or ba == "":
-            # logger.info('did not find _ba ... loading from abf file ...')
+        if ba is None or ba=='':
+            #logger.info('did not find _ba ... loading from abf file ...')
             # working on kymograph
             #                 relPath = self.getPathFromRelPath(ba._path)
-            relPath = self._df.loc[rowIdx, "relPath"]
+            relPath = self._df.loc[rowIdx, 'relPath']
             filePath = self.getPathFromRelPath(relPath)
 
-            ba = self.loadOneAnalysis(
-                filePath, uuid, allowAutoLoad=allowAutoLoad, verbose=verbose
-            )
+            ba = self.loadOneAnalysis(filePath, uuid, allowAutoLoad=allowAutoLoad, verbose=verbose)
             # load
-            """
+            '''
             logger.info(f'Loading bAnalysis from row {rowIdx} "{filePath}"')
             ba = sanpy.bAnalysis(filePath)
-            """
+            '''
             if ba is None:
-                logger.warning(
-                    f'Did not load row {rowIdx} path: "{filePath}". Analysis was probably not saved'
-                )
+                logger.warning(f'Did not load row {rowIdx} path: "{filePath}". Analysis was probably not saved')
             else:
-                self._df.at[rowIdx, "_ba"] = ba
+                self._df.at[rowIdx, '_ba'] = ba
                 # does not get a uuid until save into h5
                 if uuid:
                     # there was an original uuid (in table), means we are saved into h5
-                    self._df.at[rowIdx, "uuid"] = uuid
+                    self._df.at[rowIdx, 'uuid'] = uuid
                     if uuid != ba.uuid:
-                        logger.error(
-                            "Loaded uuid does not match existing in file table"
-                        )
-                        logger.error(f"  Loaded {ba.uuid}")
-                        logger.error(f"  Existing {uuid}")
+                        logger.error('Loaded uuid does not match existing in file table')
+                        logger.error(f'  Loaded {ba.uuid}')
+                        logger.error(f'  Existing {uuid}')
 
                 # kymograph, set ba rect from table
                 # if ba.isKymograph():
                 # if ba is not None and isinstance(ba, sanpy.fileloaders.fileLoader_tif):
                 if ba is not None and ba.fileLoader.isKymograph():
-                    left = self._df.loc[rowIdx, "kLeft"]
-                    top = self._df.loc[rowIdx, "kTop"]
-                    right = self._df.loc[rowIdx, "kRight"]
-                    bottom = self._df.loc[rowIdx, "kBottom"]
+                    left = self._df.loc[rowIdx, 'kLeft']
+                    top = self._df.loc[rowIdx, 'kTop']
+                    right = self._df.loc[rowIdx, 'kRight']
+                    bottom = self._df.loc[rowIdx, 'kBottom']
 
                     # on first load, these will be empty
                     # grab rect from ba (in _updateLoadedAnalyzed())
-                    if left == "" or top == "" or right == "" or bottom == "":
+                    if left=='' or top=='' or right=='' or bottom=='':
                         pass
                     else:
                         theRect = [left, top, right, bottom]
-                        logger.info(f"  theRect:{theRect}")
+                        logger.info(f'  theRect:{theRect}')
                         ba.fileLoader._updateTifRoi(theRect)
 
                 #
                 # update stats of table load/analyzed columns
                 self._updateLoadedAnalyzed()
 
         return ba
 
     def _setColumnType(self, df):
         """Needs to be called every time a df is created.
-        Ensures proper type of columns following sanpyColumns[key]['type']
+            Ensures proper type of columns following sanpyColumns[key]['type']
         """
-        # print('columns are:', df.columns)
+        #print('columns are:', df.columns)
         for col in df.columns:
             # when loading from csv, 'col' may not be in sanpyColumns
             if not col in self.sanpyColumns:
                 logger.warning(f'Column "{col}" is not in sanpyColumns -->> ignoring')
                 continue
-            colType = self.sanpyColumns[col]["type"]
-            # print(f'  _setColumnType() for "{col}" is type "{colType}"')
-            # print(f'    df[col]:', 'len:', len(df[col]))
-            # print(df[col])
+            colType = self.sanpyColumns[col]['type']
+            #print(f'  _setColumnType() for "{col}" is type "{colType}"')
+            #print(f'    df[col]:', 'len:', len(df[col]))
+            #print(df[col])
             if colType == str:
-                df[col] = df[col].replace(np.nan, "", regex=True)
+                df[col] = df[col].replace(np.nan, '', regex=True)
                 df[col] = df[col].astype(str)
             elif colType == int:
                 pass
-                # print('!!! df[col]:', df[col])
-                # df[col] = df[col].astype(int)
+                #print('!!! df[col]:', df[col])
+                #df[col] = df[col].astype(int)
             elif colType == float:
                 # error if ''
                 df[col] = df[col].astype(float)
             elif colType == bool:
                 df[col] = df[col].astype(bool)
             else:
                 logger.warning(f'Did not parse col "{col}" with type "{colType}"')
@@ -1197,117 +1161,103 @@
         # if it is None then bAnalysis will load this (from disk)
         if self.myApp is not None:
             _fileLoaderDict = self.myApp.getFileLoaderDict()
         else:
             _fileLoaderDict = None
 
         # load bAnalysis
-        # logger.info(f'Loading bAnalysis "{path}"')
+        #logger.info(f'Loading bAnalysis "{path}"')
         # loadData is false, load header
         ba = sanpy.bAnalysis(path, loadData=loadData, fileLoaderDict=_fileLoaderDict)
 
         if ba.loadError:
             logger.error(f'Error loading bAnalysis file "{path}"')
-            # return None, None
+            #return None, None
 
         # not sufficient to default everything to empty str ''
         # sanpyColumns can only have type in ('float', 'str')
-        rowDict = dict.fromkeys(self.sanpyColumns.keys(), "")
+        rowDict = dict.fromkeys(self.sanpyColumns.keys() , '')
         for k in rowDict.keys():
-            if self.sanpyColumns[k]["type"] == str:
-                rowDict[k] = ""
-            elif self.sanpyColumns[k]["type"] == float:
+            if self.sanpyColumns[k]['type'] == str:
+                rowDict[k] = ''
+            elif self.sanpyColumns[k]['type'] == float:
                 rowDict[k] = np.nan
 
-        # if rowIdx is not None:
+        #if rowIdx is not None:
         #    rowDict['Idx'] = rowIdx
 
-        """
+        '''
         if ba.loadError:
             rowDict['I'] = 0
         else:
             rowDict['I'] = 2 # need 2 because checkbox value is in (0,2)
-        """
+        '''
 
-        if ba.loadError:
-            return None, None
-        
-        rowDict["File"] = ba.fileLoader.filename  # os.path.split(ba.path)[1]
-        rowDict["Dur(s)"] = ba.fileLoader.recordingDur
+        rowDict['File'] = ba.fileLoader.filename #os.path.split(ba.path)[1]
+        rowDict['Dur(s)'] = ba.fileLoader.recordingDur
 
-        rowDict["Channels"] = ba.fileLoader.numChannels  # Theanne
+        rowDict['Channels'] = ba.fileLoader.numChannels  # Theanne
 
-        rowDict["Sweeps"] = ba.fileLoader.numSweeps
+        rowDict['Sweeps'] = ba.fileLoader.numSweeps
 
         # TODO: here, we do not get an epoch table until the file is loaded !!!
-        rowDict["Epochs"] = ba.fileLoader.numEpochs  # Theanne, data has to be loaded
+        rowDict['Epochs'] = ba.fileLoader.numEpochs  # Theanne, data has to be loaded
 
-        rowDict["kHz"] = ba.fileLoader.recordingFrequency
-        rowDict["Mode"] = ba.fileLoader.recordingMode.value
+        rowDict['kHz'] = ba.fileLoader.recordingFrequency
+        rowDict['Mode'] = ba.fileLoader.recordingMode.value
 
-        # rowDict['dvdtThreshold'] = 20
-        # rowDict['mvThreshold'] = -20
+        #rowDict['dvdtThreshold'] = 20
+        #rowDict['mvThreshold'] = -20
         if ba.isAnalyzed():
             dDict = ba.getDetectionDict()
-            # rowDict['I'] = dDict.getValue('include')
-            rowDict["dvdtThreshold"] = dDict.getValue("dvdtThreshold")
-            rowDict["mvThreshold"] = dDict.getValue("mvThreshold")
-            rowDict["Start(s)"] = dDict.getValue("startSeconds")
-            rowDict["Stop(s)"] = dDict.getValue("stopSeconds")
+            #rowDict['I'] = dDict.getValue('include')
+            rowDict['dvdtThreshold'] = dDict.getValue('dvdtThreshold')
+            rowDict['mvThreshold'] = dDict.getValue('mvThreshold')
+            rowDict['Start(s)'] = dDict.getValue('startSeconds')
+            rowDict['Stop(s)'] = dDict.getValue('stopSeconds')
 
         # remove the path to the folder we have loaded
-        relPath = path.replace(self.path, "")
-        
-        # logger.info(f'xxx self.path: "{self.path}"')
-        # logger.info(f'xxx path: "{path}"')
-        # logger.info(f'xxx relPath: "{relPath}"')
-        
-        if relPath.startswith("/"):
-            # so we can use os.path.join()
-            relPath = relPath[1:]
-        # added 20230505 working with johnson in 1313 to fix windows bug ???
-        if relPath.startswith("\\"):
+        relPath = path.replace(self.path, '')
+        if relPath.startswith('/'):
             # so we can use os.path.join()
             relPath = relPath[1:]
-
-        rowDict["relPath"] = relPath
-
-        #logger.info(f'2) xxx relPath: "{relPath}"')
+        rowDict['relPath'] = relPath
 
         return ba, rowDict
 
-    def getFileList(self, path: str = None) -> List[str]:
+    def getFileList(self, path : str = None) -> List[str]:
         """Get file paths from path.
 
         Uses self.theseFileTypes
         """
         if path is None:
             path = self.path
 
-        logger.warning("Remember: MODIFIED TO LOAD TIF FILES IN SUBFOLDERS")
+        logger.warning('Remember: MODIFIED TO LOAD TIF FILES IN SUBFOLDERS')
         count = 1
         tmpFileList = []
         folderDepth = self.folderDepth  # if none then all depths
-        excludeFolders = ["analysis", "hide"]
+        excludeFolders = ['analysis', 'hide']
         for root, subdirs, files in os.walk(path):
+
             subdirs[:] = [d for d in subdirs if d not in excludeFolders]
 
             # print('folderDepth:', folderDepth)
             # print('  root:', root, 'subdirs:', subdirs, 'files:', files)
-
+            
             # strip out folders that start with __
-            # _parentFolder = os.path.split(root)[1]
-            # print('root:', root)
-            # print('  parentFolder:', _parentFolder)
-            # if _parentFolder.startswith('__'):
-            if "__" in root:
-                logger.info(f"SKIPPING based on path root:{root}")
+            #_parentFolder = os.path.split(root)[1]
+            #print('root:', root)
+            #print('  parentFolder:', _parentFolder)
+            #if _parentFolder.startswith('__'):
+            if '__' in root:
+                logger.info(f'SKIPPING based on path root:{root}')
                 continue
 
-            if os.path.split(root)[1] == "analysis":
+            if os.path.split(root)[1] == 'analysis':
                 # don't load from analysis/ folder, we save analysis there
                 continue
 
             # if os.path.split(root)[1] == 'hide':
             #     # special case/convention, don't load from 'hide' folders
             #     continue
 
@@ -1320,212 +1270,211 @@
 
             count += 1
             if folderDepth is not None and count > folderDepth:
                 break
 
         fileList = []
         for file in sorted(tmpFileList):
-            if file.startswith("."):
+            if file.startswith('.'):
                 continue
             # ignore our database file
             if file == self.dbFile:
                 continue
 
             # tmpExt is like .abf, .csv, etc
             tmpFileName, tmpExt = os.path.splitext(file)
             if tmpExt in self.theseFileTypes:
                 # if getFullPath:
                 #     #file = os.path.join(path, file)
                 #     file = pathlib.Path(path) / file
                 #     file = str(file)  # return List[str] NOT List[PosixPath]
                 fileList.append(file)
         #
-        logger.info(f"found {len(fileList)} files ...")
+        logger.info(f'found {len(fileList)} files ...')
         return fileList
 
     def getRowDict(self, rowIdx):
         """
         Return a dict with selected row as dict (includes detection parameters).
 
         Important to return a copy as our '_ba' is a pointer to bAnalysis.
 
         Returns:
             theRet (dict): Be sure to make a deep copy of ['_ba'] if neccessary.
         """
         theRet = {}
         # use columns in main sanpyColumns, not in df
-        # for colStr in self.columns:
+        #for colStr in self.columns:
         for colStr in self._df.columns:
-            # theRet[colStr] = self._df.loc[rowIdx, colStr]
+            #theRet[colStr] = self._df.loc[rowIdx, colStr]
             theRet[colStr] = self._df.loc[rowIdx, colStr]
-        # theRet['_ba'] = theRet['_ba'].copy()
+        #theRet['_ba'] = theRet['_ba'].copy()
         return theRet
 
     def appendRow(self, rowDict=None, ba=None):
-        """Append an empty row."""
+        """Append an empty row.
+        """
 
         # logger.info('')
         # print('    rowDict:', rowDict)
         # print('    ba:', ba)
-
+        
         rowSeries = pd.Series()
         if rowDict is not None:
             rowSeries = pd.Series(rowDict)
             # self._data.iloc[row] = rowSeries
             # self._data = self._data.reset_index(drop=True)
 
         newRowIdx = len(self._df)
         df = self._df
-        logger.warning(f"need to replace append with concat")
+        logger.warning(f'need to replace append with concat')
         df = df.append(rowSeries, ignore_index=True)
-        # df = pd.concat([df,rowSeries], ignore_index=True, axis=1)
+        #df = pd.concat([df,rowSeries], ignore_index=True, axis=1)
         df = df.reset_index(drop=True)
 
         if ba is not None:
-            df.loc[newRowIdx, "_ba"] = ba
+            df.loc[newRowIdx, '_ba'] = ba
 
         #
         self._df = df
 
     def unloadRow(self, rowIdx):
-        self._df.loc[rowIdx, "_ba"] = None
+        self._df.loc[rowIdx, '_ba'] = None
         self._updateLoadedAnalyzed()
 
     def removeRowFromDatabase(self, rowIdx):
         # delete from h5 file
-        uuid = self._df.at[rowIdx, "uuid"]
+        uuid = self._df.at[rowIdx, 'uuid']
         self._deleteFromHdf(uuid)
 
         # clear uuid
-        self._df.at[rowIdx, "uuid"] = ""
+        self._df.at[rowIdx, 'uuid'] = ''
 
         self._updateLoadedAnalyzed()
 
     def deleteRow(self, rowIdx):
         df = self._df
 
         # delete from h5 file
-        uuid = df.at[rowIdx, "uuid"]
+        uuid = df.at[rowIdx, 'uuid']
         self._deleteFromHdf(uuid)
 
         # delete from df/model
         df = df.drop([rowIdx])
         df = df.reset_index(drop=True)
         self._df = df
 
         self._updateLoadedAnalyzed()
 
     def old_duplicateRow(self, rowIdx):
         """Depreciated, Was used to have different ocnditions within a recording,
-        this is now handled by condiiton column.
+            this is now handled by condiiton column.
         """
         # duplicate rowIdx
         newIdx = rowIdx + 0.5
 
         rowDict = self.getRowDict(rowIdx)
 
         # CRITICAL: Need to make a deep copy of the _ba pointer to bAnalysis object
         logger.info(f"copying {type(rowDict['_ba'])} {rowDict['_ba']}")
-        baNew = copy.deepcopy(rowDict["_ba"])
+        baNew = copy.deepcopy(rowDict['_ba'])
 
         # copy of bAnalysis needs a new uuid
-        new_uuid = (
-            sanpy._util.getNewUuid()
-        )  # 't' + str(uuid.uuid4())   #.replace('-', '_')
-        logger.info(f"assigning new uuid {new_uuid} to {baNew}")
+        new_uuid = sanpy._util.getNewUuid()  # 't' + str(uuid.uuid4())   #.replace('-', '_')
+        logger.info(f'assigning new uuid {new_uuid} to {baNew}')
 
         if baNew.uuid == new_uuid:
-            logger.error("!!!!!!!!!!!!!!!!!!!!!!!!!CRITICAL, new uuid is same as old")
+            logger.error('!!!!!!!!!!!!!!!!!!!!!!!!!CRITICAL, new uuid is same as old')
 
         baNew.uuid = new_uuid
 
-        rowDict["_ba"] = baNew
-        rowDict["uuid"] = baNew.uuid  # new row can never have same uuid as old
+        rowDict['_ba'] = baNew
+        rowDict['uuid'] = baNew.uuid  # new row can never have same uuid as old
 
         dfRow = pd.DataFrame(rowDict, index=[newIdx])
 
         df = self._df
         df = df.append(dfRow, ignore_index=True)
-        df = df.sort_values(by=["File"], axis="index", ascending=True, inplace=False)
+        df = df.sort_values(by=['File'], axis='index', ascending=True, inplace=False)
         df = df.reset_index(drop=True)
         self._df = df
 
         self._updateLoadedAnalyzed()
 
     def syncDfWithPath(self):
-        """Sync path with existing df. Used to detect new/removed files."""
+        """Sync path with existing df. Used to detect new/removed files.
+        """
 
         pathFileList = self.getFileList()  # always full path
-        dfFileList = self._df["File"].tolist()
+        dfFileList = self._df['File'].tolist()
 
-        logger.info("")
+        logger.info('')
         # print('    === pathFileList (on drive):')
         # print('    ', pathFileList)
         # print('    === dfFileList (in table):')
         # print('    ', dfFileList)
-
+        
         addedToDf = False
 
         # look for files in path not in df
         for pathFile in pathFileList:
             fileName = os.path.split(pathFile)[1]
             if fileName not in dfFileList:
                 logger.info(f'Found file in path "{fileName}" not in df')
                 # load bAnalysis and get df column values
                 addedToDf = True
-                # fullPathFile = os.path.join(self.path, pathFile)
-                ba, rowDict = self.getFileRow(pathFile)  # loads bAnalysis
+                #fullPathFile = os.path.join(self.path, pathFile)
+                ba, rowDict = self.getFileRow(pathFile) # loads bAnalysis
                 if rowDict is not None:
-                    # listOfDict.append(rowDict)
+                    #listOfDict.append(rowDict)
 
                     # TODO: get this into getFileROw()
-                    logger.warning("20220718, not sure we need this ???")
+                    logger.warning('20220718, not sure we need this ???')
                     # rowDict['relPath'] = pathFile
-                    rowDict["_ba"] = None
+                    rowDict['_ba'] = None
 
                     self.appendRow(rowDict=rowDict, ba=None)
 
         # look for files in df not in path
         # for dfFile in dfFileList:
         #     if not dfFile in pathFileList:
         #         logger.info(f'Found file in df "{dfFile}" not in path')
 
         if addedToDf:
             df = self._df
-            df = df.sort_values(
-                by=["File"], axis="index", ascending=True, inplace=False
-            )
+            df = df.sort_values(by=['File'], axis='index', ascending=True, inplace=False)
             df = df.reset_index(drop=True)
             self._df = df
 
         self._updateLoadedAnalyzed()
 
     def pool_build(self):
-        """Build one df with all analysis. Use this in plot tool plugin."""
-        logger.info("")
+        """Build one df with all analysis. Use this in plot tool plugin.
+        """
+        logger.info('')
         masterDf = None
         for row in range(self.numFiles):
             if not self.isAnalyzed(row):
-                logger.info(f"  row:{row} not analyzed")
+                logger.info(f'  row:{row} not analyzed')
                 continue
             ba = self.getAnalysis(row)
             oneDf = ba.asDataFrame()
             if oneDf is not None:
                 self.signalApp(f'  adding "{ba.fileLoader.filename}"')
-                oneDf["File Number"] = int(row)
+                oneDf['File Number'] = int(row)
                 if masterDf is None:
                     masterDf = oneDf
                 else:
                     masterDf = pd.concat([masterDf, oneDf])
         #
         if masterDf is None:
-            logger.error("Did not find any analysis.")
+            logger.error('Did not find any analysis.')
         else:
-            logger.info(f"final num spikes {len(masterDf)}")
-        # print(masterDf.head())
+            logger.info(f'final num spikes {len(masterDf)}')
+        #print(masterDf.head())
         self._poolDf = masterDf
 
         return self._poolDf
 
     def signalApp(self, str):
         """Update status bar of SanPy app.
 
@@ -1537,141 +1486,139 @@
         else:
             logger.info(str)
 
     def api_getFileHeaders(self):
         headerList = []
         df = self.getDataFrame()
         for row in range(len(df)):
-            # ba = self.getAnalysis(row)  # do not call this, it will load
-            ba = df.at[row, "_ba"]
+            #ba = self.getAnalysis(row)  # do not call this, it will load
+            ba = df.at[row, '_ba']
             if ba is not None:
                 headerDict = ba.api_getHeader()
                 headerList.append(headerDict)
         #
         return headerList
 
-
 def _printDict(d):
-    for k, v in d.items():
-        print("  ", k, ":", v)
-
+    for k,v in d.items():
+        print('  ', k, ':', v)
 
 def test3():
-    path = "/home/cudmore/Sites/SanPy/data"
+    path = '/home/cudmore/Sites/SanPy/data'
     bad = analysisDir(path)
 
-    # file = '19221014.abf'
+    #file = '19221014.abf'
     rowIdx = 3
     ba = bad.getAnalysis(rowIdx)
     ba = bad.getAnalysis(rowIdx)
 
     print(bad.getDataFrame())
 
-    print("bad.shape", bad.shape)
-    print("bad.columns:", bad.columns)
+    print('bad.shape', bad.shape)
+    print('bad.columns:', bad.columns)
 
-    print("bad.iloc[rowIdx,5]:", bad.iloc[rowIdx, 5])
-    print("setting to xxxyyyzzz")
+    print('bad.iloc[rowIdx,5]:', bad.iloc[rowIdx,5])
+    print('setting to xxxyyyzzz')
 
     # setter
-    # bad.iloc[2,5] = 'xxxyyyzzz'
+    #bad.iloc[2,5] = 'xxxyyyzzz'
 
-    print("bad.iloc[2,5]:", bad.iloc[rowIdx, 5])
-    print('bad.loc[2,"File"]:', bad.loc[rowIdx, "File"])
+    print('bad.iloc[2,5]:', bad.iloc[rowIdx,5])
+    print('bad.loc[2,"File"]:', bad.loc[rowIdx,'File'])
 
-    print("bad.iloc[2]")
+    print('bad.iloc[2]')
     print(bad.iloc[rowIdx])
-    # bad.iloc[rowIdx] = ''
-    print("bad.loc[2]")
+    #bad.iloc[rowIdx] = ''
+    print('bad.loc[2]')
     print(bad.loc[rowIdx])
 
-    # bad.saveDatabase()
-
+    #bad.saveDatabase()
 
 def test_hd5_2():
-    folderPath = "/home/cudmore/Sites/SanPy/data"
+    folderPath = '/home/cudmore/Sites/SanPy/data'
     if 1:
         # save analysisDir hdf
         bad = analysisDir(folderPath)
-        print("bad._df:")
+        print('bad._df:')
         print(bad._df)
-        # bad.saveDatabase()  # save .csv
+        #bad.saveDatabase()  # save .csv
         bad.saveHdf()  # save ALL bAnalysis in .h5
 
     if 0:
         # load h5 and reconstruct a bAnalysis object
         start = time.time()
-        hdfPath = "/home/cudmore/Sites/SanPy/data/sanpy_recording_db.h5"
-        with pd.HDFStore(hdfPath, "r") as hdfStore:
+        hdfPath = '/home/cudmore/Sites/SanPy/data/sanpy_recording_db.h5'
+        with pd.HDFStore(hdfPath, 'r') as hdfStore:
             for key in hdfStore.keys():
+
                 dfTmp = hdfStore[key]
-                # path = dfTmp.iloc[0]['path']
+                #path = dfTmp.iloc[0]['path']
 
-                print("===", key)
-                # if not key.startswith('/r6'):
+                print('===', key)
+                #if not key.startswith('/r6'):
                 #    continue
-                # for col in dfTmp.columns:
+                #for col in dfTmp.columns:
                 #    print('  ', col, dfTmp[col])
-                # print(key, type(dfTmp), dfTmp.shape)
-                # print('dfTmp:')
-                # print(dfTmp)
+                #print(key, type(dfTmp), dfTmp.shape)
+                #print('dfTmp:')
+                #print(dfTmp)
 
-                # print(dfTmp.iloc[0]['_sweepX'])
+
+                #print(dfTmp.iloc[0]['_sweepX'])
 
                 # load bAnalysis from a pandas DataFrame
                 ba = sanpy.bAnalysis(fromDf=dfTmp)
 
                 print(ba)
 
                 ba.spikeDetect()  # this should reproduce exactly what was save ... It WORKS !!!
 
         stop = time.time()
-        logger.info(f"h5 load took {round(stop-start,3)} seconds")
-
+        logger.info(f'h5 load took {round(stop-start,3)} seconds')
 
 def test_hd5():
     import time
-
     start = time.time()
-    hdfStore = pd.HDFStore("store.gzip")
+    hdfStore = pd.HDFStore('store.gzip')
     if 1:
-        path = "/home/cudmore/Sites/SanPy/data"
+        path = '/home/cudmore/Sites/SanPy/data'
         bad = analysisDir(path)
 
         # load all bAnalysis
         for idx in range(len(bad)):
             bad.getAnalysis(idx)
 
-        hdfStore["df"] = bad.getDataFrame()  # save it
+        hdfStore['df'] = bad.getDataFrame()  # save it
         bad.saveDatabase()
 
     if 0:
-        df = hdfStore["df"]  # load it
-        print("loaded df:")
+        df = hdfStore['df']  # load it
+        print('loaded df:')
         print(df)
     stop = time.time()
-    print(f"took {stop-start}")
-
+    print(f'took {stop-start}')
 
 def test_pool():
-    path = "/home/cudmore/Sites/SanPy/data"
+    path = '/home/cudmore/Sites/SanPy/data'
     ad = analysisDir(path)
-    print("loaded df:")
+    print('loaded df:')
     print(ad._df)
 
     ad.pool_build()
 
-
 def testCloud():
-    cloudDict = {"owner": "cudmore", "repo_name": "SanPy", "path": "data"}
+    cloudDict = {
+        'owner': 'cudmore',
+        'repo_name': 'SanPy',
+        'path': 'data'
+    }
     bad = bAnalysisDirWeb(cloudDict)
 
-
-if __name__ == "__main__":
-    # test3()
-    # test_hd5()
+if __name__ == '__main__':
+    #test3()
+    #test_hd5()
     test_hd5_2()
-    # test_pool()
-    # testCloud()
+    #test_pool()
+    #testCloud()
 
-    # test_timing()
-    # plotTiming()
+    #test_timing()
+    #plotTiming()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/analysisPlot.py` & `sanpy-ephys-0.1.6/sanpy/analysisPlot.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,126 +5,119 @@
 import scipy.signal
 import seaborn as sns
 import matplotlib.pyplot as plt
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 def old_getEddLines(ba):
     """Get lines representing linear fit of EDD rate.
 
     Args:
         ba (bAnalysis): bAnalysis object
     """
     logger.info(ba)
 
     x = []
     y = []
     if ba is None or ba.numSpikes == 0:
         return x, y
 
     # these are getting for current sweep
-    preLinearFitPnt0 = ba.getStat("preLinearFitPnt0")
+    preLinearFitPnt0 = ba.getStat('preLinearFitPnt0')
     preLinearFitSec0 = [ba.pnt2Sec_(x) for x in preLinearFitPnt0]
-    preLinearFitVal0 = ba.getStat("preLinearFitVal0")
+    preLinearFitVal0 = ba.getStat('preLinearFitVal0')
 
-    preLinearFitPnt1 = ba.getStat("preLinearFitPnt1")
+    preLinearFitPnt1 = ba.getStat('preLinearFitPnt1')
     preLinearFitSec1 = [ba.pnt2Sec_(x) for x in preLinearFitPnt1]
-    preLinearFitVal1 = ba.getStat("preLinearFitVal1")
+    preLinearFitVal1 = ba.getStat('preLinearFitVal1')
 
     thisNumSpikes = len(preLinearFitPnt0)
-    # for idx, spike in enumerate(range(ba.numSpikes)):
+    #for idx, spike in enumerate(range(ba.numSpikes)):
     for idx, spike in enumerate(range(thisNumSpikes)):
         dx = preLinearFitSec1[idx] - preLinearFitSec0[idx]
         dy = preLinearFitVal1[idx] - preLinearFitVal0[idx]
 
         lineLength = 8  # TODO: make this a function of spike frequency?
 
         x.append(preLinearFitSec0[idx])
-        x.append(preLinearFitSec1[idx] + lineLength * dx)
+        x.append(preLinearFitSec1[idx] + lineLength*dx)
         x.append(np.nan)
 
         y.append(preLinearFitVal0[idx])
-        y.append(preLinearFitVal1[idx] + lineLength * dy)
+        y.append(preLinearFitVal1[idx] + lineLength*dy)
         y.append(np.nan)
 
-        # print('here')
+        #print('here')
 
     return x, y
 
-
 def old_getHalfWidths(ba):
     """Get lines representing half-widhts (AP Dur).
 
     Args:
         ba (bAnalysis): bAnalysis object
 
     Returns:
         x,y (enum):
     """
     # defer until we know how many half-widths 20/50/80
     x = []
     y = []
     numPerSpike = 3  # rise/fall/nan
-    # numSpikes = ba.numSpikes
+    #numSpikes = ba.numSpikes
     xyIdx = 0
-    spikeDictionaries = ba.getSpikeDictionaries()  # for current sweep
+    spikeDictionaries = ba.getSpikeDictionaries() # for current sweep
     numSpikes = len(spikeDictionaries)
-    # for idx, spike in enumerate(ba.spikeDict):
+    #for idx, spike in enumerate(ba.spikeDict):
     for idx, spike in enumerate(spikeDictionaries):
-        if idx == 0:
+        if idx ==0:
             # make x/y from first spike using halfHeights = [20,50,80]
-            halfHeights = spike[
-                "halfHeights"
-            ]  # will be same for all spike, like [20, 50, 80]
+            halfHeights = spike['halfHeights'] # will be same for all spike, like [20, 50, 80]
             numHalfHeights = len(halfHeights)
             # *numHalfHeights to account for rise/fall + padding nan
             x = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
             y = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
-            # print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
+            #print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
 
-        for idx2, width in enumerate(spike["widths"]):
-            halfHeight = width["halfHeight"]  # [20,50,80]
-            risingPnt = width["risingPnt"]
-            risingVal = width["risingVal"]
-            fallingPnt = width["fallingPnt"]
-            fallingVal = width["fallingVal"]
+        for idx2, width in enumerate(spike['widths']):
+            halfHeight = width['halfHeight'] # [20,50,80]
+            risingPnt = width['risingPnt']
+            risingVal = width['risingVal']
+            fallingPnt = width['fallingPnt']
+            fallingVal = width['fallingVal']
 
             if risingPnt is None or fallingPnt is None:
                 # half-height was not detected
                 continue
 
             risingSec = ba.pnt2Sec_(risingPnt)
             fallingSec = ba.pnt2Sec_(fallingPnt)
 
             x[xyIdx] = risingSec
-            x[xyIdx + 1] = fallingSec
-            x[xyIdx + 2] = np.nan
+            x[xyIdx+1] = fallingSec
+            x[xyIdx+2] = np.nan
             # y
-            y[xyIdx] = fallingVal  # risingVal, to make line horizontal
-            y[xyIdx + 1] = fallingVal
-            y[xyIdx + 2] = np.nan
+            y[xyIdx] = fallingVal  #risingVal, to make line horizontal
+            y[xyIdx+1] = fallingVal
+            y[xyIdx+2] = np.nan
 
             # each spike has 3x pnts: rise/fall/nan
             xyIdx += numPerSpike  # accounts for rising/falling/nan
         # end for width
     # end for spike
     return x, y
 
-
-class bAnalysisPlot:
+class bAnalysisPlot():
     """
     Class to plot results of [sanpy.bAnalysis][sanpy.bAnalysis] spike detection.
-
+    
     """
-
     def __init__(self, ba=None):
         """
         Args:
             ba: [sanpy.bAnalysis][sanpy.bAnalysis] object
         """
         self._ba = ba
 
@@ -132,34 +125,34 @@
     def ba(self):
         """Get underlying bAnalysis object."""
         return self._ba
 
     def getDefaultPlotStyle(self):
         """Get dictionary with default plot style."""
         d = {
-            "linewidth": 1,
-            "color": "k",
-            "width": 9,
-            "height": 3,
+            'linewidth': 1,
+            'color': 'k',
+            'width': 9,
+            'height': 3,
         }
         return d.copy()
 
     def _makeFig(self, plotStyle=None):
         if plotStyle is None:
             plotStyle = self.getDefaultPlotStyle()
 
         grid = plt.GridSpec(1, 1, wspace=0.2, hspace=0.4)
 
-        width = plotStyle["width"]
-        height = plotStyle["height"]
+        width = plotStyle['width']
+        height = plotStyle['height']
         fig = plt.figure(figsize=(width, height))
-        ax = fig.add_subplot(grid[0, 0:])  # Vm, entire sweep
+        ax = fig.add_subplot(grid[0, 0:]) #Vm, entire sweep
 
-        ax.spines["right"].set_visible(False)
-        ax.spines["top"].set_visible(False)
+        ax.spines['right'].set_visible(False)
+        ax.spines['top'].set_visible(False)
 
         return fig, ax
 
     def plotRaw(self, plotStyle=None, ax=None):
         """
         Plot raw recording
 
@@ -169,34 +162,32 @@
         """
 
         if plotStyle is None:
             plotStyle = self.getDefaultPlotStyle()
 
         if ax is None:
             _fig, _ax = self._makeFig()
-            _fig.suptitle(f"{self._ba.fileLoader.filepath}")
+            _fig.suptitle(f'{self._ba.fileLoader.filepath}')
         else:
             _ax = ax
 
-        color = plotStyle["color"]
-        linewidth = plotStyle["linewidth"]
+        color = plotStyle['color']
+        linewidth = plotStyle['linewidth']
         sweepX = self.ba.fileLoader.sweepX
         sweepY = self.ba.fileLoader.sweepY
 
-        _ax.plot(
-            sweepX, sweepY, "-", c=color, linewidth=linewidth
-        )  # fmt = '[marker][line][color]'
+        _ax.plot(sweepX, sweepY, '-', c=color, linewidth=linewidth) # fmt = '[marker][line][color]'
 
         xUnits = self.ba.fileLoader.get_xUnits()
         yUnits = self.ba.fileLoader.get_yUnits()
         _ax.set_xlabel(xUnits)
         _ax.set_ylabel(yUnits)
 
         return _ax
-
+        
     def plotDerivAndRaw(self):
         """
         Plot both Vm and the derivative of Vm (dV/dt).
 
         Args:
             fig (matplotlib.pyplot.figure): An existing figure to plot to.
                 see: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html
@@ -205,327 +196,320 @@
             fig and axs
         """
 
         #
         # make a 2-panel figure
         grid = plt.GridSpec(2, 1, wspace=0.2, hspace=0.4)
         fig = plt.figure(figsize=(10, 8))
-        ax1 = fig.add_subplot(grid[0, 0])
-        ax2 = fig.add_subplot(grid[1, 0], sharex=ax1)
-        ax1.spines["right"].set_visible(False)
-        ax1.spines["top"].set_visible(False)
-        ax2.spines["right"].set_visible(False)
-        ax2.spines["top"].set_visible(False)
+        ax1 = fig.add_subplot(grid[0,0])
+        ax2 = fig.add_subplot(grid[1,0], sharex=ax1)
+        ax1.spines['right'].set_visible(False)
+        ax1.spines['top'].set_visible(False)
+        ax2.spines['right'].set_visible(False)
+        ax2.spines['top'].set_visible(False)
 
-        self.plotRaw(ax=ax1)
+        self.plotRaw(ax=ax1);
 
         sweepX = self.ba.fileLoader.sweepX
         filteredDeriv = self.ba.fileLoader.filteredDeriv
         ax2.plot(sweepX, filteredDeriv)
 
-        ax2.set_ylabel("dV/dt")
-        # ax2.set_xlabel('Seconds')
+        ax2.set_ylabel('dV/dt')
+        #ax2.set_xlabel('Seconds')
 
         return fig, [ax1, ax2]
 
-    def plotSpikes(
-        self,
-        plotThreshold=False,
-        plotPeak=False,
-        plotStyle=None,
-        hue: Optional[str] = "condition",
-        markerSize: Optional[int] = 4,
-        ax=None,
-    ):
-        """Plot Vm with spike analysis overlaid as symbols
+    def plotSpikes(self,
+                   plotThreshold=False, plotPeak=False,
+                   plotStyle=None,
+                   hue : Optional[str] = 'condition',
+                   markerSize : Optional[int] = 4,
+                   ax=None):
+        '''Plot Vm with spike analysis overlaid as symbols
 
         Args:
             plotThreshold
             plotPeak
             plotStyle (dict): xxx
             markerSize
             ax (xxx): If specified will plot into a MatPlotLib axes
 
         Returns
             fig
             ax
-        """
+        '''
 
         legend = False
-
+        
         if plotStyle is None:
             plotStyle = self.getDefaultPlotStyle()
 
         if ax is None:
             fig, ax = self._makeFig()
             fig.suptitle(self.ba.getFileName())
         # plot vm
         self.plotRaw(ax=ax)
 
         # plot spike times
         if plotThreshold:
-            thresholdSec = self.ba.getStat("thresholdSec")  # x
-            thresholdVal = self.ba.getStat("thresholdVal")  # y
-
-            ax.plot(thresholdSec, thresholdVal, "pr", markersize=markerSize)
+            thresholdSec = self.ba.getStat('thresholdSec')  # x
+            thresholdVal = self.ba.getStat('thresholdVal')  # y
+            
+            ax.plot(thresholdSec, thresholdVal, 'pr', markersize=markerSize)
             df = self.ba.spikeDict.asDataFrame()  # regenerates, can be expensive
-            # logger.info(f'df hue unique is: {df[hue].unique()}')
-            # sns.scatterplot(x='thresholdSec', y='thresholdVal', hue=hue, data=df, ax=ax, legend=legend)
+            #logger.info(f'df hue unique is: {df[hue].unique()}')
+            #sns.scatterplot(x='thresholdSec', y='thresholdVal', hue=hue, data=df, ax=ax, legend=legend)
 
         # plot the peak
         if plotPeak:
-            peakPnt = self.ba.getStat("peakPnt")
+            peakPnt = self.ba.getStat('peakPnt')
             # don't use this for Ca++ concentration
-            # peakVal = self.ba.getStat('peakVal')
+            #peakVal = self.ba.getStat('peakVal')
             peakVal = self.ba.fileLoader.sweepY[peakPnt]
             peakSec = [self.ba.fileLoader.pnt2Sec_(x) for x in peakPnt]
-            ax.plot(peakSec, peakVal, "oc", markersize=markerSize)
+            ax.plot(peakSec, peakVal, 'oc', markersize=markerSize)
 
         xUnits = self.ba.fileLoader.get_xUnits()
         yUnits = self.ba.fileLoader.get_yUnits()
         ax.set_xlabel(xUnits)
         ax.set_ylabel(yUnits)
 
         return ax
-
-    def plotStat(self, xStat: str, yStat: str, hue: Optional[str] = None, ax=None):
-        # ax : Optional["matplotlib.axes._subplots.AxesSubplot"] = None):
-
+    
+    def plotStat(self, xStat : str, yStat : str,
+                 hue : Optional[str] = None,
+                 ax = None):
+                 # ax : Optional["matplotlib.axes._subplots.AxesSubplot"] = None):
+        
         legend = False
-
+        
         if ax is None:
             fig, ax = self._makeFig()
             fig.suptitle(self.ba.getFileName())
         print(type(ax))
-
+              
         df = self.ba.spikeDict.asDataFrame()  # regenerates, can be expensive
         sns.scatterplot(x=xStat, y=yStat, hue=hue, data=df, ax=ax, legend=legend)
 
     def plotTimeSeries(ba, stat, halfWidthIdx=0, ax=None):
-        """Plot a given spike parameter."""
-        if stat == "peak":
-            yStatName = "peakVal"
-            yStatLabel = "Spike Peak (mV)"
-        if stat == "preMin":
-            yStatName = "preMinVal"
-            yStatLabel = "Pre Min (mV)"
-        if stat == "halfWidth":
-            yStatName = "widthPnts"
-            yStatLabel = "Spike Half Width (ms)"
+        """ Plot a given spike parameter.
+        """
+        if stat == 'peak':
+            yStatName = 'peakVal'
+            yStatLabel = 'Spike Peak (mV)'
+        if stat == 'preMin':
+            yStatName = 'preMinVal'
+            yStatLabel = 'Pre Min (mV)'
+        if stat == 'halfWidth':
+            yStatName = 'widthPnts'
+            yStatLabel = 'Spike Half Width (ms)'
 
         #
         # pull
         statX = []
         statVal = []
         for i, spike in enumerate(ba.spikeDict):
-            if i == 0 or i == len(ba.spikeTimes) - 1:
+            if i==0 or i==len(ba.spikeTimes)-1:
                 continue
             else:
-                statX.append(spike["peakSec"])
-                if stat == "halfWidth":
-                    statVal.append(spike["widths"][halfWidthIdx]["widthMs"])
+                statX.append(spike['peakSec'])
+                if stat == 'halfWidth':
+                    statVal.append(spike['widths'][halfWidthIdx]['widthMs'])
                 else:
                     statVal.append(spike[yStatName])
 
         #
         # plot
         if ax is None:
             grid = plt.GridSpec(1, 1, wspace=0.2, hspace=0.4)
 
             fig = plt.figure(figsize=(10, 8))
-            ax = fig.add_subplot(grid[0, 0:])  # Vm, entire sweep
+            ax = fig.add_subplot(grid[0, 0:]) #Vm, entire sweep
 
-        ax.plot(statX, statVal, "o-k")
+        ax.plot(statX, statVal, 'o-k')
 
         ax.set_ylabel(yStatLabel)
-        ax.set_xlabel("Time (sec)")
+        ax.set_xlabel('Time (sec)')
 
         return statVal
 
     def plotISI(ba, ax=None):
-        """Plot the inter-spike-interval (sec) between each spike threshold"""
+        """ Plot the inter-spike-interval (sec) between each spike threshold"""
         #
         # pull
-        spikeTimes_sec = [x / ba.dataPointsPerMs / 1000 for x in ba.spikeTimes]
+        spikeTimes_sec = [x/ba.dataPointsPerMs/1000 for x in ba.spikeTimes]
         isi = np.diff(spikeTimes_sec)
         isi_x = spikeTimes_sec[0:-1]
 
         #
         # plot
         if ax is None:
             grid = plt.GridSpec(1, 1, wspace=0.2, hspace=0.4)
 
             fig = plt.figure(figsize=(10, 8))
-            ax = fig.add_subplot(grid[0, 0:])  # Vm, entire sweep
+            ax = fig.add_subplot(grid[0, 0:]) #Vm, entire sweep
 
-        ax.plot(isi_x, isi, "o-k")
+        ax.plot(isi_x, isi, 'o-k')
 
-        ax.set_ylabel("Inter-Spike-Interval (sec)")
-        ax.set_xlabel("Time (sec)")
+        ax.set_ylabel('Inter-Spike-Interval (sec)')
+        ax.set_xlabel('Time (sec)')
 
-    def plotClips(
-        self, plotType="Raw", preClipWidth_ms=None, postClipWidth_ms=None, ax=None
-    ):
+    def plotClips(self, plotType='Raw', preClipWidth_ms=None, postClipWidth_ms=None, ax=None):
         """Plot clips of all detected spikes
 
         Clips are created in self.spikeDetect() and default to clipWidth_ms = 100 ms
 
         Args:
             plotType (str): From [Raw, RawPlusMean, Mean, SD, Var]
             #plotVariance (bool): If tru, plot variance. Otherwise plot all raw clips (black) with mean (red)
 
         Returns:
             xPlot
             yPlot
         """
 
-        """
+        '''
         if ax is None:
             grid = plt.GridSpec(1, 1, wspace=0.2, hspace=0.4)
 
             fig = plt.figure(figsize=(10, 8))
             ax = fig.add_subplot(grid[0, 0:]) #Vm, entire sweep
-        """
+        '''
 
         if self.ba.numSpikes == 0:
             return None, None
 
         if ax is None:
             fig, ax = self._makeFig()
             fig.suptitle(self.ba.getFileName())
 
         startSec, stopSec = None, None
         selectedSpikeList = []
-        # preClipWidth_ms = 200
-        # postClipWidth_ms = 1000
+        #preClipWidth_ms = 200
+        #postClipWidth_ms = 1000
 
         # Leave this none, if we pass none, ba.getSpikeClipsWill take care of this
-        """
+        '''
         if preClipWidth_ms is None:
             preClipWidth_ms = self.ba.detectionClass['preSpikeClipWidth_ms']
         if postClipWidth_ms is None:
             postClipWidth_ms = self.ba.detectionClass['postSpikeClipWidth_ms']
-        """
+        '''
         sweepNumber = 0
-        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(
-            startSec,
-            stopSec,
-            spikeSelection=selectedSpikeList,
-            preSpikeClipWidth_ms=preClipWidth_ms,
-            postSpikeClipWidth_ms=postClipWidth_ms,
-            sweepNumber=sweepNumber,
-        )
+        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(startSec, stopSec,
+                                                spikeSelection=selectedSpikeList,
+                                                preSpikeClipWidth_ms=preClipWidth_ms,
+                                                postSpikeClipWidth_ms=postClipWidth_ms,
+                                                sweepNumber=sweepNumber)
         numClips = len(theseClips)
 
         # convert clips to 2d ndarray ???
         xTmp = np.array(theseClips_x)
-        # xTmp /= self.ba.dataPointsPerMs * 1000  # pnt to seconds
+        #xTmp /= self.ba.dataPointsPerMs * 1000  # pnt to seconds
         xTmp /= 1000  # ms to seconds
         yTmp = np.array(theseClips)  # mV
 
         # TODO: plot each clip as different color
         # this will show variation in sequential clips (for Ca++ imaging they are decreasing)
-        # print(xTmp.shape)  # ( e.g. (9,306)
-        # sys.exit(1)
+        #print(xTmp.shape)  # ( e.g. (9,306)
+        #sys.exit(1)
 
         # plot variance
-        if plotType == "Mean":
-            xPlot = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+        if plotType == 'Mean':
+            xPlot = np.nanmean(xTmp, axis=0) # xTmp is in ms
             yPlot = np.nanmean(yTmp, axis=0)
-            ax.plot(xPlot, yPlot, "-k", linewidth=1)
-            ax.set_ylabel("Mean")
-            ax.set_xlabel("Time (sec)")
-        elif plotType == "Var":
-            xPlot = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+            ax.plot(xPlot, yPlot, '-k', linewidth=1)
+            ax.set_ylabel('Mean')
+            ax.set_xlabel('Time (sec)')
+        elif plotType == 'Var':
+            xPlot = np.nanmean(xTmp, axis=0) # xTmp is in ms
             yPlot = np.nanvar(yTmp, axis=0)
-            ax.plot(xPlot, yPlot, "-k", linewidth=1)
-            ax.set_ylabel("Variance")
-            ax.set_xlabel("Time (sec)")
-        elif plotType == "SD":
-            xPlot = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+            ax.plot(xPlot, yPlot, '-k', linewidth=1)
+            ax.set_ylabel('Variance')
+            ax.set_xlabel('Time (sec)')
+        elif plotType == 'SD':
+            xPlot = np.nanmean(xTmp, axis=0) # xTmp is in ms
             yPlot = np.nanstd(yTmp, axis=0)
-            ax.plot(xPlot, yPlot, "-k", linewidth=1)
-            ax.set_ylabel("STD")
-            ax.set_xlabel("Time (sec)")
-        elif plotType in ["Raw", "RawPlusMean"]:
+            ax.plot(xPlot, yPlot, '-k', linewidth=1)
+            ax.set_ylabel('STD')
+            ax.set_xlabel('Time (sec)')
+        elif plotType in ['Raw', 'RawPlusMean']:
             # plot raw
-            # logger.info('PLOTTING RAW')
+            #logger.info('PLOTTING RAW')
 
-            cmap = plt.get_cmap("jet")
+            cmap = plt.get_cmap('jet')
             colors = [cmap(i) for i in np.linspace(0, 1, numClips)]
 
             for i in range(numClips):
                 color = colors[i]
-                xPlot = xTmp[i, :]
-                yPlot = yTmp[i, :]
+                xPlot = xTmp[i,:]
+                yPlot = yTmp[i,:]
                 # I want different colors here
-                # ax.plot(xPlot, yPlot, '-k', linewidth=0.5)
+                #ax.plot(xPlot, yPlot, '-k', linewidth=0.5)
                 # WHY IS THIS NOT WORKING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-                # logger.info(f'!!!!!!!!!!!!!!!!!!!!!! plotting color g {plotType} {color}')
-                # ax.plot(xPlot, yPlot, '-g', linewidth=0.5, color='g')
-                ax.plot(xPlot, yPlot, "-", label=f"{i}", color=color, linewidth=0.5)
+                #logger.info(f'!!!!!!!!!!!!!!!!!!!!!! plotting color g {plotType} {color}')
+                #ax.plot(xPlot, yPlot, '-g', linewidth=0.5, color='g')
+                ax.plot(xPlot, yPlot, '-', label=f'{i}', color=color, linewidth=0.5)
 
             yLabel = self.ba._sweepLabelY
             ax.set_ylabel(yLabel)
-            ax.set_xlabel("Time (sec)")
+            ax.set_xlabel('Time (sec)')
 
             # plot mean
-            if plotType == "RawPlusMean":
-                xMeanClip = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+            if plotType == 'RawPlusMean':
+                xMeanClip = np.nanmean(xTmp, axis=0) # xTmp is in ms
                 yMeanClip = np.nanmean(yTmp, axis=0)
-                ax.plot(xMeanClip, yMeanClip, "-r", linewidth=1)
+                ax.plot(xMeanClip, yMeanClip, '-r', linewidth=1)
 
             # show legend for each raw race 0,1,2,3,...
-            ax.legend(loc="best")
+            ax.legend(loc='best')
 
         else:
-            logger.error(f"Did not understand plot type: {plotType}")
+            logger.error(f'Did not understand plot type: {plotType}')
 
         #
         return xPlot, yPlot
 
     def plotPhasePlot(self, oneSpikeNumber=None, ax=None):
         if ax is None:
             grid = plt.GridSpec(1, 1, wspace=0.2, hspace=0.4)
 
             fig = plt.figure(figsize=(10, 8))
-            ax = fig.add_subplot(grid[0, 0:])  # Vm, entire sweep
+            ax = fig.add_subplot(grid[0, 0:]) #Vm, entire sweep
 
-        filteredClip = scipy.signal.medfilt(self.spikeClips[oneSpikeNumber], 3)
+        filteredClip = scipy.signal.medfilt(self.spikeClips[oneSpikeNumber],3)
         dvdt = np.diff(filteredClip)
         # add an initial point so it is the same length as raw data in abf.sweepY
-        dvdt = np.concatenate(([0], dvdt))
-        (line,) = ax.plot(filteredClip, dvdt, "y")
+        dvdt = np.concatenate(([0],dvdt))
+        line, = ax.plot(filteredClip, dvdt, 'y')
 
-        ax.set_ylabel("filtered dV/dt")
-        ax.set_xlabel("filtered Vm (mV)")
+        ax.set_ylabel('filtered dV/dt')
+        ax.set_xlabel('filtered Vm (mV)')
 
         return line
 
-
 def test_plot(path):
-    print("=== test_plot() path:", path)
+    print('=== test_plot() path:', path)
     ba = sanpy.bAnalysis(path)
 
     # detect
     dDict = sanpy.bAnalysis.getDefaultDetection()
-    dDict["dvdThreshold"] = 50
+    dDict['dvdThreshold'] = 50
     ba.spikeDetect(dDict)
 
     # plot
     bp = sanpy.bAnalysisPlot(ba)
 
     fig = bp.plotDerivAndRaw()
 
     fig = bp.plotSpikes()
 
     plt.show()
 
-
-if __name__ == "__main__":
-    path = "data/19114001.abf"
+if __name__ == '__main__':
+    path = 'data/19114001.abf'
     test_plot(path)
 
     # TODO: check if error
 
-    path = "data/19114001.csv"
+    path = 'data/19114001.csv'
     test_plot(path)
```

### Comparing `sanpy-ephys-0.1.13/sanpy/analysisUtil.py` & `sanpy-ephys-0.1.6/sanpy/analysisUtil.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,59 +1,49 @@
 """General purpose (numerical) utilities for spike detection and plotting.
 """
 
 import numpy as np
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-def throwOutAboveBelow(
-    vm,
-    spikeTimes,
-    spikeErrors,
-    peakWindow_pnts,
-    onlyPeaksAbove_mV=None,
-    onlyPeaksBelow_mV=None,
-):
+def throwOutAboveBelow(vm, spikeTimes, spikeErrors, peakWindow_pnts, onlyPeaksAbove_mV=None, onlyPeaksBelow_mV=None):
     """
     Args:
         vm (np.ndarray):
         spikeTimes (list): list of spike times
         spikeErrors (list): list of error
     """
     newSpikeTimes = []
     newSpikeErrorList = []
     newSpikePeakPnt = []
     newSpikePeakVal = []
     for i, spikeTime in enumerate(spikeTimes):
-        peakPnt = np.argmax(vm[spikeTime : spikeTime + peakWindow_pnts])
+        peakPnt = np.argmax(vm[spikeTime:spikeTime+peakWindow_pnts])
         peakPnt += spikeTime
-        peakVal = np.max(vm[spikeTime : spikeTime + peakWindow_pnts])
+        peakVal = np.max(vm[spikeTime:spikeTime+peakWindow_pnts])
 
         goodSpikeAbove = True
         if onlyPeaksAbove_mV is not None and (peakVal < onlyPeaksAbove_mV):
             goodSpikeAbove = False
         goodSpikeBelow = True
         if onlyPeaksBelow_mV is not None and (peakVal > onlyPeaksBelow_mV):
             goodSpikeBelow = False
 
         if goodSpikeAbove and goodSpikeBelow:
             newSpikeTimes.append(spikeTime)
             newSpikeErrorList.append(spikeErrors[i])
             newSpikePeakPnt.append(peakPnt)
             newSpikePeakVal.append(peakVal)
         else:
-            # print('spikeDetect() peak height: rejecting spike', i, 'at pnt:', spikeTime, "dDict['onlyPeaksAbove_mV']:", dDict['onlyPeaksAbove_mV'])
+            #print('spikeDetect() peak height: rejecting spike', i, 'at pnt:', spikeTime, "dDict['onlyPeaksAbove_mV']:", dDict['onlyPeaksAbove_mV'])
             pass
     #
     return newSpikeTimes, newSpikeErrorList, newSpikePeakPnt, newSpikePeakVal
 
-
 def getEddLines(ba):
     """Get lines representing linear fit of EDD rate.
 
     Args:
         ba (bAnalysis): bAnalysis object
     """
     logger.info(ba)
@@ -61,129 +51,125 @@
     x = []
     y = []
     if ba is None or ba.numSpikes == 0:
         return x, y
 
     #
     # these are getting for current sweep
-    preLinearFitPnt0 = ba.getStat("preLinearFitPnt0")
+    preLinearFitPnt0 = ba.getStat('preLinearFitPnt0')
     preLinearFitSec0 = [ba.fileLoader.pnt2Sec_(x) for x in preLinearFitPnt0]
-    preLinearFitVal0 = ba.getStat("preLinearFitVal0")
+    preLinearFitVal0 = ba.getStat('preLinearFitVal0')
 
-    preLinearFitPnt1 = ba.getStat("preLinearFitPnt1")
+    preLinearFitPnt1 = ba.getStat('preLinearFitPnt1')
     preLinearFitSec1 = [ba.fileLoader.pnt2Sec_(x) for x in preLinearFitPnt1]
-    preLinearFitVal1 = ba.getStat("preLinearFitVal1")
+    preLinearFitVal1 = ba.getStat('preLinearFitVal1')
 
     thisNumSpikes = len(preLinearFitPnt0)
-    # for idx, spike in enumerate(range(ba.numSpikes)):
+    #for idx, spike in enumerate(range(ba.numSpikes)):
     for idx, spike in enumerate(range(thisNumSpikes)):
-        # dx = preLinearFitSec1[idx] - preLinearFitSec0[idx]
-        # dy = preLinearFitVal1[idx] - preLinearFitVal0[idx]
+        #dx = preLinearFitSec1[idx] - preLinearFitSec0[idx]
+        #dy = preLinearFitVal1[idx] - preLinearFitVal0[idx]
 
         # always plot edd rate line at constant length
-        lineLengthSec = 0.1  # 8  # TODO: make this a function of spike frequency?
+        lineLengthSec = 0.1 #8  # TODO: make this a function of spike frequency?
 
         x.append(preLinearFitSec0[idx])
         x.append(preLinearFitSec1[idx] + lineLengthSec)
         x.append(np.nan)
 
         y.append(preLinearFitVal0[idx])
         y.append(preLinearFitVal1[idx] + lineLengthSec)
         y.append(np.nan)
 
-    # logger.info(f'{len(x)} {len(y)}')
+    #logger.info(f'{len(x)} {len(y)}')
 
     return x, y
 
-
 def getHalfWidthLines(t, v, spikeDictList):
     """Get x/y pair for plotting all half widths."""
     x = []
     y = []
 
-    # if len(t.shape)>1 or len(v.shape)>1:
+    #if len(t.shape)>1 or len(v.shape)>1:
     #    logger.error('EXPECTING 1D, EXPAND THIS TO 2D SWEEPS')
     #    print(t.shape, v.shape)
     #    return x, y
 
     if t.shape != v.shape:
-        logger.error(f"t:{t.shape} and v:{v.shape} are not the same length")
+        logger.error(f't:{t.shape} and v:{v.shape} are not the same length')
         return x, y
 
     is2D = len(t.shape) > 1
 
     numPerSpike = 3  # rise/fall/nan
-    # numSpikes = self.ba.numSpikes
+    #numSpikes = self.ba.numSpikes
     numSpikes = len(spikeDictList)
-    logger.info(f"numSpikes:{numSpikes}")
+    logger.info(f'numSpikes:{numSpikes}')
     xyIdx = 0
-    # for idx, spike in enumerate(self.ba.spikeDict):
-    # spikeDictionaries = self.ba.getSpikeDictionaries(sweepNumber=self.sweepNumber)
+    #for idx, spike in enumerate(self.ba.spikeDict):
+    #spikeDictionaries = self.ba.getSpikeDictionaries(sweepNumber=self.sweepNumber)
     for idx, spike in enumerate(spikeDictList):
-        sweep = spike["sweep"]
-        if idx == 0:
+        sweep = spike['sweep']
+        if idx ==0:
             # make x/y from first spike using halfHeights = [20,50,80,...]
-            halfHeights = spike[
-                "halfHeights"
-            ]  # will be same for all spike, like [20, 50, 80]
+            halfHeights = spike['halfHeights'] # will be same for all spike, like [20, 50, 80]
             numHalfHeights = len(halfHeights)
             # *numHalfHeights to account for rise/fall + padding nan
             x = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
             y = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
-            # print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
+            #print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
 
-        if "widths" not in spike.keys():
+        if 'widths' not in spike.keys():
             logger.error(f'=== Did not find "widths" key in spike {idx}')
 
-        for idx2, width in enumerate(spike["widths"]):
-            # halfHeight = width['halfHeight'] # [20,50,80]
-            risingPnt = width["risingPnt"]
-            # risingVal = width['risingVal']
-            fallingPnt = width["fallingPnt"]
-            # fallingVal = width['fallingVal']
+        for idx2, width in enumerate(spike['widths']):
+            #halfHeight = width['halfHeight'] # [20,50,80]
+            risingPnt = width['risingPnt']
+            #risingVal = width['risingVal']
+            fallingPnt = width['fallingPnt']
+            #fallingVal = width['fallingVal']
 
             if risingPnt is None or fallingPnt is None:
                 # half-height was not detected
                 continue
 
-            # risingSec = self.ba.pnt2Sec_(risingPnt)
-            # fallingSec = self.ba.pnt2Sec_(fallingPnt)
+            #risingSec = self.ba.pnt2Sec_(risingPnt)
+            #fallingSec = self.ba.pnt2Sec_(fallingPnt)
+
 
             # if v or t are 2D, we have multiple sweeps
             # one sweep per column
             if is2D:
-                risingVal = v[risingPnt, sweep]
-                fallingVal = v[fallingPnt, sweep]
-                risingSec = t[risingPnt, sweep]
-                fallingSec = t[fallingPnt, sweep]
+                risingVal = v[risingPnt,sweep]
+                fallingVal = v[fallingPnt,sweep]
+                risingSec = t[risingPnt,sweep]
+                fallingSec = t[fallingPnt,sweep]
             else:
                 risingVal = v[risingPnt]
                 fallingVal = v[fallingPnt]
                 risingSec = t[risingPnt]
                 fallingSec = t[fallingPnt]
 
-            # print(f'fallingVal:{fallingVal} {type(fallingVal)}')
+            #print(f'fallingVal:{fallingVal} {type(fallingVal)}')
 
             # x
             x[xyIdx] = risingSec
-            x[xyIdx + 1] = fallingSec
-            x[xyIdx + 2] = np.nan
+            x[xyIdx+1] = fallingSec
+            x[xyIdx+2] = np.nan
             # y
-            y[
-                xyIdx
-            ] = fallingVal  # risingVal, re-use fallingVal to make line horizontal
-            y[xyIdx + 1] = fallingVal
-            y[xyIdx + 2] = np.nan
+            y[xyIdx] = fallingVal  #risingVal, re-use fallingVal to make line horizontal
+            y[xyIdx+1] = fallingVal
+            y[xyIdx+2] = np.nan
 
             # each spike has 3x pnts: rise/fall/nan
             xyIdx += numPerSpike  # accounts for rising/falling/nan
         # end for width
     # end for spike
 
-    """
+    '''
     print(f't:{len(t)} {type(t)} {t.shape}')
     print(f'v:{len(v)} {type(v)} {v.shape}')
     print(f'x:{len(x)} {type(x)} {x[0:10]}')
     print(f'y:{len(y)} {type(y)} {y[0:10]}')
-    """
+    '''
     #
     return x, y
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bAbfText.py` & `sanpy-ephys-0.1.6/sanpy/bAbfText.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,23 +2,20 @@
 
 import os, sys
 import numpy as np
 
 import tifffile
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class bAbfText:
     """
     mimic a pyabf file to load from a text file
     """
-
     def __init__(self, path=None, theDict=None):
         """
         path is either:
             path to .csv file with columns (time (seconds), vm)
             path to .tif file
 
         theDict:
@@ -31,112 +28,112 @@
         self.sweepX = None
         self.sweepY = None
         self.dataRate = None
         self.dataPointsPerMs = None
         self.sweepList = [0]
 
         self.tif = None
-        self.tifNorm = None  # not used
+        self.tifNorm = None # not used
         self.tifHeader = None
 
         if theDict is not None:
-            logger.info("bAbfText() from dict")
-            self.sweepX = theDict["sweepX"]
-            self.sweepY = theDict["sweepY"]
-        elif path.endswith(".tif"):
-            self.sweepX, self.sweepY, self.tif, self.tifNorm = self._abfFromLineScanTif(
-                path
-            )
-            # self.tifHeader = self._loadLineScanHeader(path)
+            logger.info('bAbfText() from dict')
+            self.sweepX = theDict['sweepX']
+            self.sweepY = theDict['sweepY']
+        elif path.endswith('.tif'):
+            self.sweepX, self.sweepY, self.tif, self.tifNorm = \
+                                self._abfFromLineScanTif(path)
+            #self.tifHeader = self._loadLineScanHeader(path)
 
-            # logger.info(f'tif params: {np.min(self.tif)} {np.max(self.tif)} {self.tif.shape} {self.tif.dtype}')
+            #logger.info(f'tif params: {np.min(self.tif)} {np.max(self.tif)} {self.tif.shape} {self.tif.dtype}')
         else:
-            logger.info("bAbfText() from path: {path}")
+            logger.info('bAbfText() from path: {path}')
             if not os.path.isfile(path):
-                logger.error("Did not find file: {path}")
+                logger.error('Did not find file: {path}')
                 return
 
-            tmpNumPy = np.loadtxt(path, skiprows=1, delimiter=",")
-            self.sweepX = tmpNumPy[:, 0]
-            self.sweepY = tmpNumPy[:, 1]
+            tmpNumPy = np.loadtxt(path, skiprows=1, delimiter=',')
+            self.sweepX = tmpNumPy[:,0]
+            self.sweepY = tmpNumPy[:,1]
 
         #
         # linescan is like
         # 'secondsPerLine': 0.0042494285714285715,
         # 1 / secondsPerLine = 235.32
         # 20220926, if this is '1' second, detection will fail
         #  because self.dataPointsPerMs goes to 0
         secondsPerSample = self.sweepX[1] - self.sweepX[0]
         samplesPerSecond = 1 / secondsPerSample
-        self.dataRate = samplesPerSecond  # 235 #10000 # samples per second
+        self.dataRate = samplesPerSecond #235 #10000 # samples per second
 
         # todo: calculat from dataRate
         secondsPerSample = 1 / samplesPerSecond
         msPerSample = secondsPerSample * 1000
         samplesPerMs = 1 / msPerSample
-        self.dataPointsPerMs = samplesPerMs  # 4.255 #1/235*1000,10 # 10 kHz
+        self.dataPointsPerMs = samplesPerMs #4.255 #1/235*1000,10 # 10 kHz
 
-        self.sweepUnitsX = "todo: fix"
-        self.sweepUnitsY = "todo: fix"
+        self.sweepUnitsX = 'todo: fix'
+        self.sweepUnitsY = 'todo: fix'
 
-        # self.myRectRoi = None
+        #self.myRectRoi = None
         self.myRectRoiBackground = None
-        # self.minLineScan = None
+        #self.minLineScan = None
 
         # done in _abfFromLineScanTif
         # defaultRect = self.defaultTifRoi_background()  # for kymograph
         # self.updateTifRoi_background(defaultRect)
 
         # defaultRect = self.defaultTifRoi()  # for kymograph
         # self.updateTifRoi(defaultRect)
 
         #
         # print results
-        """
+        '''
         if self.tifHeader is not None:
             for k,v in self.tifHeader.items():
                 print('  ', k, ':', v)
 
         print('  ', 'bAbfText secondsPerSample:', secondsPerSample, 'seconds/sample')
         print('  ', 'bAbfText self.dataRate:', self.dataRate, 'samples/second')
         print('  ', 'bAbfText self.dataPointsPerMs:', self.dataPointsPerMs)
-        """
+        '''
 
     def defaultTifRoi_background(self):
         """
         Default ROI for kymograph background
 
         - height/width about 5 pixels
         - position near the end of the line
         """
         widthTif = self.tif.shape[1]
         heightTif = self.tif.shape[0]
         insetPixels = 10  # from end of line (top)
         roiWidthHeight = 5
-        # tifHeightPercent = self.tif.shape[0] * 0.15
+        #tifHeightPercent = self.tif.shape[0] * 0.15
 
-        left = int(widthTif / 2)
+        left = int(widthTif/2)
         top = heightTif - insetPixels
         right = left + roiWidthHeight - 1
         bottom = top - roiWidthHeight + 1
 
         return [left, top, right, bottom]
 
     def resetRoi(self):
-        """reset the kymograph roi to default"""
+        """reset the kymograph roi to default
+        """
         defaultRect = self.defaultTifRoi()
         self.updateTifRoi(defaultRect)
         return defaultRect
 
     def defaultTifRoi(self):
         """
         A default rectangular ROI for main kymograph analysis.
 
         TODO: Remove hard coding of 0.15 percent of height
-
+        
         Return:
             list: [left, top, right, bottom]
         """
         xRoiPos = 0  # startSeconds
         yRoiPos = 0  # pixels
         widthRoi = self.tif.shape[1]
         heightRoi = self.tif.shape[0]
@@ -201,32 +198,30 @@
         tif = self.tif
 
         left = 0  # startSec
         top = tif.shape[0]
         right = tif.shape[1]  # stopSec
         bottom = 0
         if theRect is not None:
-            # left = theRect[0]
+            #left = theRect[0]
             top = theRect[1]
-            # right = theRect[2]
+            #right = theRect[2]
             bottom = theRect[3]
 
         # number of pixels in subset of line scan
         numPixels = top - bottom + 1
 
-        # theBackground = self.updateTifRoi_background()
+        #theBackground = self.updateTifRoi_background()
 
         # logger.warning(f'I turned off background subtract .. placement of background is sometimes bad')
 
-        _secondsPerLine = self.tifHeader["secondsPerLine"]
+        _secondsPerLine = self.tifHeader['secondsPerLine']
         if _secondsPerLine is None:
             _secondsPerLine = 0.001  # so we get 1 pnt per ms
-            logger.warning(
-                f"No header, secondsPerLine is None. Using fake _secondsPerLine:{_secondsPerLine}"
-            )
+            logger.warning(f'No header, secondsPerLine is None. Using fake _secondsPerLine:{_secondsPerLine}')
 
         # retains shape of entire tif
         yLineScanSum = [np.nan] * tif.shape[1]
         xLineScanSum = [np.nan] * tif.shape[1]
         for i in range(tif.shape[1]):
             # sum each column and background subtract
 
@@ -236,220 +231,218 @@
             #     # no units on kymograph
             #     _fakeSecondsPerLine = 0.001
             #     #logger.error(f'No header, secondsPerLine is None. Using _fakeSecondsPerLine:{_fakeSecondsPerLine}')
             #     xLineScanSum[i] = firstFrameSeconds + (_fakeSecondsPerLine * i)
             # else:
             #     xLineScanSum[i] = firstFrameSeconds + (self.tifHeader['secondsPerLine'] * i)
 
-            if i < left or i > right:
+            if i<left or i>right:
                 continue
 
             # each line scan
             theSum = np.sum(tif[bottom:top, i])
 
             # background subtract
-            # print(f'   === theSum:{theSum} {type(theSum)} theBackground:{theBackground} {type(theBackground)}')
-            # if not isinstance(theSum, np.uint64) or not isinstance(theBackground, np.uint64):
+            #print(f'   === theSum:{theSum} {type(theSum)} theBackground:{theBackground} {type(theBackground)}')
+            #if not isinstance(theSum, np.uint64) or not isinstance(theBackground, np.uint64):
             #    print(f'   === theSum:{theSum} {type(theSum)} theBackground:{theBackground} {type(theBackground)}')
 
-            # logger.warning(f'I turned off background subtract .. placement of background is sometimes bad')
-            # theSum -= theBackground
+            #logger.warning(f'I turned off background subtract .. placement of background is sometimes bad')
+            #theSum -= theBackground
 
-            # sys.exit(1)
+            #sys.exit(1)
 
             # f / f_0
             theSum /= numPixels  # tif.shape[0] # norm to number of pixels in line
             yLineScanSum[i] = theSum
 
         xLineScanSum = np.asarray(xLineScanSum)
         yLineScanSum = np.asarray(yLineScanSum)
 
         # derive simplified f/f0 by dividing by min
         self.minLineScan = np.nanmin(yLineScanSum)
-
+        
         # 20221003, do not do this, ysweep will be sum/pnts
         # yLineScanSum /= self.minLineScan
 
-        logger.info("updating sweepX and sweepY with new rect ROI")
+        logger.info('updating sweepX and sweepY with new rect ROI')
         self.sweepX = xLineScanSum
         self.sweepY = yLineScanSum
 
     def setSweep(self, sweep):
         pass
 
     def _abfFromLineScanTif(self, path, theRect=None):
         """
 
         Returns:
             xLineScanSum (np.ndarray) e.g. sweepX
             yLineScanSum (np.ndarray) e.g. sweepY
         """
         if not os.path.isfile(path):
-            logger.error(f"Did not find file: {path}")
+            logger.error(f'Did not find file: {path}')
             return None, None, None, None
 
         tif = tifffile.imread(path)
-        logger.info(f"Loaded tif with shape: {tif.shape}")
-
+        logger.info(f'Loaded tif with shape: {tif.shape}')
+        
         if len(tif.shape) == 3:
-            tif = tif[:, :, 1]  # assuming image channel is 1
-
+            tif = tif[:,:,1] # assuming image channel is 1
+        
         # we want our tiffs to be short and wide
         # shape[0] is space, shape[1] is time
         if tif.shape[0] < tif.shape[1]:
             # correct shape
             pass
         else:
-            tif = np.rot90(tif)  # rotates 90 degrees counter-clockwise
+            tif = np.rot90(tif) # rotates 90 degrees counter-clockwise
 
         f0 = tif.mean()
         tifNorm = (tif - f0) / f0
 
         self.tif = tif
 
         # assuming this was exported using Olympus software
         # which gives us a .txt file
         self.tifHeader = self._loadLineScanHeader(path)
-        # self.tifHeader['shape'] = tif.shape
-        # self.tifHeader['secondsPerLine'] = \
+        #self.tifHeader['shape'] = tif.shape
+        #self.tifHeader['secondsPerLine'] = \
         #                self.tifHeader['totalSeconds'] / self.tifHeader['shape'][1]
-        # tifHeader['abfPath'] = abfFile
+        #tifHeader['abfPath'] = abfFile
 
         # updateTifRoi sets sweepX and seepY
         defaultRect = self.defaultTifRoi()
         self.updateTifRoi(defaultRect)
 
         firstFrameSeconds = 0
 
         #
         # sum the inensities of each image line scan
-        # print('tif.shape:', tif.shape) # like (146, 10000)
-        """
+        #print('tif.shape:', tif.shape) # like (146, 10000)
+        '''
         yLineScanSum = [np.nan] * tif.shape[1]
         xLineScanSum = [np.nan] * tif.shape[1]
         for i in range(tif.shape[1]):
             theSum = np.sum(tif[:,i])
             theSum /= tif.shape[0] # norm to number of pixels in line
             yLineScanSum[i] = theSum
             xLineScanSum[i] = firstFrameSeconds + (self.tifHeader['secondsPerLine'] * i)
 
         xLineScanSum = np.asarray(xLineScanSum)
         yLineScanSum = np.asarray(yLineScanSum)
-        """
+        '''
 
         # normalize to 0..1
         # 20220114, was this
         # yLineScanSum = self._NormalizeData(yLineScanSum)
 
-        # print('bAbfText xLineScanSum:', xLineScanSum.shape)
-        # print('bAbfText yLineScanSum:', yLineScanSum.shape)
-
+        #print('bAbfText xLineScanSum:', xLineScanSum.shape)
+        #print('bAbfText yLineScanSum:', yLineScanSum.shape)
+        
         return self.sweepX, self.sweepY, tif, tifNorm
 
     def _loadLineScanHeader(self, path):
         """Load scale from .txt file saved by olympus export.
 
         Args:
             path: full path to tif
 
         returns dict:
             numPixels:
             umLength:
             umPerPixel:
             totalSeconds:
         """
-
         def _defaultHeader():
             defaultHeader = {
-                "tif": path,
-                "numLines": self.tif.shape[1],
-                "totalSeconds": None,
-                "shape": self.tif.shape,
-                "secondsPerLine": 0.001,
+                'tif': path,
+                'numLines': self.tif.shape[1],
+                'totalSeconds': None,
+                'shape': self.tif.shape,
+                'secondsPerLine': 0.001,
                 #'linesPerSecond': None,  # 1/secondsPerLine
-                "numPixels": self.tif.shape[0],
-                "umLength": None,
-                "umPerPixel": 1,
+
+                'numPixels': self.tif.shape[0],
+                'umLength': None,
+                'umPerPixel': 1,
             }
             return defaultHeader
-
+        
         # "X Dimension"    "138, 0.0 - 57.176 [um], 0.414 [um/pixel]"
         # "T Dimension"    "1, 0.000 - 35.496 [s], Interval FreeRun"
         # "Image Size(Unit Converted)"    "57.176 [um] * 35500.000 [ms]"
-        txtFile = os.path.splitext(path)[0] + ".txt"
+        txtFile = os.path.splitext(path)[0] + '.txt'
 
         theRet = _defaultHeader()
-        # theRet = {'tif': path}
-        # theRet['numLines'] = self.tif.shape[1]
+        #theRet = {'tif': path}
+        #theRet['numLines'] = self.tif.shape[1]
 
         if not os.path.isfile(txtFile):
-            logger.warning(f"Did not find file: {txtFile}")
-            logger.warning(f"  The Kymograph will have no scale.")
+            logger.warning(f'Did not find file: {txtFile}')
+            logger.warning(f'  The Kymograph will have no scale.')
             return theRet
 
         # to open export .txt file for Olympus FV3000
-        with open(txtFile, "r") as fp:
+        with open(txtFile, 'r') as fp:
             lines = fp.readlines()
             for line in lines:
                 line = line.strip()
                 if line.startswith('"X Dimension"'):
                     line = line.replace('"', "")
-                    line = line.replace(",", "")
-                    # print('loadLineScanHeader:', line)
+                    line = line.replace(',', "")
+                    #print('loadLineScanHeader:', line)
                     # 2 number of pixels in line
                     # 5 um length of line
                     # 7 um/pixel
                     splitLine = line.split()
                     for idx, split in enumerate(splitLine):
-                        # print('  ', idx, split)
+                        #print('  ', idx, split)
                         if idx == 2:
                             numPixels = int(split)
-                            theRet["numPixels"] = numPixels
+                            theRet['numPixels'] = numPixels
                         elif idx == 5:
                             umLength = float(split)
-                            theRet["umLength"] = umLength
+                            theRet['umLength'] = umLength
                         elif idx == 7:
                             umPerPixel = float(split)
-                            theRet["umPerPixel"] = umPerPixel
+                            theRet['umPerPixel'] = umPerPixel
 
                 elif line.startswith('"T Dimension"'):
                     line = line.replace('"', "")
-                    line = line.replace(",", "")
-                    # print('loadLineScanHeader:', line)
+                    line = line.replace(',', "")
+                    #print('loadLineScanHeader:', line)
                     # 5 total duration of image acquisition (seconds)
                     splitLine = line.split()
                     for idx, split in enumerate(splitLine):
-                        # print('  ', idx, split)
+                        #print('  ', idx, split)
                         if idx == 5:
                             totalSeconds = float(split)
-                            theRet["totalSeconds"] = totalSeconds
+                            theRet['totalSeconds'] = totalSeconds
 
-                            # theRet['secondsPerLine'] =
+                            #theRet['secondsPerLine'] =
 
-                # elif line.startswith('"Image Size(Unit Converted)"'):
+                #elif line.startswith('"Image Size(Unit Converted)"'):
                 #    print('loadLineScanHeader:', line)
 
-        # theRet['shape'] = self.tif.shape
-        theRet["secondsPerLine"] = theRet["totalSeconds"] / theRet["shape"][1]
-        # theRet['linesPerSecond'] = 1 / theRet['secondsPerLine']
+        #theRet['shape'] = self.tif.shape
+        theRet['secondsPerLine'] = theRet['totalSeconds'] / theRet['shape'][1]
+        #theRet['linesPerSecond'] = 1 / theRet['secondsPerLine']
         #
         return theRet
 
     def _NormalizeData(self, data):
         """
         normalize to [0..1]
         """
         return (data - np.min(data)) / (np.max(data) - np.min(data))
 
-
 def test_load_tif():
-    path = "/Users/cudmore/data/dual-lcr/20210115/data/20210115__0001.tif"
+    path = '/Users/cudmore/data/dual-lcr/20210115/data/20210115__0001.tif'
     abf = bAbfText(path=path)
 
     import matplotlib.pyplot as plt
-
     plt.plot(abf.sweepX, abf.sweepY)
     plt.show()
 
+if __name__ == '__main__':
 
-if __name__ == "__main__":
     test_load_tif()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bAnalysisResults.py` & `sanpy-ephys-0.1.6/sanpy/bAnalysisResults.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,760 +1,709 @@
+"""
+Dec 2022, NOT USED BY ANY OTHER CODE ?
+
+Utilities to define analysis results.
+
+These are keys in bAnalysis_ spike dict and columns in output reports
+"""
+
 import json
 import os
 from typing import Dict, List, Tuple
 
 import numpy as np  # needed to convert np types to JSON types in save
 import pandas as pd
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-defaultVal = float("nan")
+defaultVal = float('nan')
 
 # each key in analysisResultDict needs to have the same dict
 def getDefaultDict():
     defaultDict = {
-        "type": "",  # like: int, float, boolean, list
-        "default": "",  # default value, can be 0, None, NaN, ...
-        "units": "",  # real world units like point, mV, dvdt
-        "depends on detection": "",  # organize documentation and refer to bDetect keys
-        "error": "",  # if this analysis results can trigger an error
-        "description": "",  # long description for documentation
-    }
+        'type': '',  # like: int, float, boolean, list
+        'default': '',  # default value, can be 0, None, NaN, ...
+        'units': '',  # real world units like point, mV, dvdt
+        'depends on detection': '',  # organize documentation and refer to bDetect keys
+        'error': '',  # if this analysis results can trigger an error
+        'description': '',  # long description for documentation
+        }
     return defaultDict.copy()
 
 analysisResultDict = {}
 
-key = "spikeNumber"
+key = 'analysisDate'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Date of analysis in yyyymmdd format.'
+
+key = 'analysisTime'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Time of analysis in hh:mm:ss 24 hours format.'
+
+key = 'modDate'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Modification date if AP is modified after detection.'
+
+key = 'modTime'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Modification time if AP is modified after detection.'
+
+key = 'analysisVersion'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Analysis version when analysis was run. See sanpy.analysisVersion'
+
+key = 'interfaceVersion'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Interface version string when analysis was run. See sanpy.interfaceVersion'
+
+key = 'file'
 analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = None  # todo: not sure
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Spike number across all sweeps. Zero based."
-
-key = "include"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "bool"
-analysisResultDict[key]["default"] = True
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Boolean indication include or not. Can be set by user/programmatically  after analysis."
-
-key = "detectionType"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = ""
-analysisResultDict[key]["default"] = None
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Type of detection, either vm or dvdt. See enum sanpy.bDetection.detectionTypes"
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Name of raw data file analyzed'
+
+key = 'detectionType'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = ''
+analysisResultDict[key]['default'] = None
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Type of detection, either vm or dvdt. See enum sanpy.bDetection.detectionTypes'
+
+key = 'cellType'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'User specified cell type'
+
+key = 'sex'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'User specified sex'
+
+key = 'condition'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'str'
+analysisResultDict[key]['default'] = ''
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'User specified condition'
 
 #
 # start real analysis results
-key = "sweep"
+key = 'sweep'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = 0  # todo: not sure
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Sweep number of analyzed sweep. Zero based.'
+
+key = 'epoch'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = np.nan  # todo: not sure
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Stimulus epoch number the spike occured in. Zero based.'
+
+key = 'epochLevel'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = np.nan  # todo: not sure
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Epoch level (DAC) stimulus during the spike.'
+
+key = 'sweepSpikeNumber'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = None  # todo: not sure
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Spike number within the sweep. Zero based.'
+
+key = 'spikeNumber'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = None  # todo: not sure
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Spike number across all sweeps. Zero based.'
+
+key = 'include'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'bool'
+analysisResultDict[key]['default'] = True
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Boolean indication include or not. Can be set by user/programmatically  after analysis.'
+
+key = 'userType'
 analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = 0  # todo: not sure
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Sweep number of analyzed sweep. Zero based."
-
-key = "epoch"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = np.nan  # todo: not sure
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Stimulus epoch number the spike occured in. Zero based."
-
-key = "epochLevel"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = np.nan  # todo: not sure
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Epoch level (DAC) stimulus during the spike."
-
-key = "sweepSpikeNumber"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = None  # todo: not sure
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Spike number within the sweep. Zero based."
-
-key = "userType"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = 0
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Integer indication user type. Can be set by user/programmatically  after analysis."
-
-key = "errors"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "list"
-analysisResultDict[key]["default"] = []
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "List of dictionary to hold detection errors for this spike"
-
-key = "analysisDate"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Date of analysis in yyyymmdd format."
-
-key = "analysisTime"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Time of analysis in hh:mm:ss 24 hours format."
-
-key = "modDate"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Modification date if AP is modified after detection."
-
-key = "modTime"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Modification time if AP is modified after detection."
-
-key = "analysisVersion"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Analysis version when analysis was run. See sanpy.analysisVersion"
-
-key = "interfaceVersion"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "Interface version string when analysis was run. See sanpy.interfaceVersion"
-
-key = "file"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Name of raw data file analyzed"
-
-key = "cellType"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "User specified cell type"
-
-key = "sex"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "User specified sex"
-
-key = "condition"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "str"
-analysisResultDict[key]["default"] = ""
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "User specified condition"
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = 0
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Integer indication user type. Can be set by user/programmatically  after analysis.'
+
+
+key = 'errors'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'list'
+analysisResultDict[key]['default'] = []
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'List of dictionary to hold detection errors for this spike'
 
 #
 # detection parameters
-key = "dvdtThreshold"
+key = 'dvdtThreshold'
 analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "dvdt"
-analysisResultDict[key]["depends on detection"] = "dvdtThreshold"
-analysisResultDict[key]["description"] = "AP Threshold in derivative dv/dt"
-
-key = "mvThreshold"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"
-analysisResultDict[key]["depends on detection"] = "mvThreshold"
-analysisResultDict[key]["description"] = "AP Threshold in primary recording mV"
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'dvdt'
+analysisResultDict[key]['depends on detection'] = 'dvdtThreshold'
+analysisResultDict[key]['description'] = 'AP Threshold in derivative dv/dt'
+
+key = 'mvThreshold'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'
+analysisResultDict[key]['depends on detection'] = 'mvThreshold'
+analysisResultDict[key]['description'] = 'AP Threshold in primary recording mV'
 
 # todo: what about solay ...
-key = "medianFilter"
+key = 'medianFilter'
 analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = 0
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["depends on detection"] = "medianFilter"
-analysisResultDict[key][
-    "description"
-] = "Median filter to generate filtered vm and dvdt. Value 0 indicates no filter."
-
-key = "halfHeights"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "list"
-analysisResultDict[key]["default"] = []
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["depends on detection"] = "halfHeights"
-analysisResultDict[key][
-    "description"
-] = "List of int to specify half-heights like [10, 20, 50, 80, 90]."
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = 0
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['depends on detection'] = 'medianFilter'
+analysisResultDict[key]['description'] = 'Median filter to generate filtered vm and dvdt. Value 0 indicates no filter.'
+
+key = 'halfHeights'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'list'
+analysisResultDict[key]['default'] = []
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['depends on detection'] = 'halfHeights'
+analysisResultDict[key]['description'] = 'List of int to specify half-heights like [10, 20, 50, 80, 90].'
 
 #
 # actual value coming out of detection !!!!
-key = "thresholdPnt"
+key = 'thresholdPnt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['description'] = 'AP threshold point'
+
+key = 'thresholdSec'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'sec'
+analysisResultDict[key]['description'] = 'AP threshold seconds'
+
+key = 'thresholdVal'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'  # TODO: will be pA for voltage-clamp
+analysisResultDict[key]['description'] = 'Value of Vm at AP threshold point.'
+
+key = 'thresholdVal_dvdt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'dvdt'  # TODO: will be pA for voltage-clamp
+analysisResultDict[key]['description'] = 'Value of dvdt at AP threshold point.'
+
+key = 'dacCommand'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'  # TODO: will be pA for voltage-clamp
+analysisResultDict[key]['description'] = 'Value of DAC command at AP threshold point.'
+
+key = 'peakPnt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['depends on detection'] = '(onlyPeaksAbove_mV, peakWindow_ms)'
+analysisResultDict[key]['description'] = 'AP peak point.'
+
+key = 'peakSec'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'sec'
+analysisResultDict[key]['description'] = 'AP peak seconds.'
+
+key = 'peakVal'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV' # voltage-clamp'
+analysisResultDict[key]['description'] = 'Value of Vm at AP peak point.'
+
+key = 'peakHeight'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'  # voltage-clamp
+analysisResultDict[key]['description'] = 'Difference between peakVal minus thresholdVal.'
+
+key = 'timeToPeak_ms'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'ms' # voltage-clamp'
+analysisResultDict[key]['description'] = 'Time to peak (ms) after TOP.'
+
+key = 'preMinPnt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'  # voltage-clamp
+analysisResultDict[key]['depends on detection'] = 'mdp_ms'
+analysisResultDict[key]['description'] = 'Minimum before an AP taken from predefined window.'
+
+key = 'preMinVal'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'  # voltage-clamp
+analysisResultDict[key]['description'] = 'Minimum before an AP taken from predefined window.'
+
+key = 'preLinearFitPnt0'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'  # voltage-clamp
+analysisResultDict[key]['description'] = 'Point where pre linear fit starts. Used for EDD Rate'
+
+key = 'preLinearFitPnt1'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'  # voltage-clamp
+analysisResultDict[key]['description'] = 'Point where pre linear fit stops. Used for EDD Rate'
+
+key = 'earlyDiastolicDuration_ms'
 analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key]["description"] = "AP threshold point"
-
-key = "thresholdSec"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "sec"
-analysisResultDict[key]["description"] = "AP threshold seconds"
-
-key = "thresholdVal"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"  # TODO: will be pA for voltage-clamp
-analysisResultDict[key]["description"] = "Value of Vm at AP threshold point."
-
-key = "thresholdVal_dvdt"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "dvdt"  # TODO: will be pA for voltage-clamp
-analysisResultDict[key]["description"] = "Value of dvdt at AP threshold point."
-
-key = "dacCommand"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"  # TODO: will be pA for voltage-clamp
-analysisResultDict[key]["description"] = "Value of DAC command at AP threshold point."
-
-key = "peakPnt"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key]["depends on detection"] = "(onlyPeaksAbove_mV, peakWindow_ms)"
-analysisResultDict[key]["description"] = "AP peak point."
-
-key = "peakSec"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "sec"
-analysisResultDict[key]["description"] = "AP peak seconds."
-
-key = "peakVal"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"  # voltage-clamp'
-analysisResultDict[key]["description"] = "Value of Vm at AP peak point."
-
-key = "peakHeight"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"  # voltage-clamp
-analysisResultDict[key][
-    "description"
-] = "Difference between peakVal minus thresholdVal."
-
-key = "timeToPeak_ms"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "ms"  # voltage-clamp'
-analysisResultDict[key]["description"] = "Time to peak (ms) after TOP."
-
-key = "preMinPnt"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"  # voltage-clamp
-analysisResultDict[key]["depends on detection"] = "mdp_ms"
-analysisResultDict[key][
-    "description"
-] = "Minimum before an AP taken from predefined window."
-
-key = "preMinVal"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"  # voltage-clamp
-analysisResultDict[key][
-    "description"
-] = "Minimum before an AP taken from predefined window."
-
-key = "preLinearFitPnt0"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"  # voltage-clamp
-analysisResultDict[key][
-    "description"
-] = "Point where pre linear fit starts. Used for EDD Rate"
-
-key = "preLinearFitPnt1"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"  # voltage-clamp
-analysisResultDict[key][
-    "description"
-] = "Point where pre linear fit stops. Used for EDD Rate"
-
-key = "earlyDiastolicDuration_ms"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "ms"  # voltage-clamp
-analysisResultDict[key]["description"] = "Time (ms) between start/stop of EDD."
-
-key = "preLinearFitVal0"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mv"  # voltage-clamp
-analysisResultDict[key]["description"] = ""
-
-key = "preLinearFitVal1"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mv"
-analysisResultDict[key]["description"] = ""
-
-key = "earlyDiastolicDurationRate"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mv/S"
-analysisResultDict[key][
-    "description"
-] = "Early diastolic duration rate, the slope of the linear fit between start/stop of EDD."
-
-key = "lateDiastolicDuration"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key]["description"] = "Depreciated"
-
-key = "preSpike_dvdt_max_pnt"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key][
-    "description"
-] = "Point corresponding to peak in dv/dt before an AP."
-
-key = "preSpike_dvdt_max_val"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"
-analysisResultDict[key]["description"] = "Value of Vm at peak of dv/dt before an AP."
-
-key = "preSpike_dvdt_max_val2"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "dv/dt"
-analysisResultDict[key]["description"] = "Value of dv/dt at peak of dv/dt before an AP."
-
-key = "postSpike_dvdt_min_pnt"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key]["depends on detection"] = "dvdtPostWindow_ms"
-analysisResultDict[key][
-    "description"
-] = "Point corresponding to min in dv/dt after an AP."
-
-key = "postSpike_dvdt_min_val"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "mV"
-analysisResultDict[key]["description"] = "Value of Vm at minimum of dv/dt after an AP."
-
-key = "postSpike_dvdt_min_val2"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "dvdt"
-analysisResultDict[key][
-    "description"
-] = "Value of dv/dt at minimum of dv/dt after an AP."
-
-key = "isi_pnts"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key]["depends on detection"] = "refractory_ms"
-analysisResultDict[key][
-    "description"
-] = "Inter-Spike-Interval (points) with respect to previous AP."
-
-key = "isi_ms"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "ms"
-analysisResultDict[key][
-    "description"
-] = "Inter-Spike-Interval (ms) with respect to previous AP."
-
-key = "spikeFreq_hz"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "Hz"
-analysisResultDict[key]["description"] = "AP frequency with respect to previous AP."
-
-key = "cycleLength_pnts"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key][
-    "description"
-] = "Points between APs with respect to previous AP."
-
-key = "cycleLength_ms"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "int"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "point"
-analysisResultDict[key][
-    "description"
-] = "Time (ms) between APs with respect to previous AP."
-
-key = "diastolicDuration_ms"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "float"
-analysisResultDict[key]["default"] = defaultVal
-analysisResultDict[key]["units"] = "ms"
-analysisResultDict[key][
-    "description"
-] = "Time (ms) between minimum before AP (preMinPnt) and AP time (thresholdPnt)."
-
-key = "widths"
-analysisResultDict[key] = getDefaultDict()
-analysisResultDict[key]["type"] = "list"
-analysisResultDict[key]["default"] = []
-analysisResultDict[key]["units"] = ""
-analysisResultDict[key][
-    "description"
-] = "A list of dict to hold half-height information for each half-height in detection halfHeights."
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'ms'  # voltage-clamp
+analysisResultDict[key]['description'] = 'Time (ms) between start/stop of EDD.'
+
+key = 'preLinearFitVal0'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mv'  # voltage-clamp
+analysisResultDict[key]['description'] = ''
+
+key = 'preLinearFitVal1'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mv'
+analysisResultDict[key]['description'] = ''
+
+key = 'earlyDiastolicDurationRate'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mv/S'
+analysisResultDict[key]['description'] = 'Early diastolic duration rate, the slope of the linear fit between start/stop of EDD.'
+
+key = 'lateDiastolicDuration'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'Depreciated'
+
+key = 'preSpike_dvdt_max_pnt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['description'] = 'Point corresponding to peak in dv/dt before an AP.'
+
+key = 'preSpike_dvdt_max_val'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'
+analysisResultDict[key]['description'] = 'Value of Vm at peak of dv/dt before an AP.'
+
+key = 'preSpike_dvdt_max_val2'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'dv/dt'
+analysisResultDict[key]['description'] = 'Value of dv/dt at peak of dv/dt before an AP.'
+
+key = 'postSpike_dvdt_min_pnt'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['depends on detection'] = 'dvdtPostWindow_ms'
+analysisResultDict[key]['description'] = 'Point corresponding to min in dv/dt after an AP.'
+
+key = 'postSpike_dvdt_min_val'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'mV'
+analysisResultDict[key]['description'] = 'Value of Vm at minimum of dv/dt after an AP.'
+
+key = 'postSpike_dvdt_min_val2'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'dvdt'
+analysisResultDict[key]['description'] = 'Value of dv/dt at minimum of dv/dt after an AP.'
+
+key = 'isi_pnts'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['depends on detection'] = 'refractory_ms'
+analysisResultDict[key]['description'] = 'Inter-Spike-Interval (points) with respect to previous AP.'
+
+key = 'isi_ms'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'ms'
+analysisResultDict[key]['description'] = 'Inter-Spike-Interval (ms) with respect to previous AP.'
+
+key = 'spikeFreq_hz'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'Hz'
+analysisResultDict[key]['description'] = 'AP frequency with respect to previous AP.'
+
+key = 'cycleLength_pnts'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['description'] = 'Points between APs with respect to previous AP.'
+
+key = 'cycleLength_ms'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'int'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'point'
+analysisResultDict[key]['description'] = 'Time (ms) between APs with respect to previous AP.'
+
+key = 'diastolicDuration_ms'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'float'
+analysisResultDict[key]['default'] = defaultVal
+analysisResultDict[key]['units'] = 'ms'
+analysisResultDict[key]['description'] = 'Time (ms) between minimum before AP (preMinPnt) and AP time (thresholdPnt).'
+
+key = 'widths'
+analysisResultDict[key] = getDefaultDict()
+analysisResultDict[key]['type'] = 'list'
+analysisResultDict[key]['default'] = []
+analysisResultDict[key]['units'] = ''
+analysisResultDict[key]['description'] = 'A list of dict to hold half-height information for each half-height in detection halfHeights.'
 
 # need to define keys width_<i> from halfHeights list [10, 20, 50, 80, 90]
 for i in [10, 20, 50, 80, 90]:
-    key = "widths_" + str(i)
+    key = 'widths_' + str(i)
     analysisResultDict[key] = getDefaultDict()
-    analysisResultDict[key]["type"] = "int"
-    analysisResultDict[key]["default"] = defaultVal
-    analysisResultDict[key]["units"] = "percent"
-    analysisResultDict[key]["depends on detection"] = "halfWidthWindow_ms"
-    analysisResultDict[key]["description"] = f"Width (ms) at half-height {i} %."
+    analysisResultDict[key]['type'] = 'int'
+    analysisResultDict[key]['default'] = defaultVal
+    analysisResultDict[key]['units'] = 'percent'
+    analysisResultDict[key]['depends on detection'] = 'halfWidthWindow_ms'
+    analysisResultDict[key]['description'] = f'Width (ms) at half-height {i} %.'
 
 # now we have (AP threshold, AP peak), derive stats about each AP
 
-
 def printDocs():
     """
     Print out human readable detection parameters and convert to markdown table.
 
     Requires:
         pip install tabulate
 
     See: bDetection.printDocs()
     """
     import pandas as pd
     from datetime import datetime
 
-    logger.info("Ensure there are no errors")
+    logger.info('Ensure there are no errors')
 
     dictList = []
     for k, v in analysisResultDict.items():
         # iterating on getDefaultDict() to ensure all code above has valid k/v pairs
-        # lineStr = k + '\t'
+        #lineStr = k + '\t'
         oneDict = {
-            "Name": k,
+            'Name': k,
         }
         for k2 in getDefaultDict().keys():
-            # print(f'  {k}: {k2}: {v[k2]}')
-            # lineStr += f'{v[k2]}' + '\t'
+            #print(f'  {k}: {k2}: {v[k2]}')
+            #lineStr += f'{v[k2]}' + '\t'
             oneDict[k2] = v[k2]
         #
-        # print(lineStr)
+        #print(lineStr)
 
         dictList.append(oneDict)
 
         # check that k is in headerDefaultDict
         for k3 in v:
             if not k3 in getDefaultDict().keys():
                 logger.error(f'Found extra key "{k}" in "analysisResultDict"')
 
     #
     df = pd.DataFrame(dictList)
-
+    
     if 1:
         # to markdown for mkdocs md file
-        # str = df.to_markdown()
+        #str = df.to_markdown()
         str = df.to_html()
-        myDate = datetime.today().strftime("%Y-%m-%d")
-        print(f"Generated {myDate} with sanpy.analysisVersion {sanpy.analysisVersion}")
+        myDate = datetime.today().strftime('%Y-%m-%d')
+        print(f'Generated {myDate} with sanpy.analysisVersion {sanpy.analysisVersion}')
         print(str)
 
     if 0:
-        path = "/Users/cudmore/Desktop/sanpy-analysis-results.csv"
-        print("saving:", path)
+        path = '/Users/cudmore/Desktop/sanpy-analysis-results.csv'
+        print('saving:', path)
         df.to_csv(path, index=False)
 
-
 class NumpyEncoder(json.JSONEncoder):
-    """Special json encoder for numpy types"""
-
+    """ Special json encoder for numpy types """
     def default(self, obj):
         if isinstance(obj, np.integer):
             return int(obj)
         elif isinstance(obj, np.floating):
             return float(obj)
         elif isinstance(obj, np.ndarray):
             return obj.tolist()
         return json.JSONEncoder.default(self, obj)
 
-
 class analysisResultList:
-    """Class encapsulating a list of analysis results.
-    
-    Each row is an analysisResultDict for one spike.
-
-    These are keys in bAnalysis_ spike dict and columns in output reports
+    """Class encapsulating a list of analysisResultDict (one dict per spike).
     """
-
     def __init__(self):
         # one copy for entire list
-
+        
         # TODO: put xxx in a function getAnalysisResltDict()
         self._dDict = analysisResultDict
 
         # list of analysisResultDict
         self._myList = []
 
         self._iterIdx = -1
 
-    def setFromListDict(self, listOfDict: List[dict]):
+    def setFromListDict(self, listOfDict : List[dict]):
         """Set analysis results from a list of dict.
-
+        
         Used when loading sanpy.bAnalysis from h5 file.
 
         When we create self (during spike detect) we have a list of class analysisResult.
         When we save/load we have a list of dict.
 
         This is assuming we re-create self every time we do spike detection
         """
-
+        
         # do not do this, we are an analysisResultList as a list of analysisResult
         # self._myList = listOfDict
-
+        
         self._myList = []
         for oneDict in listOfDict:
             oneAnalysisResult = analysisResult(theDict=oneDict)
             self._myList.append(oneAnalysisResult)
 
     def analysisDate(self):
         if len(self) > 0:
-            return self._myList[0]["analysisDate"]
+            return self._myList[0]['analysisDate']
         else:
             return None
 
     def analysisTime(self):
         if len(self) > 0:
-            return self._myList[0]["analysisTime"]
+            return self._myList[0]['analysisTime']
         else:
             return None
-
-    def _old_save(self, saveBase):
-        savePath = saveBase + "-analysis.json"
+        
+    def old_save(self, saveBase):
+        savePath = saveBase + '-analysis.json'
 
         analysisList = self.asList()
 
-        # print(analysisList[0].print())
+        #print(analysisList[0].print())
         print(self._myList[0])
 
-        with open(savePath, "w") as f:
+        with open(savePath, 'w') as f:
             json.dump(analysisList, f, cls=NumpyEncoder, indent=4)
 
-    def _old_load(self, loadBase):
-        loadPath = loadBase + "-analysis.json"
+    def old_load(self, loadBase):
+        loadPath = loadBase + '-analysis.json'
 
         if not os.path.isfile(loadPath):
-            logger.error(f"Did not find file: {loadPath}")
+            logger.error(f'Did not find file: {loadPath}')
             return
 
-        with open(loadPath, "r") as f:
+        with open(loadPath, 'r') as f:
             self._myList = json.load(f)
 
     def appendDefault(self):
         """Append a spike to analysis.
-
+        
         Used in bAnalysis spike detection.
         """
         oneResult = analysisResult()
         self._myList.append(oneResult)
 
     def appendAnalysis(self, analysisResultList):
         for analysisResult in analysisResultList:
             # analysisResult is for one spike
             self._myList.append(analysisResult)
 
     def addAnalysisResult(self, theKey, theDefault=None):
+
         # go through list and add to each [i] dict
         for spike in self:
             spike.addNewKey(theKey, theDefault=theDefault)
 
     def asList(self):
         """
         Return underlying list.
         """
-        # return [spike.asDict() for spike in self._myList]
+        #return [spike.asDict() for spike in self._myList]
         return [x.asDict() for x in self._myList]
 
     def asDataFrame(self):
         """
         Note: underlying _myList is a list of analysisResult
         """
         return pd.DataFrame(self.asList())
 
     def __getitem__(self, key):
         """
         Allow [] indexing with self[int].
         """
         try:
-            # return self._dDict[key]['currentValue']
+            #return self._dDict[key]['currentValue']
             return self._myList[key]
-        except IndexError as e:
-            logger.error(f"{e}")
+        except (IndexError) as e:
+            logger.error(f'{e}')
 
     def __len__(self):
-        """Allow len() with len(this)"""
+        """ Allow len() with len(this)
+        """
         return len(self._myList)
 
     def __iter__(self):
-        """Allow iteration with "for item in self"
         """
-        _iterIdx = -1
+        Allow iteration with "for item in self"
+        """
         return self
 
     def __next__(self):
-        """Allow iteration with "for item in self"
+        """
+        Allow iteration with "for item in self"
         """
         self._iterIdx += 1
         if self._iterIdx >= len(self._myList):
-            self._iterIdx = -1  # reset to initial value
+            self._iterIdx = -1 # reset to initial value
             raise StopIteration
         else:
             return self._myList[self._iterIdx]
 
-
 class analysisResult:
     def __init__(self, theDict=None):
         """Create an anlysis item (for one spike)
-
+        
         Args:
             theDict: Pre-existing dict when we load form h5 file
         """
         # this is the raw definition of analysis results (See above)
         # pull from this to create key/value self.rDict
-        # self._dDict = analysisResultDict
+        #self._dDict = analysisResultDict
         defaultDict = analysisResultDict
         # this is simple key/value pairs as we will in detection
         self._rDict = {}
-        for k, v in defaultDict.items():
-            default = v["default"]
+        for k,v in defaultDict.items():
+            default = v['default']
             self._rDict[k] = default
 
         if theDict is not None:
-            for k, v in theDict.items():
+            for k,v in theDict.items():
                 self[k] = v  # calls __setitem__()
 
     # this was interfering with converting to DataFrame ???
-    """
+    '''
     def __str__(self):
         printList = []
         for k,v in self._rDict.items():
             if isinstance(v, dict):
                 for k2,v2 in v.items():
                     printList.append(f'  {k2} : {v2} {type(v2)}')
             else:
                 printList.append(f'{k} : {v} {type(v)}')
         return '\n'.join(printList)
-    """
+    '''
 
     def print(self):
         printList = []
-        for k, v in self._rDict.items():
+        for k,v in self._rDict.items():
             if isinstance(v, list):
                 for item in v:
-                    for k2, v2 in item.items():
-                        printList.append(f"  {k2} : {v2} {type(v2)}")
+                    for k2,v2 in item.items():
+                        printList.append(f'  {k2} : {v2} {type(v2)}')
             else:
-                printList.append(f"{k} : {v} {type(v)}")
-        return "\n".join(printList)
+                printList.append(f'{k} : {v} {type(v)}')
+        return '\n'.join(printList)
 
     def addNewKey(self, theKey, theDefault=None):
         """
         Add a new key to this spike.
 
         Returns: (bool) True if new key added, false if key already exists.
         """
         if theDefault is None:
-            # theType = 'float'
-            theDefault = float("nan")
+            #theType = 'float'
+            theDefault = float('nan')
 
         # check if key exists
         keyExists = theKey in self._rDict.keys()
         addedKey = False
         if keyExists:
-            # key exists, don't modify
-            # logger.warning(f'The key "{theKey}" already exists and has value "{self._rDict[theKey]}"')
-            pass
+             #key exists, don't modify
+             #logger.warning(f'The key "{theKey}" already exists and has value "{self._rDict[theKey]}"')
+             pass
         else:
             self._rDict[theKey] = theDefault
             addedKey = True
 
         #
         return addedKey
 
@@ -764,76 +713,75 @@
         """
         return self._rDict
 
     def __getitem__(self, key):
         # to mimic a dictionary
         ret = None
         try:
-            # return self._dDict[key]['currentValue']
+            #return self._dDict[key]['currentValue']
             ret = self._rDict[key]
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'Error getting key "{key}" exception:{e}')
             raise
         #
         return ret
 
     def __setitem__(self, key, value):
         # to mimic a dictionary
         try:
-            # self._dDict[key]['currentValue'] = value
+            #self._dDict[key]['currentValue'] = value
             self._rDict[key] = value
-        except KeyError as e:
-            logger.error(f"{e}")
+        except (KeyError) as e:
+            logger.error(f'{e}')
 
     def items(self):
         # to mimic a dictionary
         return self._rDict.items()
 
     def keys(self):
         # to mimic a dictionary
         return self._rDict.keys()
 
 
 def test():
     ar = analysisResultList()
 
-    for k, v in ar.items():
-        print(k, v)
+    for k,v in ar.items():
+        print(k,v)
 
-    key = "analysisVersion"
-    print(f'key:{key} value:"{ar[key]}" type:{type(ar[key])}')
 
-    key = "errors"
+    key = 'analysisVersion'
     print(f'key:{key} value:"{ar[key]}" type:{type(ar[key])}')
 
+    key = 'errors'
+    print(f'key:{key} value:"{ar[key]}" type:{type(ar[key])}')
 
 def test2():
     # load abf
-    path = "data/19114000.abf"
+    path = 'data/19114000.abf'
     ba = sanpy.bAnalysis(path)
 
     # detect
     sweepNumber = 0
     detectionClass = ba.detectionClass
-    detectionClass["verbose"] = True
+    detectionClass['verbose'] = True
     ba.spikeDetect2__(sweepNumber, detectionClass)
 
-    """
+    '''
     printSpikeNum = 4
     print(f'== printing spike {printSpikeNum}')
     ba.printSpike(printSpikeNum)
-    """
+    '''
 
-    # ba.printErrors()
+    #ba.printErrors()
 
     sd = ba.getSpikeDictionaries()
-    """
+    '''
     for idx, s in enumerate(sd):
         if idx == 2:
             print(s)
-    """
-
+    '''
 
-if __name__ == "__main__":
-    # test()
-    # test2()
+if __name__ == '__main__':
+    #test()
+    #test2()
     printDocs()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bAnalysisUtil.py` & `sanpy-ephys-0.1.6/sanpy/bAnalysisUtil.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 import sys, os, json
 from collections import OrderedDict
 from typing import List
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 """
 A dictionary of detection parameters.
 
 Functions to map human readable name to backend stat name and vica versa.
 
@@ -29,527 +28,504 @@
 humanStr = getHumandFromStat('thresholdSec')
 statStr = getStatFromHuman('Spike Time (s)')
 ```
 """
 
 # add this to keep all key VALUES the same
 # or maybe make a class??? like bDetection (which holds detection parameters?)
-"""
+'''
 def _defaultStatDict():
     return
-"""
+'''
 
 statList = OrderedDict()
-statList["Spike Time (s)"] = {
-    "name": "thresholdSec",
-    "units": "s",
-    "yStat": "thresholdVal",
-    "yStatUnits": "mV",
-    "xStat": "thresholdSec",
-    "xStatUnits": "s",
-}
-statList["Spike Number"] = {
-    "name": "spikeNumber",
-    "units": "",
-    "yStat": "",
-    "yStatUnits": "",
-    "xStat": "spikeNumber",
-    "xStatUnits": "",
-}
-statList["Sweep Spike Number"] = {
-    "name": "sweepSpikeNumber",
-    "units": "",
-    "yStat": "",
-    "yStatUnits": "",
-    "xStat": "sweepSpikeNumber",
-    "xStatUnits": "",
-}
-statList["Sweep Number"] = {
-    "name": "sweep",
-    "units": "",
-    "yStat": "sweep",
-    "yStatUnits": "",
-    "xStat": "",
-    "xStatUnits": "",
-}
+statList['Spike Time (s)'] = {
+    'name': 'thresholdSec',
+    'units': 's',
+    'yStat': 'thresholdVal',
+    'yStatUnits': 'mV',
+    'xStat': 'thresholdSec',
+    'xStatUnits': 's'
+    }
+statList['Spike Number'] = {
+    'name': 'spikeNumber',
+    'units': '',
+    'yStat': '',
+    'yStatUnits': '',
+    'xStat': 'spikeNumber',
+    'xStatUnits': ''
+    }
+statList['Sweep Spike Number'] = {
+    'name': 'sweepSpikeNumber',
+    'units': '',
+    'yStat': '',
+    'yStatUnits': '',
+    'xStat': 'sweepSpikeNumber',
+    'xStatUnits': ''
+    }
+statList['Sweep Number'] = {
+    'name': 'sweep',
+    'units': '',
+    'yStat': 'sweep',
+    'yStatUnits': '',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 # removed 20230320
 # statList['DAC Command'] = {
-# 'name': 'dacCommand',
-# 'units': '',
-# 'yStat': 'dacCommand',
-# 'yStatUnits': '',
-# 'xStat': '',
-# 'xStatUnits': ''
-# }
+    # 'name': 'dacCommand',
+    # 'units': '',
+    # 'yStat': 'dacCommand',
+    # 'yStatUnits': '',
+    # 'xStat': '',
+    # 'xStatUnits': ''
+    # }
 
 # added 20230320
 # stimulus epoch number a spike is within
-statList["Epoch"] = {
-    "name": "epoch",
-    "units": "",
-    "yStat": "epoch",
-    "yStatUnits": "",
-    "xStat": "",
-    "xStatUnits": "",
-}
+statList['Epoch'] = {
+    'name': 'epoch',
+    'units': '',
+    'yStat': 'epoch',
+    'yStatUnits': '',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 # added 20230320
 # the epoch level (for I-Clamp, corresponds to DAC command)
-statList["Epoch DAC"] = {
-    "name": "epochLevel",
-    "units": "",
-    "yStat": "epochLevel",
-    "yStatUnits": "",
-    "xStat": "",
-    "xStatUnits": "",
-}
+statList['Epoch DAC'] = {
+    'name': 'epochLevel',
+    'units': '',
+    'yStat': 'epochLevel',
+    'yStatUnits': '',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 # added 20230320
 # the spike number within the epoch
 # not implemented
-statList["Epoch Spike Number"] = {
-    "name": "epochSpikeNumber",
-    "units": "",
-    "yStat": "epochSpikeNumber",
-    "yStatUnits": "",
-    "xStat": "",
-    "xStatUnits": "",
-}
-
-statList["Take Off Potential (mV)"] = {
-    "name": "thresholdVal",
-    "units": "mV",
-    "yStat": "thresholdVal",
-    "yStatUnits": "mV",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-statList["Spike Frequency (Hz)"] = {
-    "name": "spikeFreq_hz",
-    "units": "Hz",
-    "yStat": "spikeFreq_hz",
-    "yStatUnits": "Hz",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-statList["Inter-Spike-Interval (ms)"] = {
-    "name": "isi_ms",
-    "units": "ms",
-    "yStat": "isi_ms",
-    "yStatUnits": "ms",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-statList["Cycle Length (ms)"] = {
-    "name": "cycleLength_ms",
-    "units": "ms",
-    "yStat": "cycleLength_ms",
-    "yStatUnits": "ms",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-statList["AP Peak (mV)"] = {
-    "name": "peakVal",
-    "units": "mV",
-    "yStat": "peakVal",
-    "yStatUnits": "mV",
-    "xStat": "peakPnt",
-    "xStatUnits": "Points",
-}
-# spikeDict['peakVal'] - spikeDict['thresholdVal']
-statList["AP Height (mV)"] = {
-    "name": "peakHeight",
-    "units": "mV",
-    "yStat": "peakHeight",
-    "yStatUnits": "mV",
-    "xStat": "peakPnt",
-    "xStatUnits": "Points",
-}
+statList['Epoch Spike Number'] = {
+    'name': 'epochSpikeNumber',
+    'units': '',
+    'yStat': 'epochSpikeNumber',
+    'yStatUnits': '',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+
+statList['Take Off Potential (mV)'] = {
+    'name': 'thresholdVal',
+    'units': 'mV',
+    'yStat': 'thresholdVal',
+    'yStatUnits': 'mV',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Spike Frequency (Hz)'] = {
+    'name': 'spikeFreq_hz',
+    'units': 'Hz',
+    'yStat': 'spikeFreq_hz',
+    'yStatUnits': 'Hz',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Inter-Spike-Interval (ms)'] = {
+    'name': 'isi_ms',
+    'units': 'ms',
+    'yStat': 'isi_ms',
+    'yStatUnits': 'ms',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Cycle Length (ms)'] = {
+    'name': 'cycleLength_ms',
+    'units': 'ms',
+    'yStat': 'cycleLength_ms',
+    'yStatUnits': 'ms',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+statList['AP Peak (mV)'] = {
+    'name': 'peakVal',
+    'units': 'mV',
+    'yStat': 'peakVal',
+    'yStatUnits': 'mV',
+    'xStat': 'peakPnt',
+    'xStatUnits': 'Points'
+    }
+#spikeDict['peakVal'] - spikeDict['thresholdVal']
+statList['AP Height (mV)'] = {
+    'name': 'peakHeight',
+    'units': 'mV',
+    'yStat': 'peakHeight',
+    'yStatUnits': 'mV',
+    'xStat': 'peakPnt',
+    'xStatUnits': 'Points'
+    }
 # new 20220122
-statList["Time To Peak (ms)"] = {
-    "name": "timeToPeak_ms",
-    "units": "ms",
-    "yStat": "peakVal",
-    "yStatUnits": "mV",
-    "xStat": "peakPnt",
-    "xStatUnits": "Points",
-}
-statList["Pre AP Min (mV)"] = {
-    "name": "preMinVal",
-    "units": "mV",
-    "yStat": "preMinVal",
-    "yStatUnits": "mV",
-    "xStat": "preMinPnt",
-    "xStatUnits": "Points",
-}
-statList["Post AP Min (mV)"] = {
-    "name": "postMinVal",
-    "units": "mV",
-    "yStat": "postMinVal",
-    "yStatUnits": "mV",
-    "xStat": "postMinPnt",
-    "xStatUnits": "Points",
-}
+statList['Time To Peak (ms)'] = {
+    'name': 'timeToPeak_ms',
+    'units': 'ms',
+    'yStat': 'peakVal',
+    'yStatUnits': 'mV',
+    'xStat': 'peakPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Pre AP Min (mV)'] = {
+    'name': 'preMinVal',
+    'units': 'mV',
+    'yStat': 'preMinVal',
+    'yStatUnits': 'mV',
+    'xStat': 'preMinPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Post AP Min (mV)'] = {
+    'name': 'postMinVal',
+    'units': 'mV',
+    'yStat': 'postMinVal',
+    'yStatUnits': 'mV',
+    'xStat': 'postMinPnt',
+    'xStatUnits': 'Points'
+    }
 # todo: fix this
-statList["Early Diastolic Depol Rate (dV/s)"] = {
-    "name": "earlyDiastolicDurationRate",
-    "units": "dV/s",
-    "yStat": "earlyDiastolicDurationRate",
-    "yStatUnits": "dV/s",
-    "xStat": "",
-    "xStatUnits": "",
-}
+statList['Early Diastolic Depol Rate (dV/s)'] = {
+    'name': 'earlyDiastolicDurationRate',
+    'units': 'dV/s',
+    'yStat': 'earlyDiastolicDurationRate',
+    'yStatUnits': 'dV/s',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 # todo: fix this
-statList["Early Diastolic Duration (ms)"] = {
-    "name": "earlyDiastolicDuration_ms",
-    "units": "ms",
-    "yStat": "earlyDiastolicDuration_ms",
-    "yStatUnits": "dV/s",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-
-statList["Diastolic Duration (ms)"] = {
-    "name": "diastolicDuration_ms",
-    "units": "ms",
-    "yStat": "diastolicDuration_ms",
-    "yStatUnits": "dV/s",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
-statList["Max AP Upstroke (mV)"] = {
-    "name": "preSpike_dvdt_max_val",
-    "units": "mV",
-    "yStat": "preSpike_dvdt_max_val",
-    "yStatUnits": "dV/s",
-    "xStat": "preSpike_dvdt_max_pnt",
-    "xStatUnits": "Points",
-}
-statList["Max AP Upstroke (dV/dt)"] = {
-    "name": "preSpike_dvdt_max_val2",
-    "units": "dV/dt",
-    "yStat": "preSpike_dvdt_max_val2",
-    "yStatUnits": "dV/dt",
-    "xStat": "preSpike_dvdt_max_pnt",
-    "xStatUnits": "Points",
-}
-statList["Max AP Repolarization (mV)"] = {
-    "name": "postSpike_dvdt_min_val",
-    "units": "mV",
-    "yStat": "postSpike_dvdt_min_val",
-    "yStatUnits": "mV",
-    "xStat": "postSpike_dvdt_min_pnt",
-    "xStatUnits": "Points",
-}
+statList['Early Diastolic Duration (ms)'] = {
+    'name': 'earlyDiastolicDuration_ms',
+    'units': 'ms',
+    'yStat': 'earlyDiastolicDuration_ms',
+    'yStatUnits': 'dV/s',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+
+statList['Diastolic Duration (ms)'] = {
+    'name': 'diastolicDuration_ms',
+    'units': 'ms',
+    'yStat': 'diastolicDuration_ms',
+    'yStatUnits': 'dV/s',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
+statList['Max AP Upstroke (mV)'] = {
+    'name': 'preSpike_dvdt_max_val',
+    'units': 'mV',
+    'yStat': 'preSpike_dvdt_max_val',
+    'yStatUnits': 'dV/s',
+    'xStat': 'preSpike_dvdt_max_pnt',
+    'xStatUnits': 'Points'
+    }
+statList['Max AP Upstroke (dV/dt)'] = {
+    'name': 'preSpike_dvdt_max_val2',
+    'units': 'dV/dt',
+    'yStat': 'preSpike_dvdt_max_val2',
+    'yStatUnits': 'dV/dt',
+    'xStat': 'preSpike_dvdt_max_pnt',
+    'xStatUnits': 'Points'
+    }
+statList['Max AP Repolarization (mV)'] = {
+    'name': 'postSpike_dvdt_min_val',
+    'units': 'mV',
+    'yStat': 'postSpike_dvdt_min_val',
+    'yStatUnits': 'mV',
+    'xStat': 'postSpike_dvdt_min_pnt',
+    'xStatUnits': 'Points'
+    }
 # todo: fix this
-statList["AP Duration (ms)"] = {
-    "name": "apDuration_ms",
-    "units": "ms",
-    "yStat": "apDuration_ms",
-    "yStatUnits": "ms",
-    "xStat": "thresholdPnt",
-    "xStatUnits": "Points",
-}
+statList['AP Duration (ms)'] = {
+    'name': 'apDuration_ms',
+    'units': 'ms',
+    'yStat': 'apDuration_ms',
+    'yStatUnits': 'ms',
+    'xStat': 'thresholdPnt',
+    'xStatUnits': 'Points'
+    }
 
 # new 20210211
-statList["Half Width 10 (ms)"] = {
-    "name": "widths_10",
-    "yStat": "widths_10",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
-statList["Half Width 20 (ms)"] = {
-    "name": "widths_20",
-    "yStat": "widths_20",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
-statList["Half Width 50 (ms)"] = {
-    "name": "widths_50",
-    "yStat": "widths_50",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
-statList["Half Width 80 (ms)"] = {
-    "name": "widths_80",
-    "yStat": "widths_80",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
-statList["Half Width 90 (ms)"] = {
-    "name": "widths_90",
-    "yStat": "widths_90",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
+statList['Half Width 10 (ms)'] = {
+    'name': 'widths_10',
+    'yStat': 'widths_10',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+statList['Half Width 20 (ms)'] = {
+    'name': 'widths_20',
+    'yStat': 'widths_20',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+statList['Half Width 50 (ms)'] = {
+    'name': 'widths_50',
+    'yStat': 'widths_50',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+statList['Half Width 80 (ms)'] = {
+    'name': 'widths_80',
+    'yStat': 'widths_80',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+statList['Half Width 90 (ms)'] = {
+    'name': 'widths_90',
+    'yStat': 'widths_90',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 # sa node specific
-"""
+'''
 statList['Region'] = {
     'yStat': 'Region',
     'yStatUnits': '',
     'xStat': '',
     'xStatUnits': ''
     }
-"""
+'''
 # kymograph analysis
-statList["Ca++ Delay (s)"] = {
-    "yStat": "caDelay_sec",
-    "yStatUnits": "s",
-    "xStat": "",
-    "xStatUnits": "",
-}
-statList["Ca++ Width (ms)"] = {
-    "yStat": "caWidth_ms",
-    "yStatUnits": "ms",
-    "xStat": "",
-    "xStatUnits": "",
-}
-
+statList['Ca++ Delay (s)'] = {
+    'yStat': 'caDelay_sec',
+    'yStatUnits': 's',
+    'xStat': '',
+    'xStatUnits': ''
+    }
+statList['Ca++ Width (ms)'] = {
+    'yStat': 'caWidth_ms',
+    'yStatUnits': 'ms',
+    'xStat': '',
+    'xStatUnits': ''
+    }
 
 def getHumanFromStat(statName):
     """Get human readable stat name from backend stat name."""
-    ret = ""
-    for k, v in statList.items():
-        name = v["name"]
+    ret = ''
+    for k,v in statList.items():
+        name = v['name']
         if name == statName:
             ret = k
             break
-    if ret == "":
+    if ret =='':
         logger.warning(f'Did not find "{statName}"')
     #
     return ret
 
-
 def getStatFromHuman(humanStat):
     """Get backend stat name from human readable stat."""
-    ret = ""
+    ret = ''
     try:
-        ret = statList[humanStat]["name"]
-    except KeyError as e:
+        ret = statList[humanStat]['name']
+    except (KeyError) as e:
         logger.warning(f'Bad key "{humanStat}"')
     #
     return ret
 
-
 def _print():
     """
     Print out human readable detection parameters and convert to markdown table
 
     Requires:
         pip install tabulate
     """
     import pandas as pd
 
     # statList is a dict with keys, one key per stat
     d = statList
 
     dictList = []
-    for k, v in d.items():
+    for k,v in d.items():
         stat = k
         oneDict = {
-            "Stat": stat,
+            'Stat': stat,
         }
-        for k2, v2 in v.items():
+        for k2,v2 in v.items():
             oneDict[k2] = v2
 
         dictList.append(oneDict)
     #
     df = pd.DataFrame(dictList)
     str = df.to_markdown()
     print(str)
 
-
 class bAnalysisUtil:
     def __init__(self):
         self.configDict = self.configDefault()
 
         # load preferences
-        if getattr(sys, "frozen", False):
+        if getattr(sys, 'frozen', False):
             # we are running in a bundle (frozen)
             bundle_dir = sys._MEIPASS
         else:
             # we are running in a normal Python environment
             bundle_dir = os.path.dirname(os.path.abspath(__file__))
-        self.configFilePath = os.path.join(bundle_dir, "AnalysisApp_Config.json")
+        self.configFilePath = os.path.join(bundle_dir, 'AnalysisApp_Config.json')
 
         self.configLoad()
 
         # self.top = None  # used by tkinter interface
 
     @staticmethod
     def getStatList():
         """20210929 working on extending stat list with sanpy.userAnalysis
 
         We first define stat list in this function as statList
         We then ask for user defined stat functions static members xxx
         """
         coreStatList = statList  # from global withing function
 
-        # userStatList = sanpy.userAnalysis.findUserAnalysis()
-        # userStatList = sanpy.userAnalysis.baseUserAnalysis.findUserAnalysis()
-        # userStatList = findUserAnalysis()
-
-        #logger.warning(f"need to reactivate getting user stats")
-
+        #userStatList = sanpy.userAnalysis.findUserAnalysis()
+        #userStatList = sanpy.userAnalysis.baseUserAnalysis.findUserAnalysis()
+        #userStatList = findUserAnalysis()
+        
+        logger.warning(f'need to reactivate getting user stats')
+        
         """
         Each entry in statList looks like:
         
         statList['Spike Time (s)'] = {
             'name': 'thresholdSec',
             'units': 's',
             'yStat': 'thresholdVal',
             'yStatUnits': 'mV',
             'xStat': 'thresholdSec',
             'xStatUnits': 's'
             }
         """
-        userStatList: List[
-            dict
-        ] = sanpy.user_analysis.baseUserAnalysis.findUserAnalysisStats()
+        userStatList : List[dict] = sanpy.user_analysis.baseUserAnalysis.findUserAnalysisStats()
         for userStatDict in userStatList:
             for k, v in userStatDict.items():
                 if k in coreStatList.keys():
-                    logger.error(
-                        f'user analysis key "{k}" already exists in core stat List'
-                    )
+                    logger.error(f'user analysis key "{k}" already exists in core stat List')
                 else:
                     # name = v['name']
                     # coreStatList[k] = {}
                     # coreStatList[k][name] = name
                     coreStatList[k] = v
 
         return coreStatList
 
-        # 20220630, was this
+        #20220630, was this
         userStatList = sanpy.user_analysis.baseUserAnalysis.findUserAnalysis()
 
         for k, v in userStatList.items():
             # check if key exists !!!
             if k in coreStatList.keys():
-                logger.error(
-                    f'user analysis key {"k"} already exists in core stat List'
-                )
+                logger.error(f'user analysis key {"k"} already exists in core stat List')
             else:
-                name = v["name"]
+                name = v['name']
                 coreStatList[k] = {}
                 coreStatList[k][name] = name
 
         return coreStatList
 
-    """
+    '''
     @staticmethod
     def humanStatToBackend(theStat):
         return ''
-    """
+    '''
 
     def prettyPrint(self):
         print(json.dumps(self.configDict, indent=4, sort_keys=True))
 
     def getDetectionConfig(self):
         return self.config
 
     def getDetectionParam(self, theParam):
-        if theParam in self.configDict["detection"].keys():
-            return self.configDict["detection"][theParam]["value"]
+        if theParam in self.configDict['detection'].keys():
+            return self.configDict['detection'][theParam]['value']
         else:
-            print(
-                "error: bAnalysisUtil.getDetectionParam() detection parameter not found:",
-                theParam,
-            )
+            print('error: bAnalysisUtil.getDetectionParam() detection parameter not found:', theParam)
             return None
 
     def getDetectionDescription(self, theParam):
-        if theParam in self.configDict["detection"].keys():
-            return self.configDict["detection"][theParam]["meaning"]
+        if theParam in self.configDict['detection'].keys():
+            return self.configDict['detection'][theParam]['meaning']
         else:
-            print(
-                "error: bAnalysisUtil.getDetectionDescription() detection parameter not found:",
-                theParam,
-            )
+            print('error: bAnalysisUtil.getDetectionDescription() detection parameter not found:', theParam)
             return None
 
     def setDetectionParam(self, theParam, theValue):
-        if theParam in self.configDict["detection"].keys():
-            self.configDict["detection"][theParam]["value"] = theValue
+        if theParam in self.configDict['detection'].keys():
+            self.configDict['detection'][theParam]['value'] = theValue
         else:
-            print(
-                "error: bAnalysisUtil.setDetectionParam() detection parameter not found:",
-                theParam,
-            )
+            print('error: bAnalysisUtil.setDetectionParam() detection parameter not found:', theParam)
             return None
 
     def configSave(self):
-        print("bAnalysisUtil.configSave()")
-        with open(self.configFilePath, "w") as outfile:
+        print('bAnalysisUtil.configSave()')
+        with open(self.configFilePath, 'w') as outfile:
             json.dump(self.configDict, outfile, indent=4, sort_keys=True)
 
     def configLoad(self):
         if os.path.isfile(self.configFilePath):
-            print(
-                "    bAnalysisUtil.configLoad() loading configFile file:",
-                self.configFilePath,
-            )
+            print('    bAnalysisUtil.configLoad() loading configFile file:', self.configFilePath)
             with open(self.configFilePath) as f:
                 self.configDict = json.load(f)
         else:
-            # print('    bAnalysisUtil.preferencesLoad() using program provided default options')
+            #print('    bAnalysisUtil.preferencesLoad() using program provided default options')
             self.configDefault()
 
     def configDefault(self):
         theRet = OrderedDict()
 
-        theRet["detection"] = OrderedDict()
+        theRet['detection'] = OrderedDict()
 
-        theRet["detection"]["dvdtThreshold"] = OrderedDict()
-        theRet["detection"]["dvdtThreshold"] = {
-            "value": 100,
-            "meaning": "Threshold crossing in dV/dt",
+        theRet['detection']['dvdtThreshold'] = OrderedDict()
+        theRet['detection']['dvdtThreshold'] = {
+            'value': 100,
+            'meaning': 'Threshold crossing in dV/dt',
         }
 
-        theRet["detection"]["minSpikeVm"] = OrderedDict()
-        theRet["detection"]["minSpikeVm"] = {
-            "value": -20,
-            "meaning": "Minimum Vm to accept a detected spike",
+        theRet['detection']['minSpikeVm'] = OrderedDict()
+        theRet['detection']['minSpikeVm'] = {
+            'value': -20,
+            'meaning': 'Minimum Vm to accept a detected spike',
         }
 
-        theRet["detection"]["medianFilter"] = OrderedDict()
-        theRet["detection"]["medianFilter"] = {
-            "value": 5,
-            "meaning": "Median filter for Vm (must be odd)",
+        theRet['detection']['medianFilter'] = OrderedDict()
+        theRet['detection']['medianFilter'] = {
+            'value': 5,
+            'meaning': 'Median filter for Vm (must be odd)',
         }
 
-        theRet["detection"]["minISI_ms"] = OrderedDict()
-        theRet["detection"]["minISI_ms"] = {
-            "value": 75,
-            "meaning": "Minimum allowable inter-spike-interval (ms), anything shorter than this will be rejected",
+        theRet['detection']['minISI_ms'] = OrderedDict()
+        theRet['detection']['minISI_ms'] = {
+            'value': 75,
+            'meaning': 'Minimum allowable inter-spike-interval (ms), anything shorter than this will be rejected',
         }
 
         return theRet
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     if 0:
         _fullStatList = sanpy.bAnalysisUtil.getStatList()
         for oneStat in _fullStatList:
             sanpy._util.pprint(oneStat)
-
+    
     if 0:
         # unit tests
         bau = bAnalysisUtil()
-        print("dvdtThreshold:", bau.getDetectionParam("dvdtThreshold"))
-        print("minSpikeVm:", bau.getDetectionParam("minSpikeVm"))
-        print("medianFilter:", bau.getDetectionParam("medianFilter"))
+        print('dvdtThreshold:', bau.getDetectionParam('dvdtThreshold'))
+        print('minSpikeVm:', bau.getDetectionParam('minSpikeVm'))
+        print('medianFilter:', bau.getDetectionParam('medianFilter'))
         bau.configSave()
 
         bau.prettyPrint()
 
     _print()
 
     # abb removed 20201109, not using this, write a PyQt preferences panel
-    """
+    '''
     myRoot = tkinter.Tk()
     bau.tk_PreferenesPanel(myRoot)
     myRoot.mainloop()
-    """
+    '''
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bAnalysis_.py` & `sanpy-ephys-0.1.6/sanpy/bAnalysis_.py`

 * *Files 5% similar despite different names*

```diff
@@ -22,18 +22,16 @@
 import sanpy.bDetection
 import sanpy.user_analysis.baseUserAnalysis  # to stop circular imports
 import sanpy.h5Util
 import sanpy.fileloaders
 from sanpy.fileloaders import recordingModes
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class bAnalysis:
     """
     The bAnalysis class represents a whole-cell recording and provides functions for analysis.
 
     A bAnalysis object can be created in a number of ways:
     (i) From a file path including .abf and .csv
     (ii) From a pandas DataFrame when loading from a h5 file.
@@ -52,113 +50,101 @@
     print(ba)
     ```
     """
 
     # def getNewUuid():
     #     return 't' + str(uuid.uuid4()).replace('-', '_')
 
-    def __init__(
-        self,
-        filepath: str = None,
-        byteStream=None,
-        loadData: bool = True,
-        fileLoaderDict: dict = None,
-        stimulusFileFolder: str = None,
-        verbose: bool = False,
-    ):
+    def __init__(self,
+                    filepath :str = None,
+                    byteStream = None,
+                    loadData : bool = True,
+                    fileLoaderDict : dict = None,
+                    stimulusFileFolder : str = None,
+                    verbose : bool = False):
         """
         Args:
             filepath (str): Path to either .abf or .csv with time/mV columns.
             byteStream (io.BytesIO): Binary stream for use in the cloud.
             loadData: If true, load raw data, otherwise just load header
-            fileLoaderDict (dict)
-                If None then fetch from sanpy.fileloaders.getFileLoaders()
-                Do this if running in a script.
-                If running an SanPy app, we pass the dict
+            fileLoaderDict: if None then fetch from sanpy.fileloaders.getFileLoaders()
+                Do this if running in a script. If running an SanPy app, we pass the dict
             stimulusFileFolder:
         """
 
-        """
+        '''
         self._path = file  # todo: change this to filePath
-        """
+        '''
         """str: File path."""
 
-        self._detectionDict: dict = None  # corresponds to an item in sanpy.bDetection
+        self._detectionDict : dict = None # corresponds to an item in sanpy.bDetection
 
-        self._isAnalyzed: bool = False
+        self._isAnalyzed : bool = False
 
-        self.loadError: bool = False
+        self.loadError : bool = False
         """bool: True if error loading file/stream."""
 
-        # self.detectionDict = None  # remember the parameters of our last detection
+        #self.detectionDict = None  # remember the parameters of our last detection
         """dict: Dictionary specifying detection parameters, see bDetection.getDefaultDetection."""
 
-        # self._abf = None
+        #self._abf = None
         """pyAbf: If loaded from binary .abf file"""
 
-        self.dateAnalyzed: str = None
+        self.dateAnalyzed : str = None
         """str: Date Time of analysis. TODO: make a property."""
 
-        # self.detectionType = None
+        #self.detectionType = None
         """str: From ('dvdt', 'mv')"""
 
-        self.spikeDict: sanpy.bAnalysisResults.analysisResultList = (
-            sanpy.bAnalysisResults.analysisResultList()
-        )
+        self.spikeDict : sanpy.bAnalysisResults.analysisResultList \
+                        = sanpy.bAnalysisResults.analysisResultList()
         # class to store all analysis results
 
-        # self._spikesPerSweep : int = None
+        #self._spikesPerSweep : int = None
 
         self.spikeClips = []  # created in self.spikeDetect()
         self.spikeClips_x = []  #
         self.spikeClips_x2 = []  #
 
         self.dfError = None  # dataframe with a list of detection errors
         self._dfReportForScatter = None  # dataframe to be used by scatterplotwidget
 
         self._detectionDirty = False
 
         # will be overwritten by existing uuid in self._loadFromDf()
         self.uuid = sanpy._util.getNewUuid()
 
-        # self.tifData = None
+        #self.tifData = None
         # when we have a tif kymograph
 
-        # self.isBytesIO = False
+        #self.isBytesIO = False
         # when we are running in the cloud
 
         # TODO (cudmore) need to parse folder of file loaders in fileloders/ and determine
         # class to use to load file (using fileLoader.filetype
         self._fileLoader = None
         if filepath is not None and not os.path.isfile(filepath):
             logger.error(f'File does not exist: "{filepath}"')
             self.loadError = True
         else:
             if fileLoaderDict is None:
-                fileLoaderDict = (
-                    sanpy.fileloaders.getFileLoaders()
-                )  # EXPENSIVE, to do, pass in from app
-
+                fileLoaderDict = sanpy.fileloaders.getFileLoaders()  # EXPENSIVE, to do, pass in from app
+            
             _ext = os.path.splitext(filepath)[1]
             _ext = _ext[1:]
             try:
                 if verbose:
-                    logger.info(f"Loading file with extension: {_ext}")
-                constructorObject = fileLoaderDict[_ext]["constructor"]
+                    logger.info(f'Loading file with extension: {_ext}')
+                constructorObject = fileLoaderDict[_ext]['constructor']
                 self._fileLoader = constructorObject(filepath)
-                # may 2, 2023
-                if self._fileLoader._loadError:
-                    logger.error(f'load error in file loader for ext: "{_ext}"')
-                    self.loadError = True
-
-            except KeyError as e:
+            except (KeyError) as e:
                 logger.error(f'did not find a file loader for extension "{_ext}"')
                 self.loadError = True
-
-        """
+            
+        '''
         if byteStream is not None:
             self._loadAbf(byteStream=byteStream,
                     loadData=loadData,
                     stimulusFileFolder=stimulusFileFolder)
         elif file is not None and file.endswith('.abf'):
             self._loadAbf(loadData=loadData)
         elif file is not None and file.endswith('.atf'):
@@ -167,395 +153,360 @@
             self._loadTif()
         elif file is not None and file.endswith('.csv'):
             self._loadCsv()
         else:
             pass
             #logger.error(f'Can only open abf/csv/tif/stream files: {file}')
             #self.loadError = True
-        """
+        '''
 
         # get default derivative
-        if loadData and not self.loadError:
+        if loadData:
             self._rebuildFiltered()
 
         self._detectionDirty = False
 
-        """
+        '''
         self.setSweep()
-        """
+        '''
 
     @property
     def fileLoader(self):
-        """ """
+        """
+        """
         return self._fileLoader
 
     def getFileName(self):
         return self.fileLoader.filename
-
+    
     def asDataFrame(self):
         """Return analysis as a Pandas DataFrame.
 
-        Important:
-            This returns a COPY !!!
-            Do not modify and expect changes to stick
+            Important:
+                This returns a COPY !!!
+                Do not modify and expect changes to stick
         """
         return self._dfReportForScatter
-        # return self.spikeDict.asDataFrame()
+        #return self.spikeDict.asDataFrame()
 
-    def getDetectionDict(self, asCopy: bool = False):
-        """Get the detection dictionary that was used for detect()."""
+    def getDetectionDict(self, asCopy : bool = False):
+        """Get the detection dictionary that was used for detect().
+        """
         if asCopy:
             return copy.deepcopy(self._detectionDict)
         else:
             return self._detectionDict
-
+        
     def __str__(self):
-        """Get a brief str representation. Usefull for print()."""
+        """Get a brief str representation. Usefull for print().
+        """
         # if self.isBytesIO:
         #      filename = '<BytesIO>'
         # else:
         #     filename = self.getFileName()
         fileLoadStr = self.fileLoader.__str__()
-        txt = f"fileLoader: {fileLoadStr} spikes:{self.numSpikes}"
+        txt = f'fileLoader: {fileLoadStr} spikes:{self.numSpikes}'
         return txt
 
     def _saveHdf_pytables(self, hdfPath):
-        """Save detection parameters and analysis into an hdf5 file."""
+        """Save detection parameters and analysis into an hdf5 file.
+        """
         if not self.detectionDirty:
             # Do not save it detection has not changed
-            logger.info(f"NOT SAVING, is not dirty {self}")
+            logger.info(f'NOT SAVING, is not dirty {self}')
             return False
 
         # when making df from dict, need to pass it a list
         # o.w. key values that are lists get expanded into rows
         dfDetection = pd.DataFrame([self._detectionDict])
 
         # convert spikeList (list of dict) to json
-        # spikeList = self.spikeDict.asList()
-        # dataJson = json.dumps(spikeList, cls=NumpyEncoder)  # list of dict
-        # dfAnalysis = pd.DataFrame(spikeList)
+        #spikeList = self.spikeDict.asList()
+        #dataJson = json.dumps(spikeList, cls=NumpyEncoder)  # list of dict
+        #dfAnalysis = pd.DataFrame(spikeList)
         dfAnalysis = self.spikeDict.asDataFrame()
 
         uuid = self.uuid
 
-        logger.info(
-            f"    Saving {self.numSpikes} spikes to uuid {uuid} in h5 file {hdfPath}"
-        )
+        logger.info(f'    Saving {self.numSpikes} spikes to uuid {uuid} in h5 file {hdfPath}')
 
         with pd.HDFStore(hdfPath) as hdfStore:
-            key = uuid + "/" + "detectionDict"
+            key = uuid + '/' + 'detectionDict'
             dfDetection.to_hdf(hdfStore, key)  # default mode='a'
 
-            key = uuid + "/" + "analysisList"
+            key = uuid + '/' + 'analysisList'
             dfAnalysis.to_hdf(hdfStore, key)
 
         # we saved, detection is not dirty
         self._detectionDirty = False
-
+        
         return True
 
     def _loadHdf_pytables(self, hdfPath, uuid):
-        """Load analysis from an h5 file using key 'uuid'.
-
-        Notes
-        -----
+        """
+        Load analysis from an h5 file using key 'uuid'.
+        
+        Notes:
             df.to_dict() requires into=OrderedDIct, o.w. column order is sorted
-            Error report needs to be generated (is not in h5 file)
-                use getErrorReport()
         """
 
         # cant use pd.HDFStore(<path>) as read_hdf does not understand file pointer
-
-        logger.info(f"loading {uuid} from {hdfPath}")
+        
+        logger.info(f'loading {uuid} from {hdfPath}')
 
         # load pandas dataframe(s) from h5 file
         didLoad = True
         try:
-            detectionDictKey = uuid + "/" + "detectionDict"  # group
+            detectionDictKey = uuid + '/' + 'detectionDict'  # group
             dfDetection = pd.read_hdf(hdfPath, detectionDictKey)
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(e)
             didLoad = False
         try:
-            analysisListKey = uuid + "/" + "analysisList"
+            analysisListKey = uuid + '/' + 'analysisList'
             dfAnalysis = pd.read_hdf(hdfPath, analysisListKey)
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(e)
             didLoad = False
 
         if didLoad:
             # we take on the uuid we were loaded from
             self.uuid = uuid
-
+            
             # convert to a dict
-            detectionDict = dfDetection.to_dict("records", into=OrderedDict)[
-                0
-            ]  # one dict
-
+            detectionDict = dfDetection.to_dict('records', into=OrderedDict)[0]  # one dict
+            
             self._detectionDict = detectionDict
-            # pprint(detectionDict)
+            #pprint(detectionDict)
 
             # convert to a list of dict
-            analysisList = dfAnalysis.to_dict(
-                "records", into=OrderedDict
-            )  # list of dict
+            analysisList = dfAnalysis.to_dict('records', into=OrderedDict)  # list of dict
             self.spikeDict.setFromListDict(analysisList)
-            # pprint(analysisList[0])
+            #pprint(analysisList[0])
 
             # recreate spike analysis dataframe
-            self._dfReportForScatter = dfAnalysis
-
-            # regenerate error report
-            self.dfError = self.getErrorReport()
+            self._dfReportForScatter =  dfAnalysis
 
             # dec 2022
             self._isAnalyzed = True
 
-            logger.info(
-                f"    loaded {len(detectionDict.keys())} detection keys and {len(self.spikeDict)} spikes"
-            )
+            logger.info(f'    loaded {len(detectionDict.keys())} detection keys and {len(self.spikeDict)} spikes')
         else:
-            logger.error(f"    LOAD FAILED")
-
+            logger.error(f'    LOAD FAILED')
+ 
     @property
     def detectionDirty(self):
         return self._detectionDirty
 
     @property
     def numSpikes(self):
         """Get the total number of detected spikes (all sweeps).
-
+        
         See getNumSpikes(sweep)
         """
-        return len(self.spikeDict)  # spikeDict has all spikes for all sweeps
+        return len(self.spikeDict) # spikeDict has all spikes for all sweeps
 
-    def getNumSpikes(self, sweep: int = 0):
+    def getNumSpikes(self, sweep : int = 0):
         """Get number of spikes in a sweep.
 
         See property numSpikes
         """
-        thresholdSec = self.getStat("thresholdSec", sweepNumber=sweep)
+        thresholdSec = self.getStat('thresholdSec', sweepNumber=sweep)
         return len(thresholdSec)
-        # return self._spikesPerSweep[sweep]
-
-    @property
-    def numErrors(self) -> int:
-        """Get number of detection errors.
-        """
-        if self.dfError is None:
-            # no analysis
-            return None
-        else:
-            return len(self.dfError)
-        
-    def _old_getAbsSpikeFromSweep(self, sweepSpikeIdx: int, sweep: int) -> int:
+        #return self._spikesPerSweep[sweep]
+    
+    def _old_getAbsSpikeFromSweep(self, sweepSpikeIdx : int, sweep : int) -> int:
         """Given a spike index within a sweep, get the absolute spike index.
 
         See getSweepSpikeFromAbsolute()
-        """
+        """        
         absIdx = 0
         for sweepIdx in range(sweep):
             absIdx += self._spikesPerSweep[sweepIdx]
         absIdx += sweepSpikeIdx
         return absIdx
-
-    def getSweepSpikeFromAbsolute(self, absSpikeIdx: int, sweep: int) -> int:
+    
+    def getSweepSpikeFromAbsolute(self, absSpikeIdx : int, sweep : int) -> int:
         """Get sweep spike from absolute spike.
-
+        
         See getAbsSpikeFromSweep()
         """
-        sweepSpikeNum = self.spikeDict[absSpikeIdx]["sweepSpikeNumber"]
+        sweepSpikeNum = self.spikeDict[absSpikeIdx]['sweepSpikeNumber']
         return sweepSpikeNum
-
+        
         # absIdx = 0
         # for oneSweep in range(sweep):
         #     absIdx += self._spikesPerSweep[oneSweep]
         # sweepSpike = absSpikeIdx - absIdx
         # return sweepSpike
 
+
     def isDirty(self):
         """Return True if analysis has been modified but not save."""
         return self._detectionDirty
 
     def isAnalyzed(self):
         """Return True if this bAnalysis has been analyzed, False otherwise."""
         return self._isAnalyzed
 
-    def getStatMean(self, statName: str, sweepNumber: int = None):
+    def getStatMean(self, statName : str, sweepNumber : int = None):
         """
         Get the mean of an analysis parameter.
 
         Args:
             statName (str): Name of the statistic to retreive.
                 For a list of available stats use bDetection.defaultDetection.
         """
         theMean = None
         x = self.getStat(statName, sweepNumber=sweepNumber)
-        if x is not None and len(x) > 1:
+        if x is not None and len(x)>1:
             theMean = np.nanmean(x)
         return theMean
 
-    def getSpikeStat(self, spikeList : List[int], stat : str):
-        """Get one stat from a list of spikes
-        
-        Parameters
-        ----------
-        spikeList : List[int]
-        stat : str
-        """
-
-        # if isinstance(spikeList, int):
-        #     spikeList = [spikeList]
-
+    def getSpikeStat(self, spikeList, stat):
         if len(spikeList) == 0:
             return None
 
-        # logger.info(f'spikeList: {spikeList} stat:{stat}')
-        
         retList = []
-        # count = 0
+        #count = 0
         for idx, spike in enumerate(self.spikeDict):
-            # logger.info(f'  idx:{idx}')
             if idx in spikeList:
                 try:
                     val = spike[stat]
                     retList.append(val)
-                    # count += 1
-                except KeyError as e:
-                    logger.error(e)
-        # logger.info(f'  retList: {retList}')
+                    #count += 1
+                except (KeyError) as e:
+                    logger.info(e)
         return retList
 
-    def setSpikeStat_time(self, startSec: int, stopSec: int, stat: str, value):
-        """Set a spike stat for spikes in a range of time."""
-
+    def setSpikeStat_time(self,
+                          startSec : int,
+                          stopSec : int,
+                          stat : str,
+                          value):
+        """Set a spike stat for spikes in a range of time.
+        """
+        
         # get spike list in range [startSec, stopSec]
         spikeSeconds = self.getSpikeSeconds()
-        spikeList = [
-            idx for idx, x in enumerate(spikeSeconds) if x >= startSec and x < stopSec
-        ]
+        spikeList = [idx for idx, x in enumerate(spikeSeconds) if x>=startSec and x<stopSec]
         self.setSpikeStat(spikeList, stat, value)
 
-    def setSpikeStat(self, spikeList: Union[list, int], stat: str, value):
+    def setSpikeStat(self, spikeList : Union[list, int],
+                     stat : str, value):
         """Set a spike stat for one spike or a list of spikes.
-
+        
         Used to set things like ('isBad', 'userType1', 'condition', ...)
         """
         if isinstance(spikeList, int):
             spikeList = [spikeList]
-            # else:
-            #     logger.error(f'Expecting list[int] or int but got spikeList type {type(spikeList)}')
+        # else:
+        #     logger.error(f'Expecting list[int] or int but got spikeList type {type(spikeList)}')
             return
 
         if len(spikeList) == 0:
             return
 
         now = datetime.datetime.now()
-        modDate = now.strftime("%Y%m%d")
-        modTime = now.strftime("%H:%M:%S")
+        modDate = now.strftime('%Y%m%d')
+        modTime = now.strftime('%H:%M:%S')
 
         for spike in spikeList:
             self.spikeDict[spike][stat] = value
-            self.spikeDict[spike]["modDate"] = modDate
-            self.spikeDict[spike]["modTime"] = modTime
-
+            self.spikeDict[spike]['modDate'] = modDate
+            self.spikeDict[spike]['modTime'] = modTime
+            
         self._detectionDirty = True
 
         logger.info(f'set spikes {spikeList} stat "{stat}" to value "{value}"')
 
-        """
+        '''
         count = 0
         for idx, spike in enumerate(self.spikeDict):
             if idx in spikeList:
                 try:
                     spike[stat] = value
                     count += 1
                 except (KeyError) as e:
                     logger.info(e)
         #
         logger.info(f'Given {len(spikeList)} and set {count}')
-        """
+        '''
 
-    def getSweepStats(
-        self, statName: str, decimals=3, asDataFrame=False, df: pd.DataFrame = None
-    ):
+    def getSweepStats(self, statName : str, decimals=3,
+                        asDataFrame = False, df :pd.DataFrame = None):
         """
 
         Args:
             df (pd.DataFrame): For kymograph we sometimes have to convert (peak) values to molar
         """
 
         if df is None:
             df = self.spikeDict.asDataFrame()
 
         sweepStatList = []
 
         for sweep in range(self.fileLoader.numSweeps):
-            oneDf = df[df["sweep"] == sweep]
+            oneDf = df[ df['sweep']==sweep ]
             theValues = oneDf[statName]
 
             theCount = np.count_nonzero(~np.isnan(theValues))
             theMin = np.min(theValues)
             theMax = np.max(theValues)
             theMean = np.nanmean(theValues)
 
-            theMin = round(theMin, decimals)
-            theMax = round(theMax, decimals)
-            theMean = round(theMean, decimals)
+            theMin = round(theMin,decimals)
+            theMax = round(theMax,decimals)
+            theMean = round(theMean,decimals)
 
-            if theCount > 2:
+            if theCount>2:
                 theMedian = np.nanmedian(theValues)
                 theSEM = scipy.stats.sem(theValues)
                 theSD = np.nanstd(theValues)
                 theVar = np.nanvar(theValues)
                 theCV = theSD / theVar
 
-                theMedian = round(theMedian, decimals)
-                theSEM = round(theSEM, decimals)
-                theSD = round(theSD, decimals)
-                theVar = round(theVar, decimals)
-                theCV = round(theCV, decimals)
+                theMedian = round(theMedian,decimals)
+                theSEM = round(theSEM,decimals)
+                theSD = round(theSD,decimals)
+                theVar = round(theVar,decimals)
+                theCV = round(theCV,decimals)
 
             else:
                 theMedian = None
                 theSEM = None
                 theSD = None
                 theVar = None
                 theCV = None
 
             oneDict = {
-                statName + "_sweep": sweep,
-                statName + "_count": theCount,
-                statName + "_min": theMin,
-                statName + "_max": theMax,
-                statName + "_mean": theMean,
-                statName + "_median": theMedian,
-                statName + "_sem": theSEM,
-                statName + "_std": theSD,
-                statName + "_var": theVar,
-                statName + "_cv": theCV,
+                statName+'_sweep': sweep,
+                statName+'_count': theCount,
+                statName+'_min': theMin,
+                statName+'_max': theMax,
+                statName+'_mean': theMean,
+                statName+'_median': theMedian,
+                statName+'_sem': theSEM,
+                statName+'_std': theSD,
+                statName+'_var': theVar,
+                statName+'_cv': theCV,
             }
 
             sweepStatList.append(oneDict)
 
         #
         if asDataFrame:
             return pd.DataFrame(sweepStatList)
         else:
             return sweepStatList
 
-    def getStat(
-        self,
-        statName1,
-        statName2: Optional[str] = None,
-        sweepNumber: Optional[int] = None,
-        epochNumber: Optional[int] = None,
-        asArray: Optional[bool] = False,
-        getFullList : Optional[bool] = False
-    ):
+    def getStat(self, statName1, statName2 : Optional[str] = None,
+                sweepNumber : Optional[int] = None,
+                epochNumber : Optional[int] = None,
+                asArray : Optional[bool] = False):
         """Get a list of values for one or two analysis results.
 
         Parameters
         ----------
         statName1 : str
             Name of the first analysis parameter to retreive.
         statName2 : str
@@ -581,153 +532,117 @@
             List of analysis parameter values, None if error.
             Returns a np.array is asArray is True
         """
 
         def clean(val):
             """Convert None to float('nan')"""
             if val is None:
-                val = float("nan")
+                val = float('nan')
             return val
 
         x = []  # None
         y = []  # None
         error = False
         if len(self.spikeDict) == 0:
-            # logger.error(f'Did not find any spikes in spikeDict')
+            #logger.error(f'Did not find any spikes in spikeDict')
             error = True
         elif statName1 not in self.spikeDict[0].keys():
             logger.error(f'Did not find statName1: "{statName1}" in spikeDict')
             error = True
         elif statName2 is not None and statName2 not in self.spikeDict[0].keys():
             logger.error(f'Did not find statName2: "{statName2}" in spikeDict')
             error = True
 
         if sweepNumber is None:
-            sweepNumber = "All"
+            sweepNumber = 'All'
 
         if epochNumber is None:
-            epochNumber = "All"
+            epochNumber = 'All'
 
         if not error:
             # original
-            # x = [clean(spike[statName1]) for spike in self.spikeDict]
-            
-            if getFullList:
-                # April 15, 2023, trying to fix bug in scatter plugin when we are
-                # using sweep and epoch
-                # strategy is to return all spikes, just nan out the ones we 
-                # are not interested in
-                x = []
-                for spike in self.spikeDict:
-                    _include = \
-                        (sweepNumber == "All" or spike["sweep"] == sweepNumber) \
-                            and (epochNumber == "All" or spike["epoch"] == epochNumber)
-                    if _include:
-                        x.append(clean(spike[statName1]))
-                    else:
-                        x.append(float("nan"))
-            
-            else:
-                # only current sweep and epoch
-                # (1) was this
-                x = [
-                    clean(spike[statName1])
-                    for spike in self.spikeDict
-                    if (sweepNumber == "All" or spike["sweep"] == sweepNumber)
-                    and (epochNumber == "All" or spike["epoch"] == epochNumber)
-                ]
-
+            #x = [clean(spike[statName1]) for spike in self.spikeDict]
+            # only current spweek
+            x = [clean(spike[statName1]) for spike in
+                self.spikeDict if (sweepNumber=='All' or spike['sweep']==sweepNumber) and (epochNumber=='All' or spike['epoch']==epochNumber)]
 
             if statName2 is not None:
                 # original
-                # y = [clean(spike[statName2]) for spike in self.spikeDict]
+                #y = [clean(spike[statName2]) for spike in self.spikeDict]
                 # only current spweek
-                y = [
-                    clean(spike[statName2])
-                    for spike in self.spikeDict
-                    if sweepNumber == "All" or spike["sweep"] == sweepNumber
-                ]
+                y = [clean(spike[statName2]) for spike in self.spikeDict if sweepNumber=='All' or spike['sweep']==sweepNumber]
 
         if asArray:
             x = np.array(x)
             if statName2 is not None:
                 y = np.array(y)
 
         if statName2 is not None:
             return x, y
         else:
             return x
 
-    def getSpikeTimes(self, sweepNumber=None, epochNumber='All'):
-        """Get spike times (points) for current sweep"""
-        # theRet = [spike['thresholdPnt'] for spike in self.spikeDict if spike['sweep']==self.currentSweep]
-        theRet = self.getStat("thresholdPnt", sweepNumber=sweepNumber, epochNumber=epochNumber)
+    def getSpikeTimes(self, sweepNumber=None):
+        """Get spike times (points) for current sweep
+        """
+        #theRet = [spike['thresholdPnt'] for spike in self.spikeDict if spike['sweep']==self.currentSweep]
+        theRet = self.getStat('thresholdPnt', sweepNumber=sweepNumber)
         return theRet
 
     def getSpikeSeconds(self, sweepNumber=None):
-        """Get spike times (seconds) for current sweep"""
-        # theRet = [spike['thresholdSec'] for spike in self.spikeDict if spike['sweep']==self.currentSweep]
-        theRet = self.getStat("thresholdSec", sweepNumber=sweepNumber)
+        """Get spike times (seconds) for current sweep
+        """
+        #theRet = [spike['thresholdSec'] for spike in self.spikeDict if spike['sweep']==self.currentSweep]
+        theRet = self.getStat('thresholdSec', sweepNumber=sweepNumber)
         return theRet
 
     def getSpikeDictionaries(self, sweepNumber=None):
         """Get spike dictionaries for current sweep
         """
         if sweepNumber is None:
-            sweepNumber = "All"
-        # logger.info(f'sweepNumber:{sweepNumber}')
-        theRet = [
-            spike
-            for spike in self.spikeDict
-            if sweepNumber == "All" or spike["sweep"] == sweepNumber
-        ]
+            sweepNumber = 'All'
+        #logger.info(f'sweepNumber:{sweepNumber}')
+        theRet = [spike for spike in self.spikeDict if sweepNumber=='All' or spike['sweep']==sweepNumber]
         return theRet
 
-    def getOneSpikeDict(self, spikeNumber: int):
+    def getOneSpikeDict(self, spikeNumber : int):
         return self.spikeDict[spikeNumber]
-
+    
     def _rebuildFiltered(self):
         if self.fileLoader.sweepX is None:
             # no data
-            logger.warning("not getting derivative ... sweepX was none?")
+            logger.warning('not getting derivative ... sweepX was none?')
             return
 
-        if (
-            self.fileLoader.recordingMode == recordingModes.iclamp
-            or self.fileLoader.recordingMode == recordingModes.kymograph
-        ):
+        if self.fileLoader.recordingMode == recordingModes.iclamp or self.fileLoader.recordingMode == recordingModes.kymograph:
             self.fileLoader._getDerivative()
         elif self.fileLoader.recordingMode == recordingModes.vclamp:
             self.fileLoader._getDerivative()
         else:
-            logger.warning(
-                f'Did not take derivative, unknown recording mode "{self.fileLoader.recordingMode}"'
-            )
+            logger.warning(f'Did not take derivative, unknown recording mode "{self.fileLoader.recordingMode}"')
 
     def _getFilteredRecording(self):
         """
         Get a filtered version of recording, used for both V-Clamp and I-Clamp.
 
         Args:
             dDict (dict): Default detection dictionary. See bDetection.defaultDetection
         """
 
         if self._detectionDict is not None:
-            medianFilter = self._detectionDict["medianFilter"]
-            SavitzkyGolay_pnts = self._detectionDict["SavitzkyGolay_pnts"]
-            SavitzkyGolay_poly = self._detectionDict["SavitzkyGolay_poly"]
+            medianFilter = self._detectionDict['medianFilter']
+            SavitzkyGolay_pnts = self._detectionDict['SavitzkyGolay_pnts']
+            SavitzkyGolay_poly = self._detectionDict['SavitzkyGolay_poly']
         else:
             # we have not been analyzed, impose some defaults
             medianFilter = 0  # no median filter
             SavitzkyGolay_pnts = 5
             SavitzkyGolay_poly = 2
 
-        self.fileLoader._getDerivative(
-            medianFilter, SavitzkyGolay_pnts, SavitzkyGolay_poly
-        )
+        self.fileLoader._getDerivative(medianFilter, SavitzkyGolay_pnts, SavitzkyGolay_poly)
 
         # if medianFilter > 0:
         #     if not medianFilter % 2:
         #         medianFilter += 1
         #         logger.warning(f'Please use an odd value for the median filter, set medianFilter: {medianFilter}')
         #     medianFilter = int(medianFilter)
         #     self._filteredVm = scipy.signal.medfilt2d(self.sweepY(), [medianFilter,1])
@@ -743,147 +658,126 @@
         Backup spike time using deminishing SD and diff b/w vm at pnt[i]-pnt[i-1]
         Used when detecting with just mV threshold (not dv/dt)
 
         Args:
             spikeTimes (list of float):
             medianFilter (int): bin width
         """
-        # realSpikeTimePnts = [np.nan] * self.numSpikes
+        #realSpikeTimePnts = [np.nan] * self.numSpikes
         realSpikeTimePnts = [np.nan] * len(spikeTimes)
 
         medianFilter = 5
         sweepY = self.fileLoader.sweepY
-        if medianFilter > 0:
+        if medianFilter>0:
             myVm = scipy.signal.medfilt(sweepY, medianFilter)
         else:
             myVm = sweepY
 
         #
         # TODO: this is going to fail if spike is at start/stop of recorrding
         #
 
-        maxNumPntsToBackup = 20  # todo: add _ms
+        maxNumPntsToBackup = 20 # todo: add _ms
         bin_ms = 1
         bin_pnts = round(bin_ms * self.fileLoader.dataPointsPerMs)
-        half_bin_pnts = math.floor(bin_pnts / 2)
+        half_bin_pnts = math.floor(bin_pnts/2)
         for idx, spikeTimePnts in enumerate(spikeTimes):
             foundRealThresh = False
             thisMean = None
             thisSD = None
             backupNumPnts = 0
             atBinPnt = spikeTimePnts
             while not foundRealThresh:
-                thisWin = myVm[atBinPnt - half_bin_pnts : atBinPnt + half_bin_pnts]
+                thisWin = myVm[atBinPnt-half_bin_pnts: atBinPnt+half_bin_pnts]
                 if thisMean is None:
                     thisMean = np.mean(thisWin)
                     thisSD = np.std(thisWin)
 
-                nextStart = atBinPnt - 1 - bin_pnts - half_bin_pnts
-                nextStop = atBinPnt - 1 - bin_pnts + half_bin_pnts
+                nextStart = atBinPnt-1-bin_pnts-half_bin_pnts
+                nextStop = atBinPnt-1-bin_pnts+half_bin_pnts
                 nextWin = myVm[nextStart:nextStop]
                 nextMean = np.mean(nextWin)
                 nextSD = np.std(nextWin)
 
                 meanDiff = thisMean - nextMean
                 # logic
-                sdMult = 0.7  # 2
-                if (meanDiff < nextSD * sdMult) or (
-                    backupNumPnts == maxNumPntsToBackup
-                ):
+                sdMult = 0.7 # 2
+                if (meanDiff < nextSD * sdMult) or (backupNumPnts==maxNumPntsToBackup):
                     # second clause will force us to terminate (this recording has a very slow rise time)
                     # bingo!
                     foundRealThresh = True
                     # not this xxx but the previous
                     moveForwardPnts = 4
-                    backupNumPnts = backupNumPnts - 1  # the prev is thresh
-                    if backupNumPnts < moveForwardPnts:
-                        logger.warning(
-                            f"spike {idx} backupNumPnts:{backupNumPnts} < moveForwardPnts:{moveForwardPnts}"
-                        )
-                        # print('  -->> not adjusting spike time')
+                    backupNumPnts = backupNumPnts - 1 # the prev is thresh
+                    if backupNumPnts<moveForwardPnts:
+                        logger.warning(f'spike {idx} backupNumPnts:{backupNumPnts} < moveForwardPnts:{moveForwardPnts}')
+                        #print('  -->> not adjusting spike time')
                         realBackupPnts = backupNumPnts - 0
-                        realPnt = spikeTimePnts - (realBackupPnts * bin_pnts)
+                        realPnt = spikeTimePnts - (realBackupPnts*bin_pnts)
 
                     else:
                         realBackupPnts = backupNumPnts - moveForwardPnts
-                        realPnt = spikeTimePnts - (realBackupPnts * bin_pnts)
+                        realPnt = spikeTimePnts - (realBackupPnts*bin_pnts)
                     #
                     realSpikeTimePnts[idx] = realPnt
 
                 # increment
                 thisMean = nextMean
                 thisSD = nextSD
 
                 atBinPnt -= bin_pnts
                 backupNumPnts += 1
-                """
+                '''
                 if backupNumPnts>maxNumPntsToBackup:
                     print(f'  WARNING: _backupSpikeVm() exiting spike {idx} ... reached maxNumPntsToBackup:{maxNumPntsToBackup}')
                     print('  -->> not adjusting spike time')
                     foundRealThresh = True # set this so we exit the loop
                     realSpikeTimePnts[idx] = spikeTimePnts
-                """
+                '''
 
         #
         return realSpikeTimePnts
 
     def _throwOutRefractory(self, spikeTimes0, goodSpikeErrors, refractory_ms=20):
         """
         spikeTimes0: spike times to consider
         goodSpikeErrors: list of errors per spike, can be None
         refractory_ms:
         """
         before = len(spikeTimes0)
 
         # if there are doubles, throw-out the second one
-        # refractory_ms = 20 #10 # remove spike [i] if it occurs within refractory_ms of spike [i-1]
-        lastGood = 0  # first spike [0] will always be good, there is no spike [i-1]
+        #refractory_ms = 20 #10 # remove spike [i] if it occurs within refractory_ms of spike [i-1]
+        lastGood = 0 # first spike [0] will always be good, there is no spike [i-1]
         for i in range(len(spikeTimes0)):
-            if i == 0:
+            if i==0:
                 # first spike is always good
                 continue
             dPoints = spikeTimes0[i] - spikeTimes0[lastGood]
-            if dPoints < self.fileLoader.dataPointsPerMs * refractory_ms:
+            if dPoints < self.fileLoader.dataPointsPerMs*refractory_ms:
                 # remove spike time [i]
                 spikeTimes0[i] = 0
             else:
                 # spike time [i] was good
                 lastGood = i
         # regenerate spikeTimes0 by throwing out any spike time that does not pass 'if spikeTime'
         # spikeTimes[i] that were set to 0 above (they were too close to the previous spike)
         # will not pass 'if spikeTime', as 'if 0' evaluates to False
         if goodSpikeErrors is not None:
-            goodSpikeErrors = [
-                goodSpikeErrors[idx]
-                for idx, spikeTime in enumerate(spikeTimes0)
-                if spikeTime
-            ]
+            goodSpikeErrors = [goodSpikeErrors[idx] for idx, spikeTime in enumerate(spikeTimes0) if spikeTime]
         spikeTimes0 = [spikeTime for spikeTime in spikeTimes0 if spikeTime]
 
         # TODO: put back in and log if detection ['verbose']
         after = len(spikeTimes0)
-        if self._detectionDict["verbose"]:
-            logger.info(
-                f"From {before} to {after} spikes with refractory_ms:{refractory_ms}"
-            )
+        if self._detectionDict['verbose']:
+            logger.info(f'From {before} to {after} spikes with refractory_ms:{refractory_ms}')
 
         return spikeTimes0, goodSpikeErrors
 
-    def _getHalfWidth(
-        self,
-        vm,
-        iIdx,
-        spikeDict,
-        thresholdPnt,
-        peakPnt,
-        hwWindowPnts,
-        dataPointsPerMs,
-        halfHeightList,
-        verbose=False,
-    ):
+    def _getHalfWidth(self, vm, iIdx, spikeDict, thresholdPnt, peakPnt, hwWindowPnts, dataPointsPerMs, halfHeightList, verbose=False):
         """
         Get half-widhts for one spike.
 
         Note: Want to make this standalone function outside of class but we need self._getErrorDict()
 
         Args:
             vm ():
@@ -899,632 +793,556 @@
 
         halfWidthWindow_ms = hwWindowPnts / dataPointsPerMs
 
         thresholdVal = vm[thresholdPnt]
         peakVal = vm[peakPnt]
         spikeHeight = peakVal - thresholdVal
 
-        spikeSecond = thresholdPnt / dataPointsPerMs / 1000
-        peakSec = peakPnt / dataPointsPerMs / 1000
+        spikeSecond = thresholdPnt / dataPointsPerMs /1000
+        peakSec = peakPnt / dataPointsPerMs /1000
 
         widthDictList = []
         errorList = []
 
         # clear out any existing list
-        spikeDict[iIdx]["widths"] = []
+        spikeDict[iIdx]['widths'] = []
 
         tmpErrorType = None
         for j, halfHeight in enumerate(halfHeightList):
             # halfHeight in [20, 50, 80]
 
             # search rising/falling phae of vm for this vm
             thisVm = thresholdVal + spikeHeight * (halfHeight * 0.01)
 
-            # todo: logic is broken, this get over-written in following try
+            #todo: logic is broken, this get over-written in following try
             widthDict = {
-                "halfHeight": halfHeight,
-                "risingPnt": None,
+                'halfHeight': halfHeight,
+                'risingPnt': None,
                 #'risingVal': defaultVal,
-                "fallingPnt": None,
+                'fallingPnt': None,
                 #'fallingVal': defaultVal,
-                "widthPnts": None,
-                "widthMs": float("nan"),
+                'widthPnts': None,
+                'widthMs': float('nan')
             }
-            widthMs = float("nan")
+            widthMs = float('nan')
             try:
-                postRange = vm[peakPnt : peakPnt + hwWindowPnts]
-                fallingPnt = np.where(postRange < thisVm)[0]  # less than
-                if len(fallingPnt) == 0:
+                postRange = vm[peakPnt:peakPnt+hwWindowPnts]
+                fallingPnt = np.where(postRange<thisVm)[0] # less than
+                if len(fallingPnt)==0:
                     # no falling pnts found within hwWindowPnts
-                    tmpErrorType = "falling point"
+                    tmpErrorType = 'falling point'
                     raise IndexError
-                fallingPnt = fallingPnt[0]  # first falling point
+                fallingPnt = fallingPnt[0] # first falling point
                 fallingPnt += peakPnt
                 fallingVal = vm[fallingPnt]
 
                 # use the post/falling to find pre/rising
                 preRange = vm[thresholdPnt:peakPnt]
-                risingPnt = np.where(preRange > fallingVal)[0]  # greater than
-                if len(risingPnt) == 0:
-                    tmpErrorType = "rising point"
+                risingPnt = np.where(preRange>fallingVal)[0] # greater than
+                if len(risingPnt)==0:
+                    tmpErrorType = 'rising point'
                     raise IndexError
-                risingPnt = risingPnt[0]  # first rising point
+                risingPnt = risingPnt[0] # first rising point
                 risingPnt += thresholdPnt
-                # risingVal = vm[risingPnt]
+                #risingVal = vm[risingPnt]
 
                 # width (pnts)
                 widthPnts = fallingPnt - risingPnt
                 widthMs = widthPnts / dataPointsPerMs
                 # 20210825 may want to add this to analysis
-                # widthPnts2 = fallingPnt - thresholdPnt
+                #widthPnts2 = fallingPnt - thresholdPnt
                 # assign
-                widthDict["halfHeight"] = halfHeight
-                widthDict["risingPnt"] = risingPnt
-                # widthDict['risingVal'] = risingVal
-                widthDict["fallingPnt"] = fallingPnt
-                # widthDict['fallingVal'] = fallingVal
-                widthDict["widthPnts"] = widthPnts
-                widthDict["widthMs"] = widthMs
-                # widthMs = widthPnts / dataPointsPerMs # abb 20210125
+                widthDict['halfHeight'] = halfHeight
+                widthDict['risingPnt'] = risingPnt
+                #widthDict['risingVal'] = risingVal
+                widthDict['fallingPnt'] = fallingPnt
+                #widthDict['fallingVal'] = fallingVal
+                widthDict['widthPnts'] = widthPnts
+                widthDict['widthMs'] = widthMs
+                #widthMs = widthPnts / dataPointsPerMs # abb 20210125
 
                 # may want to add this
-                # widthDict['widthPnts2'] = widthPnts2
-                # widthDict['widthMs2'] = widthPnts2 / dataPointsPerMs
+                #widthDict['widthPnts2'] = widthPnts2
+                #widthDict['widthMs2'] = widthPnts2 / dataPointsPerMs
 
-            except IndexError as e:
-                errorType = "Spike Width"
-                errorStr = (
-                    f'Half width {halfHeight} error in "{tmpErrorType}" '
-                    f"with halfWidthWindow_ms:{halfWidthWindow_ms} "
-                    f"searching for Vm:{round(thisVm,2)} from peak sec {round(peakSec,2)}"
-                )
+            except (IndexError) as e:
+                errorType = 'Spike Width'
+                errorStr = (f'Half width {halfHeight} error in "{tmpErrorType}" '
+                        f"with halfWidthWindow_ms:{halfWidthWindow_ms} "
+                        f'searching for Vm:{round(thisVm,2)} from peak sec {round(peakSec,2)}'
+                        )
 
                 # was this
-                # eDict = self._getErrorDict(spikeNumber, thresholdPnt, errorType, errorStr) # spikeTime is in pnts
-                eDict = self._getErrorDict(
-                    iIdx, thresholdPnt, errorType, errorStr
-                )  # spikeTime is in pnts
-                # self.spikeDict[dictNumber]['errors'].append(eDict)
-                spikeDict[iIdx]["errors"].append(eDict)
+                #eDict = self._getErrorDict(spikeNumber, thresholdPnt, errorType, errorStr) # spikeTime is in pnts
+                eDict = self._getErrorDict(iIdx, thresholdPnt, errorType, errorStr) # spikeTime is in pnts
+                #self.spikeDict[dictNumber]['errors'].append(eDict)
+                spikeDict[iIdx]['errors'].append(eDict)
                 if verbose:
-                    print(
-                        f"_getHalfWidth() error iIdx:{iIdx} j:{j} halfHeight:{halfHeight} eDict:{eDict}"
-                    )
+                    print(f'_getHalfWidth() error iIdx:{iIdx} j:{j} halfHeight:{halfHeight} eDict:{eDict}')
             #
-            # self.spikeDict[dictNumber]['widths_'+str(halfHeight)] = widthMs
-            # self.spikeDict[dictNumber]['widths'][j] = widthDict
+            #self.spikeDict[dictNumber]['widths_'+str(halfHeight)] = widthMs
+            #self.spikeDict[dictNumber]['widths'][j] = widthDict
 
-            # logger.info('================')
-            # print(f'len(spikeDict):{len(spikeDict)} iIdx:{iIdx} j:{j} widthDict:{widthDict}')
+            #logger.info('================')
+            #print(f'len(spikeDict):{len(spikeDict)} iIdx:{iIdx} j:{j} widthDict:{widthDict}')
 
-            spikeDict[iIdx]["widths_" + str(halfHeight)] = widthMs
-            # spikeDict[iIdx]['widths'][j] = widthDict
-            spikeDict[iIdx]["widths"].append(widthDict)
+            spikeDict[iIdx]['widths_'+str(halfHeight)] = widthMs
+            #spikeDict[iIdx]['widths'][j] = widthDict
+            spikeDict[iIdx]['widths'].append(widthDict)
 
         #
-        # return widthDictList, errorList
+        #return widthDictList, errorList
 
-    def _getErrorDict(self, spikeNumber, pnt, _type : str, detailStr) -> dict:
-        """Get error dict for one spike
-        
-        Notes
-        -----
-        Can't use self.getSpikeStat() because it is not created yet.
-            We are in the middle of analysis
+    def _getErrorDict(self, spikeNumber, pnt, type, detailStr):
         """
-        sec = self.fileLoader.pnt2Sec_(pnt)  # pnt / self.dataPointsPerMs / 1000
-        sec = round(sec, 4)
+        Get error dict for one spike
 
-        # print(f'  spikeNumber: {spikeNumber} {type(spikeNumber)}')
-        # print('    sweep:', self.getSpikeStat([spikeNumber], 'sweep'))
+        TODO: xxx
+        """
+        sec = self.fileLoader.pnt2Sec_(pnt)  # pnt / self.dataPointsPerMs / 1000
+        sec = round(sec,4)
 
         eDict = {
-            "Spike": spikeNumber,
-            "Seconds": sec,
-            "Sweep": '',  # self.getSpikeStat([spikeNumber], 'sweep')[0],
-            "Epoch": '',  # self.getSpikeStat([spikeNumber], 'epoch')[0],
-            "Type": _type,
-            "Details": detailStr,
+            'Spike': spikeNumber,
+            'Seconds': sec,
+            'Type': type,
+            'Details': detailStr,
         }
         return eDict
 
-    def _spikeDetect_dvdt(self, dDict: dict, sweepNumber: int, verbose: bool = False):
+    def _spikeDetect_dvdt(self, dDict : dict, sweepNumber : int, verbose : bool = False):
         """
         Search for threshold crossings (dvdtThreshold) in first derivative (dV/dt) of membrane potential (Vm)
         append each threshold crossing (e.g. a spike) in self.spikeTimes list
 
         Returns:
             self.spikeTimes (pnts): the time before each threshold crossing when dv/dt crosses 15% of its max
             self.filteredVm:
             self.filtereddVdt:
         """
 
         #
         # analyze full recording
         filteredDeriv = self.fileLoader.filteredDeriv
-        Is = np.where(filteredDeriv > dDict["dvdtThreshold"])[0]
-        Is = np.concatenate(([0], Is))
-        Ds = Is[:-1] - Is[1:] + 1
-        spikeTimes0 = Is[np.where(Ds)[0] + 1]
+        Is=np.where(filteredDeriv>dDict['dvdtThreshold'])[0]
+        Is=np.concatenate(([0],Is))
+        Ds=Is[:-1]-Is[1:]+1
+        spikeTimes0 = Is[np.where(Ds)[0]+1]
 
         #
         # reduce spike times based on start/stop
-        # logger.error('THIS IS a BUg if start sec is none then set to 0 !!!')
+        #logger.error('THIS IS a BUg if start sec is none then set to 0 !!!')
         # THIS IS ABUG ... FIX
-        if dDict["startSeconds"] is not None and dDict["stopSeconds"] is not None:
-            startPnt = self.fileLoader.dataPointsPerMs * (
-                dDict["startSeconds"] * 1000
-            )  # seconds to pnt
-            stopPnt = self.fileLoader.dataPointsPerMs * (
-                dDict["stopSeconds"] * 1000
-            )  # seconds to pnt
-            tmpSpikeTimes = [
-                spikeTime
-                for spikeTime in spikeTimes0
-                if (spikeTime >= startPnt and spikeTime <= stopPnt)
-            ]
+        if dDict['startSeconds'] is not None and dDict['stopSeconds'] is not None:
+            startPnt = self.fileLoader.dataPointsPerMs * (dDict['startSeconds']*1000) # seconds to pnt
+            stopPnt = self.fileLoader.dataPointsPerMs * (dDict['stopSeconds']*1000) # seconds to pnt
+            tmpSpikeTimes = [spikeTime for spikeTime in spikeTimes0 if (spikeTime>=startPnt and spikeTime<=stopPnt)]
             spikeTimes0 = tmpSpikeTimes
 
         #
         # throw out all spikes that are below a threshold Vm (usually below -20 mV)
-        peakWindow_pnts = self.fileLoader.ms2Pnt_(dDict["peakWindow_ms"])
-        # peakWindow_pnts = self.dataPointsPerMs * dDict['peakWindow_ms']
-        # peakWindow_pnts = round(peakWindow_pnts)
+        peakWindow_pnts = self.fileLoader.ms2Pnt_(dDict['peakWindow_ms'])
+        #peakWindow_pnts = self.dataPointsPerMs * dDict['peakWindow_ms']
+        #peakWindow_pnts = round(peakWindow_pnts)
         goodSpikeTimes = []
         sweepY = self.fileLoader.sweepY
         for spikeTime in spikeTimes0:
-            peakVal = np.max(sweepY[spikeTime : spikeTime + peakWindow_pnts])
-            if peakVal > dDict["mvThreshold"]:
+            peakVal = np.max(sweepY[spikeTime:spikeTime+peakWindow_pnts])
+            if peakVal > dDict['mvThreshold']:
                 goodSpikeTimes.append(spikeTime)
         spikeTimes0 = goodSpikeTimes
 
         #
         # throw out spike that are not upward deflections of Vm
-        """
+        '''
         prePntUp = 7 # pnts
         goodSpikeTimes = []
         for spikeTime in spikeTimes0:
             preAvg = np.average(self.abf.sweepY[spikeTime-prePntUp:spikeTime-1])
             postAvg = np.average(self.abf.sweepY[spikeTime+1:spikeTime+prePntUp])
             #print(preAvg, postAvg)
             if preAvg < postAvg:
                 goodSpikeTimes.append(spikeTime)
         spikeTimes0 = goodSpikeTimes
-        """
+        '''
 
         #
         # if there are doubles, throw-out the second one
         spikeTimeErrors = None
-        spikeTimes0, ignoreSpikeErrors = self._throwOutRefractory(
-            spikeTimes0, spikeTimeErrors, refractory_ms=dDict["refractory_ms"]
-        )
-
-        # logger.warning('REMOVED SPIKE TOP AS % OF DVDT')
-        # return spikeTimes0, [None] * len(spikeTimes0)
+        spikeTimes0, ignoreSpikeErrors = self._throwOutRefractory(spikeTimes0, spikeTimeErrors, refractory_ms=dDict['refractory_ms'])
 
+        #logger.warning('REMOVED SPIKE TOP AS % OF DVDT')
+        #return spikeTimes0, [None] * len(spikeTimes0)
+        
         #
         # for each threshold crossing, search backwards in dV/dt for a % of maximum (about 10 ms)
-        # dvdt_percentOfMax = 0.1
-        # window_ms = 2
-        window_pnts = dDict["dvdtPreWindow_ms"] * self.fileLoader.dataPointsPerMs
+        #dvdt_percentOfMax = 0.1
+        #window_ms = 2
+        window_pnts = dDict['dvdtPreWindow_ms'] * self.fileLoader.dataPointsPerMs
         # abb 20210130 lcr analysis
         window_pnts = round(window_pnts)
         spikeTimes1 = []
         spikeErrorList1 = []
         filteredDeriv = self.fileLoader.filteredDeriv
         for i, spikeTime in enumerate(spikeTimes0):
             # get max in derivative
 
-            preDerivClip = filteredDeriv[
-                spikeTime - window_pnts : spikeTime
-            ]  # backwards
-            postDerivClip = filteredDeriv[
-                spikeTime : spikeTime + window_pnts
-            ]  # forwards
+            preDerivClip = filteredDeriv[spikeTime-window_pnts:spikeTime] # backwards
+            postDerivClip = filteredDeriv[spikeTime:spikeTime+window_pnts] # forwards
 
             if len(preDerivClip) == 0:
-                print(
-                    "FIX ERROR: spikeDetect_dvdt()",
-                    "spike",
-                    i,
-                    "at pnt",
-                    spikeTime,
-                    "window_pnts:",
-                    window_pnts,
-                    "dvdtPreWindow_ms:",
-                    dDict["dvdtPreWindow_ms"],
-                    "len(preDerivClip)",
-                    len(preDerivClip),
-                )  # preDerivClip = np.flip(preDerivClip)
+                print('FIX ERROR: spikeDetect_dvdt()',
+                        'spike', i, 'at pnt', spikeTime,
+                        'window_pnts:', window_pnts,
+                        'dvdtPreWindow_ms:', dDict['dvdtPreWindow_ms'],
+                        'len(preDerivClip)', len(preDerivClip))#preDerivClip = np.flip(preDerivClip)
 
             # look for % of max in dvdt
             try:
-                # peakPnt = np.argmax(preDerivClip)
+                #peakPnt = np.argmax(preDerivClip)
                 peakPnt = np.argmax(postDerivClip)
-                # peakPnt += spikeTime-window_pnts
+                #peakPnt += spikeTime-window_pnts
                 peakPnt += spikeTime
                 peakVal = filteredDeriv[peakPnt]
 
-                percentMaxVal = (
-                    peakVal * dDict["dvdt_percentOfMax"]
-                )  # value we are looking for in dv/dt
-                preDerivClip = np.flip(preDerivClip)  # backwards
-                tmpWhere = np.where(preDerivClip < percentMaxVal)
-                # print('tmpWhere:', type(tmpWhere), tmpWhere)
+                percentMaxVal = peakVal * dDict['dvdt_percentOfMax'] # value we are looking for in dv/dt
+                preDerivClip = np.flip(preDerivClip) # backwards
+                tmpWhere = np.where(preDerivClip<percentMaxVal)
+                #print('tmpWhere:', type(tmpWhere), tmpWhere)
                 tmpWhere = tmpWhere[0]
                 if len(tmpWhere) > 0:
-                    threshPnt2 = np.where(preDerivClip < percentMaxVal)[0][0]
+                    threshPnt2 = np.where(preDerivClip<percentMaxVal)[0][0]
                     threshPnt2 = (spikeTime) - threshPnt2
-                    # print('i:', i, 'spikeTime:', spikeTime, 'peakPnt:', peakPnt, 'threshPnt2:', threshPnt2)
-                    threshPnt2 -= 1  # backup by 1 pnt
+                    #print('i:', i, 'spikeTime:', spikeTime, 'peakPnt:', peakPnt, 'threshPnt2:', threshPnt2)
+                    threshPnt2 -= 1 # backup by 1 pnt
                     spikeTimes1.append(threshPnt2)
                     spikeErrorList1.append(None)
 
                 else:
-                    errorType = "dvdt Percent"
+                    errorType = 'dvdt Percent'
                     errStr = f"Did not find dvdt_percentOfMax: {dDict['dvdt_percentOfMax']} peak dV/dt is {round(peakVal,2)}"
-                    eDict = self._getErrorDict(
-                        i, spikeTime, errorType, errStr
-                    )  # spikeTime is in pnts
+                    eDict = self._getErrorDict(i, spikeTime, errorType, errStr) # spikeTime is in pnts
                     spikeErrorList1.append(eDict)
                     # always append, do not REJECT spike if we can't find % in dv/dt
                     spikeTimes1.append(spikeTime)
             except (IndexError, ValueError) as e:
                 ##
-                print(
-                    "   FIX ERROR: bAnalysis.spikeDetect_dvdt() looking for dvdt_percentOfMax"
-                )
-                print("      ", "IndexError for spike", i, spikeTime)
-                print("      ", e)
+                print('   FIX ERROR: bAnalysis.spikeDetect_dvdt() looking for dvdt_percentOfMax')
+                print('      ', 'IndexError for spike', i, spikeTime)
+                print('      ', e)
                 # always append, do not REJECT spike if we can't find % in dv/dt
                 spikeTimes1.append(spikeTime)
 
         return spikeTimes1, spikeErrorList1
 
-    def _spikeDetect_vm(self, dDict: dict, sweepNumber: int, verbose: bool = False):
+    def _spikeDetect_vm(self, dDict : dict, sweepNumber : int, verbose : bool = False):
         """
         spike detect using Vm threshold and NOT dvdt
         append each threshold crossing (e.g. a spike) in self.spikeTimes list
 
         Returns:
             self.spikeTimes (pnts): the time before each threshold crossing when dv/dt crosses 15% of its max
             self.filteredVm:
             self.filtereddVdt:
         """
 
         filteredVm = self.fileLoader.sweepY_filtered
-        Is = np.where(filteredVm > dDict["mvThreshold"])[0]  # returns boolean array
-        Is = np.concatenate(([0], Is))
-        Ds = Is[:-1] - Is[1:] + 1
-        spikeTimes0 = Is[np.where(Ds)[0] + 1]
+        Is=np.where(filteredVm>dDict['mvThreshold'])[0] # returns boolean array
+        Is=np.concatenate(([0],Is))
+        Ds=Is[:-1]-Is[1:]+1
+        spikeTimes0 = Is[np.where(Ds)[0]+1]
 
         #
         # reduce spike times based on start/stop
-        if dDict["startSeconds"] is not None and dDict["stopSeconds"] is not None:
-            startPnt = self.fileLoader.dataPointsPerMs * (
-                dDict["startSeconds"] * 1000
-            )  # seconds to pnt
-            stopPnt = self.fileLoader.dataPointsPerMs * (
-                dDict["stopSeconds"] * 1000
-            )  # seconds to pnt
-            tmpSpikeTimes = [
-                spikeTime
-                for spikeTime in spikeTimes0
-                if (spikeTime >= startPnt and spikeTime <= stopPnt)
-            ]
+        if dDict['startSeconds'] is not None and dDict['stopSeconds'] is not None:
+            startPnt = self.fileLoader.dataPointsPerMs * (dDict['startSeconds']*1000) # seconds to pnt
+            stopPnt = self.fileLoader.dataPointsPerMs * (dDict['stopSeconds']*1000) # seconds to pnt
+            tmpSpikeTimes = [spikeTime for spikeTime in spikeTimes0 if (spikeTime>=startPnt and spikeTime<=stopPnt)]
             spikeTimes0 = tmpSpikeTimes
 
         spikeErrorList = [None] * len(spikeTimes0)
 
         #
         # throw out all spikes that are below a threshold Vm (usually below -20 mV)
-        # spikeTimes0 = [spikeTime for spikeTime in spikeTimes0 if self.abf.sweepY[spikeTime] > self.mvThreshold]
+        #spikeTimes0 = [spikeTime for spikeTime in spikeTimes0 if self.abf.sweepY[spikeTime] > self.mvThreshold]
         # 20190623 - already done in this vm threshold funtion
-        """
+        '''
         peakWindow_ms = 10
         peakWindow_pnts = self.abf.dataPointsPerMs * peakWindow_ms
         goodSpikeTimes = []
         for spikeTime in spikeTimes0:
             peakVal = np.max(self.abf.sweepY[spikeTime:spikeTime+peakWindow_pnts])
             if peakVal > self.mvThreshold:
                 goodSpikeTimes.append(spikeTime)
         spikeTimes0 = goodSpikeTimes
-        """
+        '''
 
         #
         # throw out spike that are NOT upward deflections of Vm
         tmpLastGoodSpike_pnts = None
-        # minISI_pnts = 5000 # at 20 kHz this is 0.25 sec
-        minISI_ms = 75  # 250
+        #minISI_pnts = 5000 # at 20 kHz this is 0.25 sec
+        minISI_ms = 75 #250
         minISI_pnts = self.fileLoader.ms2Pnt_(minISI_ms)
 
-        prePntUp = 10  # pnts
+        prePntUp = 10 # pnts
         goodSpikeTimes = []
         goodSpikeErrors = []
         sweepY = self.fileLoader.sweepY
         for tmpIdx, spikeTime in enumerate(spikeTimes0):
-            tmpFuckPreClip = sweepY[
-                spikeTime - prePntUp : spikeTime
-            ]  # not including the stop index
-            tmpFuckPostClip = sweepY[
-                spikeTime + 1 : spikeTime + prePntUp + 1
-            ]  # not including the stop index
+            tmpFuckPreClip = sweepY[spikeTime-prePntUp:spikeTime]  # not including the stop index
+            tmpFuckPostClip = sweepY[spikeTime+1:spikeTime+prePntUp+1]  # not including the stop index
             preAvg = np.average(tmpFuckPreClip)
             postAvg = np.average(tmpFuckPostClip)
             if postAvg > preAvg:
                 # tmpSpikeTimeSec = self.fileLoader.pnt2Sec_(spikeTime)
-                if (
-                    tmpLastGoodSpike_pnts is not None
-                    and (spikeTime - tmpLastGoodSpike_pnts) < minISI_pnts
-                ):
+                if tmpLastGoodSpike_pnts is not None and (spikeTime-tmpLastGoodSpike_pnts) < minISI_pnts:
                     continue
                 goodSpikeTimes.append(spikeTime)
                 goodSpikeErrors.append(spikeErrorList[tmpIdx])
                 tmpLastGoodSpike_pnts = spikeTime
             else:
                 tmpSpikeTimeSec = self.fileLoader.pnt2Sec_(spikeTime)
 
         # todo: add this to spikeDetect_dvdt()
-        goodSpikeTimes, goodSpikeErrors = self._throwOutRefractory(
-            goodSpikeTimes, goodSpikeErrors, refractory_ms=dDict["refractory_ms"]
-        )
+        goodSpikeTimes, goodSpikeErrors = self._throwOutRefractory(goodSpikeTimes, goodSpikeErrors, refractory_ms=dDict['refractory_ms'])
         spikeTimes0 = goodSpikeTimes
         spikeErrorList = goodSpikeErrors
 
         #
         return spikeTimes0, spikeErrorList
 
-    def spikeDetect(self, detectionDict: dict):
+    def spikeDetect(self, detectionDict : dict):
         """Run spike detection for all sweeps.
 
         Each spike is a row and has 'sweep'
 
         Args:
             detectionDict: From sanpy.bDetection
         """
 
-        rememberSweep = (
-            self.fileLoader.currentSweep
-        )  # This is BAD we are mixing analysis with interface !!!
+        rememberSweep = self.fileLoader.currentSweep  # This is BAD we are mixing analysis with interface !!!
 
         startTime = time.time()
 
         #
         # todo: ask user if they want to remove their settings for (isBad, userType)
         #
 
         self._detectionDict = detectionDict
 
-        if detectionDict["verbose"]:
-            logger.info("=== detectionDict is:")
+        if detectionDict['verbose']:
+            logger.info('=== detectionDict is:')
             for k in detectionDict.keys():
                 v = detectionDict[k]
                 print(f'  {k} value:"{v}" is type {type(v)}')
 
         self._isAnalyzed = True
 
         self.spikeDict = sanpy.bAnalysisResults.analysisResultList()
-        # we are filling this in, one dict for each spike
-        # self.spikeDict = [] # we are filling this in, one dict for each spike
+         # we are filling this in, one dict for each spike
+        #self.spikeDict = [] # we are filling this in, one dict for each spike
 
-        # self._spikesPerSweep = [0] * self.fileLoader.numSweeps
+        #self._spikesPerSweep = [0] * self.fileLoader.numSweeps
 
         for sweepNumber in self.fileLoader.sweepList:
-            # self.setSweep(sweep)
+            #self.setSweep(sweep)
             self._spikeDetect2(sweepNumber)
 
         #
         self.fileLoader.setSweep(rememberSweep)
 
         stopTime = time.time()
 
-        if detectionDict["verbose"]:
-            logger.info(
-                f"Detected {len(self.spikeDict)} spikes in {round(stopTime-startTime,3)} seconds"
-            )
+        if detectionDict['verbose']:
+            logger.info(f'Detected {len(self.spikeDict)} spikes in {round(stopTime-startTime,3)} seconds')
 
-    def _spikeDetect2(self, sweepNumber: int):
+    def _spikeDetect2(self, sweepNumber : int):
         """Detect all spikes in one sweep.
 
          Populate bAnalysisResult.py.
 
         Notes
         -----
         First spike in a sweep cannot have interval statistics like freq or isi
 
         Parameters
         ----------
         sweepNumber : int
         """
         dDict = self._detectionDict
-
+        
         # a list of dict of sanpy.bAnalysisResults.analysisResult (one dict per spike)
         spikeDict = sanpy.bAnalysisResults.analysisResultList()
 
-        verbose = dDict["verbose"]
-
+        verbose = dDict['verbose']
+        
         #
         self.fileLoader.setSweep(sweepNumber)
         #
 
         # in case dDict has new filter values
         self._getFilteredRecording()
 
         #
         # spike detect
-        detectionType = dDict["detectionType"]
+        detectionType = dDict['detectionType']
 
         # detect all spikes either with dvdt or mv
-        if detectionType == sanpy.bDetection.detectionTypes["mv"].value:
+        if detectionType == sanpy.bDetection.detectionTypes['mv'].value:
             # detect using mV threshold
             spikeTimes, spikeErrorList = self._spikeDetect_vm(dDict, sweepNumber)
 
             # TODO: get rid of this and replace with foot
             # backup childish vm threshold
-            if dDict["doBackupSpikeVm"]:
-                spikeTimes = self._backupSpikeVm(
-                    spikeTimes, sweepNumber, dDict["medianFilter"]
-                )
-        elif detectionType == sanpy.bDetection.detectionTypes["dvdt"].value:
+            if dDict['doBackupSpikeVm']:
+                spikeTimes = self._backupSpikeVm(spikeTimes, sweepNumber, dDict['medianFilter'])
+        elif detectionType == sanpy.bDetection.detectionTypes['dvdt'].value:
             # detect using dv/dt threshold AND min mV
             spikeTimes, spikeErrorList = self._spikeDetect_dvdt(dDict, sweepNumber)
         else:
             logger.error(f'Unknown detection type "{detectionType}"')
             return
 
         #
         # backup thrshold to zero crossing in dvdt
         if 0:
-            tmp_window_ms = dDict["dvdtPreWindow_ms"]
+            tmp_window_ms = dDict['dvdtPreWindow_ms']
             tmp_window_pnts = self.fileLoader.ms2Pnt_(tmp_window_ms)
             spikeTimes = self._getFeet(spikeTimes, tmp_window_pnts)
 
         #
         # set up
         sweepX = self.fileLoader.sweepX  # sweepNumber is not optional
         filteredVm = self.fileLoader.sweepY_filtered  # sweepNumber is not optional
         filteredDeriv = self.fileLoader.filteredDeriv
         sweepC = self.fileLoader.sweepC
 
         #
         now = datetime.datetime.now()
-        dateStr = now.strftime("%Y%m%d")
-        timeStr = now.strftime("%H:%M:%S")
+        dateStr = now.strftime('%Y%m%d')
+        timeStr = now.strftime('%H:%M:%S')
         self.dateAnalyzed = dateStr
 
         #
         # look in a window after each threshold crossing to get AP peak
-        peakWindow_pnts = self.fileLoader.ms2Pnt_(dDict["peakWindow_ms"])
+        peakWindow_pnts = self.fileLoader.ms2Pnt_(dDict['peakWindow_ms'])
 
         #
         # throw out spikes that have peak BELOW onlyPeaksAbove_mV
         # throw out spikes that have peak ABOVE onlyPeaksBelow_mV
-        onlyPeaksAbove_mV = dDict["onlyPeaksAbove_mV"]
-        onlyPeaksBelow_mV = dDict["onlyPeaksBelow_mV"]
-        (
-            spikeTimes,
-            spikeErrorList,
-            newSpikePeakPnt,
-            newSpikePeakVal,
-        ) = sanpy.analysisUtil.throwOutAboveBelow(
-            filteredVm,
-            spikeTimes,
-            spikeErrorList,
-            peakWindow_pnts,
-            onlyPeaksAbove_mV=onlyPeaksAbove_mV,
-            onlyPeaksBelow_mV=onlyPeaksBelow_mV,
-        )
+        onlyPeaksAbove_mV = dDict['onlyPeaksAbove_mV']
+        onlyPeaksBelow_mV = dDict['onlyPeaksBelow_mV']
+        spikeTimes,spikeErrorList, newSpikePeakPnt, newSpikePeakVal \
+                         = sanpy.analysisUtil.throwOutAboveBelow(filteredVm,
+                                spikeTimes, spikeErrorList,
+                                peakWindow_pnts,
+                                onlyPeaksAbove_mV=onlyPeaksAbove_mV,
+                                onlyPeaksBelow_mV=onlyPeaksBelow_mV)
 
         #
         # small window to average Vm to calculate MDP (itself in a window before spike)
-        avgWindow_pnts = self.fileLoader.ms2Pnt_(dDict["avgWindow_ms"])
-        avgWindow_pnts = math.floor(avgWindow_pnts / 2)
+        avgWindow_pnts = self.fileLoader.ms2Pnt_(dDict['avgWindow_ms'])
+        avgWindow_pnts = math.floor(avgWindow_pnts/2)
 
         #
         # for each spike
-        # numSpikes = len(spikeTimes)
+        #numSpikes = len(spikeTimes)
         for i, spikeTime in enumerate(spikeTimes):
             # spikeTime units is ALWAYS points
 
             # new, add a spike dict for this spike time
             spikeDict.appendDefault()
 
             # get the AP peak
             peakPnt = newSpikePeakPnt[i]
             peakVal = newSpikePeakVal[i]
             peakSec = (newSpikePeakPnt[i] / self.fileLoader.dataPointsPerMs) / 1000
 
             # create one spike dictionary
-            # spikeDict = OrderedDict() # use OrderedDict so Pandas output is in the correct order
-
-            # spikeDict[i]['isBad'] = False
-            spikeDict[i]["analysisDate"] = dateStr
-            spikeDict[i]["analysisTime"] = timeStr
-            spikeDict[i]["analysisVersion"] = sanpy.analysisVersion
-            spikeDict[i]["interfaceVersion"] = sanpy.interfaceVersion
-            spikeDict[i]["file"] = self.fileLoader.filename
-
-            spikeDict[i]["detectionType"] = detectionType
+            #spikeDict = OrderedDict() # use OrderedDict so Pandas output is in the correct order
 
-            spikeDict[i]["cellType"] = dDict["cellType"]
-            spikeDict[i]["sex"] = dDict["sex"]
-            spikeDict[i]["condition"] = dDict["condition"]
+            #spikeDict[i]['isBad'] = False
+            spikeDict[i]['analysisDate'] = dateStr
+            spikeDict[i]['analysisTime'] = timeStr
+            spikeDict[i]['analysisVersion'] = sanpy.analysisVersion
+            spikeDict[i]['interfaceVersion'] = sanpy.interfaceVersion
+            spikeDict[i]['file'] = self.fileLoader.filename
+
+            spikeDict[i]['detectionType'] = detectionType
+
+            spikeDict[i]['cellType'] = dDict['cellType']
+            spikeDict[i]['sex'] = dDict['sex']
+            spikeDict[i]['condition'] = dDict['condition']
 
-            spikeDict[i]["sweep"] = sweepNumber
-
-            epoch = float("nan")
-            epochLevel = float("nan")
+            spikeDict[i]['sweep'] = sweepNumber
+            
+            epoch = float('nan')
+            epochLevel = float('nan')
             epochTable = self.fileLoader.getEpochTable(sweepNumber)
             if epochTable is not None:
-                epoch = epochTable.findEpoch(spikeTime)
+                epoch = epochTable.findEpoch(spikeTime)   
                 epochLevel = epochTable.getLevel(epoch)
-            spikeDict[i]["epoch"] = epoch
-            spikeDict[i]["epochLevel"] = epochLevel
+            spikeDict[i]['epoch'] = epoch
+            spikeDict[i]['epochLevel'] = epochLevel
 
             # keep track of per sweep spike and total spike
-            spikeDict[i]["sweepSpikeNumber"] = i
-            spikeDict[i]["spikeNumber"] = self.numSpikes + i
+            spikeDict[i]['sweepSpikeNumber'] = i
+            spikeDict[i]['spikeNumber'] = self.numSpikes + i
 
-            spikeDict[i]["include"] = True
+            spikeDict[i]['include'] = True
 
             # todo: make this a byte encoding so we can have multiple user tyes per spike
-            spikeDict[i]["userType"] = 0  # One userType (int) that can have values
+            spikeDict[i]['userType'] = 0  # One userType (int) that can have values
 
             # using bAnalysisResults will already be []
-            spikeDict[i]["errors"] = []
+            spikeDict[i]['errors'] = []
 
             # append existing spikeErrorList from spikeDetect_dvdt() or spikeDetect_mv()
             tmpError = spikeErrorList[i]
             if tmpError is not None and tmpError != np.nan:
-                spikeDict[i]["errors"].append(tmpError)  # tmpError is from:
+                spikeDict[i]['errors'].append(tmpError) # tmpError is from:
                 if verbose:
-                    print(f"  spike:{i} error:{tmpError}")
+                    print(f'  spike:{i} error:{tmpError}')
             #
             # detection params
-            spikeDict[i]["dvdtThreshold"] = dDict["dvdtThreshold"]
-            spikeDict[i]["mvThreshold"] = dDict["mvThreshold"]
-            spikeDict[i]["medianFilter"] = dDict["medianFilter"]
-            spikeDict[i]["halfHeights"] = dDict["halfHeights"]
-
-            spikeDict[i]["thresholdPnt"] = spikeTime
-            spikeDict[i]["thresholdSec"] = (
-                spikeTime / self.fileLoader.dataPointsPerMs
-            ) / 1000
-            spikeDict[i]["thresholdVal"] = filteredVm[spikeTime]  # in vm
-            spikeDict[i]["thresholdVal_dvdt"] = filteredDeriv[
-                spikeTime
-            ]  # in dvdt, spikeTime is points
+            spikeDict[i]['dvdtThreshold'] = dDict['dvdtThreshold']
+            spikeDict[i]['mvThreshold'] = dDict['mvThreshold']
+            spikeDict[i]['medianFilter'] = dDict['medianFilter']
+            spikeDict[i]['halfHeights'] = dDict['halfHeights']
+
+            spikeDict[i]['thresholdPnt'] = spikeTime
+            spikeDict[i]['thresholdSec'] = (spikeTime / self.fileLoader.dataPointsPerMs) / 1000
+            spikeDict[i]['thresholdVal'] = filteredVm[spikeTime] # in vm
+            spikeDict[i]['thresholdVal_dvdt'] = filteredDeriv[spikeTime] # in dvdt, spikeTime is points
 
-            # TODO: revamp this for 'Plot FI' plugin
+            #TODO: revamp this for 'Plot FI' plugin
             # spikeTime falls into wrong epoch for first fast spike
             # DAC command at the precise spike point
-            # spikeDict[i]['dacCommand'] = sweepC[spikeTime]  # spikeTime is in points
-            # spikeDict[i]['dacCommand'] = sweepC[peakPnt]  # spikeTime is in points
+            #spikeDict[i]['dacCommand'] = sweepC[spikeTime]  # spikeTime is in points
+            #spikeDict[i]['dacCommand'] = sweepC[peakPnt]  # spikeTime is in points
 
-            spikeDict[i]["peakPnt"] = peakPnt
-            spikeDict[i]["peakSec"] = peakSec
-            spikeDict[i]["peakVal"] = peakVal
-
-            spikeDict[i]["peakHeight"] = (
-                spikeDict[i]["peakVal"] - spikeDict[i]["thresholdVal"]
-            )
+            spikeDict[i]['peakPnt'] = peakPnt
+            spikeDict[i]['peakSec'] = peakSec
+            spikeDict[i]['peakVal'] = peakVal
 
-            tmpThresholdSec = spikeDict[i]["thresholdSec"]
-            spikeDict[i]["timeToPeak_ms"] = (peakSec - tmpThresholdSec) * 1000
+            spikeDict[i]['peakHeight'] = spikeDict[i]['peakVal'] - spikeDict[i]['thresholdVal']
+
+            tmpThresholdSec = spikeDict[i]['thresholdSec']
+            spikeDict[i]['timeToPeak_ms'] = (peakSec - tmpThresholdSec) * 1000
 
             # only append to spikeDict after we are done (accounting for spikes within a sweep)
-            # self.spikeDict.append(spikeDict)
-            # iIdx = len(self.spikeDict) - 1
+            #self.spikeDict.append(spikeDict)
+            #iIdx = len(self.spikeDict) - 1
 
             iIdx = i
 
             # todo: get rid of this
-            defaultVal = float("nan")
+            defaultVal = float('nan')
 
-            """
+            '''
             # get pre/post spike minima
             self.spikeDict[iIdx]['preMinPnt'] = None
             self.spikeDict[iIdx]['preMinVal'] = defaultVal
 
             # early diastolic duration
             # 0.1 to 0.5 of time between pre spike min and spike time
             self.spikeDict[iIdx]['preLinearFitPnt0'] = None
@@ -1567,596 +1385,510 @@
                     'fallingVal': defaultVal,
                     'widthPnts': None,
                     'widthMs': defaultVal
                 }
                 # was this
                 #spikeDict[iIdx]['widths_' + str(halfHeight)] = defaultVal
                 spikeDict[iIdx]['widths'].append(widthDict)
-            """
+            '''
 
             #
-            mdp_ms = dDict["mdp_ms"]
+            mdp_ms = dDict['mdp_ms']
             mdp_pnts = self.fileLoader.ms2Pnt_(mdp_ms)  # mdp_ms * self.dataPointsPerMs
             mdp_pnts = int(mdp_pnts)
 
             # pre spike min
             # other algorithms look between spike[i-1] and spike[i]
             # here we are looking in a predefined window
-            startPnt = spikeTimes[i] - mdp_pnts
+            startPnt = spikeTimes[i]-mdp_pnts
             if startPnt < 0:
-                # logger.info('TODO: add an official warning, we went past 0 for pre spike mdp ms window')
+                #logger.info('TODO: add an official warning, we went past 0 for pre spike mdp ms window')
                 startPnt = 0
                 # log error
-                errorType = "Pre spike min under-run (mdp)"
-                errorStr = "Went past time 0 searching for pre-spike min"
-                eDict = self._getErrorDict(
-                    i, spikeTimes[i], errorType, errorStr
-                )  # spikeTime is in pnts
-                spikeDict[iIdx]["errors"].append(eDict)
+                errorType = 'Pre spike min under-run (mdp)'
+                errorStr = 'Went past time 0 searching for pre-spike min'
+                eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                spikeDict[iIdx]['errors'].append(eDict)
                 if verbose:
-                    print(f"  spike:{iIdx} error:{eDict}")
+                    print(f'  spike:{iIdx} error:{eDict}')
 
-            preRange = filteredVm[startPnt : spikeTimes[i]]  # EXCEPTION
+            preRange = filteredVm[startPnt:spikeTimes[i]] # EXCEPTION
             try:
                 preMinPnt = np.argmin(preRange)
-            except ValueError as e:
+            except (ValueError) as e:
                 # 20220926, happend when we have no scale and mdp_pnts=0
-                # print(f'xxx i:{i} mdp_pnts:{mdp_pnts} len:{len(filteredVm)} startPnt:{startPnt} spikeTimes[i]:{spikeTimes[i]}')
+                #print(f'xxx i:{i} mdp_pnts:{mdp_pnts} len:{len(filteredVm)} startPnt:{startPnt} spikeTimes[i]:{spikeTimes[i]}')
                 # 20220926, we really just want ot bail on this error
                 # lots of code below relies on this
                 # TODO: fix this mess
                 preMinPnt = startPnt
-                errorType = "Pre spike min 0 (mdp)"
-                errorStr = f"Did not find preMinPnt mdp_pnts:{mdp_pnts} startPnt:{startPnt} spikeTimes[i]:{spikeTimes[i]}"
-                eDict = self._getErrorDict(
-                    i, spikeTimes[i], errorType, errorStr
-                )  # spikeTime is in pnts
-                spikeDict[iIdx]["errors"].append(eDict)
+                errorType = 'Pre spike min 0 (mdp)'
+                errorStr = f'Did not find preMinPnt mdp_pnts:{mdp_pnts} startPnt:{startPnt} spikeTimes[i]:{spikeTimes[i]}'
+                eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                spikeDict[iIdx]['errors'].append(eDict)
                 if verbose:
-                    print(f"  spike:{iIdx} error:{eDict}")
+                    print(f'  spike:{iIdx} error:{eDict}')
             if preMinPnt is not None:
                 preMinPnt += startPnt
                 # the pre min is actually an average around the real minima
-                avgRange = filteredVm[
-                    preMinPnt - avgWindow_pnts : preMinPnt + avgWindow_pnts
-                ]
+                avgRange = filteredVm[preMinPnt-avgWindow_pnts:preMinPnt+avgWindow_pnts]
                 preMinVal = np.average(avgRange)
 
                 # search backward from spike to find when vm reaches preMinVal (avg)
-                preRange = filteredVm[preMinPnt : spikeTimes[i]]
-                preRange = np.flip(preRange)  # we want to search backwards from peak
+                preRange = filteredVm[preMinPnt:spikeTimes[i]]
+                preRange = np.flip(preRange) # we want to search backwards from peak
                 try:
-                    preMinPnt2 = np.where(preRange < preMinVal)[0][0]
+                    preMinPnt2 = np.where(preRange<preMinVal)[0][0]
                     preMinPnt = spikeTimes[i] - preMinPnt2
-                    spikeDict[iIdx]["preMinPnt"] = preMinPnt
-                    spikeDict[iIdx]["preMinVal"] = preMinVal
+                    spikeDict[iIdx]['preMinPnt'] = preMinPnt
+                    spikeDict[iIdx]['preMinVal'] = preMinVal
 
-                except IndexError as e:
-                    errorType = "Pre spike min (mdp)"
-                    errorStr = "Did not find preMinVal: " + str(
-                        round(preMinVal, 3)
-                    )  # + ' postRange min:' + str(np.min(postRange)) + ' max ' + str(np.max(postRange))
-                    eDict = self._getErrorDict(
-                        i, spikeTimes[i], errorType, errorStr
-                    )  # spikeTime is in pnts
-                    spikeDict[iIdx]["errors"].append(eDict)
+                except (IndexError) as e:
+                    errorType = 'Pre spike min (mdp)'
+                    errorStr = 'Did not find preMinVal: ' + str(round(preMinVal,3)) #+ ' postRange min:' + str(np.min(postRange)) + ' max ' + str(np.max(postRange))
+                    eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                    spikeDict[iIdx]['errors'].append(eDict)
                     if verbose:
-                        print(f"  spike:{iIdx} error:{eDict}")
-
+                        print(f'  spike:{iIdx} error:{eDict}')
+                    
             #
             # The nonlinear late diastolic depolarization phase was
             # estimated as the duration between 1% and 10% dV/dt
             # linear fit on 10% - 50% of the time from preMinPnt to self.spikeTimes[i]
-            startLinearFit = 0.1  # percent of time between pre spike min and AP peak
-            stopLinearFit = 0.5  #
+            startLinearFit = 0.1 # percent of time between pre spike min and AP peak
+            stopLinearFit = 0.5 #
             timeInterval_pnts = spikeTimes[i] - preMinPnt
             # taking round() so we always get an integer # points
             preLinearFitPnt0 = preMinPnt + round(timeInterval_pnts * startLinearFit)
             preLinearFitPnt1 = preMinPnt + round(timeInterval_pnts * stopLinearFit)
             preLinearFitVal0 = filteredVm[preLinearFitPnt0]
             preLinearFitVal1 = filteredVm[preLinearFitPnt1]
 
             # linear fit before spike
-            spikeDict[iIdx]["preLinearFitPnt0"] = preLinearFitPnt0
-            spikeDict[iIdx]["preLinearFitPnt1"] = preLinearFitPnt1
-            spikeDict[iIdx]["earlyDiastolicDuration_ms"] = self.fileLoader.pnt2Ms_(
-                preLinearFitPnt1 - preLinearFitPnt0
-            )
-            spikeDict[iIdx]["preLinearFitVal0"] = preLinearFitVal0
-            spikeDict[iIdx]["preLinearFitVal1"] = preLinearFitVal1
+            spikeDict[iIdx]['preLinearFitPnt0'] = preLinearFitPnt0
+            spikeDict[iIdx]['preLinearFitPnt1'] = preLinearFitPnt1
+            spikeDict[iIdx]['earlyDiastolicDuration_ms'] = self.fileLoader.pnt2Ms_(preLinearFitPnt1 - preLinearFitPnt0)
+            spikeDict[iIdx]['preLinearFitVal0'] = preLinearFitVal0
+            spikeDict[iIdx]['preLinearFitVal1'] = preLinearFitVal1
 
             # a linear fit where 'm,b = np.polyfit(x, y, 1)'
             # m*x+b"
             xFit = sweepX[preLinearFitPnt0:preLinearFitPnt1]  # abb added +1
             yFit = filteredVm[preLinearFitPnt0:preLinearFitPnt1]
 
             # sometimes xFit/yFit have 0 length -->> TypeError
-            # print(f' {iIdx} preLinearFitPnt0:{preLinearFitPnt0}, preLinearFitPnt1:{preLinearFitPnt1}')
-            # print(f'    xFit:{len(xFit)} yFit:{len(yFit)}')
+            #print(f' {iIdx} preLinearFitPnt0:{preLinearFitPnt0}, preLinearFitPnt1:{preLinearFitPnt1}')
+            #print(f'    xFit:{len(xFit)} yFit:{len(yFit)}')
 
             # TODO: somehow trigger following errors to confirm code works (pytest)
             with warnings.catch_warnings():
-                warnings.filterwarnings("error")
+                warnings.filterwarnings('error')
                 try:
-                    mLinear, bLinear = np.polyfit(
-                        xFit, yFit, 1
-                    )  # m is slope, b is intercept
-                    spikeDict[iIdx]["earlyDiastolicDurationRate"] = mLinear
+                    mLinear, bLinear = np.polyfit(xFit, yFit, 1) # m is slope, b is intercept
+                    spikeDict[iIdx]['earlyDiastolicDurationRate'] = mLinear
                     # todo: make an error if edd rate is too low
-                    lowestEddRate = dDict["lowEddRate_warning"]  # 8
+                    lowestEddRate = dDict['lowEddRate_warning']  #8
                     if mLinear <= lowestEddRate:
-                        errorType = "Fit EDD"
-                        errorStr = f"Early diastolic duration rate fit - Too low {round(mLinear,3)}<={lowestEddRate}"
-                        eDict = self._getErrorDict(
-                            i, spikeTimes[i], errorType, errorStr
-                        )  # spikeTime is in pnts
-                        # print('fit edd start num error:', 'iIdx:', iIdx, 'num error:', len(spikeDict[iIdx]['errors']))
-                        spikeDict[iIdx]["errors"].append(eDict)
-                        # print('  after num error:', len(spikeDict[iIdx]['errors']))
+                        errorType = 'Fit EDD'
+                        errorStr = f'Early diastolic duration rate fit - Too low {round(mLinear,3)}<={lowestEddRate}'
+                        eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                        #print('fit edd start num error:', 'iIdx:', iIdx, 'num error:', len(spikeDict[iIdx]['errors']))
+                        spikeDict[iIdx]['errors'].append(eDict)
+                        #print('  after num error:', len(spikeDict[iIdx]['errors']))
                         if verbose:
-                            print(f"  spike:{iIdx} error:{eDict}")
+                            print(f'  spike:{iIdx} error:{eDict}')
 
-                except TypeError as e:
-                    # catching exception:  expected non-empty vector for x
+                except (TypeError) as e:
+                    #catching exception:  expected non-empty vector for x
                     # xFit/yFit turn up empty when mdp and TOP points are within 1 point
-                    spikeDict[iIdx]["earlyDiastolicDurationRate"] = defaultVal
-                    errorType = "Fit EDD"
-                    # errorStr = 'Early diastolic duration rate fit - TypeError'
-                    errorStr = (
-                        "Early diastolic duration rate fit - preMinPnt == spikePnt"
-                    )
+                    spikeDict[iIdx]['earlyDiastolicDurationRate'] = defaultVal
+                    errorType = 'Fit EDD'
+                    #errorStr = 'Early diastolic duration rate fit - TypeError'
+                    errorStr = 'Early diastolic duration rate fit - preMinPnt == spikePnt'
                     eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr)
-                    spikeDict[iIdx]["errors"].append(eDict)
+                    spikeDict[iIdx]['errors'].append(eDict)
                     if verbose:
-                        print(f"  spike:{iIdx} error:{eDict}")
-                except np.RankWarning as e:
-                    # logger.error('== FIX preLinearFitPnt0/preLinearFitPnt1 RankWarning')
-                    # logger.error(f'  error is: {e}')
-                    # print('RankWarning')
+                        print(f'  spike:{iIdx} error:{eDict}')
+                except (np.RankWarning) as e:
+                    #logger.error('== FIX preLinearFitPnt0/preLinearFitPnt1 RankWarning')
+                    #logger.error(f'  error is: {e}')
+                    #print('RankWarning')
                     # also throws: RankWarning: Polyfit may be poorly conditioned
-                    spikeDict[iIdx]["earlyDiastolicDurationRate"] = defaultVal
-                    errorType = "Fit EDD"
-                    errorStr = "Early diastolic duration rate fit - RankWarning"
+                    spikeDict[iIdx]['earlyDiastolicDurationRate'] = defaultVal
+                    errorType = 'Fit EDD'
+                    errorStr = 'Early diastolic duration rate fit - RankWarning'
+                    eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr)
+                    spikeDict[iIdx]['errors'].append(eDict)
+                    if verbose:
+                        print(f'  spike:{iIdx} error:{eDict}')
+                except:
+                    logger.error(f' !!!!!!!!!!!!!!!!!!!!!!!!!!! UNKNOWN EXCEPTION DURING EDD LINEAR FIT for spike {i}')
+                    spikeDict[iIdx]['earlyDiastolicDurationRate'] = defaultVal
+                    errorType = 'Fit EDD'
+                    errorStr = 'Early diastolic duration rate fit - Unknown Exception'
                     eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr)
-                    spikeDict[iIdx]["errors"].append(eDict)
                     if verbose:
-                        print(f"  spike:{iIdx} error:{eDict}")
-                # 20230422, don't ever catch an unknown exception
-                # except:
-                #     logger.error(
-                #         f" !!!!!!!!!!!!!!!!!!!!!!!!!!! UNKNOWN EXCEPTION DURING EDD LINEAR FIT for spike {i}"
-                #     )
-                #     spikeDict[iIdx]["earlyDiastolicDurationRate"] = defaultVal
-                #     errorType = "Fit EDD"
-                #     errorStr = "Early diastolic duration rate fit - Unknown Exception"
-                #     eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr)
-                #     if verbose:
-                #         print(f"  spike:{iIdx} error:{eDict}")
+                        print(f'  spike:{iIdx} error:{eDict}')
 
             # not implemented
-            # self.spikeDict[i]['lateDiastolicDuration'] = ???
+            #self.spikeDict[i]['lateDiastolicDuration'] = ???
 
             #
             # maxima in dv/dt before spike (between TOP and peak)
             try:
-                preRange = filteredDeriv[spikeTimes[i] : peakPnt + 1]
+                preRange = filteredDeriv[spikeTimes[i]:peakPnt+1]
                 preSpike_dvdt_max_pnt = np.argmax(preRange)
                 preSpike_dvdt_max_pnt += spikeTimes[i]
-                spikeDict[iIdx]["preSpike_dvdt_max_pnt"] = preSpike_dvdt_max_pnt
-                spikeDict[iIdx]["preSpike_dvdt_max_val"] = filteredVm[
-                    preSpike_dvdt_max_pnt
-                ]  # in units mV
-                spikeDict[iIdx]["preSpike_dvdt_max_val2"] = filteredDeriv[
-                    preSpike_dvdt_max_pnt
-                ]  # in units mV
-            except ValueError as e:
+                spikeDict[iIdx]['preSpike_dvdt_max_pnt'] = preSpike_dvdt_max_pnt
+                spikeDict[iIdx]['preSpike_dvdt_max_val'] = filteredVm[preSpike_dvdt_max_pnt] # in units mV
+                spikeDict[iIdx]['preSpike_dvdt_max_val2'] = filteredDeriv[preSpike_dvdt_max_pnt] # in units mV
+            except (ValueError) as e:
                 # sometimes preRange is empty, don't try and put min/max in error
-                errorType = "Pre Spike dvdt"
-                errorStr = "Searching for dvdt max - ValueError"
-                eDict = self._getErrorDict(
-                    i, spikeTimes[i], errorType, errorStr
-                )  # spikeTime is in pnts
-                spikeDict[iIdx]["errors"].append(eDict)
+                errorType = 'Pre Spike dvdt'
+                errorStr = 'Searching for dvdt max - ValueError'
+                eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                spikeDict[iIdx]['errors'].append(eDict)
                 if verbose:
-                    print(f"  spike:{iIdx} error:{eDict}")
+                    print(f'  spike:{iIdx} error:{eDict}')
 
             #
             # minima in dv/dt after spike
-            # postRange = dvdt[self.spikeTimes[i]:postMinPnt]
-            # postSpike_ms = 20 # 10
-            # postSpike_pnts = self.ms2Pnt_(postSpike_ms)
-            dvdtPostWindow_ms = dDict["dvdtPostWindow_ms"]
+            #postRange = dvdt[self.spikeTimes[i]:postMinPnt]
+            #postSpike_ms = 20 # 10
+            #postSpike_pnts = self.ms2Pnt_(postSpike_ms)
+            dvdtPostWindow_ms = dDict['dvdtPostWindow_ms']
             dvdtPostWindow_pnts = self.fileLoader.ms2Pnt_(dvdtPostWindow_ms)
-            postRange = filteredDeriv[
-                peakPnt : peakPnt + dvdtPostWindow_pnts
-            ]  # fixed window after spike
+            postRange = filteredDeriv[peakPnt:peakPnt+dvdtPostWindow_pnts] # fixed window after spike
 
             postSpike_dvdt_min_pnt = np.argmin(postRange)
             postSpike_dvdt_min_pnt += peakPnt
-            spikeDict[iIdx]["postSpike_dvdt_min_pnt"] = postSpike_dvdt_min_pnt
-            spikeDict[iIdx]["postSpike_dvdt_min_val"] = filteredVm[
-                postSpike_dvdt_min_pnt
-            ]
-            spikeDict[iIdx]["postSpike_dvdt_min_val2"] = filteredDeriv[
-                postSpike_dvdt_min_pnt
-            ]
+            spikeDict[iIdx]['postSpike_dvdt_min_pnt'] = postSpike_dvdt_min_pnt
+            spikeDict[iIdx]['postSpike_dvdt_min_val'] = filteredVm[postSpike_dvdt_min_pnt]
+            spikeDict[iIdx]['postSpike_dvdt_min_val2'] = filteredDeriv[postSpike_dvdt_min_pnt]
 
             #
             # diastolic duration was defined as the interval between MDP and TOP
             # one off error when preMinPnt is not defined
-            spikeDict[iIdx]["diastolicDuration_ms"] = self.fileLoader.pnt2Ms_(
-                spikeTime - preMinPnt
-            )
+            spikeDict[iIdx]['diastolicDuration_ms'] = self.fileLoader.pnt2Ms_(spikeTime - preMinPnt)
 
             #
             # calculate instantaneous spike frequency and ISI, for first spike this is not defined
-            spikeDict[iIdx]["cycleLength_ms"] = float("nan")
+            spikeDict[iIdx]['cycleLength_ms'] = float('nan')
             if iIdx > 0:
-                isiPnts = (
-                    spikeDict[iIdx]["thresholdPnt"]
-                    - spikeDict[iIdx - 1]["thresholdPnt"]
-                )
+                isiPnts = spikeDict[iIdx]['thresholdPnt'] - spikeDict[iIdx-1]['thresholdPnt']
                 isi_ms = self.fileLoader.pnt2Ms_(isiPnts)
                 isi_hz = 1 / (isi_ms / 1000)
-                spikeDict[iIdx]["isi_pnts"] = isiPnts
-                spikeDict[iIdx]["isi_ms"] = self.fileLoader.pnt2Ms_(isiPnts)
-                spikeDict[iIdx]["spikeFreq_hz"] = 1 / (
-                    self.fileLoader.pnt2Ms_(isiPnts) / 1000
-                )
+                spikeDict[iIdx]['isi_pnts'] = isiPnts
+                spikeDict[iIdx]['isi_ms'] = self.fileLoader.pnt2Ms_(isiPnts)
+                spikeDict[iIdx]['spikeFreq_hz'] = 1 / (self.fileLoader.pnt2Ms_(isiPnts) / 1000)
 
                 # Cycle length was defined as the interval between MDPs in successive APs
-                prevPreMinPnt = spikeDict[iIdx - 1]["preMinPnt"]  # can be nan
-                thisPreMinPnt = spikeDict[iIdx]["preMinPnt"]
+                prevPreMinPnt = spikeDict[iIdx-1]['preMinPnt'] # can be nan
+                thisPreMinPnt = spikeDict[iIdx]['preMinPnt']
                 if prevPreMinPnt is not None and thisPreMinPnt is not None:
                     cycleLength_pnts = thisPreMinPnt - prevPreMinPnt
-                    spikeDict[iIdx]["cycleLength_pnts"] = cycleLength_pnts
-                    spikeDict[iIdx]["cycleLength_ms"] = self.fileLoader.pnt2Ms_(
-                        cycleLength_pnts
-                    )
+                    spikeDict[iIdx]['cycleLength_pnts'] = cycleLength_pnts
+                    spikeDict[iIdx]['cycleLength_ms'] = self.fileLoader.pnt2Ms_(cycleLength_pnts)
                 else:
                     # error
                     prevPreMinSec = self.fileLoader.pnt2Sec_(prevPreMinPnt)
                     thisPreMinSec = self.fileLoader.pnt2Sec_(thisPreMinPnt)
-                    # errorStr = f'Previous spike preMinPnt is {prevPreMinPnt} and this preMinPnt: {thisPreMinPnt}'
-                    errorType = "Cycle Length"
-                    errorStr = f"Previous spike preMinPnt (s) is {prevPreMinSec} and this preMinPnt: {thisPreMinSec}"
-                    eDict = self._getErrorDict(
-                        i, spikeTimes[i], errorType, errorStr
-                    )  # spikeTime is in pnts
-                    spikeDict[iIdx]["errors"].append(eDict)
+                    #errorStr = f'Previous spike preMinPnt is {prevPreMinPnt} and this preMinPnt: {thisPreMinPnt}'
+                    errorType = 'Cycle Length'
+                    errorStr = f'Previous spike preMinPnt (s) is {prevPreMinSec} and this preMinPnt: {thisPreMinSec}'
+                    eDict = self._getErrorDict(i, spikeTimes[i], errorType, errorStr) # spikeTime is in pnts
+                    spikeDict[iIdx]['errors'].append(eDict)
                     if verbose:
-                        print(f"  spike:{iIdx} error:{eDict}")
+                        print(f'  spike:{iIdx} error:{eDict}')
 
             #
             # TODO: Move half-width to a function !!!
             #
-            hwWindowPnts = dDict["halfWidthWindow_ms"] * self.fileLoader.dataPointsPerMs
+            hwWindowPnts = dDict['halfWidthWindow_ms'] * self.fileLoader.dataPointsPerMs
             hwWindowPnts = round(hwWindowPnts)
-            halfHeightList = dDict["halfHeights"]
+            halfHeightList = dDict['halfHeights']
             # was this
-            # self._getHalfWidth(filteredVm, i, iIdx, spikeTime, peakPnt, hwWindowPnts, self.dataPointsPerMs, halfHeightList)
-            self._getHalfWidth(
-                filteredVm,
-                iIdx,
-                spikeDict,
-                spikeTime,
-                peakPnt,
-                hwWindowPnts,
-                self.fileLoader.dataPointsPerMs,
-                halfHeightList,
-                verbose=verbose,
-            )
+            #self._getHalfWidth(filteredVm, i, iIdx, spikeTime, peakPnt, hwWindowPnts, self.dataPointsPerMs, halfHeightList)
+            self._getHalfWidth(filteredVm, iIdx, spikeDict, spikeTime, peakPnt,
+                                hwWindowPnts, self.fileLoader.dataPointsPerMs, halfHeightList, verbose=verbose)
 
         #
         # look between threshold crossing to get minima
         # we will ignore the first and last spike
 
         #
         # spike clips
         self.spikeClips = None
         self.spikeClips_x = None
         self.spikeClips_x2 = None
 
         # SUPER important, previously our self.spikeDict was simple list of dict
         # now it is a list of class xxx
-        # print('=== addind', len(spikeDict))
+        #print('=== addind', len(spikeDict))
         self.spikeDict.appendAnalysis(spikeDict)
-        # print('   now have', len(self.spikeDict))
-        # print(self.spikeDict)
+        #print('   now have', len(self.spikeDict))
+        #print(self.spikeDict)
 
         # keep track of spikes per sweep (expensive to calculate)
-        # self._spikesPerSweep[sweepNumber] = len(spikeDict)
+        #self._spikesPerSweep[sweepNumber] = len(spikeDict)
 
         # run all user analysis ... what if this fails ???
         sanpy.user_analysis.baseUserAnalysis.runAllUserAnalysis(self)
 
         #
         # generate a df holding stats (used by scatterplotwidget)
-        # startSeconds = dDict['startSeconds']
-        # stopSeconds = dDict['stopSeconds']
+        #startSeconds = dDict['startSeconds']
+        #stopSeconds = dDict['stopSeconds']
         if self.numSpikes > 0:
-            # exportObject = sanpy.bExport(self)
-            # self.dfReportForScatter = exportObject.report(startSeconds, stopSeconds)
-            self._dfReportForScatter = self.spikeDict.asDataFrame()
+            #exportObject = sanpy.bExport(self)
+            #self.dfReportForScatter = exportObject.report(startSeconds, stopSeconds)
+            self._dfReportForScatter =  self.spikeDict.asDataFrame()
         else:
             self.dfReportForScatter = None
 
-        # generate error report
-        self.dfError = self.getErrorReport()
+        self.dfError = self.errorReport()
 
-        # bAnalysis needs to be saved
         self._detectionDirty = True
+        # e.g. bAnalysis needs to be saved
 
         ## done
 
-    def _getFeet(self, thresholdPnts: List[int], prePnts: int) -> List[int]:
+    def _getFeet(self, thresholdPnts : List[int], prePnts : int) -> List[int]:
         """
-
+        
         Args:
             thresholdPnts (list of int)
             prePnts (int): pre point window to search for zero crossing
 
         Notes:
             Will need to calculate new (height, half widths)
         """
 
-        # prePnts = int(prePnts)
-
-        logger.info(f"num thresh:{len(thresholdPnts)} prePnts:{prePnts}")
+        #prePnts = int(prePnts)
+        
+        logger.info(f'num thresh:{len(thresholdPnts)} prePnts:{prePnts}')
 
-        # df = self.asDataFrame()
-        # peaks = df['peakVal']
-        # thresholdPnts = df['thresholdPnt']
+        #df = self.asDataFrame()
+        #peaks = df['peakVal']
+        #thresholdPnts = df['thresholdPnt']
 
-        verbose = self._detectionDict["verbose"]
+        verbose = self._detectionDict['verbose']
 
         # using the derivstive to find zero crossing before
         # original full width left point
         # TODO: USer self.filteredDeriv
-        # yFull = self.filteredVm
-        # yDiffFull = np.diff(yFull)
-        # yDiffFull = np.insert(yDiffFull, 0, np.nan)
+        #yFull = self.filteredVm
+        #yDiffFull = np.diff(yFull)
+        #yDiffFull = np.insert(yDiffFull, 0, np.nan)
         yDiffFull = self.fileLoader.filteredDeriv
 
         secondDeriv = np.diff(yDiffFull, axis=0)
         secondDeriv = np.insert(secondDeriv, 0, np.nan)
 
         n = len(thresholdPnts)
         footPntList = [None] * n
         footSec = [None] * n  # not used
         yFoot = [None] * n  # not used
-        # myHeight = []
+        #myHeight = []
 
         # todo: add this to bAnalysis
-        # preMs = self._detectionParams['preFootMs']
-        # prePnts = self._sec2Pnt(preMs/1000)
+        #preMs = self._detectionParams['preFootMs']
+        #prePnts = self._sec2Pnt(preMs/1000)
 
         # TODO: add to bDetection
-        logger.warning("ADD preMs AS PARAMETER !!!")
-        # preWinMs = 50  # sa-node
-        # prePnts = self.ms2Pnt_(preMs)
+        logger.warning('ADD preMs AS PARAMETER !!!')
+        #preWinMs = 50  # sa-node
+        #prePnts = self.ms2Pnt_(preMs)
 
-        for idx, footPnt in enumerate(thresholdPnts):
-            # footPnt = round(footPnt)  # footPnt is in fractional points
+        for idx,footPnt in enumerate(thresholdPnts):
+            #footPnt = round(footPnt)  # footPnt is in fractional points
             lastCrossingPnt = footPnt
             # move forwared a bit in case we are already in a local minima ???
-            logger.warning("REMOVED WHEN WORKING ON NEURON DETECTION")
+            logger.warning('REMOVED WHEN WORKING ON NEURON DETECTION')
             footPnt += 2  # TODO: add as param
             preStart = footPnt - prePnts
             preClip = yDiffFull[preStart:footPnt]
 
-            zero_crossings = np.where(np.diff(np.sign(preClip)))[
-                0
-            ]  # find where derivative flips sign (crosses 0)
+            zero_crossings = np.where(np.diff(np.sign(preClip)))[0]  # find where derivative flips sign (crosses 0)
             xLastCrossing = self.fileLoader.pnt2Sec_(footPnt)  # defaults
             yLastCrossing = self.fileLoader.sweepY_filtered[footPnt]
-            if len(zero_crossings) == 0:
+            if len(zero_crossings)==0:
                 if verbose:
                     tmpSec = round(self.fileLoader.pnt2Sec_(footPnt), 3)
-                    logger.error(
-                        f"  no foot for peak {idx} at sec {tmpSec} ... did not find zero crossings"
-                    )
+                    logger.error(f'  no foot for peak {idx} at sec {tmpSec} ... did not find zero crossings')
             else:
-                # print(idx, 'footPnt:', footPnt, zero_crossings, preClip)
+                #print(idx, 'footPnt:', footPnt, zero_crossings, preClip)
                 lastCrossingPnt = preStart + zero_crossings[-1]
                 xLastCrossing = self.fileLoader.pnt2Sec_(lastCrossingPnt)
                 # get y-value (pA) from filtered. This removes 'pops' in raw data
                 yLastCrossing = self.fileLoader.sweepY_filtered[lastCrossingPnt]
 
+
             # find peak in second derivative
-            """
+            '''
             preStart2 = lastCrossingPnt
             footMs2 = 20
             footPnt2 = preStart2 + self.ms2Pnt_(footMs2)
             preClip2 = secondDeriv[preStart2:footPnt2]
             #zero_crossings = np.where(np.diff(np.sign(preClip2)))[0]
             peakPnt2 = np.argmax(preClip2)
             peakPnt2 += preStart2
 
             #
             footPntList[idx] = peakPnt2
-            """
+            '''
 
-            footPntList[idx] = lastCrossingPnt  # was this and worked, a bit too early
+            footPntList[idx] = lastCrossingPnt # was this and worked, a bit too early
 
             footSec[idx] = xLastCrossing
             yFoot[idx] = yLastCrossing
 
-            """
+            '''
             peakPnt = df.loc[idx, 'peak_pnt']
             peakVal = self.sweepY_filtered[peakPnt]
             height = peakVal - yLastCrossing
             #print(f'idx {idx} {peakPnt} {peakVal} - {yLastCrossing} = {height}')
             myHeight[idx] = (height)
-            """
+            '''
 
         #
-        # df =self._analysisList[self._analysisIdx]['results_full']
-        """
+        #df =self._analysisList[self._analysisIdx]['results_full']
+        '''
         df['foot_pnt'] = footPntList  # sec
         df['foot_sec'] = footSec  # sec
         df['foot_val'] = yFoot  # pA
-        """
-        # df['myHeight'] = myHeight
+        '''
+        #df['myHeight'] = myHeight
 
-        # return footPntList, footSec, yFoot
+        #return footPntList, footSec, yFoot
         return footPntList
 
     def printSpike(self, idx):
         """
         Print values in one spike analysis using self.spikeDict (sanpy.bAnalysisResults).
         """
         spike = self.spikeDict[idx]
-        for k, v in spike.items():
-            if k == "widths":
+        for k,v in spike.items():
+            if k == 'widths':
                 widths = v
-                print(f"  spike:{idx} has {len(widths)} widths...")
+                print(f'  spike:{idx} has {len(widths)} widths...')
                 for wIdx, width in enumerate(widths):
-                    print(f"    spike:{idx} width:{wIdx}: {width}")
-            elif k == "errors":
+                    print(f'    spike:{idx} width:{wIdx}: {width}')
+            elif k == 'errors':
                 errors = v
-                print(f"  spike:{idx} has {len(errors)} errors...")
+                print(f'  spike:{idx} has {len(errors)} errors...')
                 for eIdx, error in enumerate(errors):
-                    print(f"    spike:{idx} error #:{eIdx}: {error}")
+                    print(f'    spike:{idx} error #:{eIdx}: {error}')
             else:
-                print(f"{k}: {v}")
+                print(f'{k}: {v}')
 
     def printErrors(self):
         for idx, spike in enumerate(self.spikeDict):
             print(f"spike {idx} has {len(spike['errors'])} errors")
-            for eIdx, error in enumerate(spike["errors"]):
-                print(f"  error # {eIdx} is: {error}")
+            for eIdx, error in enumerate(spike['errors']):
+                print(f'  error # {eIdx} is: {error}')
 
-    def _makeSpikeClips(
-        self,
-        preSpikeClipWidth_ms,
-        postSpikeClipWidth_ms=None,
-        theseTime_sec=None,
-        sweepNumber=None,
-        epochNumber='All'
-    ):
+    def _makeSpikeClips(self, preSpikeClipWidth_ms, postSpikeClipWidth_ms=None, theseTime_sec=None, sweepNumber=None):
         """
         (Internal) Make small clips for each spike.
 
         Args:
             preSpikeClipWidth_ms (int): Width of each spike clip in milliseconds.
             postSpikeClipWidth_ms (int): Width of each spike clip in milliseconds.
             theseTime_sec (list of float): [NOT USED] List of seconds to make clips from.
 
         Returns:
             spikeClips_x2: ms
             self.spikeClips (list): List of spike clips
         """
 
-        verbose = self._detectionDict["verbose"]
+        verbose = self._detectionDict['verbose']
 
         if preSpikeClipWidth_ms is None:
-            preSpikeClipWidth_ms = self._detectionDict["preSpikeClipWidth_ms"]
+            preSpikeClipWidth_ms = self._detectionDict['preSpikeClipWidth_ms']
         if postSpikeClipWidth_ms is None:
-            postSpikeClipWidth_ms = self._detectionDict["postSpikeClipWidth_ms"]
+            postSpikeClipWidth_ms = self._detectionDict['postSpikeClipWidth_ms']
 
         if sweepNumber is None:
-            sweepNumber = "All"
+            sweepNumber = 'All'
 
-        # print('makeSpikeClips() spikeClipWidth_ms:', spikeClipWidth_ms, 'theseTime_sec:', theseTime_sec)
+        #print('makeSpikeClips() spikeClipWidth_ms:', spikeClipWidth_ms, 'theseTime_sec:', theseTime_sec)
         if theseTime_sec is None:
-            theseTime_pnts = self.getSpikeTimes(sweepNumber=sweepNumber, epochNumber=epochNumber)
+            theseTime_pnts = self.getSpikeTimes(sweepNumber=sweepNumber)
         else:
             # convert theseTime_sec to pnts
-            theseTime_ms = [x * 1000 for x in theseTime_sec]
-            theseTime_pnts = [x * self.fileLoader.dataPointsPerMs for x in theseTime_ms]
+            theseTime_ms = [x*1000 for x in theseTime_sec]
+            theseTime_pnts = [x*self.fileLoader.dataPointsPerMs for x in theseTime_ms]
             theseTime_pnts = [round(x) for x in theseTime_pnts]
 
         preClipWidth_pnts = self.fileLoader.ms2Pnt_(preSpikeClipWidth_ms)
-        # if preClipWidth_pnts % 2 == 0:
+        #if preClipWidth_pnts % 2 == 0:
         #    pass # Even
-        # else:
+        #else:
         #    clipWidth_pnts += 1 # Make odd even
         postClipWidth_pnts = self.fileLoader.ms2Pnt_(postSpikeClipWidth_ms)
 
-        # halfClipWidth_pnts = int(clipWidth_pnts/2)
+        #halfClipWidth_pnts = int(clipWidth_pnts/2)
 
-        # print('  makeSpikeClips() clipWidth_pnts:', clipWidth_pnts, 'halfClipWidth_pnts:', halfClipWidth_pnts)
+        #print('  makeSpikeClips() clipWidth_pnts:', clipWidth_pnts, 'halfClipWidth_pnts:', halfClipWidth_pnts)
         # make one x axis clip with the threshold crossing at 0
         # was this, in ms
-        # self.spikeClips_x = [(x-halfClipWidth_pnts)/self.dataPointsPerMs for x in range(clipWidth_pnts)]
+        #self.spikeClips_x = [(x-halfClipWidth_pnts)/self.dataPointsPerMs for x in range(clipWidth_pnts)]
 
         # in ms
-        self.spikeClips_x = [
-            (x - preClipWidth_pnts) / self.fileLoader.dataPointsPerMs
-            for x in range(preClipWidth_pnts)
-        ]
-        self.spikeClips_x += [
-            (x) / self.fileLoader.dataPointsPerMs for x in range(postClipWidth_pnts)
-        ]
+        self.spikeClips_x = [(x-preClipWidth_pnts)/self.fileLoader.dataPointsPerMs for x in range(preClipWidth_pnts)]
+        self.spikeClips_x += [(x)/self.fileLoader.dataPointsPerMs for x in range(postClipWidth_pnts)]
 
-        # 20190714, added this to make all clips same length, much easier to plot in MultiLine
+        #20190714, added this to make all clips same length, much easier to plot in MultiLine
         numPointsInClip = len(self.spikeClips_x)
 
         self.spikeClips = []
         self.spikeClips_x2 = []
 
         sweepY = self.fileLoader.sweepY_filtered
 
         # when there are no spikes getStat() will not return anything
         # For 'All' sweeps, we need to know column
-        sweepNum = self.getStat("sweep", sweepNumber=sweepNumber)
+        sweepNum = self.getStat('sweep', sweepNumber=sweepNumber)
 
-        # logger.info(f'sweepY: {sweepY.shape} {len(sweepY.shape)}')
-        # logger.info(f'theseTime_pnts: {theseTime_pnts}')
+        #logger.info(f'sweepY: {sweepY.shape} {len(sweepY.shape)}')
+        #logger.info(f'theseTime_pnts: {theseTime_pnts}')
 
         for idx, spikeTime in enumerate(theseTime_pnts):
+
             sweep = sweepNum[idx]
 
             if len(sweepY.shape) == 1:
                 # 1D case where recording has only oone sweep
-                # currentClip = sweepY[spikeTime-halfClipWidth_pnts:spikeTime+halfClipWidth_pnts]
-                currentClip = sweepY[
-                    spikeTime - preClipWidth_pnts : spikeTime + postClipWidth_pnts
-                ]
+                #currentClip = sweepY[spikeTime-halfClipWidth_pnts:spikeTime+halfClipWidth_pnts]
+                currentClip = sweepY[spikeTime-preClipWidth_pnts:spikeTime+postClipWidth_pnts]
             else:
                 # 2D case where recording has multiple sweeps
-                # currentClip = sweepY[spikeTime-halfClipWidth_pnts:spikeTime+halfClipWidth_pnts, sweep]
+                #currentClip = sweepY[spikeTime-halfClipWidth_pnts:spikeTime+halfClipWidth_pnts, sweep]
                 try:
-                    currentClip = sweepY[
-                        spikeTime - preClipWidth_pnts : spikeTime + preClipWidth_pnts,
-                        sweep,
-                    ]
-                except IndexError as e:
+                    currentClip = sweepY[spikeTime-preClipWidth_pnts:spikeTime+preClipWidth_pnts, sweep]
+                except (IndexError) as e:
                     logger.error(e)
-                    print(f"sweep: {sweep}")
-                    print(f"sweepY.shape: {sweepY.shape}")
+                    print(f'sweep: {sweep}')
+                    print(f'sweepY.shape: {sweepY.shape}')
 
             if len(currentClip) == numPointsInClip:
                 self.spikeClips.append(currentClip)
-                self.spikeClips_x2.append(
-                    self.spikeClips_x
-                )  # a 2D version to make pyqtgraph multiline happy
+                self.spikeClips_x2.append(self.spikeClips_x) # a 2D version to make pyqtgraph multiline happy
             else:
-                # pass
+                #pass
                 if verbose:
-                    logger.warning(
-                        f"Did not add clip for spike index: {idx} at time: {spikeTime} len(currentClip): {len(currentClip)} != numPointsInClip: {numPointsInClip}"
-                    )
+                    logger.warning(f'Did not add clip for spike index: {idx} at time: {spikeTime} len(currentClip): {len(currentClip)} != numPointsInClip: {numPointsInClip}')
 
         #
         return self.spikeClips_x2, self.spikeClips
 
-    def getSpikeClips(
-        self,
-        theMin,
-        theMax,
-        spikeSelection=[],
-        preSpikeClipWidth_ms=None,
-        postSpikeClipWidth_ms=None,
-        sweepNumber=None,
-        epochNumber='All',
-        ignoreMinMax=False  # added 20230418
-    ):
-        """Get 2d list of spike clips, spike clips x, and 1d mean spike clip.
+    def getSpikeClips(self, theMin, theMax, spikeSelection=[], preSpikeClipWidth_ms=None, postSpikeClipWidth_ms=None, sweepNumber=None):
+        """
+        Get 2d list of spike clips, spike clips x, and 1d mean spike clip
 
         Args:
             theMin (float): Start seconds.
             theMax (float): Stop seconds.
             spikeSelection (list): List of spike numbers
             preSpikeClipWidth_ms (float):
             postSpikeClipWidth_ms (float):
@@ -2178,229 +1910,198 @@
             pass
         elif theMin is None or theMax is None:
             theMin = 0
             theMax = self.fileLoader.recordingDur  # self.sweepX[-1]
 
         # new interface, spike detect no longer auto generates these
         # need to do this every time because we get here when sweepNumber changes
-        # if self.spikeClips is None:
+        #if self.spikeClips is None:
         #    self._makeSpikeClips(spikeClipWidth_ms=spikeClipWidth_ms, sweepNumber=sweepNumber)
         # TODO: don't make all clips
-        # self._makeSpikeClips(spikeClipWidth_ms=spikeClipWidth_ms, sweepNumber=sweepNumber)
-        self._makeSpikeClips(
-            preSpikeClipWidth_ms=preSpikeClipWidth_ms,
-            postSpikeClipWidth_ms=postSpikeClipWidth_ms,
-            sweepNumber=sweepNumber,
-            epochNumber=epochNumber
-        )
+        #self._makeSpikeClips(spikeClipWidth_ms=spikeClipWidth_ms, sweepNumber=sweepNumber)
+        self._makeSpikeClips(preSpikeClipWidth_ms=preSpikeClipWidth_ms, postSpikeClipWidth_ms=postSpikeClipWidth_ms, sweepNumber=sweepNumber)
 
         # make a list of clips within start/stop (Seconds)
         theseClips = []
         theseClips_x = []
-        tmpMeanClips = []  # for mean clip
+        tmpMeanClips = [] # for mean clip
         meanClip = []
-        
-        # spikeTimes are in pnts
-        spikeTimes = self.getSpikeTimes(sweepNumber=sweepNumber, epochNumber=epochNumber)
-
-        logger.info(f'spikeTimes:{len(spikeTimes)} sweepNumber:{sweepNumber} epochNumber:{epochNumber}')
+        spikeTimes = self.getSpikeTimes(sweepNumber=sweepNumber)
 
-        # if len(spikeTimes) != len(self.spikeClips):
+        #if len(spikeTimes) != len(self.spikeClips):
         #    logger.error(f'len spikeTimes {len(spikeTimes)} !=  spikeClips {len(self.spikeClips)}')
 
         # self.spikeClips is a list of clips
         for idx, clip in enumerate(self.spikeClips):
             doThisSpike = False
             if doSpikeSelection:
                 doThisSpike = idx in spikeSelection
             else:
                 spikeTime = spikeTimes[idx]
                 spikeTime = self.fileLoader.pnt2Sec_(spikeTime)
-                if ignoreMinMax or (spikeTime >= theMin and spikeTime <= theMax):
+                if spikeTime>=theMin and spikeTime<=theMax:
                     doThisSpike = True
             if doThisSpike:
                 theseClips.append(clip)
-                theseClips_x.append(
-                    self.spikeClips_x2[idx]
-                )  # remember, all _x are the same
+                theseClips_x.append(self.spikeClips_x2[idx]) # remember, all _x are the same
                 if len(self.spikeClips_x) == len(clip):
-                    tmpMeanClips.append(clip)  # for mean clip
+                    tmpMeanClips.append(clip) # for mean clip
         if len(tmpMeanClips):
             meanClip = np.mean(tmpMeanClips, axis=0)
 
         return theseClips, theseClips_x, meanClip
 
-    # def numErrors(self):
-    #     if self.dfError is None:
-    #         return "N/A"
-    #     else:
-    #         return len(self.dfError)
+    def numErrors(self):
+        if self.dfError is None:
+            return 'N/A'
+        else:
+            return len(self.dfError)
 
-    def getErrorReport(self):
-        """Generate an error report, one row per error.
-        
-        Spikes can have more than one error.
+    def errorReport(self):
+        """
+        Generate an error report, one row per error. Spikes can have more than one error.
 
         Returns:
             (pandas DataFrame): Pandas DataFrame, one row per error.
         """
 
         dictList = []
 
-        # numError = 0
-        # errorList = []
-
-        logger.info(f'Generating error report for {len(self.spikeDict)} spikes')
-
-        #  20230422 spikeDict is not working as an iterable
-        # use it as a list instead
-        numSpikes = len(self.spikeDict)
-        #for spike in self.spikeDict:
-        for _spikeNumber in range(numSpikes):
-            spike = self.spikeDict[_spikeNumber]
-            # spike is sanpy.bAnalysisResults.analysisResult
-            #print('spike:', spike)
-            for error in spike["errors"]:
-                # spike["errors"] is a list of dict
-                # error is dict from _getErrorDict
-                if error is None or error == np.nan or error == "nan":
+        numError = 0
+        errorList = []
+        for spikeIdx, spike in enumerate(self.spikeDict):
+            for idx, error in enumerate(spike['errors']):
+                # error is dict from _getErorDict
+                if error is None or error == np.nan or error == 'nan':
                     continue
-
-                # 20230422 add sweep and epoch to error dict
-                #_spikeNumber = error['Spike']
-                
-                #print('  _spikeNumber:', _spikeNumber, type(_spikeNumber))
-                
-                # _sweep = self.getSpikeStat([_spikeNumber], 'sweep')
-                # if len(_sweep)==0:
-                #     logger.error(f"_spikeNumber:{_spikeNumber} sweep:{_sweep}")
-                #     #print(self.getOneSpikeDict(_spikeNumber))
-                
-                error['Sweep'] = self.getSpikeStat([_spikeNumber], 'sweep')[0]
-                error['Epoch'] = self.getSpikeStat([_spikeNumber], 'epoch')[0]
-
                 dictList.append(error)
 
         if len(dictList) == 0:
-            fakeErrorDict = self._getErrorDict(1, 1, "fake", "fake")
+            fakeErrorDict = self._getErrorDict(1, 1, 'fake', 'fake')
             dfError = pd.DataFrame(columns=fakeErrorDict.keys())
         else:
             dfError = pd.DataFrame(dictList)
 
-        if self._detectionDict["verbose"]:
-            logger.info(f"Found {len(dfError)} errors in spike detection")
+        #print('bAnalysis.errorReport() returning len(dfError):', len(dfError))
+        if self._detectionDict['verbose']:
+            logger.info(f'Found {len(dfError)} errors in spike detection')
 
+        #
         return dfError
 
     def _old_to_csv(self):
-        """Save as a CSV text file with name <path>_analysis.csv'"""
+        """Save as a CSV text file with name <path>_analysis.csv'
+        """
         savefile = os.path.splitext(self._path)[0]
-        savefile += "_analysis.csv"
+        savefile += '_analysis.csv'
         saveExcel = False
         alsoSaveTxt = True
         logger.info(f'Saving "{savefile}"')
 
         be = sanpy.bExport(self)
         be.saveReport(savefile, saveExcel=saveExcel, alsoSaveTxt=alsoSaveTxt)
 
     def _normalizeData(self, data):
-        """Calculate normalized data for detection from Kymograph. Is NOT for df/d0."""
+        """Calculate normalized data for detection from Kymograph. Is NOT for df/d0.
+        """
         return (data - np.min(data)) / (np.max(data) - np.min(data))
 
     def _not_used_loadAnalysis(self):
-        """Not used."""
+        """Not used.
+        """
         saveBase = self._getSaveBase()
 
         # load detection parameters
-        # self.detectionClass.load(saveBase)
+        #self.detectionClass.load(saveBase)
 
         # load analysis
-        # self.spikeDict.load(saveBase)
+        #self.spikeDict.load(saveBase)
 
         saveBase = self._getSaveBase()
-        savePath = saveBase + "-analysis.json"
+        savePath = saveBase + '-analysis.json'
 
         if not os.path.isfile(savePath):
-            # logger.error(f'Did not find file: {savePath}')
+            #logger.error(f'Did not find file: {savePath}')
             return
 
-        logger.info(f"Loading from saved analysis: {savePath}")
+        logger.info(f'Loading from saved analysis: {savePath}')
 
-        with open(savePath, "r") as f:
-            # self._dDict = json.load(f)
+        with open(savePath, 'r') as f:
+            #self._dDict = json.load(f)
             loadedDict = json.load(f)
 
-        dDict = loadedDict["detection"]
+        dDict = loadedDict['detection']
         self.detectionClass._dDict = dDict
 
-        analysisList = loadedDict["analysis"]
+        analysisList = loadedDict['analysis']
         self.spikeDict._myList = analysisList
 
         self._detectionDirty = False
         self._isAnalyzed = True
 
     def saveAnalysis_tocsv(self):
-        """Save analysis to csv."""
+        """Save analysis to csv.
+        """
         df = self.asDataFrame()  # pd.DataFrame(self.spikeDict)
 
         saveFolder = self._getSaveFolder()
         if not os.path.isdir(saveFolder):
-            logger.info(f"making folder: {saveFolder}")
+            logger.info(f'making folder: {saveFolder}')
             os.mkdir(saveFolder)
 
         saveBase = self._getSaveBase()
-        savePath = saveBase + "-analysis.csv"
+        savePath = saveBase + '-analysis.csv'
 
         logger.info(savePath)
-
+        
         df.to_csv(savePath)
 
     def saveAnalysis(self, forceSave=False):
         """Not used.
 
         Save detection parameters and analysis results as json.
         """
         if not self._detectionDirty and not forceSave:
             return
 
         saveFolder = self._getSaveFolder()
         if not os.path.isdir(saveFolder):
-            logger.info(f"making folder: {saveFolder}")
+            logger.info(f'making folder: {saveFolder}')
             os.mkdir(saveFolder)
 
         saveBase = self._getSaveBase()
-        savePath = saveBase + "-analysis.json"
+        savePath = saveBase + '-analysis.json'
 
         # save detection parameters
-        # self.detectionClass.save(saveBase)
+        #self.detectionClass.save(saveBase)
         dDict = self.detectionClass.getDict()
 
         saveDict = {}
-        saveDict["detection"] = dDict
+        saveDict['detection'] = dDict
 
         # save list of dict
-        # self.spikeDict = sanpy.bAnalysisResults.analysisResultList()
-        # self.spikeDict.save(saveBase)
+        #self.spikeDict = sanpy.bAnalysisResults.analysisResultList()
+        #self.spikeDict.save(saveBase)
         analysisList = self.spikeDict.asList()
 
-        saveDict["analysis"] = analysisList
+        saveDict['analysis'] = analysisList
 
-        with open(savePath, "w") as f:
+        with open(savePath, 'w') as f:
             json.dump(saveDict, f, cls=NumpyEncoder, indent=4)
 
         self._detectionDirty = False
 
-        logger.info(f"Saved analysis to: {savePath}")
+        logger.info(f'Saved analysis to: {savePath}')
 
     def _getSaveFolder(self):
         """
         All analysis will be saved in folder 'sanpy_analysis'
         """
         parentPath, fileName = os.path.split(self._path)
-        saveFolder = os.path.join(parentPath, "sanpy_analysis")
+        saveFolder = os.path.join(parentPath, 'sanpy_analysis')
         return saveFolder
 
     def _getSaveBase(self):
         """
         Return basename to append to to save
 
         This will always be in a subfolder named 'sanpy_analysis'
@@ -2415,106 +2116,104 @@
 
         return savePath
 
     @property
     def analysisDate(self):
         if self.spikeDict is not None:
             return self.spikeDict.analysisDate()
-
+        
     @property
     def analysisTime(self):
         if self.spikeDict is not None:
             return self.spikeDict.analysisTime()
-
-    def _api_getHeader(self):
+        
+    def api_getHeader(self):
         """Get header as a dict.
 
         TODO:
             - add info on abf file, like samples per ms
 
         Returns:
             dict: Dictionary of information about loaded file.
         """
-        # recordingDir_sec = len(self.sweepX) / self.dataPointsPerMs / 1000
+        #recordingDir_sec = len(self.sweepX) / self.dataPointsPerMs / 1000
         recordingFrequency = self.dataPointsPerMs
 
         ret = {
-            "myFileType": self.myFileType,  # ('abf', 'tif', 'bytestream', 'csv')
-            "loadError": self.loadError,
+            'myFileType': self.myFileType, # ('abf', 'tif', 'bytestream', 'csv')
+            'loadError': self.loadError,
             #'detectionDict': self.detectionClass,
-            "path": self._path,
-            "file": self.fileLoader.filename,
-            "dateAnalyzed": self.dateAnalyzed,
+            'path': self._path,
+            'file': self.fileLoader.filename,
+            'dateAnalyzed': self.dateAnalyzed,
             #'detectionType': self.detectionType,
-            "acqDate": self.acqDate,
-            "acqTime": self.acqTime,
+            'acqDate': self.acqDate,
+            'acqTime': self.acqTime,
             #
-            "_recordingMode": self._recordingMode,
-            "get_yUnits": self.get_yUnits(),
+            '_recordingMode': self._recordingMode,
+            'get_yUnits': self.get_yUnits(),
             #'currentSweep': self.currentSweep,
-            "recording_kHz": recordingFrequency,
-            "recordingDur_sec": self.recordingDur,
+            'recording_kHz': recordingFrequency,
+            'recordingDur_sec': self.recordingDur
         }
         return ret
 
-    def _api_getSpikeInfo(self, spikeNum=None):
+    def api_getSpikeInfo(self, spikeNum=None):
         """Get info about each spike.
 
         Args:
             spikeNum (int): Get info for one spike, None for all spikes.
 
         Returns:
             list: List of dict with info for all (one) spike.
         """
         if spikeNum is not None:
             ret = [self.spikeDict[spikeNum]]
         else:
             ret = self.spikeDict
         return ret
 
-    def _api_getSpikeStat(self, stat):
+    def api_getSpikeStat(self, stat):
         """Get stat for each spike
 
         Args:
             stat (str): The name of the stat to get. Corresponds to key in self.spikeDict[i].
 
         Returns:
             list: List of values for 'stat'. Ech value is for one spike.
         """
         statList = self.getStat(statName1=stat, statName2=None)
         return statList
 
-    def _api_getRecording(self):
+    def api_getRecording(self):
         """Return primary recording
 
         Returns:
             dict: {'header', 'sweepX', 'sweepY'}
 
         TODO:
             Add param to only get every n'th point, to return a subset faster (for display)
         """
-        # start = time.time()
+        #start = time.time()
         ret = {
-            "header": self.api_getHeader(),
-            "sweepX": self.sweepX2.tolist(),
-            "sweepY": self.sweepY2.tolist(),
+            'header': self.api_getHeader(),
+            'sweepX': self.sweepX2.tolist(),
+            'sweepY': self.sweepY2.tolist(),
         }
-        # stop = time.time()
-        # print(stop-start)
+        #stop = time.time()
+        #print(stop-start)
         return ret
 
-
 class NumpyEncoder(json.JSONEncoder):
-    """Special json encoder for numpy types"""
-
+    """ Special json encoder for numpy types """
     def default(self, obj):
         if isinstance(obj, np.integer):
             return int(obj)
         elif isinstance(obj, np.floating):
             return float(obj)
         elif isinstance(obj, np.ndarray):
             return obj.tolist()
         return json.JSONEncoder.default(self, obj)
 
 
-if __name__ == "__main__":
-    pass
+if __name__ == '__main__':
+    pass
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bDetection.py` & `sanpy-ephys-0.1.6/sanpy/bDetection.py`

 * *Files 20% similar despite different names*

```diff
@@ -33,413 +33,369 @@
 import pathlib
 from pprint import pprint
 import glob
 import copy
 from collections import OrderedDict
 
 from matplotlib.font_manager import json_load
-
-# from colin.stochAnalysis import load
+#from colin.stochAnalysis import load
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class detectionTypes_(Enum):
     """
     Detection type is one of (dvdt, mv).
 
     dvdt: Search for threshold crossings in first derivative of membrane potential.
     mv: Search for threshold crossings in membrane potential.
     """
-
-    dvdt = "dvdt"
-    mv = "mv"
-
+    dvdt = 'dvdt'
+    mv = 'mv'
 
 # TODO (Cudmore) this needs to be a class so we can expand/contract based
 # on what we find on the hard-drive
 # allow user to save to detection presets
 
-
 def getDefaultDetection():
     """Get detection parameters
-
+    
     This includes a mapping from backend variable names to
     front-end human readable and long-format descriptions.
 
     Args:
         detectionPreset (enum): bDetection.detectionPresets.default
 
     Returns:
         dict: The default detection dictionary.
     """
-
+    
     theDict = OrderedDict()  # {}
 
-    """
+    '''
     key = 'include'
     theDict[key] = {}
     theDict[key]['defaultValue'] = True
     theDict[key]['type'] = 'bool'
     theDict[key]['allowNone'] = False
     theDict[key]['units'] = ''
     theDict[key]['humanName'] = 'Include'
     theDict[key]['errors'] = ('')
     theDict[key]['description'] = 'Include analysis for this file'
-    """
+    '''
+
+    key = 'detectionName'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 'default' #detectionPreset.value # ('dvdt', 'mv')
+    theDict[key]['type'] = 'string'
+    theDict[key]['allowNone'] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Detection Preset Name'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'The name of detection preset'
+
+    key = 'userSaveName'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = '' #detectionPreset.value # ('dvdt', 'mv')
+    theDict[key]['type'] = 'string'
+    theDict[key]['allowNone'] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Saved Detection Params'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'The name of saved user detection params'
+
+    key = 'detectionType'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = sanpy.bDetection.detectionTypes['dvdt'].value  # ('dvdt', 'mv')
+    theDict[key]['type'] = 'sanpy.bDetection.detectionTypes'
+    theDict[key]['allowNone'] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Detection Type'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Detect using derivative (dvdt) or membrane potential (mV)'
+
+    key = 'dvdtThreshold'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 20
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = True  # To do, have 2x entry points to bAnalysis detect, never set this to nan
+    theDict[key]['units'] = 'dVdt'
+    theDict[key]['humanName'] = 'dV/dt Threshold'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'dV/dt threshold for a spike, will be backed up to dvdt_percentOfMax and have xxx error when this fails'
+
+    key = 'mvThreshold'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = -20
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'mV'
+    theDict[key]['humanName'] = 'mV Threshold'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'mV threshold for spike AND minimum spike mV when detecting with dV/dt'
+
+    key = 'startSeconds'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = None
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = True
+    theDict[key]['units'] = 's'
+    theDict[key]['humanName'] = 'Start(s)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Start seconds of analysis'
+
+    key = 'stopSeconds'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = None
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = True
+    theDict[key]['units'] = 's'
+    theDict[key]['humanName'] = 'Stop(s)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Stop seconds of analysis'
+
+    key = 'cellType'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = ''
+    theDict[key]['type'] = 'string'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Cell Type'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Cell Type'
+
+    key = 'sex'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = ''
+    theDict[key]['type'] = 'string'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Sex'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Sex'
+
+    key = 'condition'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = ''
+    theDict[key]['type'] = 'string'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'Condition'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Condition'
 
-    key = "detectionName"
+    key = 'dvdt_percentOfMax'
     theDict[key] = {}
-    theDict[key]["defaultValue"] = "default"  # detectionPreset.value # ('dvdt', 'mv')
-    theDict[key]["type"] = "string"
-    theDict[key][
-        "allowNone"
-    ] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Detection Preset Name"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "The name of detection preset"
-
-    key = "userSaveName"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = ""  # detectionPreset.value # ('dvdt', 'mv')
-    theDict[key]["type"] = "string"
-    theDict[key][
-        "allowNone"
-    ] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Saved Detection Params"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "The name of saved user detection params"
-
-    key = "detectionType"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = sanpy.bDetection.detectionTypes[
-        "dvdt"
-    ].value  # ('dvdt', 'mv')
-    theDict[key]["type"] = "sanpy.bDetection.detectionTypes"
-    theDict[key][
-        "allowNone"
-    ] = False  # To do, have 2x entry points to bAnalysis detect, never set this to nan
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Detection Type"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Detect using derivative (dvdt) or membrane potential (mV)"
-
-    key = "dvdtThreshold"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 20
-    theDict[key]["type"] = "float"
-    theDict[key][
-        "allowNone"
-    ] = True  # To do, have 2x entry points to bAnalysis detect, never set this to nan
-    theDict[key]["units"] = "dVdt"
-    theDict[key]["humanName"] = "dV/dt Threshold"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "dV/dt threshold for a spike, will be backed up to dvdt_percentOfMax and have xxx error when this fails"
-
-    key = "mvThreshold"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = -20
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "mV"
-    theDict[key]["humanName"] = "mV Threshold"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "mV threshold for spike AND minimum spike mV when detecting with dV/dt"
-
-    key = "startSeconds"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = None
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = True
-    theDict[key]["units"] = "s"
-    theDict[key]["humanName"] = "Start(s)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Start seconds of analysis"
-
-    key = "stopSeconds"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = None
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = True
-    theDict[key]["units"] = "s"
-    theDict[key]["humanName"] = "Stop(s)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Stop seconds of analysis"
-
-    key = "cellType"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = ""
-    theDict[key]["type"] = "string"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Cell Type"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Cell Type"
-
-    key = "sex"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = ""
-    theDict[key]["type"] = "string"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Sex"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Sex"
-
-    key = "condition"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = ""
-    theDict[key]["type"] = "string"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "Condition"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Condition"
-
-    key = "dvdt_percentOfMax"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 0.1
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "Percent"
-    theDict[key]["humanName"] = "dV/dt Percent of max"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "For dV/dt detection, the final TOP is when dV/dt drops to this percent from dV/dt AP peak"
-
-    key = "onlyPeaksAbove_mV"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = None
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = True
-    theDict[key]["units"] = "mV"
-    theDict[key]["humanName"] = "Accept Peaks Above (mV)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Only accept APs with peaks above this value (mV)"
-
-    key = "onlyPeaksBelow_mV"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = None
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = True
-    theDict[key]["units"] = "mV"
-    theDict[key]["humanName"] = "Accept Peaks Below (mV)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Only accept APs below this value (mV)"
+    theDict[key]['defaultValue'] = 0.1
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'Percent'
+    theDict[key]['humanName'] = 'dV/dt Percent of max'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'For dV/dt detection, the final TOP is when dV/dt drops to this percent from dV/dt AP peak'
+
+    key = 'onlyPeaksAbove_mV'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = None
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = True
+    theDict[key]['units'] = 'mV'
+    theDict[key]['humanName'] = 'Accept Peaks Above (mV)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Only accept APs with peaks above this value (mV)'
+
+    key = 'onlyPeaksBelow_mV'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = None
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = True
+    theDict[key]['units'] = 'mV'
+    theDict[key]['humanName'] = 'Accept Peaks Below (mV)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Only accept APs below this value (mV)'
 
     # TODO: get rid of this and replace with foot
-    key = "doBackupSpikeVm"
+    key = 'doBackupSpikeVm'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = False
+    theDict[key]['type'] = 'boolean'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'Boolean'
+    theDict[key]['humanName'] = 'Backup Vm Spikes'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'If true, APs detected with just mV will be backed up until Vm falls to xxx'
+
+    key = 'refractory_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 170
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Minimum AP interval (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'APs with interval (wrt previous AP) less than this will be removed'
+
+    key = 'peakWindow_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 100
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Peak Window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window after TOP (ms) to seach for AP peak (mV)'
+
+    key = 'dvdtPreWindow_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 10
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'dV/dt Pre Window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window (ms) to search before each TOP for real threshold crossing'
+
+    key = 'dvdtPostWindow_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 20
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'dV/dt Post Window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window (ms) to search after each AP peak for minimum in dv/dt'
+
+    key = 'mdp_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 250
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Pre AP MDP window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window (ms) before an AP to look for MDP'
+
+    key = 'avgWindow_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 5
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'MDP averaging window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window (ms) to calculate MDP (mV) as a mean rather than mV at single point for MDP'
+
+    key = 'lowEddRate_warning'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 8
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'EDD slope'
+    theDict[key]['humanName'] = 'EDD slope warning'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Generate warning when EED slope is lower than this value.'
+
+    key = 'halfHeights'
     theDict[key] = {}
-    theDict[key]["defaultValue"] = False
-    theDict[key]["type"] = "boolean"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "Boolean"
-    theDict[key]["humanName"] = "Backup Vm Spikes"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "If true, APs detected with just mV will be backed up until Vm falls to xxx"
-
-    key = "refractory_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 170
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Minimum AP interval (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "APs with interval (wrt previous AP) less than this will be removed"
-
-    key = "peakWindow_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 100
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Peak Window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Window after TOP (ms) to seach for AP peak (mV)"
-
-    key = "dvdtPreWindow_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 10
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "dV/dt Pre Window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Window (ms) to search before each TOP for real threshold crossing"
-
-    key = "dvdtPostWindow_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 20
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "dV/dt Post Window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Window (ms) to search after each AP peak for minimum in dv/dt"
-
-    key = "mdp_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 250
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Pre AP MDP window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Window (ms) before an AP to look for MDP"
-
-    key = "avgWindow_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 5
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "MDP averaging window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Window (ms) to calculate MDP (mV) as a mean rather than mV at single point for MDP"
-
-    key = "lowEddRate_warning"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 8
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "EDD slope"
-    theDict[key]["humanName"] = "EDD slope warning"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Generate warning when EED slope is lower than this value."
-
-    key = "halfHeights"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = [10, 20, 50, 80, 90]
-    theDict[key]["type"] = "list"  # list of number
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "AP Durations (%)"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "AP Durations as percent of AP height (AP Peak (mV) - TOP (mV))"
-
-    key = "halfWidthWindow_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 200
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Half Width Window (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Window (ms) after TOP to look for AP Durations"
-
-    key = "preSpikeClipWidth_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 200
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Pre AP Clip Width (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "The pre duration of generated AP clips (Before AP)"
-
-    key = "postSpikeClipWidth_ms"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 500
-    theDict[key]["type"] = "float"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "ms"
-    theDict[key]["humanName"] = "Post AP Clip Width (ms)"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "The post duration of generated AP clips (After AP)"
-
-    key = "medianFilter"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 0
-    theDict[key]["type"] = "int"
-    theDict[key]["allowNone"] = True  # 0 is no median filter (see SavitzkyGolay_pnts)
-    theDict[key]["units"] = "points"
-    theDict[key]["humanName"] = "Median Filter Points"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Number of points in median filter, must be odd, 0 for no filter"
-
-    key = "SavitzkyGolay_pnts"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 5  # 20211001 was 5
-    theDict[key]["type"] = "int"
-    theDict[key]["allowNone"] = True  # 0 is no filter
-    theDict[key]["units"] = "points"
-    theDict[key]["humanName"] = "SavitzkyGolay Points"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "Number of points in SavitzkyGolay filter, must be odd, 0 for no filter"
-
-    key = "SavitzkyGolay_poly"
-    theDict[key] = {}
-    theDict[key]["defaultValue"] = 2
-    theDict[key]["type"] = "int"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = ""
-    theDict[key]["humanName"] = "SavitzkyGolay Poly Deg"
-    theDict[key]["errors"] = ""
-    theDict[key][
-        "description"
-    ] = "The degree of the polynomial for Savitzky-Golay filter"
+    theDict[key]['defaultValue'] = [10, 20, 50, 80, 90]
+    theDict[key]['type'] = 'list' # list of number
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'AP Durations (%)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'AP Durations as percent of AP height (AP Peak (mV) - TOP (mV))'
+
+    key = 'halfWidthWindow_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 200
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Half Width Window (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Window (ms) after TOP to look for AP Durations'
+
+    key = 'preSpikeClipWidth_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 200
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Pre AP Clip Width (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'The pre duration of generated AP clips (Before AP)'
+
+    key = 'postSpikeClipWidth_ms'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 500
+    theDict[key]['type'] = 'float'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'ms'
+    theDict[key]['humanName'] = 'Post AP Clip Width (ms)'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'The post duration of generated AP clips (After AP)'
+
+    key = 'medianFilter'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 0
+    theDict[key]['type'] = 'int'
+    theDict[key]['allowNone'] = True # 0 is no median filter (see SavitzkyGolay_pnts)
+    theDict[key]['units'] = 'points'
+    theDict[key]['humanName'] = 'Median Filter Points'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Number of points in median filter, must be odd, 0 for no filter'
+
+    key = 'SavitzkyGolay_pnts'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 5 #20211001 was 5
+    theDict[key]['type'] = 'int'
+    theDict[key]['allowNone'] = True # 0 is no filter
+    theDict[key]['units'] = 'points'
+    theDict[key]['humanName'] = 'SavitzkyGolay Points'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Number of points in SavitzkyGolay filter, must be odd, 0 for no filter'
+
+    key = 'SavitzkyGolay_poly'
+    theDict[key] = {}
+    theDict[key]['defaultValue'] = 2
+    theDict[key]['type'] = 'int'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = ''
+    theDict[key]['humanName'] = 'SavitzkyGolay Poly Deg'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'The degree of the polynomial for Savitzky-Golay filter'
 
     # key = 'dateAnalyzed'
     # theDict[key] = {}
     # theDict[key]['defaultValue'] = ''
     # theDict[key]['type'] = 'str'
     # theDict[key]['allowNone'] = False
     # theDict[key]['units'] = ''
     # theDict[key]['humanName'] = 'Date Analyzed'
     # theDict[key]['errors'] = ('')
     # theDict[key]['description'] = 'The date of analysis (yyyymmdd)'
 
-    key = "verbose"
+    key = 'verbose'
     theDict[key] = {}
-    theDict[key]["defaultValue"] = False
-    theDict[key]["type"] = "boolean"
-    theDict[key]["allowNone"] = False
-    theDict[key]["units"] = "Boolean"
-    theDict[key]["humanName"] = "Verbose"
-    theDict[key]["errors"] = ""
-    theDict[key]["description"] = "Verbose Detection Reporting"
+    theDict[key]['defaultValue'] = False
+    theDict[key]['type'] = 'boolean'
+    theDict[key]['allowNone'] = False
+    theDict[key]['units'] = 'Boolean'
+    theDict[key]['humanName'] = 'Verbose'
+    theDict[key]['errors'] = ('')
+    theDict[key]['description'] = 'Verbose Detection Reporting'
 
     # assign each detection param current value to it default value
-    for k, v in theDict.items():
-        defaultValue = theDict[k]["defaultValue"]
-        theDict[k]["currentValue"] = defaultValue
+    for k,v in theDict.items():
+        defaultValue = theDict[k]['defaultValue']
+        theDict[k]['currentValue'] = defaultValue
 
-    """
+    '''
     if detectionPreset == bDetection.detectionPresets.default:
         # these are defaults from above
         pass
     elif detectionPreset == bDetection.detectionPresets.sanode:
         # these are defaults from above
         pass
     elif detectionPreset == bDetection.detectionPresets.ventricular:
@@ -499,65 +455,63 @@
         theDict['preSpikeClipWidth_ms']['defaultValue'] = 200
         theDict['postSpikeClipWidth_ms']['defaultValue'] = 1000
     else:
         logger.error(f'Did not understand detection type "{detectionPreset}"')
         logger.error(f'    bDetection.detectionPresets.fastneuron: {bDetection.detectionPresets.fastneuron}')
         logger.error(f'    type(bDetection.detectionPresets.fastneuron): {type(bDetection.detectionPresets.fastneuron)}')
         logger.error(f'    detectionPreset == bDetection.detectionPresets.fastneuron: {detectionPreset == bDetection.detectionPresets.fastneuron}')
-    """
+    '''
 
     # assign each detection param current value to it default value
-    """
+    '''
     for k,v in theDict.items():
         defaultValue = theDict[k]['defaultValue']
         theDict[k]['currentValue'] = defaultValue
-    """
+    '''
 
     return theDict.copy()
 
-
 def printDocs():
     """Print out human readable detection parameters and convert to markdown table.
 
     Requires:
         pip install tabulate
 
     See: bAnalysisResults.printDocs()
     """
-    logger.info("")
-
+    logger.info('')
+    
     import pandas as pd
 
-    # detectionPreset = bDetection.detectionPresets.default  # detectionPresets_ is an enum class
+    #detectionPreset = bDetection.detectionPresets.default  # detectionPresets_ is an enum class
     d = getDefaultDetection()
     dictList = []
-    for k, v in d.items():
+    for k,v in d.items():
         parameter = k
         oneDict = {
-            "Parameter": parameter,
-            "Default Value": v["defaultValue"],
-            "Units": v["units"],
-            "Human Readable": v["humanName"],
-            "Description": v["description"],
+            'Parameter': parameter,
+            'Default Value': v['defaultValue'],
+            'Units': v['units'],
+            'Human Readable': v['humanName'],
+            'Description': v['description'],
         }
         dictList.append(oneDict)
     #
     df = pd.DataFrame(dictList)
-
+    
     # spit out markdown to copy/paste into mkdocs md file
     # REMEMBER: This requires `pip install tabulate`
-    # outStr = df.to_markdown()
+    #outStr = df.to_markdown()
     # print(outStr)
-
+    
     # save to csv for making a table for manuscript
-    path = "/Users/cudmore/Desktop/sanpy-detection-params-20230316.csv"
-    print("saving to:", path)
+    path = '/Users/cudmore/Desktop/sanpy-detection-params-20230316.csv'
+    print('saving to:', path)
     df.to_csv(path, index=False)
 
-
 '''
 class detectionPresets():
     """A list of bDetection that are saved/loaded from json files.
     """
     def __init__(self):
         self._path = 'detectionPresets'  # folder to load from
         
@@ -572,54 +526,51 @@
         for file in files:
             if not file.endswith('.json'):
                 continue
             oneJson = json_load(file)
             print(oneJson)
 '''
 
-
 class bDetection(object):
-    """Class to manage detection parameters."""
-
+    """ Class to manage detection parameters.
+    """
     detectionTypes = detectionTypes_
     """ Enum with the type of spike detection, (dvdt, mv)"""
 
     def __init__(self):
         """Load all sanpy and <user> detection json files."""
 
         # dict with detection key and current value
         self._dDict = getDefaultDetection()
-
+        
         # list of preset names including <user>SanPy/detection json files
         # use item=e[key] or item=e(value) then use item.name or item.value
         _theDict, _userPresetsDict = self._getPresetsDict()
-        self._detectionEnum = Enum("self.detectionEnum", _theDict)
+        self._detectionEnum = Enum('self.detectionEnum', _theDict)
 
         # dictionary of presets, each key is like 'sanode' and then value is a dict of
         #   detection param keys and their values
         self._detectionPreset = {}
         for item in self._detectionEnum:
             # item is like self.detectionEnum.sanode
-            # logger.info(f'  loaded {item}, {item.name}, "{item.value}"')
+            #logger.info(f'  loaded {item}, {item.name}, "{item.value}"')
             presetValues = self._getPresetValues(item)
             if presetValues:
                 # got value of built in preset
                 self._detectionPreset[item.name] = presetValues
             else:
                 # find in user loaded presets
                 _userKey = item.name
                 try:
                     self._detectionPreset[item.name] = _userPresetsDict[_userKey]
                 except:
-                    logger.erro(
-                        f"did not find item.name:{item.name} in _detectionPreset {self._detectionPreset.keys()}"
-                    )
+                    logger.erro(f'did not find item.name:{item.name} in _detectionPreset {self._detectionPreset.keys()}')
 
     def getDetectionPresetList(self):
-        """ "Get list of names of detection type.
+        """"Get list of names of detection type.
 
         Used to make a list in popup in interface/ and interface/plugins
         """
         detectionList = []
         for detectionPreset in self._detectionEnum:
             detectionList.append(detectionPreset.value)
         return detectionList
@@ -630,556 +581,514 @@
             2) <user>/Documents/Sanpy/detection/
 
         For file name like 'Fast Neuron.json' make key 'fastneuron'
 
         Returns:
             userPresets (dict): One item per user file
         """
-
+        
         def fileNameToKey(filePath):
-            """Given full path to json file, return
-            Filename without extension, and a well formed key.
+            """Given full path to json file, return 
+                Filename without extension, and a well formed key.
             """
             fileName = os.path.split(filePath)[1]
             fileName = os.path.splitext(fileName)[0]
 
             fileNameKey = os.path.split(filePath)[1]
             fileNameKey = os.path.splitext(fileNameKey)[0]
             # reduce preset json filename to (lower case, no spaces, no dash)
             fileNameKey = fileNameKey.lower()
-            fileNameKey = fileNameKey.replace(" ", "")
-            fileNameKey = fileNameKey.replace(
-                "-", ""
-            )  # in case user specifies a '-' in file name
+            fileNameKey = fileNameKey.replace(' ', '')
+            fileNameKey = fileNameKey.replace('-', '')  # in case user specifies a '-' in file name
             return fileName, fileNameKey
 
-        theDict = {}
+        theDict= {}
         userPresets = {}
 
         #
         # get files in our 'detection-presets' folder
-        """
+        '''
         presetsPath = pathlib.Path(sanpy._util.getBundledDir()) / 'detection-presets' / '*.json'
         files = glob.glob(str(presetsPath))
         for filePath in files:
             fileName, fileNameKey = fileNameToKey(filePath)
             #
             theDict[fileNameKey] = fileName
-        """
-        theDict["sanode"] = "SA Node"
-        theDict["ventricular"] = "Ventricular"
-        theDict["neuron"] = "Neuron"
-        theDict["fastneuron"] = "Fast Neuron"
-        theDict["subthreshold"] = "Sub Threshold"
-        theDict["caspikes"] = "Ca Spikes"
-        theDict["cakymograph"] = "Ca Kymograph"
+        '''
+        theDict['sanode'] = 'SA Node'
+        theDict['ventricular'] = 'Ventricular'
+        theDict['neuron'] = 'Neuron'
+        theDict['fastneuron'] = 'Fast Neuron'
+        theDict['subthreshold'] = 'Sub Threshold'
+        theDict['caspikes'] = 'Ca Spikes'
+        theDict['cakymograph'] = 'Ca Kymograph'
 
         #
         # get files in <users>/Documents/SanPy/detection/ folder
-        # userDetectionPath = pathlib.Path(sanpy._util._getUserDetectionFolder()) / '*.json'
-        # files = glob.glob(str(userDetectionPath))
+        #userDetectionPath = pathlib.Path(sanpy._util._getUserDetectionFolder()) / '*.json'
+        #files = glob.glob(str(userDetectionPath))
         files = self._getUserFiles()
-        # print('user files:', files)
+        #print('user files:', files)
         for filePath in files:
             fileName, fileNameKey = fileNameToKey(filePath)
             theDict[fileNameKey] = fileName
 
             # load user preset json and grab (param keys and values)
-            with open(filePath, "r") as f:
+            with open(filePath, 'r') as f:
                 userPresetsDict = json.load(f)
                 userPresets[fileNameKey] = userPresetsDict
 
         return theDict, userPresets
 
     def _getUserFiles(self):
-        """Get the full path to all user file presets .json"""
+        """Get the full path to all user file presets .json
+        """
         userDetectionPath = pathlib.Path(sanpy._util._getUserDetectionFolder())
         if userDetectionPath.is_dir:
-            files = userDetectionPath.glob("*.json")
+            files = userDetectionPath.glob('*.json')
             return files
         else:
             return []
 
     def toJson(self):
-        """Get key and defaultValue"""
+        """Get key and defaultValue
+        """
         theDict = {}
-        for k, v in self._dDict.items():
-            theDict[k] = v["defaultValue"]
+        for k,v in self._dDict.items():
+            theDict[k] = v['defaultValue']
 
-        # logger.info('theDict:')
-        # pprint(theDict)
+        #logger.info('theDict:')
+        #pprint(theDict)
 
-        # with open(savePath, 'w') as f:
+        #with open(savePath, 'w') as f:
         #    json.dump(self._dDict, f, indent=4)
         theJson = json.dumps(theDict, indent=4)
-        # logger.info('theJson:')
+        #logger.info('theJson:')
         return theJson
 
-    def old_saveAs(self, detectionType: str, filename, path=None):
+    def old_saveAs(self, detectionType : str, filename, path=None):
         """Save a detection dictionary to json.
-
+        
         If running in GUI, main SanPy app will specify the correct path.
 
         This is only for user defined sets, we never save our built in detection (hard coded in code).
 
         Args:
             detectionType: human readable like 'SA Node', will become 'SA Node.json'
             filename: Name of file to save (no extension, will append .json)
         """
-        # _keyName = self._detectionEnum(detectionType).name
+        #_keyName = self._detectionEnum(detectionType).name
         if path is None:
             # get <user>/Documents/SanPy/xxx folder
             savePath = sanpy._util._getUserDetectionFolder()
-            savePath = pathlib.Path(savePath) / f"{filename}.json"
+            savePath = pathlib.Path(savePath) / f'{filename}.json'
         logger.info(str(savePath))
-        with open(savePath, "w") as f:
+        with open(savePath, 'w') as f:
             dDict = self.getDetectionDict(detectionType)
-            dDict["detectionName"] = filename
+            dDict['detectionName'] = filename
             json.dump(dDict, f, indent=4)
 
     def printDict(self):
         for k in self._dDict.keys():
-            v = self._dDict[k]["currentValue"]
+            v = self._dDict[k]['currentValue']
             print(f'  {k}: "{v}" {type(v)}')
 
-    def getMasterDict(self, detectionType: str):
+    def getMasterDict(self, detectionType : str):
         """Get the full dictionary from self._dDict getDefaultDetection()
 
         This is needed by sanpy/interface/plugins/detectionParams.py
         """
 
         retDict = copy.deepcopy(self._dDict)
 
         detectionTypeKey = self._detectionEnum(detectionType).name
         oneType = self._detectionPreset[detectionTypeKey]
-        for k, v in oneType.items():
-            retDict[k]["currentValue"] = v
+        for k,v in oneType.items():
+            retDict[k]['currentValue'] = v
 
         return retDict
 
-    def getDetectionDict(self, detectionType: str, allParameter=True):
+    def getDetectionDict(self, detectionType : str, allParameter=True):
         """Get a full detection dict.
-
+        
         Presets like 'SA Node' only over-ride a subset of the defaults, thus need to merge.
         User saved detection parameters will have all keys.
-
+        
         Args:
             detectionType : detection type key, like 'SA Node'
         """
         try:
             if allParameter:
                 dDict = {}
-
+                
                 # master template to get all default values
-                for k, v in self._dDict.items():
-                    dDict[k] = v["currentValue"]
+                for k,v in self._dDict.items():
+                    dDict[k] = v['currentValue']
 
                 # use specified detection type to get over-written values
                 detectionTypeKey = self._detectionEnum(detectionType).name
                 oneType = self._detectionPreset[detectionTypeKey]
-                for k, v in oneType.items():
+                for k,v in oneType.items():
                     dDict[k] = v
             return dDict
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'Did not find detectionType:"{detectionType}"')
-        except ValueError as e:
+        except (ValueError) as e:
             logger.error(f'Did not find detectionType:"{detectionType}"')
 
-    def getValue(self, detectionType: str, key):
+    def getValue(self, detectionType : str, key):
         """Get current value from key. Valid keys are defined in getDefaultDetection().
-
+        
         Args:
             detectionType : string value from enum, like 'SA Node'
         """
         try:
-            # return self._dDict[key]['currentValue']
+            #return self._dDict[key]['currentValue']
             return self._detectionPreset[detectionType][key]
-        except KeyError as e:
-            logger.warning(
-                f'Did not find detectionType "{detectionType}" or key "{key}" to get current value'
-            )
+        except (KeyError) as e:
+            logger.warning(f'Did not find detectionType "{detectionType}" or key "{key}" to get current value')
             # TODO: define default when not found ???
             return None
 
-    def setValue(self, detectionType: str, key: str, value):
+    def setValue(self, detectionType : str, key : str, value):
         """
         Set current value for key. Valid keys are defined in getDefaultDetection.
 
         For float values that need to take on none, value comes in as -1e9
-
+        
         Args:
             detectionType : short name (not value)
         """
         try:
             valueType = type(value)
             valueIsNumber = isinstance(value, numbers.Number)
             valueIsString = isinstance(value, str)
             valueIsBool = isinstance(value, bool)
             valueIsList = isinstance(value, list)
             valueIsNone = value is None
 
             # from the master list
-            expectedType = self._dDict[key]["type"]  # (number, string, boolean)
-            allowNone = self._dDict[key][
-                "allowNone"
-            ]  # used to turn off a detection param
+            expectedType = self._dDict[key]['type'] # (number, string, boolean)
+            allowNone = self._dDict[key]['allowNone'] # used to turn off a detection param
 
-            # logger.info(f'expectedType:{expectedType} value type is {type(value)}')
+            #logger.info(f'expectedType:{expectedType} value type is {type(value)}')
 
             if allowNone and valueIsNone:
                 pass
-            elif expectedType == "number" and not valueIsNumber:
-                logger.warning(
-                    f'Type mismatch (number) setting key "{key}", got {valueType}, expecting {expectedType}'
-                )
+            elif expectedType=='number' and not valueIsNumber:
+                logger.warning(f'Type mismatch (number) setting key "{key}", got {valueType}, expecting {expectedType}')
                 return False
-            elif expectedType == "string" and not valueIsString:
-                logger.warning(
-                    f'Type mismatch (string) setting "{key}", got {valueType}, expecting {expectedType}'
-                )
+            elif expectedType=='string' and not valueIsString:
+                logger.warning(f'Type mismatch (string) setting "{key}", got {valueType}, expecting {expectedType}')
                 return False
-            elif expectedType == "boolean" and not valueIsBool:
-                logger.warning(
-                    f'Type mismatch (bool) setting "{key}", got {valueType}, expecting {expectedType}'
-                )
+            elif expectedType=='boolean' and not valueIsBool:
+                logger.warning(f'Type mismatch (bool) setting "{key}", got {valueType}, expecting {expectedType}')
                 return False
-            elif expectedType == "list" and not valueIsList:
-                logger.warning(
-                    f'Type mismatch (list) setting "{key}", got {valueType}, expecting {expectedType}'
-                )
+            elif expectedType=='list' and not valueIsList:
+                logger.warning(f'Type mismatch (list) setting "{key}", got {valueType}, expecting {expectedType}')
                 return False
-            """
+            '''
             elif expectedType=='sanpy.bDetection.detectionTypes':
                 try:
                     value = sanpy.bDetection.detectionTypes[value].name
                     #print(value == sanpy.bDetection.detectionTypes.dvdt)
                     #print(value == sanpy.bDetection.detectionTypes.mv)
                 except (KeyError) as e:
                     logger.error(f'sanpy.bDetection.detectionTypes does not contain value "{value}"')
-            """
+            '''
             #
             # set
-            # self._dDict[key]['currentValue'] = value
+            #self._dDict[key]['currentValue'] = value
             self._detectionPreset[detectionType][key] = value
 
-            logger.info(
-                f"now detectionType:{detectionType} key:{key}: {self._detectionPreset[detectionType][key]} {type(self._detectionPreset[detectionType][key])}"
-            )
+            logger.info(f"now detectionType:{detectionType} key:{key}: {self._detectionPreset[detectionType][key]} {type(self._detectionPreset[detectionType][key])}")
 
             return True
 
-        except KeyError as e:
-            logger.warning(
-                f'Did not find detectionType:{detectionType}, key:"{key}" to set current value to "{value}"'
-            )
+        except (KeyError) as e:
+            logger.warning(f'Did not find detectionType:{detectionType}, key:"{key}" to set current value to "{value}"')
             return False
 
     def old_save(self, saveBase):
         """
         Save underlying dict to json file
 
         Args:
             save base (str): basename to append '-detection.json'
         """
 
         # convert
 
-        savePath = saveBase + "-detection.json"
+        savePath = saveBase + '-detection.json'
 
-        with open(savePath, "w") as f:
+        with open(savePath, 'w') as f:
             json.dump(self._dDict, f, indent=4)
 
     def old_load(self, loadBase):
         """
         Load detection from json file.
 
         Fill in underlying dict
         """
 
-        loadPath = loadBase + "-detection.json"
+        loadPath = loadBase + '-detection.json'
 
         if not os.path.isfile(loadPath):
-            logger.error(f"Did not find file: {loadPath}")
+            logger.error(f'Did not find file: {loadPath}')
             return
 
-        with open(loadPath, "r") as f:
+        with open(loadPath, 'r') as f:
             self._dDict = json.load(f)
 
         # convert
 
     def _getPresetValues(self, detectionPreset):
         """
         detectionName : corresponds to key in enum self._detectionEnum
         """
 
         theDict = {}
-
+        
         if detectionPreset == self._detectionEnum.sanode:
-            theDict["detectionName"] = "SA Node"
-            theDict["dvdtThreshold"] = 20
-            theDict["mvThreshold"] = -20
-            theDict["refractory_ms"] = 170  # max freq of 5 Hz
-            theDict["peakWindow_ms"] = 100
-            theDict["halfWidthWindow_ms"] = 200
-            theDict["preSpikeClipWidth_ms"] = 200
-            theDict["postSpikeClipWidth_ms"] = 500
+            theDict['detectionName'] = 'SA Node'
+            theDict['dvdtThreshold'] = 20
+            theDict['mvThreshold'] = -20
+            theDict['refractory_ms'] = 170  # max freq of 5 Hz
+            theDict['peakWindow_ms'] = 100
+            theDict['halfWidthWindow_ms'] = 200
+            theDict['preSpikeClipWidth_ms'] = 200
+            theDict['postSpikeClipWidth_ms'] = 500
         elif detectionPreset == self._detectionEnum.ventricular:
-            theDict["detectionName"] = "Ventricular"
-            theDict["dvdtThreshold"] = 100
-            theDict["mvThreshold"] = -20
-            theDict["refractory_ms"] = 200  # max freq of 5 Hz
-            theDict["peakWindow_ms"] = 100
-            theDict["halfWidthWindow_ms"] = 300
-            theDict["preSpikeClipWidth_ms"] = 200
-            theDict["postSpikeClipWidth_ms"] = 500
+            theDict['detectionName'] = 'Ventricular'
+            theDict['dvdtThreshold'] = 100
+            theDict['mvThreshold'] = -20
+            theDict['refractory_ms'] = 200  # max freq of 5 Hz
+            theDict['peakWindow_ms'] = 100
+            theDict['halfWidthWindow_ms'] = 300
+            theDict['preSpikeClipWidth_ms'] = 200
+            theDict['postSpikeClipWidth_ms'] = 500
         elif detectionPreset == self._detectionEnum.neuron:
-            theDict["detectionName"] = "Neuron"
-            theDict["dvdtThreshold"] = 20
-            theDict["mvThreshold"] = -40
-            theDict["refractory_ms"] = 4
-            theDict["peakWindow_ms"] = 5
-            theDict["halfWidthWindow_ms"] = 4
-            theDict["dvdtPreWindow_ms"] = 2
-            theDict["dvdtPostWindow_ms"] = 2
-            theDict["preSpikeClipWidth_ms"] = 2
-            theDict["postSpikeClipWidth_ms"] = 2
+            theDict['detectionName'] = 'Neuron'
+            theDict['dvdtThreshold'] = 20
+            theDict['mvThreshold'] = -40
+            theDict['refractory_ms'] = 4
+            theDict['peakWindow_ms'] = 5
+            theDict['halfWidthWindow_ms'] = 4
+            theDict['dvdtPreWindow_ms'] = 2
+            theDict['dvdtPostWindow_ms'] = 2
+            theDict['preSpikeClipWidth_ms'] = 2
+            theDict['postSpikeClipWidth_ms'] = 2
         elif detectionPreset == self._detectionEnum.fastneuron:
-            theDict["detectionName"] = "Fast Neuron"
-            theDict["dvdtThreshold"] = 20
-            theDict["mvThreshold"] = -40
-            theDict["refractory_ms"] = 3
-            theDict["peakWindow_ms"] = 2
-            theDict["halfWidthWindow_ms"] = 4
-            theDict["dvdtPreWindow_ms"] = 2
-            theDict["dvdtPostWindow_ms"] = 2
-            theDict["preSpikeClipWidth_ms"] = 2
-            theDict["postSpikeClipWidth_ms"] = 2
+            theDict['detectionName'] = 'Fast Neuron'
+            theDict['dvdtThreshold'] = 20
+            theDict['mvThreshold'] = -40
+            theDict['refractory_ms'] = 3
+            theDict['peakWindow_ms'] = 2
+            theDict['halfWidthWindow_ms'] = 4
+            theDict['dvdtPreWindow_ms'] = 2
+            theDict['dvdtPostWindow_ms'] = 2
+            theDict['preSpikeClipWidth_ms'] = 2
+            theDict['postSpikeClipWidth_ms'] = 2
         elif detectionPreset == self._detectionEnum.subthreshold:
-            theDict["detectionName"] = "Subthreshold"
-            theDict["dvdtThreshold"] = math.nan
-            theDict["mvThreshold"] = -20  # user specifies
-            theDict["refractory_ms"] = 100  # max freq is 10 Hz
-            theDict["peakWindow_ms"] = 50
-            theDict["halfWidthWindow_ms"] = 100
-            theDict["preSpikeClipWidth_ms"] = 100
-            theDict["postSpikeClipWidth_ms"] = 200
-            theDict["onlyPeaksAbove_mV"] = None
-            theDict["onlyPeaksBelow_mV"] = -20
+            theDict['detectionName'] = 'Subthreshold'
+            theDict['dvdtThreshold'] = math.nan
+            theDict['mvThreshold'] = -20  # user specifies
+            theDict['refractory_ms'] = 100  # max freq is 10 Hz
+            theDict['peakWindow_ms'] = 50
+            theDict['halfWidthWindow_ms'] = 100
+            theDict['preSpikeClipWidth_ms'] = 100
+            theDict['postSpikeClipWidth_ms'] = 200
+            theDict['onlyPeaksAbove_mV'] = None
+            theDict['onlyPeaksBelow_mV'] = -20
             # todo: add onlyPeaksBelow_mV
         elif detectionPreset == self._detectionEnum.caspikes:
-            theDict["detectionName"] = "Ca Spikes"
-            # theDict['detectionType'] = sanpy.bDetection.detectionTypes.mv # ('dvdt', 'mv')
-            theDict[
-                "dvdtThreshold"
-            ] = math.nan  # if None then detect only using mvThreshold
-            theDict["mvThreshold"] = 0.5
-            # theDict['refractory_ms'] = 200 #170 # reject spikes with instantaneous frequency
-            # theDict['halfWidthWindow_ms'] = 200 #was 20
+            theDict['detectionName'] = 'Ca Spikes'
+            #theDict['detectionType'] = sanpy.bDetection.detectionTypes.mv # ('dvdt', 'mv')
+            theDict['dvdtThreshold'] = math.nan #if None then detect only using mvThreshold
+            theDict['mvThreshold'] = 0.5
+            #theDict['refractory_ms'] = 200 #170 # reject spikes with instantaneous frequency
+            #theDict['halfWidthWindow_ms'] = 200 #was 20
         elif detectionPreset == self._detectionEnum.cakymograph:
-            theDict["detectionName"] = "Ca Kymograph"
-            theDict["detectionType"] = sanpy.bDetection.detectionTypes["mv"].value
-            theDict[
-                "dvdtThreshold"
-            ] = 1.2  # rosie, was math.nan #if None then detect only using mvThreshold
-            theDict["mvThreshold"] = 1.2
-            theDict["peakWindow_ms"] = 400  # rosie, was 700
-            theDict["halfWidthWindow_ms"] = 400  # rosie, was 800
-            theDict["refractory_ms"] = 500
-            theDict["doBackupSpikeVm"] = False
+            theDict['detectionName'] = 'Ca Kymograph'
+            theDict['detectionType'] = sanpy.bDetection.detectionTypes['mv'].value
+            theDict['dvdtThreshold'] = 1.2 # rosie, was math.nan #if None then detect only using mvThreshold
+            theDict['mvThreshold'] = 1.2
+            theDict['peakWindow_ms'] = 400 # rosie, was 700
+            theDict['halfWidthWindow_ms'] = 400 # rosie, was 800
+            theDict['refractory_ms'] = 500
+            theDict['doBackupSpikeVm'] = False
             # theDict['SavitzkyGolay_pnts'] = 5
-            theDict["preSpikeClipWidth_ms"] = 200
-            theDict["postSpikeClipWidth_ms"] = 1000
+            theDict['preSpikeClipWidth_ms'] = 200
+            theDict['postSpikeClipWidth_ms'] = 1000
         else:
-            logger.error(f"did not understand detectionPreset: {detectionPreset}")
+            logger.error(f'did not understand detectionPreset: {detectionPreset}')
 
         return theDict
 
-
 def test_0():
     """
     Testing get/set of detection params
     """
 
     bd = bDetection()
 
-    # xxx = bd.getValue('xxx')
+    #xxx = bd.getValue('xxx')
 
-    # ok = bd.setValue('xxx', 2)
-    # print('ok:', ok)
+    #ok = bd.setValue('xxx', 2)
+    #print('ok:', ok)
 
-    ok1 = bd.setValue("dvdtThreshold", None)
+    ok1 = bd.setValue('dvdtThreshold', None)
     if not ok1:
-        print("ok1:", ok1)
+        print('ok1:', ok1)
 
-    ok1_5 = bd.setValue("mvThreshold", None)
+    ok1_5 = bd.setValue('mvThreshold', None)
     if not ok1_5:
-        print("failure ok ok1_5:", ok1_5)
+        print('failure ok ok1_5:', ok1_5)
 
-    ok2 = bd.setValue("cellType", "111")
+    ok2 = bd.setValue('cellType', '111')
     if not ok2:
-        print("ok2:", ok2)
+        print('ok2:', ok2)
 
     # for setting list, check that (i) not empty and (ii) list[i] == expected type
-    ok3 = bd.setValue("halfHeights", [])
+    ok3 = bd.setValue('halfHeights', [])
     if not ok3:
-        print("ok3:", ok3)
+        print('ok3:', ok3)
 
     # start/stop seconds defaults to None but we want 'number'
-    ok4 = bd.setValue("startSeconds", 1e6)
+    ok4 = bd.setValue('startSeconds', 1e6)
     if not ok4:
-        print("ok4:", ok4)
+        print('ok4:', ok4)
 
-    tmpDict = {
-        "Idx": 2.0,
-        "Include": 1.0,
-        "File": "19114001.abf",
-        "Dur(s)": 60.0,
-        "kHz": 20.0,
-        "Mode": "fix",
-        "Cell Type": "",
-        "Sex": "",
-        "Condition": "",
-        "Start(s)": math.nan,
-        "Stop(s)": math.nan,
-        "dvdtThreshold": 50.0,
-        "mvThreshold": -20.0,
-        "refractory_ms": math.nan,
-        "peakWindow_ms": math.nan,
-        "halfWidthWindow_ms": math.nan,
-        "Notes": "",
-    }
-    for k, v in tmpDict.items():
-        print("  ", k, ":", v)
+    tmpDict = {'Idx': 2.0, 'Include': 1.0, 'File': '19114001.abf', 'Dur(s)': 60.0, 'kHz': 20.0, 'Mode': 'fix', 'Cell Type': '', 'Sex': '', 'Condition': '', 'Start(s)': math.nan, 'Stop(s)': math.nan, 'dvdtThreshold': 50.0, 'mvThreshold': -20.0, 'refractory_ms': math.nan, 'peakWindow_ms': math.nan, 'halfWidthWindow_ms': math.nan, 'Notes': ''}
+    for k,v in tmpDict.items():
+        print('  ', k, ':', v)
     okSetFromDict = bd.setFromDict(tmpDict)
 
-
 def test_save_load():
     # load an abf
-    path = "/Users/cudmore/Sites/SanPy/data/19114001.abf"
+    path = '/Users/cudmore/Sites/SanPy/data/19114001.abf'
     ba = sanpy.bAnalysis(path)
 
     # analyze
     ba.spikeDetect()
     print(ba)
 
-    # print(ba._getSaveFolder())
+    #print(ba._getSaveFolder())
     saveBase = ba._getSaveBase()
 
     detectionClass = ba.detectionClass
 
-    """
+    '''
     detectionClass.save(saveBase)
     detectionClass._dDict = None
 
     detectionClass.load(saveBase)
 
     detectionClass.print()
-    """
+    '''
 
     # might work
     ba.saveAnalysis()
 
     ba.loadAnalysis()
 
-    # ba.detectionClass.print()
+    #ba.detectionClass.print()
 
     print(ba)
 
-
 def _exportDetectionJson():
     """20220705
-
+    
     need to load/save detection presets from json
 
     To start, this will save json from the hard coded getDefaultDetection() function.
     """
-    savePath = "/Users/cudmore/Desktop/detection-presets"
-
+    savePath = '/Users/cudmore/Desktop/detection-presets'
+    
     for oneDetection in bDetection.detectionPresets:
-        print("oneDetection:", oneDetection, "oneDetection.value:", oneDetection.value)
-
+        print('oneDetection:', oneDetection, 'oneDetection.value:', oneDetection.value)
+ 
         onePreset = bDetection.detectionPresets(oneDetection)
         oneDetectionClass = bDetection(onePreset)
-        # oneJson = oneDetectionClass.toJson()
-
+        #oneJson = oneDetectionClass.toJson()
+       
         _theDict = {}
-        for k, v in oneDetectionClass._dDict.items():
+        for k,v in oneDetectionClass._dDict.items():
             print(k)
-            _theDict[k] = v["defaultValue"]
+            _theDict[k] = v['defaultValue']
 
-        # print('_theDict.items():', _theDict.items())
-        # pprint(_theDict)
+        #print('_theDict.items():', _theDict.items())
+        #pprint(_theDict)
 
-        oneSaveFile = oneDetection.value + ".json"
+        oneSaveFile = oneDetection.value + '.json'
         onseSavePath = os.path.join(savePath, oneSaveFile)
-        print("    ", onseSavePath)
-
-        with open(onseSavePath, "w") as f:
-            # json.dump(oneJson, f, ensure_ascii=False, indent=4)
+        print('    ', onseSavePath)
+        
+        with open(onseSavePath, 'w') as f:
+            #json.dump(oneJson, f, ensure_ascii=False, indent=4)
             json.dump(_theDict, f, indent=4)
 
         # load to check
         with open(onseSavePath) as f:
             # need this to keep them in order ... 'object_pairs_hook=OrderedDict'
             data_loaded = json.load(f, object_pairs_hook=OrderedDict)
         pprint(data_loaded)
 
-        # break
-
+        #break
 
 def testSwitchType():
-    # bd = sanpy.bDetection() # default to bDetection.detectionDefaults.default
-    bd = sanpy.bDetection()
 
+    #bd = sanpy.bDetection() # default to bDetection.detectionDefaults.default
+    bd = sanpy.bDetection()
+    
     # names of all presets, both (built in, and user)
     presetList = bd.getDetectionPresetList()
-    print("presetList:", presetList)
+    print('presetList:', presetList)
 
     # detection dict for one
-    print("=== sanode")
-    dDict = bd.getDetectionDict("SA Node")
-    for k, v in dDict.items():
-        print(f"    {k}:{v} {type(v)}")
-
-    print("=== fastneuron2")
-    dDict = bd.getDetectionDict("Fast Neuron 2")
-    for k, v in dDict.items():
-        print(f"    {k}:{v} {type(v)}")
+    print('=== sanode')
+    dDict = bd.getDetectionDict('SA Node')
+    for k,v in dDict.items():
+        print(f'    {k}:{v} {type(v)}')
+
+    print('=== fastneuron2')
+    dDict = bd.getDetectionDict('Fast Neuron 2')
+    for k,v in dDict.items():
+        print(f'    {k}:{v} {type(v)}')
 
     # detection dict for all
-    """
+    '''
     for item in bd._detectionEnum:
         dDict = bd.getDetectionDict(item.name)
         print(f'=== {item.name} {item.value}')
         pprint(dDict)
-    """
+    '''
 
-    bd.setValue("sanode", "dvdtThreshold", 12)
+    bd.setValue('sanode', 'dvdtThreshold', 12)
 
-    print("=== after setValue 12 sanode")
-    dDict = bd.getDetectionDict("SA Node")
-    for k, v in dDict.items():
-        print(f"    {k}:{v} {type(v)}")
+    print('=== after setValue 12 sanode')
+    dDict = bd.getDetectionDict('SA Node')
+    for k,v in dDict.items():
+        print(f'    {k}:{v} {type(v)}')
 
-    newValue = bd.getValue("sanode", "dvdtThreshold")
-    print("newValue:", newValue)
+    newValue = bd.getValue('sanode', 'dvdtThreshold')
+    print('newValue:', newValue)
 
     # works
     # bd.saveAs('SA Node', filename='xxx yyy')
-    bd.saveAs("SA Node", filename="SA Node 3")
-
-
-if __name__ == "__main__":
-    # test_0()
+    bd.saveAs('SA Node', filename='SA Node 3')
+    
+if __name__ == '__main__':
+    #test_0()
 
     # this works
     printDocs()
 
-    # test_save_load()
+    #test_save_load()
 
-    # _exportDetectionJson()
+    #_exportDetectionJson()
 
-    # testSwitchType()
+    #testSwitchType()
     # print('detectionPresets.default:', bDetection.detectionPresets.default)
     # print('detectionPresets.neuron:', bDetection.detectionPresets.neuron)
     # print('detectionPresets.neuron.value:', bDetection.detectionPresets.neuron.value)
-    # print('getDetectionPresetList:', bDetection.getDetectionPresetList())
+    # print('getDetectionPresetList:', bDetection.getDetectionPresetList())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/bExport.py` & `sanpy-ephys-0.1.6/sanpy/bExport.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,33 +1,29 @@
 import os
 from collections import OrderedDict
 from pprint import pprint
-from typing import Union, Dict, List, Tuple, Optional
 
 import numpy as np
 import pandas as pd
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-class bExport:
+class bExport():
     """Once analysis is performed with sanpy.bAnalysis.spikeDetect(),
         reports can be generated with the bExport class.
 
     Example reports are:
 
     - Generating reports as a Pandas DataFrame.
     - (depreciated) Saving reports as a Microsoft Excel file.
     - Saving reports as a CSV text files.
     """
-
     def __init__(self, ba):
         """
         Args:
             ba (sanpy.bAnalysis): A bAnalysis object that has had spikes detected with detectSpikes().
         """
         self.ba = ba
         self.sweepNumber = 0
@@ -40,344 +36,264 @@
             theMin (float): Start seconds of the analysis
             theMax (float): Stop seconds of the analysis
 
         Returns:
             df: Pandas DataFrame
         """
         if theMin is None or theMax is None:
-            # return None
+            #return None
             theMin = 0
             theMax = self.ba.fileLoader.recordingDur
 
-        logger.info(f"theMin:{theMin} theMax:{theMax}")
+        logger.info(f'theMin:{theMin} theMax:{theMax}')
 
         df = self.ba.asDataFrame()
-        df = df[(df["thresholdSec"] >= theMin) & (df["thresholdSec"] <= theMax)]
+        df = df[ (df['thresholdSec']>=theMin) & (df['thresholdSec']<=theMax) ]
 
         # added when trying to make scatterwidget for one file
-        df["Condition"] = ""  # df['condition1']
-        df["File Number"] = ""  # df['condition2']
-        df["Sex"] = ""  # df['condition3']
-        df["Region"] = ""  # df['condition4']
+        df['Condition'] = '' #df['condition1']
+        df['File Number'] = '' #df['condition2']
+        df['Sex'] = '' #df['condition3']
+        df['Region'] = '' #df['condition4']
 
         # make new column with sex/region encoded
-        """
+        '''
         tmpNewCol = 'RegSex'
         self.ba.masterDf[tmpNewCol] = ''
         for tmpRegion in ['Superior', 'Inferior']:
             for tmpSex in ['Male', 'Female']:
                 newEncoding = tmpRegion[0] + tmpSex[0]
                 regSex = self.ba.masterDf[ (self.ba.masterDf['Region']==tmpRegion) & (self.ba.masterDf['Sex']==tmpSex)]
                 regSex = (self.ba.masterDf['Region']==tmpRegion) & (self.ba.masterDf['Sex']==tmpSex)
                 print('newEncoding:', newEncoding, 'regSex:', regSex.shape)
                 self.ba.masterDf.loc[regSex, tmpNewCol] = newEncoding
-        """
+        '''
 
         # want this but region/sex/condition are not defined
-        # print('bExport.report()')
-        # print(df.head())
-        tmpNewCol = "CellTypeSex"
-        cellTypeStr = df["cellType"].iloc[0]
-        sexStr = df["sex"].iloc[0]
-        # print('cellTypeStr:', cellTypeStr, 'sexStr:', sexStr)
+        #print('bExport.report()')
+        #print(df.head())
+        tmpNewCol = 'CellTypeSex'
+        cellTypeStr = df['cellType'].iloc[0]
+        sexStr = df['sex'].iloc[0]
+        #print('cellTypeStr:', cellTypeStr, 'sexStr:', sexStr)
         regSexEncoding = cellTypeStr + sexStr
         df[tmpNewCol] = regSexEncoding
 
-        minStr = "%.2f" % (theMin)
-        maxStr = "%.2f" % (theMax)
-        minStr = minStr.replace(".", "_")
-        maxStr = maxStr.replace(".", "_")
+        minStr = '%.2f'%(theMin)
+        maxStr = '%.2f'%(theMax)
+        minStr = minStr.replace('.', '_')
+        maxStr = maxStr.replace('.', '_')
 
         # TODO: bytestreams are not strictly from a hdd folder or file
         fileName = self.ba.fileLoader.filename
         if fileName is not None:
             fileName, tmpExt = os.path.splitext(fileName)
-            analysisName = fileName + "_s" + minStr + "_s" + maxStr
-            # print('    minStr:', minStr, 'maxStr:', maxStr, 'analysisName:', analysisName)
+            analysisName = fileName + '_s' + minStr + '_s' + maxStr
+            #print('    minStr:', minStr, 'maxStr:', maxStr, 'analysisName:', analysisName)
         else:
-            analysisName = "bytestream"
-        df["analysisname"] = analysisName
+            analysisName = 'bytestream'
+        df['analysisname'] = analysisName
 
         return df
 
-    def report3(self, sweep='All',
-                epoch='All',
-                theMin : Optional[float] = None,
-                theMax : Optional[float] = None,
-                ) -> pd.DataFrame:
-        """Generate a full report of all spike columns.
-        
-        Like what is save in csv but limited by sweep, epoch, etc
+    def report2(self, theMin :float, theMax : float) -> pd.DataFrame:
         """
-
-        if self.ba.numSpikes == 0:
-            logger.warning(f"did not find and spikes for summary")
-            return None
-
-        df = self.ba.asDataFrame()  # full df with all spikes
-
-        spikeList = self.ba.getStat('spikeNumber', sweepNumber=sweep, epochNumber=epoch)
-
-        # reduce to spikes in list
-        df = df.loc[df['spikeNumber'].isin(spikeList)]
-
-        if theMin is not None and theMax is not None:
-            df = df[ (df['thresholdSec']>=theMin) & (df['thresholdSec']<theMax)]
-        
-        return df
-    
-    def report2(self, sweep='All',
-                epoch='All',
-                theMin : Optional[float] = None,
-                theMax : Optional[float] = None,
-                ) -> pd.DataFrame:
-
-        """Generate a human readable report of spikes.
+        Generate a human readable report of spikes.
         Include spike times between theMin and theMax (Sec).
 
         Args:
-            sweep ('All' or int') : 'All' for all sweeps or int for one sweep
-            epoch ('All' or int) : 'All' for all epochs or int for one epoch
             theMin (float): Start seconds to save, inclusive
             theMax (float): Stop seconds to save, inclusive
 
         Returns:
             df: pd.DataFrame
         """
-
-        spikeList = self.ba.getStat('spikeNumber', sweepNumber=sweep, epochNumber=epoch)
-
         newList = []
-        for spikeIdx in spikeList:
-            spike = self.ba.getOneSpikeDict(spikeIdx)
-            
-            # if current spike time is out of bounds
-            # then continue (e.g. it is not between theMin (sec) and theMax (sec)
-            spikeTime_sec = self.ba.fileLoader.pnt2Sec_(spike["thresholdPnt"])
-            if theMin is not None and theMax is not None:
-                if spikeTime_sec < theMin or spikeTime_sec > theMax:
-                    continue
+        for spikeIdx, spike in enumerate(self.ba.spikeDict):
+
+            # if current spike time is out of bounds then continue (e.g. it is not between theMin (sec) and theMax (sec)
+            spikeTime_sec = self.ba.fileLoader.pnt2Sec_(spike['thresholdPnt'])
+            if spikeTime_sec<theMin or spikeTime_sec>theMax:
+                continue
 
-            spikeDict = (
-                OrderedDict()
-            )  # use OrderedDict so Pandas output is in the correct order
-
-            spikeDict["Spike"] = spikeIdx
-            spikeDict["Take Off Potential (s)"] = self.ba.fileLoader.pnt2Sec_(
-                spike["thresholdPnt"]
-            )
-            spikeDict["Take Off Potential (ms)"] = self.ba.fileLoader.pnt2Ms_(
-                spike["thresholdPnt"]
-            )
-            spikeDict["Take Off Potential (mV)"] = spike["thresholdVal"]
-            spikeDict["AP Peak (ms)"] = self.ba.fileLoader.pnt2Ms_(spike["peakPnt"])
-            spikeDict["AP Peak (mV)"] = spike["peakVal"]
-            spikeDict["AP Height (mV)"] = spike["peakHeight"]
-            spikeDict["Pre AP Min (mV)"] = spike["preMinVal"]
-            # spikeDict['Post AP Min (mV)'] = spike['postMinVal']
+            spikeDict = OrderedDict() # use OrderedDict so Pandas output is in the correct order
+            spikeDict['Spike'] = spikeIdx
+            spikeDict['Take Off Potential (s)'] = self.ba.fileLoader.pnt2Sec_(spike['thresholdPnt'])
+            spikeDict['Take Off Potential (ms)'] = self.ba.fileLoader.pnt2Ms_(spike['thresholdPnt'])
+            spikeDict['Take Off Potential (mV)'] = spike['thresholdVal']
+            spikeDict['AP Peak (ms)'] = self.ba.fileLoader.pnt2Ms_(spike['peakPnt'])
+            spikeDict['AP Peak (mV)'] = spike['peakVal']
+            spikeDict['AP Height (mV)'] = spike['peakHeight']
+            spikeDict['Pre AP Min (mV)'] = spike['preMinVal']
+            #spikeDict['Post AP Min (mV)'] = spike['postMinVal']
             #
-            # spikeDict['AP Duration (ms)'] = spike['apDuration_ms']
-            spikeDict["Early Diastolic Duration (ms)"] = spike[
-                "earlyDiastolicDuration_ms"
-            ]
-            spikeDict["Early Diastolic Depolarization Rate (dV/s)"] = spike[
-                "earlyDiastolicDurationRate"
-            ]  # abb 202012
-            spikeDict["Diastolic Duration (ms)"] = spike["diastolicDuration_ms"]
+            #spikeDict['AP Duration (ms)'] = spike['apDuration_ms']
+            spikeDict['Early Diastolic Duration (ms)'] = spike['earlyDiastolicDuration_ms']
+            spikeDict['Early Diastolic Depolarization Rate (dV/s)'] = spike['earlyDiastolicDurationRate'] # abb 202012
+            spikeDict['Diastolic Duration (ms)'] = spike['diastolicDuration_ms']
             #
-            spikeDict["Inter-Spike-Interval (ms)"] = spike["isi_ms"]
-            spikeDict["Spike Frequency (Hz)"] = spike["spikeFreq_hz"]
-            spikeDict["ISI (ms)"] = spike["isi_ms"]
-
-            spikeDict["Cycle Length (ms)"] = spike["cycleLength_ms"]
-
-            spikeDict["Max AP Upstroke (dV/dt)"] = spike["preSpike_dvdt_max_val2"]
-            spikeDict["Max AP Upstroke (mV)"] = spike["preSpike_dvdt_max_val"]
-
-            spikeDict["Max AP Repolarization (dV/dt)"] = spike[
-                "postSpike_dvdt_min_val2"
-            ]
-            spikeDict["Max AP Repolarization (mV)"] = spike["postSpike_dvdt_min_val"]
+            spikeDict['Inter-Spike-Interval (ms)'] = spike['isi_ms']
+            spikeDict['Spike Frequency (Hz)'] = spike['spikeFreq_hz']
+            spikeDict['ISI (ms)'] = spike['isi_ms']
+
+            spikeDict['Cycle Length (ms)'] = spike['cycleLength_ms']
+
+            spikeDict['Max AP Upstroke (dV/dt)'] = spike['preSpike_dvdt_max_val2']
+            spikeDict['Max AP Upstroke (mV)'] = spike['preSpike_dvdt_max_val']
+
+            spikeDict['Max AP Repolarization (dV/dt)'] = spike['postSpike_dvdt_min_val2']
+            spikeDict['Max AP Repolarization (mV)'] = spike['postSpike_dvdt_min_val']
 
             # half-width
-            for widthDict in spike["widths"]:
-                keyName = "width_" + str(widthDict["halfHeight"])
-                spikeDict[keyName] = widthDict["widthMs"]
+            for widthDict in spike['widths']:
+                keyName = 'width_' + str(widthDict['halfHeight'])
+                spikeDict[keyName] = widthDict['widthMs']
 
-            spikeDict["File"] = self.ba.fileLoader.filename
+            spikeDict['File'] = self.ba.fileLoader.filename
 
             # errors
-            # spikeDict['numError'] = spike['numError']
-            spikeDict["errors"] = spike["errors"]
+            #spikeDict['numError'] = spike['numError']
+            spikeDict['errors'] = spike['errors']
+
 
             # append
             newList.append(spikeDict)
 
         df = pd.DataFrame(newList)
         return df
 
-    def getSummary(self,
-                   sweep='All',
-                    epoch='All',
-                    theMin: float = None, 
-                    theMax: float = None
-                    ) -> pd.DataFrame:
+    def getSummary(self, theMin : float = None, theMax : float = None) -> pd.DataFrame:
         """Get analysis summary as df.
-        
         This adds some header information to spike report bExport.report2().
         """
 
         if self.ba.numSpikes == 0:
-            logger.warning(f"did not find and spikes for summary")
+            logger.warning(f'did not find and spikes for summary')
             return None
 
-        # if theMin is None or theMax is None:
-        #     theMin = 0
-        #     theMax = self.ba.fileLoader.recordingDur
+        if theMin is None or theMax is None:
+            theMin = 0
+            theMax = self.ba.fileLoader.recordingDur
 
         #
         # cardiac style analysis to sheet 'cardiac'
-        # human readable columns
-        cardiac_df = self.report2(sweep=sweep,
-                                  epoch=epoch,
-                                  theMin=theMin,
-                                  theMax=theMax)
+        cardiac_df = self.report2(theMin, theMax) # report2 is more 'cardiac'
 
         dDict = self.ba.getDetectionDict()
 
         #
         # header sheet
         headerDict = OrderedDict()
         filePath, fileName = os.path.split(self.ba.fileLoader.filepath)
-        headerDict["File Name"] = [fileName]
-        headerDict["File Path"] = [filePath]
+        headerDict['File Name'] = [fileName]
+        headerDict['File Path'] = [filePath]
 
-        headerDict["Cell Type"] = [dDict["cellType"]]
-        headerDict["Sex"] = [dDict["sex"]]
-        headerDict["Condition"] = [dDict["condition"]]
-
-        headerDict["Date Analyzed"] = [
-            self.ba.analysisDate
-        ]  # pulled from first detected spike
-        headerDict["Time Analyzed"] = [self.ba.analysisTime]
-
-        headerDict["Detection Type"] = [dDict["detectionType"]]
-        headerDict["dV/dt Threshold"] = [dDict["dvdtThreshold"]]
-        # headerDict['mV Threshold'] = [self.ba.mvThreshold] # abb 202012
-        headerDict["Vm Threshold (mV)"] = [dDict["mvThreshold"]]
-        # headerDict['Median Filter (pnts)'] = [self.ba.medianFilter]
-        headerDict["Analysis Version"] = [sanpy.analysisVersion]
-        headerDict["Interface Version"] = [sanpy.interfaceVersion]
-
-        # headerDict['Analysis Start (sec)'] = [self.ba.startSeconds]
-        # headerDict['Analysis Stop (sec)'] = [self.ba.stopSeconds]
-        headerDict["Sweep Number"] = ["Default 0"]  # [self.ba.currentSweep]
-        headerDict["Number of Sweeps"] = [self.ba.fileLoader.numSweeps]
-        headerDict["Export Start (sec)"] = [
-            float("%.2f" % (theMin))
-        ]  # on export, x-axis of raw plot will be ouput
-        headerDict["Export Stop (sec)"] = [
-            float("%.2f" % (theMax))
-        ]  # on export, x-axis of raw plot will be ouput
+        headerDict['Cell Type'] = [dDict['cellType']]
+        headerDict['Sex'] = [dDict['sex']]
+        headerDict['Condition'] = [dDict['condition']]
+
+        headerDict['Date Analyzed'] = [self.ba.analysisDate] # pulled from first detected spike
+        headerDict['Time Analyzed'] = [self.ba.analysisTime]
+
+        headerDict['Detection Type'] = [dDict['detectionType']]
+        headerDict['dV/dt Threshold'] = [dDict['dvdtThreshold']]
+        #headerDict['mV Threshold'] = [self.ba.mvThreshold] # abb 202012
+        headerDict['Vm Threshold (mV)'] = [dDict['mvThreshold']]
+        #headerDict['Median Filter (pnts)'] = [self.ba.medianFilter]
+        headerDict['Analysis Version'] = [sanpy.analysisVersion]
+        headerDict['Interface Version'] = [sanpy.interfaceVersion]
+
+        #headerDict['Analysis Start (sec)'] = [self.ba.startSeconds]
+        #headerDict['Analysis Stop (sec)'] = [self.ba.stopSeconds]
+        headerDict['Sweep Number'] = ['Default 0']  # [self.ba.currentSweep]
+        headerDict['Number of Sweeps'] = [self.ba.fileLoader.numSweeps]
+        headerDict['Export Start (sec)'] = [float('%.2f'%(theMin))] # on export, x-axis of raw plot will be ouput
+        headerDict['Export Stop (sec)'] = [float('%.2f'%(theMax))] # on export, x-axis of raw plot will be ouput
 
         # 'stats' has xxx columns (name, mean, sd, se, n)
-        headerDict["stats"] = []
+        headerDict['stats'] = []
 
-        ignoreColumns = ["Spike", "File"]
+        ignoreColumns = ['Spike', 'File']
         for idx, col in enumerate(cardiac_df):
             if col in ignoreColumns:
                 # in general, skip non numerical columns
                 continue
             headerDict[col] = []
 
         # mean
-        theMean = cardiac_df.mean(numeric_only=True)  # skipna default is True
-
-        logger.info('cardiac_df:')
-        print(cardiac_df)
-        logger.info('theMean:')
-        print(theMean)
-
-        theMean["errors"] = ""
-                
+        theMean = cardiac_df.mean(numeric_only=True) # skipna default is True
+        theMean['errors'] = ''
         # sd
-        theSD = cardiac_df.std(numeric_only=True)  # skipna default is True
-        theSD["errors"] = ""
-        # se
-        theSE = cardiac_df.sem(numeric_only=True)  # skipna default is True
-        theSE["errors"] = ""
-        # n
-        theN = cardiac_df.count(numeric_only=True)  # skipna default is True
-        theN["errors"] = ""
+        theSD = cardiac_df.std(numeric_only=True) # skipna default is True
+        theSD['errors'] = ''
+        #se
+        theSE = cardiac_df.sem(numeric_only=True) # skipna default is True
+        theSE['errors'] = ''
+        #n
+        theN = cardiac_df.count(numeric_only=True) # skipna default is True
+        theN['errors'] = ''
 
-        statCols = ["mean", "sd", "se", "n"]
+        statCols = ['mean', 'sd', 'se', 'n']
         for j, stat in enumerate(statCols):
             if j == 0:
                 pass
             else:
                 # need to append columns to keep Excel sheet columns in sync
-                # for k,v in headerDict.items():
+                #for k,v in headerDict.items():
                 #    headerDict[k].append('')
 
-                headerDict["File Name"].append("")
-                headerDict["File Path"].append("")
-                headerDict["Cell Type"].append("")
-                headerDict["Sex"].append("")
-                headerDict["Condition"].append("")
+                headerDict['File Name'].append('')
+                headerDict['File Path'].append('')
+                headerDict['Cell Type'].append('')
+                headerDict['Sex'].append('')
+                headerDict['Condition'].append('')
                 #
-                headerDict["Date Analyzed"].append("")
-                headerDict["Time Analyzed"].append("")
-                headerDict["Detection Type"].append("")
-                headerDict["dV/dt Threshold"].append("")
-                headerDict["Vm Threshold (mV)"].append("")
-                # headerDict['Median Filter (pnts)'].append('')
-                headerDict["Analysis Version"].append("")
-                headerDict["Interface Version"].append("")
-                headerDict["Sweep Number"].append("")
-                headerDict["Number of Sweeps"].append("")
-                headerDict["Export Start (sec)"].append("")
-                headerDict["Export Stop (sec)"].append("")
+                headerDict['Date Analyzed'].append('')
+                headerDict['Time Analyzed'].append('')
+                headerDict['Detection Type'].append('')
+                headerDict['dV/dt Threshold'].append('')
+                headerDict['Vm Threshold (mV)'].append('')
+                #headerDict['Median Filter (pnts)'].append('')
+                headerDict['Analysis Version'].append('')
+                headerDict['Interface Version'].append('')
+                headerDict['Sweep Number'].append('')
+                headerDict['Number of Sweeps'].append('')
+                headerDict['Export Start (sec)'].append('')
+                headerDict['Export Stop (sec)'].append('')
 
             # a dictionary key for each stat
-            headerDict["stats"].append(stat)
+            headerDict['stats'].append(stat)
             for idx, col in enumerate(cardiac_df):
                 if col in ignoreColumns:
                     # in general, need to ignore string columns
-                    # headerDict[col].append('')
+                    #headerDict[col].append('')
                     continue
-                # headerDict[col].append('')
-                if stat == "mean":
+                #headerDict[col].append('')
+                if stat == 'mean':
                     headerDict[col].append(theMean[col])
-                elif stat == "sd":
+                elif stat == 'sd':
                     headerDict[col].append(theSD[col])
-                elif stat == "se":
+                elif stat == 'se':
                     headerDict[col].append(theSE[col])
-                elif stat == "n":
+                elif stat == 'n':
                     headerDict[col].append(theN[col])
 
         # end for j, stat
-        # print('=== headerDict')
-        # for k,v in headerDict.items():
+        #print('=== headerDict')
+        #for k,v in headerDict.items():
         #    print(k, ':', v)
 
         # dict to pandas dataframe
         df = pd.DataFrame(headerDict).T
-        df.insert(0, "", headerDict.keys(), allow_duplicates=True)
+        df.insert(0, '', headerDict.keys(), allow_duplicates=True)
 
         return df
 
-    def saveReport(
-        self,
-        savefile,
-        theMin=None,
-        theMax=None,
-        saveExcel=True,
-        alsoSaveTxt=True,
-        verbose=True,
-    ):
+    def saveReport(self, savefile, theMin=None, theMax=None,
+                    saveExcel=True, alsoSaveTxt=True, verbose=True):
         """
         Save a spike report for detected spikes between theMin (sec) and theMax (sec).
 
         This is used by main interface 'Export Spike Report'
 
         Args:
             savefile (str): path to xlsx file
@@ -391,232 +307,226 @@
             df: df
         """
         if theMin is None or theMax is None:
             theMin = 0
             theMax = self.ba.fileLoader.recordingDur
 
         # always grab a df to the entire analysis (not sure what I will do with this)
-        # df = self.ba.report() # report() is my own 'bob' verbiage
+        #df = self.ba.report() # report() is my own 'bob' verbiage
 
         theRet = None
 
-        logger.warning("NEVER SAVING EXCEL !!! dec 2022")
+        logger.warning('NEVER SAVING EXCEL !!! dec 2022')
         saveExcel = False
         if saveExcel and savefile:
-            # if verbose: print('    bExport.saveReport() saving user specified .xlsx file:', savefile)
+            #if verbose: print('    bExport.saveReport() saving user specified .xlsx file:', savefile)
             excelFilePath = savefile
-            writer = pd.ExcelWriter(excelFilePath, engine="xlsxwriter")
+            writer = pd.ExcelWriter(excelFilePath, engine='xlsxwriter')
 
             #
             # cardiac style analysis to sheet 'cardiac'
-            cardiac_df = self.report2(theMin, theMax)  # report2 is more 'cardiac'
+            cardiac_df = self.report2(theMin, theMax) # report2 is more 'cardiac'
 
             dDict = self.ba.getDetectionDict()
             dateAnalyzed = self.ba.dateAnalyzed
             timeAnalyzed = self.ba.dateAnalyzed
 
             #
             # header sheet
             headerDict = OrderedDict()
             filePath, fileName = os.path.split(self.ba.filepath)
-            headerDict["File Name"] = [fileName]
-            headerDict["File Path"] = [filePath]
+            headerDict['File Name'] = [fileName]
+            headerDict['File Path'] = [filePath]
 
-            headerDict["Cell Type"] = [dDict["cellType"]]
-            headerDict["Sex"] = [dDict["sex"]]
-            headerDict["Condition"] = [dDict["condition"]]
+            headerDict['Cell Type'] = [dDict['cellType']]
+            headerDict['Sex'] = [dDict['sex']]
+            headerDict['Condition'] = [dDict['condition']]
 
             # todo: get these params in ONE dict inside self.ba
-            # dateAnalyzed, timeAnalyzed = self.ba.dateAnalyzed.split(' ')
-            headerDict["Date Analyzed"] = [dateAnalyzed]
-            headerDict["Time Analyzed"] = [timeAnalyzed]
-            headerDict["Detection Type"] = [dDict["detectionType"]]
-            headerDict["dV/dt Threshold"] = [dDict["dvdtThreshold"]]
-            # headerDict['mV Threshold'] = [self.ba.mvThreshold] # abb 202012
-            headerDict["Vm Threshold (mV)"] = [dDict["mvThreshold"]]
-            # headerDict['Median Filter (pnts)'] = [self.ba.medianFilter]
-            headerDict["Analysis Version"] = [sanpy.analysisVersion]
-            headerDict["Interface Version"] = [sanpy.interfaceVersion]
-
-            # headerDict['Analysis Start (sec)'] = [self.ba.startSeconds]
-            # headerDict['Analysis Stop (sec)'] = [self.ba.stopSeconds]
-            headerDict["Sweep Number"] = ["Default 0"]  # [self.ba.currentSweep]
-            headerDict["Number of Sweeps"] = [self.ba.fileLoader.numSweeps]
-            headerDict["Export Start (sec)"] = [
-                float("%.2f" % (theMin))
-            ]  # on export, x-axis of raw plot will be ouput
-            headerDict["Export Stop (sec)"] = [
-                float("%.2f" % (theMax))
-            ]  # on export, x-axis of raw plot will be ouput
+            #dateAnalyzed, timeAnalyzed = self.ba.dateAnalyzed.split(' ')
+            headerDict['Date Analyzed'] = [dateAnalyzed]
+            headerDict['Time Analyzed'] = [timeAnalyzed]
+            headerDict['Detection Type'] = [dDict['detectionType']]
+            headerDict['dV/dt Threshold'] = [dDict['dvdtThreshold']]
+            #headerDict['mV Threshold'] = [self.ba.mvThreshold] # abb 202012
+            headerDict['Vm Threshold (mV)'] = [dDict['mvThreshold']]
+            #headerDict['Median Filter (pnts)'] = [self.ba.medianFilter]
+            headerDict['Analysis Version'] = [sanpy.analysisVersion]
+            headerDict['Interface Version'] = [sanpy.interfaceVersion]
+
+            #headerDict['Analysis Start (sec)'] = [self.ba.startSeconds]
+            #headerDict['Analysis Stop (sec)'] = [self.ba.stopSeconds]
+            headerDict['Sweep Number'] = ['Default 0']  # [self.ba.currentSweep]
+            headerDict['Number of Sweeps'] = [self.ba.fileLoader.numSweeps]
+            headerDict['Export Start (sec)'] = [float('%.2f'%(theMin))] # on export, x-axis of raw plot will be ouput
+            headerDict['Export Stop (sec)'] = [float('%.2f'%(theMax))] # on export, x-axis of raw plot will be ouput
 
             # 'stats' has xxx columns (name, mean, sd, se, n)
-            headerDict["stats"] = []
+            headerDict['stats'] = []
 
-            ignoreColumns = ["Spike", "File"]
+            ignoreColumns = ['Spike', 'File']
             for idx, col in enumerate(cardiac_df):
                 if col in ignoreColumns:
                     # in general, need to ignore string columns
-                    # headerDict[col].append('')
+                    #headerDict[col].append('')
                     continue
                 headerDict[col] = []
 
             # mean
-            theMean = cardiac_df.mean()  # skipna default is True
-            theMean["errors"] = ""
+            theMean = cardiac_df.mean() # skipna default is True
+            theMean['errors'] = ''
             # sd
-            theSD = cardiac_df.std()  # skipna default is True
-            theSD["errors"] = ""
-            # se
-            theSE = cardiac_df.sem()  # skipna default is True
-            theSE["errors"] = ""
-            # n
-            theN = cardiac_df.count()  # skipna default is True
-            theN["errors"] = ""
+            theSD = cardiac_df.std() # skipna default is True
+            theSD['errors'] = ''
+            #se
+            theSE = cardiac_df.sem() # skipna default is True
+            theSE['errors'] = ''
+            #n
+            theN = cardiac_df.count() # skipna default is True
+            theN['errors'] = ''
 
-            statCols = ["mean", "sd", "se", "n"]
+            statCols = ['mean', 'sd', 'se', 'n']
             for j, stat in enumerate(statCols):
                 if j == 0:
                     pass
                 else:
                     # need to append columns to keep Excel sheet columns in sync
-                    # for k,v in headerDict.items():
+                    #for k,v in headerDict.items():
                     #    headerDict[k].append('')
 
-                    headerDict["File Name"].append("")
-                    headerDict["File Path"].append("")
-                    headerDict["Cell Type"].append("")
-                    headerDict["Sex"].append("")
-                    headerDict["Condition"].append("")
+                    headerDict['File Name'].append('')
+                    headerDict['File Path'].append('')
+                    headerDict['Cell Type'].append('')
+                    headerDict['Sex'].append('')
+                    headerDict['Condition'].append('')
                     #
-                    headerDict["Date Analyzed"].append("")
-                    headerDict["Time Analyzed"].append("")
-                    headerDict["Detection Type"].append("")
-                    headerDict["dV/dt Threshold"].append("")
-                    headerDict["Vm Threshold (mV)"].append("")
-                    # headerDict['Median Filter (pnts)'].append('')
-                    headerDict["Analysis Version"].append("")
-                    headerDict["Interface Version"].append("")
-                    headerDict["Sweep Number"].append("")
-                    headerDict["Number of Sweeps"].append("")
-                    headerDict["Export Start (sec)"].append("")
-                    headerDict["Export Stop (sec)"].append("")
+                    headerDict['Date Analyzed'].append('')
+                    headerDict['Time Analyzed'].append('')
+                    headerDict['Detection Type'].append('')
+                    headerDict['dV/dt Threshold'].append('')
+                    headerDict['Vm Threshold (mV)'].append('')
+                    #headerDict['Median Filter (pnts)'].append('')
+                    headerDict['Analysis Version'].append('')
+                    headerDict['Interface Version'].append('')
+                    headerDict['Sweep Number'].append('')
+                    headerDict['Number of Sweeps'].append('')
+                    headerDict['Export Start (sec)'].append('')
+                    headerDict['Export Stop (sec)'].append('')
 
                 # a dictionary key for each stat
-                headerDict["stats"].append(stat)
+                headerDict['stats'].append(stat)
                 for idx, col in enumerate(cardiac_df):
                     if col in ignoreColumns:
                         # in general, need to ignore string columns
-                        # headerDict[col].append('')
+                        #headerDict[col].append('')
                         continue
-                    # headerDict[col].append('')
-                    if stat == "mean":
+                    #headerDict[col].append('')
+                    if stat == 'mean':
                         headerDict[col].append(theMean[col])
-                    elif stat == "sd":
+                    elif stat == 'sd':
                         headerDict[col].append(theSD[col])
-                    elif stat == "se":
+                    elif stat == 'se':
                         headerDict[col].append(theSE[col])
-                    elif stat == "n":
+                    elif stat == 'n':
                         headerDict[col].append(theN[col])
 
-            # print(headerDict)
-            # for k,v in headerDict.items():
+            #print(headerDict)
+            #for k,v in headerDict.items():
             #    print(k, v)
 
             # dict to pandas dataframe
             df = pd.DataFrame(headerDict).T
-            df.to_excel(writer, sheet_name="summary")
+            df.to_excel(writer, sheet_name='summary')
 
             # set the column widths in excel sheet 'cardiac'
             columnWidth = 25
-            worksheet = writer.sheets["summary"]  # pull worksheet object
+            worksheet = writer.sheets['summary']  # pull worksheet object
             for idx, col in enumerate(df):  # loop through all columns
                 worksheet.set_column(idx, idx, columnWidth)  # set column width
 
             #
             # 'params' sheet with all detection params
             # need to convert list values in dict to string (o.w. we get one row per item in list)
             exportDetectionDict = {}
             for k, v in dDict.items():
                 # v is a dict from bDetection
                 if isinstance(v, list):
                     v = f'"{v}"'
                 exportDetectionDict[k] = v
-            # print('  === "params" sheet exportDetectionDict:', exportDetectionDict)
-            # df = pd.DataFrame(exportDetectionDict, index=[0]).T # index=[0] needed when dict has all scalar values
+            #print('  === "params" sheet exportDetectionDict:', exportDetectionDict)
+            #df = pd.DataFrame(exportDetectionDict, index=[0]).T # index=[0] needed when dict has all scalar values
             detection_df = pd.DataFrame(exportDetectionDict).T
-            detection_df.to_excel(writer, sheet_name="params")
+            detection_df.to_excel(writer, sheet_name='params')
             # worksheet is <class 'xlsxwriter.worksheet.Worksheet'>
-            worksheet = writer.sheets["params"]  # pull worksheet object
+            worksheet = writer.sheets['params']  # pull worksheet object
             # set first 20 columns to columnWidth
             columnWidth = 18
             startCol = 0
-            stopCol = 20  # xlswriter.worksheet does not care about the stop column
+            stopCol = 20 # xlswriter.worksheet does not care about the stop column
             worksheet.set_column(0, stopCol, columnWidth)  # set column width
 
             #
             # 'cardiac' sheet with human readable stat names
-            cardiac_df.to_excel(writer, sheet_name="cardiac")
+            cardiac_df.to_excel(writer, sheet_name='cardiac')
 
             # set the column widths in excel sheet 'cardiac'
             columnWidth = 20
-            worksheet = writer.sheets["cardiac"]  # pull worksheet object
+            worksheet = writer.sheets['cardiac']  # pull worksheet object
             for idx, col in enumerate(cardiac_df):  # loop through all columns
                 worksheet.set_column(idx, idx, columnWidth)  # set column width
 
+
             #
             # mean spike clip
-            theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(
-                theMin, theMax, sweepNumber=self.sweepNumber
-            )
+            theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(theMin, theMax, sweepNumber=self.sweepNumber)
             try:
-                first_X = theseClips_x[0]  # - theseClips_x[0][0]
-                # if verbose: print('    bExport.saveReport() saving mean clip to sheet "Avg Spike" from', len(theseClips), 'clips')
+                first_X = theseClips_x[0] #- theseClips_x[0][0]
+                #if verbose: print('    bExport.saveReport() saving mean clip to sheet "Avg Spike" from', len(theseClips), 'clips')
                 df = pd.DataFrame(meanClip, first_X)
-                df.to_excel(writer, sheet_name="Avg Spike")
-            except IndexError as e:
-                logger.warning("Got bad spike clips. Usually happend when 1-2 spikes")
+                df.to_excel(writer, sheet_name='Avg Spike')
+            except (IndexError) as e:
+                logger.warning('Got bad spike clips. Usually happend when 1-2 spikes')
 
             writer.save()
 
         #
         # save a csv text file
         #
-        analysisName = ""
+        analysisName = ''
         if alsoSaveTxt:
             # this also saves
             analysisName, df0 = self.getReportDf(theMin, theMax, savefile)
 
             #
             # save mean spike clip
 
-            not_used_theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(
-                theMin, theMax, sweepNumber=self.sweepNumber
-            )
+            not_used_theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(theMin, theMax, sweepNumber=self.sweepNumber)
             if len(theseClips_x) == 0:
                 pass
             else:
-                first_X = theseClips_x[0]  # - theseClips_x[0][0]
+                first_X = theseClips_x[0] #- theseClips_x[0][0]
                 first_X = np.array(first_X)
-                first_X /= self.ba.fileLoader.dataPointsPerMs  # pnts to ms
-                # if verbose: print('    bExport.saveReport() saving mean clip to sheet "Avg Spike" from', len(theseClips), 'clips')
-                # dfClip = pd.DataFrame(meanClip, first_X)
-                dfClip = pd.DataFrame.from_dict({"xMs": first_X, "yVm": meanClip})
+                first_X /= self.ba.fileLoader.dataPointsPerMs # pnts to ms
+                #if verbose: print('    bExport.saveReport() saving mean clip to sheet "Avg Spike" from', len(theseClips), 'clips')
+                #dfClip = pd.DataFrame(meanClip, first_X)
+                dfClip = pd.DataFrame.from_dict({
+                    'xMs': first_X,
+                    'yVm': meanClip
+                    })
                 # load clip based on analysisname (with start/stop seconds)
-                analysisname = df0["analysisname"].iloc[
-                    0
-                ]  # name with start/stop seconds
-                logger.info(f"analysisname: {analysisname}")
-                clipFileName = analysisname + "_clip.csv"
+                analysisname = df0['analysisname'].iloc[0] # name with start/stop seconds
+                logger.info(f'analysisname: {analysisname}')
+                clipFileName = analysisname + '_clip.csv'
                 tmpPath, tmpFile = os.path.split(savefile)
-                tmpPath = os.path.join(tmpPath, "analysis")
+                tmpPath = os.path.join(tmpPath, 'analysis')
                 # dir is already created in getReportDf
                 if not os.path.isdir(tmpPath):
                     os.mkdir(tmpPath)
                 clipSavePath = os.path.join(tmpPath, clipFileName)
-                logger.info(f"clipSavePath: {clipSavePath}")
+                logger.info(f'clipSavePath: {clipSavePath}')
                 dfClip.to_csv(clipSavePath)
             #
             theRet = df0
         #
         return analysisName, theRet
 
     def getReportDf(self, theMin, theMax, savefile):
@@ -631,96 +541,92 @@
             df: Pandas DataFrame
         """
         filePath, fileName = os.path.split(os.path.abspath(savefile))
 
         dDict = self.ba.getDetectionDict()
 
         # make an analysis folder
-        filePath = os.path.join(filePath, "analysis")
+        filePath = os.path.join(filePath, 'analysis')
         if not os.path.isdir(filePath):
-            logger.info(f"Making output folder: {filePath}")
+            logger.info(f'Making output folder: {filePath}')
             os.mkdir(filePath)
 
         textFileBaseName, tmpExtension = os.path.splitext(fileName)
-        textFilePath = os.path.join(filePath, textFileBaseName + ".csv")
+        textFilePath = os.path.join(filePath, textFileBaseName + '.csv')
 
         # save header
         textFileHeader = OrderedDict()
-        textFileHeader["file"] = self.ba.fileLoader.filename
-        # textFileHeader['condition1'] = self.ba.condition1
-        # textFileHeader['condition2'] = self.ba.condition2
-        # textFileHeader['condition3'] = self.ba.condition3
-        textFileHeader["cellType"] = dDict["cellType"]
-        textFileHeader["sex"] = dDict["sex"]
-        textFileHeader["condition"] = dDict["condition"]
+        textFileHeader['file'] = self.ba.fileLoader.filename
+        #textFileHeader['condition1'] = self.ba.condition1
+        #textFileHeader['condition2'] = self.ba.condition2
+        #textFileHeader['condition3'] = self.ba.condition3
+        textFileHeader['cellType'] = dDict['cellType']
+        textFileHeader['sex'] = dDict['sex']
+        textFileHeader['condition'] = dDict['condition']
         #
-        textFileHeader["dateAnalyzed"] = self.ba.dateAnalyzed
-        textFileHeader["detectionType"] = dDict["detectionType"]
-        textFileHeader["dvdtThreshold"] = [dDict["dvdtThreshold"]]
-        textFileHeader["mvThreshold"] = [dDict["mvThreshold"]]
-        # textFileHeader['medianFilter'] = self.ba.medianFilter
-        textFileHeader["startSeconds"] = "%.2f" % (theMin)
-        textFileHeader["stopSeconds"] = "%.2f" % (theMax)
-        # textFileHeader['startSeconds'] = self.ba.startSeconds
-        # textFileHeader['stopSeconds'] = self.ba.stopSeconds
-        textFileHeader["currentSweep"] = "Default 0"  # self.ba.currentSweep
-        textFileHeader["numSweeps"] = self.ba.fileLoader.numSweeps
-        # textFileHeader['theMin'] = theMin
-        # textFileHeader['theMax'] = theMax
+        textFileHeader['dateAnalyzed'] = self.ba.dateAnalyzed
+        textFileHeader['detectionType'] = dDict['detectionType']
+        textFileHeader['dvdtThreshold'] = [dDict['dvdtThreshold']]
+        textFileHeader['mvThreshold'] = [dDict['mvThreshold']]
+        #textFileHeader['medianFilter'] = self.ba.medianFilter
+        textFileHeader['startSeconds'] = '%.2f'%(theMin)
+        textFileHeader['stopSeconds'] = '%.2f'%(theMax)
+        #textFileHeader['startSeconds'] = self.ba.startSeconds
+        #textFileHeader['stopSeconds'] = self.ba.stopSeconds
+        textFileHeader['currentSweep'] = 'Default 0' # self.ba.currentSweep
+        textFileHeader['numSweeps'] = self.ba.fileLoader.numSweeps
+        #textFileHeader['theMin'] = theMin
+        #textFileHeader['theMax'] = theMax
 
         # 20210125, this is not needed, we are saviing pandas df below ???
-        headerStr = ""
-        for k, v in textFileHeader.items():
-            headerStr += k + "=" + str(v) + ";"
-        headerStr += "\n"
-        # print('headerStr:', headerStr)
-        with open(textFilePath, "w") as f:
+        headerStr = ''
+        for k,v in textFileHeader.items():
+            headerStr += k + '=' + str(v) + ';'
+        headerStr += '\n'
+        #print('headerStr:', headerStr)
+        with open(textFilePath,'w') as f:
             f.write(headerStr)
 
-        # df = self.report(theMin, theMax)
+        #df = self.report(theMin, theMax)
         df = self.ba.asDataFrame()
-
+        
         # we need a column indicating (path), the original .abf file
         # along with (start,stop) which should make this analysis unique?
-        minStr = "%.2f" % (theMin)
-        maxStr = "%.2f" % (theMax)
-        minStr = minStr.replace(".", "_")
-        maxStr = maxStr.replace(".", "_")
+        minStr = '%.2f'%(theMin)
+        maxStr = '%.2f'%(theMax)
+        minStr = minStr.replace('.', '_')
+        maxStr = maxStr.replace('.', '_')
         tmpPath, tmpFile = os.path.split(self.ba.fileLoader.filepath)
         tmpFile, tmpExt = os.path.splitext(tmpFile)
-        analysisName = tmpFile + "_s" + minStr + "_s" + maxStr
-        logger.info(f"minStr:{minStr} maxStr:{maxStr} analysisName:{analysisName}")
-        df["analysisname"] = analysisName
+        analysisName = tmpFile + '_s' + minStr + '_s' + maxStr
+        logger.info(f'minStr:{minStr} maxStr:{maxStr} analysisName:{analysisName}')
+        df['analysisname'] = analysisName
 
         # should be filled in by self.ba.report
-        # df['Condition'] =     df['condition1']
-        # df['File Number'] =     df['condition2']
-        # df['Sex'] =     df['condition3']
-        # df['Region'] =     df['condition4']
-        df["filename"] = [
-            os.path.splitext(os.path.split(x)[1])[0] for x in df["file"].tolist()
-        ]
+        #df['Condition'] =     df['condition1']
+        #df['File Number'] =     df['condition2']
+        #df['Sex'] =     df['condition3']
+        #df['Region'] =     df['condition4']
+        df['filename'] = [os.path.splitext(os.path.split(x)[1])[0] for x in     df['file'].tolist()]
 
         #
-        logger.info("saving text file: {textFilePath}")
-        # df.to_csv(textFilePath, sep=',', index_label='index', mode='a')
-        df.to_csv(textFilePath, sep=",", index_label="index", mode="w")
+        logger.info('saving text file: {textFilePath}')
+        #df.to_csv(textFilePath, sep=',', index_label='index', mode='a')
+        df.to_csv(textFilePath, sep=',', index_label='index', mode='w')
 
         return analysisName, df
 
-
 def test():
-    path = "data/19114001.abf"
+    path = 'data/19114001.abf'
     ba = sanpy.bAnalysis(path)
 
     bd = sanpy.bDetection()  # gets default
-    dDict = bd.getDetectionDict("SA Node")
+    dDict = bd.getDetectionDict('SA Node')
     ba.spikeDetect(dDict)
 
     be = bExport(ba)
     df = be.getSummary()
-    logger.info("")
+    logger.info('')
     print(df)
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     test()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/epochAnalysis.py` & `sanpy-ephys-0.1.6/sanpy/epochAnalysis.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,115 +1,112 @@
 """
 """
 from pprint import pprint
 import pandas as pd
 
 import sanpy
 
-
-class epochAnalysis:
-    def __init__(self, ba: sanpy.bAnalysis):
+class epochAnalysis():
+    def __init__(self, ba : sanpy.bAnalysis):
+        
         retDictList = []
 
         df = ba.asDataFrame()
 
-        files = df["file"].unique()
+        files = df['file'].unique()
         for file in files:
-            dfFile = df[df["file"] == file]
-            sweeps = dfFile["sweep"].unique()
+            dfFile = df[df['file']==file]
+            sweeps = dfFile['sweep'].unique()
             for sweep in sweeps:
-                dfSweep = dfFile[dfFile["sweep"] == sweep]
-                epochs = dfSweep["epoch"].unique()
+                dfSweep = dfFile[dfFile['sweep']==sweep]
+                epochs = dfSweep['epoch'].unique()
                 for epoch in epochs:
-                    dfEpoch = dfSweep[dfSweep["epoch"] == epoch]
-
-                    # pprint(dfEpoch)
-
+                    dfEpoch = dfSweep[dfSweep['epoch']==epoch]
+                    
+                    #pprint(dfEpoch)
+                    
                     # count number of spikes in this (file, sweep, epoch)
                     numSpikes = len(dfEpoch)
-
-                    firstSpikeFreq = float("nan")
-                    spikeFreq_mean = float("nan")
+                    
+                    firstSpikeFreq = float('nan')
+                    spikeFreq_mean = float('nan')
                     if numSpikes > 1:
-                        firstSpikeFreq = dfEpoch["spikeFreq_hz"].iloc[1]
-
+                        firstSpikeFreq = dfEpoch['spikeFreq_hz'].iloc[1]
+                    
                         # TODO: this can't include the first spike in the epoch
                         # average spike freq from each spikes 'spikeFreq_hz'
-                        spikeFreq_mean = (
-                            dfEpoch["spikeFreq_hz"].iloc[1 : len(dfEpoch)].mean()
-                        )
-
-                    # print('file:', file, 'sweep:', sweep, 'epoch:', epoch, 'numSpikes:', numSpikes)
-
+                        spikeFreq_mean = dfEpoch['spikeFreq_hz'].iloc[1:len(dfEpoch)].mean()
+                    
+                    #print('file:', file, 'sweep:', sweep, 'epoch:', epoch, 'numSpikes:', numSpikes)
+                    
                     oneDict = self.getDefaultDict()
-                    oneDict["file"] = file
-                    oneDict["sweep"] = sweep
-                    oneDict["epoch"] = epoch
-                    oneDict["numSpikes"] = numSpikes
-                    oneDict["spikeFreq_mean"] = spikeFreq_mean
-                    oneDict["firstSpikeFreq"] = firstSpikeFreq
+                    oneDict['file'] = file
+                    oneDict['sweep'] = sweep
+                    oneDict['epoch'] = epoch
+                    oneDict['numSpikes'] = numSpikes
+                    oneDict['spikeFreq_mean'] = spikeFreq_mean
+                    oneDict['firstSpikeFreq'] = firstSpikeFreq
                     retDictList.append(oneDict)
-
+        
         #
         dfReturn = pd.DataFrame(retDictList)
         pprint(dfReturn)
 
     def getDefaultDict(self):
         """A dictionary for one (file, sweep, epoch).
-
+        
         Will be a row in a dataframe
         """
         retDict = {
-            "file": "",
-            "sweep": float("nan"),
-            "epoch": float("nan"),
-            "numSpikes": float("nan"),
+            'file': '',
+            'sweep': float('nan'),
+            'epoch': float('nan'),
+            'numSpikes': float('nan'),
         }
         return retDict.copy()
 
-
-if __name__ == "__main__":
-    path = "/Users/cudmore/Sites/SanPy/data/2021_07_20_0010.abf"
+if __name__ == '__main__':
+    path = '/Users/cudmore/Sites/SanPy/data/2021_07_20_0010.abf'
     ba = sanpy.bAnalysis(path)
 
     detectionPreset = sanpy.bDetection.detectionPresets.fastneuron
     detectionClass = sanpy.bDetection(detectionPreset=detectionPreset)
-
-    """
+    
+    '''
     detectionClass['dvdtThreshold'] = 20
     detectionClass['refractory_ms'] = 3
     detectionClass['peakWindow_ms'] = 2
     detectionClass['halfWidthWindow_ms'] = 4
     detectionClass['preSpikeClipWidth_ms'] = 2
     detectionClass['postSpikeClipWidth_ms'] = 2
-    """
+    '''
 
     ba.spikeDetect(detectionClass=detectionClass)
 
     # print(ba)
     # df = ba.asDataFrame()
 
     ea = epochAnalysis(ba)
 
     # works
-    """
+    '''
     numSweeps = ba.numSweeps
     for sweep in range(numSweeps):
         et = ba.getEpochTable(sweep)
         dfEpoch = et.getEpochList(asDataFrame=True)
         print(dfEpoch)
-    """
+    '''
 
     # works, while trying to understand abf sweep epoch table
     # each sweep has its own epoch table
-    """
+    '''
     import pyabf
     abf = pyabf.ABF(path)
     numSweeps = len(abf.sweepList)
     for sweep in range(numSweeps):
         abf.setSweep(sweep)
         print(abf.sweepNumber)
         et = sanpy.fileloaders.epochTable(abf)
         #dfEpoch = ba._epochTable.getEpochList(asDataFrame=True)
         dfEpoch = et.getEpochList(asDataFrame=True)
         print(dfEpoch)
-    """
+    '''
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fftUtils.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/plotScatter.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,1052 +1,1097 @@
-"""sanpy fft backend.
-
-TODO:
-	- get rid of (spikeDetect, _getHalfWidths, _throwOutRefractory)
-		- these are used to spike detect model data
-		- try and use main bAnalysis_
-"""
-
-import math, time, os
-from math import exp
-from functools import partial
-from tokenize import blank_re
-
+import math
 import numpy as np
 import pandas as pd
 
-from scipy.signal import lfilter, freqz
-import scipy.signal
+from PyQt5 import QtCore, QtWidgets, QtGui
 
+from matplotlib.backends import backend_qt5agg
 import matplotlib as mpl
 import matplotlib.pyplot as plt
-
-import sanpy
+from matplotlib.widgets import RectangleSelector  # To click+drag rectangular selection
+import matplotlib.markers as mmarkers  # To define different markers for scatter
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
+import sanpy
+from sanpy.interface.plugins import sanpyPlugin
 
-def butter_sos(cutOff, fs, order=50, passType="lowpass"):
-    """
-    passType (str): ('lowpass', 'highpass')
+class plotScatter(sanpyPlugin):
     """
+    Plot x/y statiistics as a scatter
 
+    Get stat names and variables from sanpy.bAnalysisUtil.getStatList()
     """
-	nyq = fs * 0.5
-	normal_cutoff = cutOff / nyq
-	"""
-
-    logger.info(
-        f"Making butter file with order:{order} cutOff:{cutOff} passType:{passType} fs:{fs}"
-    )
-
-    # sos = butter(order, normal_cutoff, btype='low', analog=False, output='sos')
-    # sos = scipy.signal.butter(N=order, Wn=normal_cutoff, btype=passType, analog=False, fs=fs, output='sos')
-    sos = scipy.signal.butter(
-        N=order, Wn=cutOff, btype=passType, analog=False, fs=fs, output="sos"
-    )
-    return sos
-
-
-def spikeDetect(t, dataFiltered, dataThreshold2, startPoint=None, stopPoint=None):
-    verbose = False
-    # dataThreshold2 = -59.81
-
-    g_backupFraction = 0.3  # 0.5 or 0.3
-
-    logger.info(
-        f"dataThreshold2:{dataThreshold2} startPoint:{startPoint} stopPoint:{stopPoint}"
-    )
-
-    #
-    # detect spikes, dataThreshold2 changes as we zoom
-    Is = np.where(dataFiltered > dataThreshold2)[0]
-    Is = np.concatenate(([0], Is))
-    Ds = Is[:-1] - Is[1:] + 1
-    spikePoints = Is[np.where(Ds)[0] + 1]
-    spikeSeconds = t[spikePoints]
-
-    #
-    # Throw out spikes that are within refractory (ms) of previous
-    spikePoints = _throwOutRefractory(spikePoints, refractory_ms=100)
-    spikeSeconds = t[spikePoints]
-
-    #
-    # remove spikes outside of start/stop
-    goodSpikes = []
-    if startPoint is not None and stopPoint is not None:
-        if verbose:
-            print(f"  Removing spikes outside point range {startPoint} ... {stopPoint}")
-        # print(f'    {t[startPoint]} ... {t[stopPoint]} (s)')
-        for idx, spikePoint in enumerate(spikePoints):
-            if spikePoint < startPoint or spikePoint > stopPoint:
-                pass
-            else:
-                goodSpikes.append(spikePoint)
-                if verbose:
-                    print(f"    appending spike {idx} {t[spikePoint]}(s)")
-    #
-    spikePoints = goodSpikes
-    spikeSeconds = t[spikePoints]
-
-    #
-    # only accept rising phase
-    windowPoints = 40  # assuming 10 kHz -->> 4 ms
-    goodSpikes = []
-    for idx, spikePoint in enumerate(spikePoints):
-        preClip = dataFiltered[spikePoint - windowPoints : spikePoint - 1]
-        postClip = dataFiltered[spikePoint + 1 : spikePoint + windowPoints]
-        preMean = np.nanmean(preClip)
-        postMean = np.nanmean(postClip)
-        if preMean < postMean:
-            goodSpikes.append(spikePoint)
-        else:
-            pass
-            # print(f'  rejected spike {idx}, at point {spikePoint}')
-    #
-    spikePoints = goodSpikes
-    spikeSeconds = t[spikePoints]
-
-    #
-    # throw out above take-off-potential of APs (-30 mV)
-    apTakeOff = -30
-    goodSpikes = []
-    for idx, spikePoint in enumerate(spikePoints):
-        if dataFiltered[spikePoint] < apTakeOff:
-            goodSpikes.append(spikePoint)
-    #
-    spikePoints = goodSpikes
-    spikeSeconds = t[spikePoints]
-
-    #
-    # find peak for eack spike
-    # at 500 pnts, assuming spikes are slower than 20 Hz
-    peakWindow_pnts = 500
-    peakPoints = []
-    peakVals = []
-    for idx, spikePoint in enumerate(spikePoints):
-        peakPnt = np.argmax(dataFiltered[spikePoint : spikePoint + peakWindow_pnts])
-        peakPnt += spikePoint
-        peakVal = np.max(dataFiltered[spikePoint : spikePoint + peakWindow_pnts])
+    myHumanName = 'Plot Scatter'
+
+    def __init__(self, **kwargs):
+        """
+        Args:
+            ba (bAnalysis): Not required
+        """
+        super().__init__(**kwargs)
+
+        self.plotChasePlot = False # i vs i-1
+        #self.plotColorTime = False
+        self._hue = 'None'
+        #self.plotIsBad= True
+        self.plotHistograms = True
+
+        # keep track of what we are plotting, use this in replot()
+        self.xStatName = None
+        self.yStatName = None
+        self.xStatHumanName = None
+        self.yStatHumanName = None
+
+        self.xData = []
+        self.yData = []
+        #self.xAxisSpikeNumber = []  # We need to keep track of this for 'Chase Plot'
+
+        # main layout
+        hLayout = QtWidgets.QHBoxLayout()
+        hSplitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
+        hLayout.addWidget(hSplitter)
+
+        # coontrols and 2x stat list
+        vLayout = QtWidgets.QVBoxLayout()
+
         #
-        peakPoints.append(peakPnt)
-        peakVals.append(peakVal)
+        # controls
+        controlWidget = QtWidgets.QWidget()
+
+        hLayout2 = QtWidgets.QHBoxLayout()
 
-    #
-    # backup each spike until pre/post is not changing
-    # uses g_backupFraction to get percent of dv/dt at spike veruus each backup window
-    backupWindow_pnts = 30
-    maxSteps = 30  # 30 steps at 20 pnts (2ms) per step gives 60 ms
-    backupSpikes = []
-    for idx, spikePoint in enumerate(spikePoints):
-        # print(f'=== backup spike:{idx} at {t[spikePoint]}(s)')
-        foundBackupPoint = None
-        for step in range(maxSteps):
-            tmpPnt = spikePoint - (step * backupWindow_pnts)
-            tmpSeconds = t[tmpPnt]
-            preClip = dataFiltered[
-                tmpPnt - 1 - backupWindow_pnts : tmpPnt - 1
-            ]  # reversed
-            postClip = dataFiltered[tmpPnt + 1 : tmpPnt + 1 + backupWindow_pnts]
-            preMean = np.nanmean(preClip)
-            postMean = np.nanmean(postClip)
-            diffMean = postMean - preMean
-            if step == 0:
-                initialDiff = diffMean
-            # print(f'  spike {idx} step:{step} tmpSeconds:{round(tmpSeconds,4)} initialDiff:{round(initialDiff,4)} diff:{round(diffMean,3)}')
-            # if diffMean is 1/2 initial AP slope then accept
-            if diffMean < (initialDiff * g_backupFraction):
-                # stop
-                if foundBackupPoint is None:
-                    foundBackupPoint = tmpPnt
-                # break
         #
-        if foundBackupPoint is not None:
-            backupSpikes.append(foundBackupPoint)
-        else:
-            # needed to keep spike parity
-            logger.warning(
-                f"Did not find backupSpike for spike {idx} at {t[spikePoint]}(s)"
-            )
-            backupSpikes.append(spikePoint)
-
-    #
-    # use backupSpikes (points) to get each spike amplitude
-    spikeAmps = []
-    for idx, backupSpike in enumerate(backupSpikes):
-        if backupSpikes == np.nan or math.isnan(backupSpike):
-            continue
-        # print('backupSpike:', backupSpike)
-        footVal = dataFiltered[backupSpike]
-        peakVal = peakVals[idx]
-        spikeAmp = peakVal - footVal
-        spikeAmps.append(spikeAmp)
-
-    # TODO: use foot and peak to get real half/width
-    theseWidths = [10, 20, 50, 80, 90]
-    window_ms = 100
-    spikeDictList = _getHalfWidths(
-        t,
-        dataFiltered,
-        backupSpikes,
-        peakPoints,
-        theseWidths=theseWidths,
-        window_ms=window_ms,
-    )
-    # for idx, spikeDict in enumerate(spikeDictList):
-    # 	print(idx, spikeDict)
-
-    #
-    # get estimate of duration
-    # for each spike, find next downward crossing (starting at peak)
-    """
-	minDurationPoints = 10
-	windowPoints = 1000  # 100 ms
-	fallingPoints = []
-	for idx, spikePoint in enumerate(spikePoints):
-		peakPoint = peakPoints[idx]
-		backupPoint = backupSpikes[idx]
-		if backupPoint == np.nan or math.isnan(backupPoint):
-			continue
-		spikeSecond = spikeSeconds[idx]
-		# Not informative because we are getting spikes from absolute threshold
-		thisThreshold = dataFiltered[backupPoint]
-		thisPeak = dataFiltered[peakPoint]
-		halfHeight = thisThreshold + (thisPeak - thisThreshold) / 2
-		startPoint = peakPoint #+ 50
-		postClip = dataFiltered[startPoint:startPoint+windowPoints]
-		tmpFallingPoints = np.where(postClip<halfHeight)[0]
-		if len(tmpFallingPoints) > 0:
-			fallingPoint = startPoint + tmpFallingPoints[0]
-			# TODO: check if falling point is AFTER next spike
-			duration = fallingPoint - spikePoint
-			if duration > minDurationPoints:
-				fallingPoints.append(fallingPoint)
-			else:
-				print(f'  reject spike {idx} at {spikeSecond} (s), duration is {duration} points, minDurationPoints:{minDurationPoints}')
-				#fallingPoints.append(fallingPoint)
-		else:
-			print(f'    did not find falling pnt for spike {idx} at {spikeSecond}(s) point {spikePoint}, assume it is longer than windowPoints')
-			pass
-			#fallingPoints.append(np.nan)
-	"""
-
-    # TODO: Package all results into a dictionary
-    spikeDictList = [{}] * len(spikePoints)
-    for idx, spikePoint in enumerate(spikePoints):
-        """
-        spikeSecond = spikeSeconds[idx]
-        peakPoint = peakPoints[idx]
-        peakVal = peakVals[idx]
-        fallingPoint = fallingPoints[idx]  # get rid of this
-        backupSpike = backupSpikes[idx]  # get rid of this
-        spikeAmp = spikeAmps[idx]  # get rid of this
-        """
-        spikeDictList[idx]["spikePoint"] = spikePoint
-        spikeDictList[idx]["spikeSecond"] = spikeSeconds[idx]
-        spikeDictList[idx]["peakPoint"] = peakPoints[idx]
-        spikeDictList[idx]["peakVal"] = peakVals[idx]
-        # spikeDictList[idx]['fallingPoint'] = fallingPoints[idx]
-        spikeDictList[idx]["backupSpike"] = backupSpikes[idx]
-        spikeDictList[idx]["spikeAmp"] = spikeAmps[idx]
-    #
-    spikeSeconds = t[spikePoints]
-    # return spikeSeconds, spikePoints, peakPoints, peakVals, fallingPoints, backupSpikes, spikeAmps
-    # removved fallingPoints
-    return (
-        spikeDictList,
-        spikeSeconds,
-        spikePoints,
-        peakPoints,
-        peakVals,
-        backupSpikes,
-        spikeAmps,
-    )
-
-
-def _getHalfWidths(
-    t, v, spikePoints, peakPoints, theseWidths=[10, 20, 50, 80, 90], window_ms=50
-):
-    """Get half widths.
-
-    Args:
-            t (ndarray): Time
-            v (ndaray): Recording (usually curent clamp Vm)
-            spikePoints (list of int): List of spike threshold crossings.
-                                                    Usually the back-up version
-            peakPoints (list of int):
-            theseWidths (list of int): Specifies full-width-half maximal to calculate
-            window_ms (int): Number of ms to look after the peak for downward 1/2 height crossing
+        self.b2 = QtWidgets.QCheckBox("Chase Plot")
+        self.b2.setChecked(self.plotChasePlot)
+        self.b2.stateChanged.connect(lambda:self.btnstate(self.b2))
+        hLayout2.addWidget(self.b2)
 
-    Returns:
-            List of dict, one elemennt per spike
-    """
-    logger.info(
-        f"theseWidths:{theseWidths} window_ms:{window_ms} spikePoints:{len(spikePoints)} peakPoints:{len(peakPoints)}"
-    )
-
-    pointsPerMs = 10  # ToDo: generalize this
-    window_pnts = window_ms * pointsPerMs
-
-    spikeDictList = [{}] * len(spikePoints)  # an empy list of dict with proper size
-    for idx, spikePoint in enumerate(spikePoints):
-        # print(f'Spike {idx} pnt:{spikePoint}')
-
-        # each spike has a list of dict for each width result
-        spikeDictList[idx]["widths"] = []
-
-        # check each pre/post pnt is before next spike
-        nextSpikePnt = None
-        if idx < len(spikePoints) - 1:
-            nextSpikePnt = spikePoints[idx + 1]
+        #
+        # self.colorTime = QtWidgets.QCheckBox("Color Time")
+        # self.colorTime.setChecked(self.plotColorTime)
+        # self.colorTime.stateChanged.connect(lambda:self.btnstate(self.colorTime))
+        # hLayout2.addWidget(self.colorTime)
+
+        aLabel = QtWidgets.QLabel('Hue')
+        hLayout2.addWidget(aLabel)
+        aComboBox = QtWidgets.QComboBox()
+        _items = ['None', 'Time', 'Sweep']
+        aComboBox.addItems(_items)
+        aComboBox.currentTextChanged.connect(self.on_select_hue)
+        hLayout2.addWidget(aComboBox)
 
-        peakPoint = peakPoints[idx]
-        try:
-            vSpike = v[spikePoint]
-        except IndexError as e:
-            logger.error(f"spikePoint:{spikePoint} {type(spikePoint)}")
-        vPeak = v[peakPoint]
-        height = vPeak - vSpike
-        preStartPnt = spikePoint + 1
-        preClip = v[preStartPnt : peakPoint - 1]
-        postStartPnt = peakPoint + 1
-        postClip = v[postStartPnt : peakPoint + window_pnts]
-        for width in theseWidths:
-            thisHeight = vSpike + (height / width)  # search for a percent of height
-            prePnt = np.where(preClip >= thisHeight)[0]
-            if len(prePnt) > 0:
-                prePnt = preStartPnt + prePnt[0]
-            else:
-                # print(f'  Error: Spike {idx} "prePnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
-                prePnt = None
-            postPnt = np.where(postClip < thisHeight)[0]
-            if len(postPnt) > 0:
-                postPnt = postStartPnt + postPnt[0]
-            else:
-                # print(f'  Error: Spike {idx} "postPnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
-                postPnt = None
-            widthMs = None
-            if prePnt is not None and postPnt is not None:
-                widthPnts = postPnt - prePnt
-                widthMs = widthPnts / pointsPerMs
-                # print(f'  width:{width} tPre:{t[prePnt]} tPost:{t[postPnt]} widthMs:{widthMs}')
-                if nextSpikePnt is not None and prePnt >= nextSpikePnt:
-                    print(
-                        f"  Error: Spike {idx} widthMs:{widthMs} prePnt:{prePnt} is after nextSpikePnt:{nextSpikePnt}"
-                    )
-                if nextSpikePnt is not None and postPnt >= nextSpikePnt:
-                    print(
-                        f"  Error: Spike {idx} widthMs:{widthMs} postPnt:{postPnt} is after nextSpikePnt:{nextSpikePnt}"
-                    )
-
-            # put into dict
-            widthDict = {
-                "halfHeight": width,
-                "risingPnt": prePnt,
-                #'risingVal': defaultVal,
-                "fallingPnt": postPnt,
-                #'fallingVal': defaultVal,
-                #'widthPnts': None,
-                "widthMs": widthMs,
-            }
-            spikeDictList[idx]["widths_" + str(width)] = widthMs
-            spikeDictList[idx]["widths"].append(widthDict)
-    #
-    return spikeDictList
+        #
+        '''
+        self.colorType = QtWidgets.QCheckBox("Color Type")
+        self.colorType.setChecked(self.plotColorType)
+        self.colorType.stateChanged.connect(lambda:self.btnstate(self.colorType))
+        hLayout2.addWidget(self.colorType)
+        '''
 
+        #
+        '''
+        self.showBad = QtWidgets.QCheckBox("Show Bad")
+        self.showBad.setChecked(self.plotIsBad)
+        self.showBad.stateChanged.connect(lambda:self.btnstate(self.showBad))
+        hLayout2.addWidget(self.showBad)
+        '''
 
-def _throwOutRefractory(spikePoints, refractory_ms=100):
-    """
-    spikePoints: spike times to consider
-    refractory_ms:
-    """
-    dataPointsPerMs = 10
+        #
+        self.histogramCheckbox = QtWidgets.QCheckBox("Histograms")
+        self.histogramCheckbox.setChecked(self.plotHistograms)
+        self.histogramCheckbox.stateChanged.connect(lambda:self.btnstate(self.histogramCheckbox))
+        hLayout2.addWidget(self.histogramCheckbox)
+
+        vLayout.addLayout(hLayout2)
+
+        # second row of controls
+        hLayout2_2 = QtWidgets.QHBoxLayout()
+
+        aName = 'Spike: None'
+        self.spikeNumberLabel = QtWidgets.QLabel(aName)
+        hLayout2_2.addWidget(self.spikeNumberLabel)
+
+        vLayout.addLayout(hLayout2_2)
+
+        # x and y stat lists
+        hLayout3 = QtWidgets.QHBoxLayout()
+        self.xPlotWidget = myStatListWidget(self, headerStr='X Stat')
+        self.xPlotWidget.myTableWidget.selectRow(0)
+        self.yPlotWidget = myStatListWidget(self, headerStr='Y Stat')
+        self.yPlotWidget.myTableWidget.selectRow(7)
+        hLayout3.addWidget(self.xPlotWidget)
+        hLayout3.addWidget(self.yPlotWidget)
+        vLayout.addLayout(hLayout3)
 
-    before = len(spikePoints)
+        controlWidget.setLayout(vLayout)
 
-    # if there are doubles, throw-out the second one
-    # refractory_ms = 20 #10 # remove spike [i] if it occurs within refractory_ms of spike [i-1]
-    lastGood = 0  # first spike [0] will always be good, there is no spike [i-1]
-    for i in range(len(spikePoints)):
-        if i == 0:
-            # first spike is always good
-            continue
-        dPoints = spikePoints[i] - spikePoints[lastGood]
-        if dPoints < dataPointsPerMs * refractory_ms:
-            # remove spike time [i]
-            spikePoints[i] = 0
+        #
+        # create a mpl plot (self._static_ax, self.static_canvas)
+        #self.mplWindow2()
+        # plt.style.use('dark_background')
+        if self.darkTheme:
+            plt.style.use('dark_background')
         else:
-            # spike time [i] was good
-            lastGood = i
-    # regenerate spikeTimes0 by throwing out any spike time that does not pass 'if spikeTime'
-    # spikeTimes[i] that were set to 0 above (they were too close to the previous spike)
-    # will not pass 'if spikeTime', as 'if 0' evaluates to False
-    # if goodSpikeErrors is not None:
-    # 	goodSpikeErrors = [goodSpikeErrors[idx] for idx, spikeTime in enumerate(spikeTimes0) if spikeTime]
-    spikePoints = [spikePoint for spikePoint in spikePoints if spikePoint]
-
-    # TODO: put back in and log if detection ['verbose']
-    after = len(spikePoints)
-    logger.info(f"From {before} to {after} spikes with refractory_ms:{refractory_ms}")
-
-    return spikePoints
-
-
-def getKernel(type="sumExp", amp=5, tau1=30, tau2=70):
-    """Get a kernel for convolution with a spike train."""
-    N = 500  # pnts
-    t = [x for x in range(N)]
-    y = t
-
-    if type == "sumExp":
-        for i in t:
-            y[i] = -amp * (exp(-t[i] / tau1) - (exp(-t[i] / tau2)))
-    #
-    return y
-
-
-def getSpikeTrain(numSeconds=1, fs=10000, spikeFreq=3, amp=10, noiseAmp=10):
-    """Get a spike train at given frequency.
-
-    Arguments:
-            numSeconds (int): Total number of seconds
-            fs (int): Sampling frequency, 10000 for 10 kH
-            spikeFreq (int): Frequency of events in spike train, e.g. simulated EPSPs
-            amp (float): Amplitude of sum exponential kernel (getKernel)
-    """
-    n = int(numSeconds * fs)  # total number of samples
-    numSpikes = int(numSeconds * spikeFreq)
-    spikeTrain = np.zeros(n)
-    start = fs / spikeFreq
-    spikeTimes = np.linspace(start, n, numSpikes, endpoint=False)
-    for idx, spike in enumerate(spikeTimes):
-        # print(idx, spike)
-        spike = int(spike)
-        spikeTrain[spike] = 1
-
-    expKernel = getKernel(amp=amp)
-    epspTrain = scipy.signal.convolve(spikeTrain, expKernel, mode="same")
-    # shift to -60 mV
-    epspTrain -= 60
-
-    # add noise
-    if noiseAmp == 0:
-        pass
-    else:
-        # noise_power = 0.001 * fs / noiseAmp
-        # epspTrain += np.random.normal(scale=np.sqrt(noise_power), size=epspTrain.shape)
-        epspTrain += np.random.normal(scale=noiseAmp, size=epspTrain.shape)
-
-    #
-    t = np.linspace(0, numSeconds, n, endpoint=True)
-    #
-    return t, spikeTrain, epspTrain
-
-
-class fftFromRecording:
-    def __init__(
-        self,
-        path=None,
-        ba=None,
-        sweepNumber=0,
-        startSec=None,
-        stopSec=None,
-        doPlot=True,
-    ):
-        """fft backend.
+            plt.rcParams.update(plt.rcParamsDefault)
+            
+        # this is dangerous, collides with self.mplWindow()
+        self.fig = mpl.figure.Figure()
+        self.static_canvas = backend_qt5agg.FigureCanvas(self.fig)
+        self.static_canvas.setFocusPolicy( QtCore.Qt.ClickFocus ) # this is really triccky and annoying
+        self.static_canvas.setFocus()
+        # self.axs[idx] = self.static_canvas.figure.add_subplot(numRow,1,plotNum)
+
+        self._switchScatter()
+        '''
+        # gridspec for scatter + hist
+        self.gs = self.fig.add_gridspec(2, 2,  width_ratios=(7, 2), height_ratios=(2, 7),
+                                left=0.1, right=0.9, bottom=0.1, top=0.9,
+                                wspace=0.05, hspace=0.05)
+
+        self.axScatter = self.static_canvas.figure.add_subplot(self.gs[1, 0])
+        self.axHistX = self.static_canvas.figure.add_subplot(self.gs[0, 0], sharex=self.axScatter)
+        self.axHistY = self.static_canvas.figure.add_subplot(self.gs[1, 1], sharey=self.axScatter)
+
+
+        # make initial empty scatter plot
+        #self.lines, = self._static_ax.plot([], [], 'ow', picker=5)
+        self.cmap = mpl.pyplot.cm.coolwarm
+        self.cmap.set_under("white") # only works for dark theme
+        #self.lines = self._static_ax.scatter([], [], c=[], cmap=self.cmap, picker=5)
+        self.lines = self.axScatter.scatter([], [], c=[], cmap=self.cmap, picker=5)
+
+        # make initial empty spike selection plot
+        #self.spikeSel, = self._static_ax.plot([], [], 'oy')
+        self.spikeSel, = self.axScatter.plot([], [], 'oy')
+
+        # despine top/right
+        self.axScatter.spines['right'].set_visible(False)
+        self.axScatter.spines['top'].set_visible(False)
+        self.axHistX.spines['right'].set_visible(False)
+        self.axHistX.spines['top'].set_visible(False)
+        self.axHistY.spines['right'].set_visible(False)
+        self.axHistY.spines['top'].set_visible(False)
+        '''
+
+        #can do self.mplToolbar.hide()
+        # matplotlib.backends.backend_qt5.NavigationToolbar2QT
+        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(self.static_canvas, self.static_canvas)
+
+        # put toolbar and static_canvas in a V layout
+        plotWidget = QtWidgets.QWidget()
+        vLayoutPlot = QtWidgets.QVBoxLayout()
+        vLayoutPlot.addWidget(self.static_canvas)
+        vLayoutPlot.addWidget(self.mplToolbar)
+        plotWidget.setLayout(vLayoutPlot)
 
-        Args:
-                path (str) if specified, load abf from path
-                ba (bAnalysis) if specified use that
+        #
+        # finalize
+        #hLayout.addLayout(vLayout)
+        hSplitter.addWidget(controlWidget)
+        #hSplitter.addWidget(self.static_canvas) # add mpl canvas
+        hSplitter.addWidget(plotWidget)
+
+        # set the layout of the main window
+        # playing with dock
+        #self.mainWidget.setLayout(hLayout)
+        
+        # mar 17 was this
+        # self.setLayout(hLayout)
+        self.getVBoxLayout().addLayout(hLayout)
+        
+        #self.mainWidget.setGeometry(100, 100, 1200, 600)
+
+        self.replot()
+
+    def _switchScatter(self):
+        """Switch between single scatter plot and scatter + marginal histograms
         """
 
-        if ba is not None:
-            self.ba = ba
-        elif path is not None:
-            self.ba = sanpy.bAnalysis(path)
+        if self.plotHistograms:
+            # gridspec for scatter + hist
+            self.gs = self.fig.add_gridspec(2, 2,  width_ratios=(7, 2), height_ratios=(2, 7),
+                                    left=0.1, right=0.9, bottom=0.1, top=0.9,
+                                    wspace=0.05, hspace=0.05)
         else:
-            logger.error(f"Expecting either a path or existing bAnalysis object")
+            self.gs = self.fig.add_gridspec(1, 1,
+                                    left=0.1, right=0.9, bottom=0.1, top=0.9,
+                                    wspace=0.05, hspace=0.05)
+
+        self.static_canvas.figure.clear()
+        if self.plotHistograms:
+            self.axScatter = self.static_canvas.figure.add_subplot(self.gs[1, 0])
+
+            # x/y hist
+            self.axHistX = self.static_canvas.figure.add_subplot(self.gs[0, 0], sharex=self.axScatter)
+            self.axHistY = self.static_canvas.figure.add_subplot(self.gs[1, 1], sharey=self.axScatter)
+            #
+            self.axHistX.spines['right'].set_visible(False)
+            self.axHistX.spines['top'].set_visible(False)
+            self.axHistY.spines['right'].set_visible(False)
+            self.axHistY.spines['top'].set_visible(False)
 
-        # self.ba.setSweep(sweepNumber)
-        self.sweepNumber = sweepNumber
-
-        if startSec is None or stopSec is None:
-            self.startSec = 0
-            self.stopSec = self.ba.recordingDur
+            #self.axHistX.tick_params(axis="x", labelbottom=False) # no labels
+            #self.axHistX.tick_params(axis="y", labelleft=False) # no labels
         else:
-            self.startSec = startSec
-            self.stopSec = stopSec
+            self.axScatter = self.static_canvas.figure.add_subplot(self.gs[0, 0])
+            self.axHistX = None
+            self.axHistY = None
+
+        # we might have memory garbage collection issues
+        # passing self so we can receive selectSpikesFromHighlighter()
+        self.myHighlighter = Highlighter(self, self.axScatter, [], [])
 
-        self.plotRawAxis = True
+        #
+        # we will always have axScatter
+        #
+        # make initial empty scatter plot
+        self.cmap = mpl.pyplot.cm.coolwarm.copy()
+        self.cmap.set_under("white") # only works for dark theme
+        # do not specify 'c' argument, we set colors using set_facecolor, set_color
+
+        self.lines = self.axScatter.scatter([], [], picker=5)
+
+        # make initial empty spike selection plot
+
+        # self.spikeSel, = self.axScatter.plot([], [], 'x', markerfacecolor='none', color='y', markersize=10)  # no picker for selection
+        # TODO: standardize this with Highlighter scatter
+        # was this
+        # self.spikeListSel, = self.axScatter.plot([], [], 'o', markerfacecolor='none', color='y', markersize=10)  # no picker for selection
+        logger.info('!!!!!!!!!!!!!!!')
+        markerSize = 10
+        self.spikeListSel, = self.axScatter.plot([], [], 'o', markersize=markerSize, color='yellow', zorder=10)
+
+        # despine top/right
+        self.axScatter.spines['right'].set_visible(False)
+        self.axScatter.spines['top'].set_visible(False)
+
+        # TODO: refactor and use mplToolBar()
+        self.cid = self.static_canvas.mpl_connect('pick_event', self.spike_pick_event2)
+        
+        self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
 
-        self.doButterFilter = True
-        self.butterOrder = 70
-        self.butterCutoff = [0.7, 10]  # [low freq, high freq] for bandpass
+        #
+        #self.replot()
+
+    def spike_pick_event2(self, event):
+        """Respond to user left-mouse clicks in mpl plot.
+                
+        Args:
+            event : matplotlib.backend_bases.PickEvent
+                PickEvent with indices in ind[]
+
+        Notes:
+            need to clean up fft on pick, it is still in base plugin class
+        """
+        
+        # ignore when not left mouse button
+        if event.mouseevent.button != 1:
+            return
+    
+        if len(event.ind) < 1:
+            return
 
-        self._resultsDictList = []
-        self._resultsDictList2 = []
-        self._resultStr = ""
+        logger.info(f'{event}')
+        logger.info(f'{event.mouseevent}')
 
-        self.isModel = False
+        spikeNumber = event.ind[0]
 
-        self._store_ba = None  # allow switching between model and self.ba
+        doZoom = False
+        modifiers = QtWidgets.QApplication.keyboardModifiers()
+        if modifiers == QtCore.Qt.ShiftModifier:
+            doZoom = True
+
+        logger.info(f'got {len(event.ind)} candidates, first is spike:{spikeNumber} doZoom:{doZoom}')
+
+        # propagate a signal to parent
+        # TODO: use class SpikeSelectEvent()
+        sDict = {
+            'spikeList': [spikeNumber],
+            'doZoom': doZoom,
+            'ba': self.ba,
+        }
+        self.signalSelectSpikeList.emit(sDict)
 
-        if self.ba is not None:
-            self.fs = self.ba.recordingFrequency * 1000
+    def btnstate(self, b):
+        state = b.isChecked()
+        #if b.text() == "Respond To Analysis Changes":
+        #    self.setRespondToAnalysisChange(state)
+        if b.text() == 'Chase Plot':
+            self.plotChasePlot = state
+            logger.info(f'plotChasePlot:{self.plotChasePlot}')
+            self.replot()
+        # elif b.text() == 'Color Time':
+        #     self.plotColorTime = state
+        #     logger.info(f'plotColorTime:{self.plotColorTime}')
+        #     self.replot()
+
+        #elif b.text() == 'Color Type':
+        #    self.plotColorType = state
+        #    logger.info(f'plotColorType:{self.plotColorType}')
+        #    self.replot()
+        #elif b.text() == 'Show Bad':
+        #    self.plotIsBad = state
+        #    logger.info(f'plotIsBad:{self.plotIsBad}')
+        #    self.replot()
+        elif b.text() == 'Histograms':
+            self.plotHistograms = state
+            self._switchScatter()
+            logger.info(f'plotHistograms:{self.plotHistograms}')
+            self.replot()
         else:
-            self.fs = None
-        self.psdWindowStr = "Hanning"  # mpl.mlab.window_hanning
+            logger.warning(f'Did not respond to button "{b.text()}"')
 
-        # fft Freq (Hz) resolution is fs/nfft --> resolution 0.2 Hz = 10000/50000
-        self.nfft = 50000  # 512 * 100
+    def on_select_hue(self, hue : str):
+        self._hue = hue
+        self.replot()
 
-        self.signalHz = None  # assign when using fake data
-        self.maxPlotHz = 10  # limit x-axis frequenccy
+    def setAxis(self):
+        """Inherited, respond to user setting x-axis.
 
-        self.medianFilterPnts = 0
-
-        self.dataLine = None
-        self.dataFilteredLine = None
-        self.spikesLine = None
-        self.peaksLine = None
-        self.dataMeanLine = None
-        self.thresholdLine2 = None
-        self.thresholdLine3 = None
+        Generate a list of spikes and select them.
+        """
 
-        # self.fig = mpl.figure.Figure(constrained_layout=True)
-        self.fig = plt.figure(constrained_layout=True)
+        startSec, stopSec = self.getStartStop()
+        if startSec is None or stopSec is None:
+            return
 
-        if self.plotRawAxis:
-            numRow = 3
-        else:
-            numRow = 2
+        # select spike in range
+        thresholdSec = self.getStat('thresholdSec')
+
+        _selectedSpikeList = [spikeIdx for spikeIdx,spikeSec in enumerate(thresholdSec)
+                              if (spikeSec>startSec and spikeSec<stopSec)]
 
-        gs = self.fig.add_gridspec(numRow, 3)
+        self.setSelectedSpikes(_selectedSpikeList)
+        self.selectSpikeList()
+
+    def replot(self):
+        """Replot when file or analysis changes.
+        """
 
-        if self.plotRawAxis:
-            self.rawAxes = self.fig.add_subplot(gs[0, :])
-            self.rawZoomAxes = self.fig.add_subplot(gs[1, :])
-            # 3rd row has 3 subplots
-            self.psdAxes = self.fig.add_subplot(gs[2, 0])
-            self.spectrogramAxes = self.fig.add_subplot(gs[2, -2])
+        logger.info(f'sweepNumber:{self.sweepNumber} epochNumber:{self.epochNumber}')
+        
+        # get from stat lists
+        xHumanStat, xStat = self.xPlotWidget.getCurrentStat()
+        yHumanStat, yStat = self.yPlotWidget.getCurrentStat()
+
+        #logger.info(f'x:"{xHumanStat}" y:"{yHumanStat}"')
+        #logger.info(f'x:"{xStat}" y:"{yStat}"')
+
+        if self.ba is None or xHumanStat is None or yHumanStat is None:
+            xData = []
+            yData = []
         else:
-            self.rawAxes = None
-            self.rawZoomAxes = self.fig.add_subplot(gs[0, :])
-            # 3rd row has 3 subplots
-            self.psdAxes = self.fig.add_subplot(gs[1, 0])
-            self.spectrogramAxes = self.fig.figure.add_subplot(gs[1, -2])
-
-        if doPlot:
-            self.replot_fft2(sweepNumber=self.sweepNumber)
-
-    def getFigFileName(self):
-        filename = self.ba.getFileName()
-        filename = os.path.splitext(filename)[0]
-        sweep = self.ba.currentSweep
-        figFileName = f"{filename}_sweep_{sweep}.png"
-        return figFileName
-
-    def saveFig(self, folderPath=None):
-        """Save the current figure."""
-
-        # TODO: if folderPath then check it exists
-
-        figFileName = self.getFigFileName()
-        figFilePath = os.path.join(folderPath, figFileName)
-
-        logger.info(f"Saving figure to: {figFilePath}")
-
-        self.fig.savefig(figFilePath, dpi=300)
-
-    def getStartStop(self):
-        # logger.warning('remember to set start/stop')
-        # startSec = 0
-        # stopSec = self.ba.recordingDur
-        return self.startSec, self.stopSec
-
-    def linearDetrend(self, x):
-        # print('myDetrend() x:', x.shape)
-        y = plt.mlab.detrend_linear(x)
-        # y = plt.mlab.detrend_mean(y)
-        return y
+            xData = self.getStat(xStat)
+            yData = self.getStat(yStat)
 
-    def replot_fft2(self, sweepNumber=0):
-        start = time.time()
+        #
+        # TODO: use ba.getStat() option for this.)
+        xData = np.array(xData)
+        yData = np.array(yData)
 
-        if self.ba is None:
+        #
+        # return if we got no data, happend when there is no analysis
+        if xData is None or yData is None or np.isnan(xData).all() or np.isnan(yData).all():
+            # We get here when there is no analysis
+            #logger.warning(f'Did not find either xStat: "{xStat}" or yStat: "{yStat}"')
+            self.lines.set_offsets([np.nan, np.nan])
+            self.scatter_hist([], [], self.axHistX, self.axHistY)
+            self.static_canvas.draw()
             return
 
-        self.ba.setSweep(sweepNumber)
+        self.xStatName = xStat
+        self.yStatName = yStat
+        self.xStatHumanName = xHumanStat
+        self.yStatHumanName = yHumanStat
+
+        # need to mask color and marker
+        if self.plotChasePlot:
+            # keep track of x-axis spike number (for chase plot)
+            xAxisSpikeNumber = self.getStat('spikeNumber')
+            xAxisSpikeNumber = np.array(xAxisSpikeNumber)
+
+            # on selection, ind will refer to y-axis spike
+            xData = xData[1:-1] # x is the reference spike for marking (bad, type)
+            yData = yData[0:-2]
+            #
+            #xAxisSpikeNumber = xAxisSpikeNumber[1:-1]
+            xAxisSpikeNumber = xAxisSpikeNumber[0:-2]
+
+        self.xData = xData
+        self.yData = yData
+        #self.xAxisSpikeNumber = xAxisSpikeNumber
+
+        # data
+        data = np.stack([xData, yData], axis=1)
+        self.lines.set_offsets(data)  # (N, 2)
 
-        # if self.sweepNumber == 'All':
-        # 	logger.warning(f'fft plugin can only show one sweep, received sweepNumber:{self.sweepNumber}')
-        # 	return
+        #
+        # color
+        if self._hue == 'Time':
+            tmpColor = np.array(range(len(xData)))
+            self.lines.set_array(tmpColor)  # set_array is for a color map
+            self.lines.set_cmap(self.cmap)  # mpl.pyplot.cm.coolwarm
+            self.lines.set_color(None)
+        elif self._hue == 'Sweep':
+            # color sweeps
+            _sweeps = self.getStat('sweep')
+            tmpColor = np.array(range(len(_sweeps)))
+            self.lines.set_array(tmpColor)  # set_array is for a color map
+            self.lines.set_cmap(self.cmap)  # mpl.pyplot.cm.coolwarm
+            self.lines.set_color(None)
 
-        # logger.info(f'using ba: {self.ba}')
-        startSec, stopSec = self.getStartStop()
-        if (
-            startSec is None
-            or stopSec is None
-            or math.isnan(startSec)
-            or math.isnan(stopSec)
-        ):
-            logger.info(f"Resetting start/stop seconds to max")
-            startSec = 0
-            stopSec = self.ba.recordingDur  # self.ba.sweepX()[-1]
-        logger.info(f"Using start(s):{startSec} stop(s):{stopSec}")
-        self.lastLeft = round(startSec * 1000 * self.ba.dataPointsPerMs)
-        self.lastRight = round(stopSec * 1000 * self.ba.dataPointsPerMs)
-
-        leftPoint = self.lastLeft
-        rightPoint = self.lastRight
-
-        # sweepY = self.getSweep('y')
-        sweepY = self.ba.sweepY
-        if leftPoint < 0:
-            leftPoint = 0
-        if rightPoint > sweepY.shape[0]:
-            rightPoint = sweepY.shape[0]
-
-        y = sweepY[leftPoint:rightPoint]
-
-        medianPnts = self.medianFilterPnts  # 50
-        if medianPnts > 0:
-            logger.info(f"  Median filter with pnts={medianPnts}")
-            yFiltered = scipy.ndimage.median_filter(y, medianPnts)
         else:
-            logger.info("  No median filter")
-            yFiltered = y
-
-        # logger.info(f'Fetching sweepX with sweepNumber: {self.sweepNumber}')
+            #tmpColor = np.array(range(len(xData)))
+            # assuming self.cmap.set_under("white")
 
-        # sweepX = self.getSweep('x')
-        sweepX = self.ba.fileLoader.sweepX
+            #from matplotlib.colors import ListedColormap
+            color_dict={1:"blue",
+                2:"red",
+                13:"orange",
+                7:"green"}
+            color_dict= {
+                'good': (0,1,1,1), # cyan
+                'bad': (1,0,0,1), # red
+                #'userType1':(0,0,1,1), # blue
+                #'userType2':(0,1,1,1), # cyan
+                #'userType3':(1,0,1,1), # magenta
+            }
+            marker_dict = {
+                'userType1': mmarkers.MarkerStyle('*'),  # star
+                'userType2': mmarkers.MarkerStyle('v'),  # triangle_down
+                'userType3': mmarkers.MarkerStyle('<'),  # triangle_left
+            }
 
-        # logger.info(f'  sweepX: {sweepX.shape}')
-        # logger.info(f'  leftSec:{sweepX[leftPoint]} rightSec:{sweepX[rightPoint-1]}')
-        t = sweepX[leftPoint:rightPoint]
-
-        dt = t[1] - t[0]  # 0.0001
-        fs = round(1 / dt)  # samples per second
-        nfft = self.nfft  # The number of data points used in each block for the FFT
-        # print(f'  fs:{fs} nfft:{nfft}')
-
-        # 20220329 hijacking raw plot to show stim
-        if self.plotRawAxis:
-            sweepC = self.ba.sweepC
-
-            self.rawAxes.clear()
-            # self.rawAxes.plot(sweepX, sweepY, '-', linewidth=1)
-            self.rawAxes.plot(sweepX, sweepC, "-", linewidth=1)
-            # draw a rectangle to show left/right time selecction
-            """
-			yMin = np.nanmin(sweepY)
-			yMax = np.nanmax(sweepY)
-			xRect = startSec
-			yRect = yMin
-			wRect = stopSec-startSec
-			hRect = yMax-yMin
-			rect1 = mpl.patches.Rectangle((xRect,yRect), wRect, hRect, color='gray')
-			self.rawAxes.add_patch(rect1)
-			"""
-            # self.rawAxes.set_xlim([sweepX[0], sweepX[-1]])
-            self.rawAxes.set_xlim([self.startSec, self.stopSec])
+            # no need for a cmap ???
+            #cm = ListedColormap([color_dict[x] for x in color_dict.keys()])
+            #self.lines.set_cmap(cm)
+
+            goodSpikes = self.getStat('include')
+            userTypeList = self.getStat('userType')
+
+            logger.warning('   debug set spike stat, user types need to be int')
+            logger.warning('   we ARE NOT GETTING THE CORRECT SPIKE INDEX')
+            # print(userTypeList)
+
+            if self.plotChasePlot:
+                #xData = xData[1:-1] # x is the reference spike for marking (bad, type)
+                #goodSpikes = goodSpikes[1:-1]
+                #userTypeList = userTypeList[1:-1]
+                goodSpikes = goodSpikes[0:-2]
+                userTypeList = userTypeList[0:-2]
+
+            tmpColors = [color_dict['bad']] * len(xData) # start as all good
+            
+            # user types will use symbols
+            #tmpColors = [color_dict['type'+num2str(x)] if x>0 else tmpColors[idx] for idx,x in enumerate(userTypeList)]
+            # bad needs to trump user type !!!
+            tmpColors = [color_dict['good'] if x else tmpColors[idx] for idx,x in enumerate(goodSpikes)]
+            tmpColors = np.array(tmpColors)
+            #print('tmpColors', type(tmpColors), tmpColors.shape, tmpColors)
+
+            self.lines.set_array(None)  # used to map [0,1] to color map
+            self.lines.set_facecolor(tmpColors)
+            self.lines.set_color(tmpColors)  # sets the outline
+
+            # set user type 2 to 'star'
+            # see: https://stackoverflow.com/questions/52303660/iterating-markers-in-plots/52303895#52303895
+            #import matplotlib.markers as mmarkers
+            myMarkerList = [marker_dict['userType'+str(x)] if x>0 else mmarkers.MarkerStyle('o') for x in userTypeList]
+            myPathList = []
+            for myMarker in myMarkerList:
+                path = myMarker.get_path().transformed(myMarker.get_transform())
+                myPathList.append(path)
+            self.lines.set_paths(myPathList)
 
         #
-        # replot the clip +/- std we analyzed, after detrend
-        yDetrend = self.linearDetrend(yFiltered)
+        # update highlighter, needs coordinates of x/y to highlight
+        self.myHighlighter.setData(xData, yData)
 
+        # label axes
+        xStatLabel = xHumanStat
+        yStatLabel = yHumanStat
+        if self.plotChasePlot:
+            xStatLabel += ' [i]'
+            yStatLabel += ' [i-1]'
+        self.axScatter.set_xlabel(xStatLabel)
+        self.axScatter.set_ylabel(yStatLabel)
+
+        # don't cancel on replot
+        '''
+        # cancel any selections
+        self.spikeSel.set_data([], [])
+        #self.spikeSel.set_offsets([], [])
+        self.spikeListSel.set_data([], [])
+        #self.spikeListSel.set_offsets([], [])
+        '''
+
+        xMin = np.nanmin(xData)
+        xMax = np.nanmax(xData)
+        yMin = np.nanmin(yData)
+        yMax = np.nanmax(yData)
+        # expand by 5%
+        xSpan = abs(xMax - xMin)
+        percentSpan = xSpan * 0.05
+        xMin -= percentSpan
+        xMax += percentSpan
         #
-        if self.doButterFilter:
-            # self.butterCutoff = 10  # Hz
-            # self.butterOrder = 70
-            # self.sos = butter_sos(self.butterCutoff, self.fs, order=self.butterOrder, passType='lowpass')
-            # self.butterCutoff = [0.7, 10]
-            # logger.info(f'  butterOrder:{self.butterOrder} butterCutoff:{self.butterCutoff}')
-            self.sos = butter_sos(
-                self.butterCutoff, self.fs, order=self.butterOrder, passType="bandpass"
-            )
-            # filtfilt should remove phase delay in time. A forward-backward digital filter using cascaded second-order sections.
-            yFiltered_Butter = scipy.signal.sosfiltfilt(self.sos, yDetrend, axis=0)
-            # print('yDetrend:', yDetrend.shape, np.nanmin(yDetrend), np.nanmax(yDetrend))
-            # print('yFiltered_Butter:', yFiltered_Butter.shape, np.nanmin(yFiltered_Butter), np.nanmax(yFiltered_Butter))
-
-            # we use this for remaining
-            yFiltered = yFiltered_Butter
-
-        dataMean = np.nanmean(yDetrend)
-        dataStd = np.nanstd(yDetrend)
-        dataThreshold2 = dataMean + (2 * dataStd)
-        dataThreshold3 = dataMean + (3 * dataStd)
-
-        self.rawZoomAxes.clear()
-        self.rawZoomAxes.plot(t, yDetrend, "-", linewidth=1)
-        self.rawZoomAxes.axhline(
-            dataMean, marker="", color="r", linestyle="--", linewidth=0.5
-        )
-        self.rawZoomAxes.axhline(
-            dataThreshold2, marker="", color="r", linestyle="--", linewidth=0.5
-        )
-        self.rawZoomAxes.axhline(
-            dataThreshold3, marker="", color="r", linestyle="--", linewidth=0.5
-        )
-        self.rawZoomAxes.set_xlim([t[0], t[-1]])
-        #
-        if self.doButterFilter:
-            self.rawZoomAxes.plot(t, yFiltered, "-r", linewidth=1)
+        ySpan = abs(yMax - yMin)
+        percentSpan = ySpan * 0.05
+        yMin -= percentSpan
+        yMax += percentSpan
+
+        self.axScatter.set_xlim([xMin, xMax])
+        self.axScatter.set_ylim([yMin, yMax])
+
+        #self.scatter_hist(xData, yData, self.axScatter, self.axHistX, self.axHistY)
+        self.scatter_hist(xData, yData, self.axHistX, self.axHistY)
+
+        # redraw
+        self.static_canvas.draw()
+        # was this
+        #self.repaint() # update the widget
 
-        # save yDetrend, yFiltered as csv
+    #def scatter_hist(self, x, y, ax, ax_histx, ax_histy):
+    def scatter_hist(self, x, y, ax_histx, ax_histy):
         """
-		print('=== FOR FERNANDO')
-		import pandas as pd
-		print('  t:', t.shape)
-		print('  yDetrend:', yDetrend.shape)
-		print('  yFiltered:', yFiltered.shape)
-		tmpDf = pd.DataFrame(columns=['s', 'yDetrend', 'yFiltered'])
-		tmpDf['s'] = t
-		tmpDf['yDetrend'] = yDetrend
-		tmpDf['yFiltered'] = yFiltered
-		print(tmpDf.head())
-		dfFile = 'fft-20200707-0000-16sec-31sec.csv'
-		print('saving dfFile:', dfFile)
-		tmpDf.to_csv(dfFile, index=False)
-		print('=== END')
-		"""
-
-        # we will still scale a freq plots to [0, self.maxPlotHz]
-        if self.doButterFilter:
-            minPlotFreq = self.butterCutoff[0]
-            maxPlotFreq = self.butterCutoff[1]
-        else:
-            minPlotFreq = 0
-            maxPlotFreq = self.maxPlotHz  # 15
+        plot a scatter with x/y histograms in margin
 
-        #
-        # spectrogram
-        # self.fftAxes.clear()
-        nfft2 = int(nfft / 4)
-        specSpectrum, specFreqs, spec_t, specIm = self.spectrogramAxes.specgram(
-            yFiltered, NFFT=nfft2, Fs=fs, detrend=self.linearDetrend
-        )
-        """
-		print('=== specgram')
-		print('  yFiltered:', yFiltered.shape)
-		print('  specSpectrum (freq, t):', specSpectrum.shape)  # (25601, 20) is (freq, t)
-		print('    ', np.nanmin(specSpectrum), np.nanmax(specSpectrum))
-		print('  specFreqs:', specFreqs.shape)
-		print('  spec_t:', spec_t.shape)
-		print('  specIm:', type(specIm))
-		"""
-        mask = (specFreqs >= minPlotFreq) & (specFreqs <= maxPlotFreq)
-        specSpectrum = specSpectrum[mask, :]  # TRANSPOSE
-        """
-		print('  2 Transpose specSpectrum (freq, t):', specSpectrum.shape)  # (25601, 20) is (freq, t)
-		print('    ', np.nanmin(specSpectrum), np.nanmax(specSpectrum))
-		"""
-
-        # careful: I want to eventually scale y-axis to [0, self.maxPlotHz]
-        # for now use [minPlotFreq, maxPlotFreq]
-        x_min = startSec
-        x_max = stopSec
-        y_min = maxPlotFreq  # minPlotFreq
-        y_max = minPlotFreq  # maxPlotFreq
-        extent = [x_min, x_max, y_min, y_max]
-
-        self.spectrogramAxes.clear()
-        self.spectrogramAxes.imshow(
-            specSpectrum, extent=extent, aspect="auto", cmap="viridis"
-        )
-        self.spectrogramAxes.invert_yaxis()
-        self.spectrogramAxes.set_xlabel("Time (s)")
-        self.spectrogramAxes.set_ylabel("Freq (Hz)")
+        Args:
+            x (date):
+            y (data):
+            ax_histx (axes) Histogram Axes
+            ax_histy (axes) Histogram Axes
+        """
 
-        #
-        # matplotlib psd
-        if self.psdWindowStr == "Hanning":
-            psdWindow = mpl.mlab.window_hanning
-        elif self.psdWindowStr == "Blackman":
-            psdWindow = np.blackman(nfft)
+        xBins = 'auto'
+        yBins = 'auto'
+
+        xTmp = np.array(x)  #y[~np.isnan(y)]
+        xTmp = xTmp[~np.isnan(xTmp)]
+        xTmpBins = np.histogram_bin_edges(xTmp, 'auto')
+        xNumBins = len(xTmpBins)
+        if xNumBins*2 < len(x):
+            xNumBins *= 2
+        xBins = xNumBins
+
+        yTmp = np.array(y)  #y[~np.isnan(y)]
+        yTmp = yTmp[~np.isnan(yTmp)]
+        yTmpBins = np.histogram_bin_edges(yTmp, 'auto')
+        yNumBins = len(yTmpBins)
+        if yNumBins*2 < len(y):
+            yNumBins *= 2
+        yBins = yNumBins
+
+        # x
+        if ax_histx is not None:
+            ax_histx.clear()
+            nHistX, binsHistX, patchesHistX = ax_histx.hist(x, bins=xBins, facecolor='silver', edgecolor="gray")
+            ax_histx.tick_params(axis="x", labelbottom=False) # no labels
+            #ax_histx.spines['right'].set_visible(False)
+            #ax_histx.spines['top'].set_visible(False)
+            #ax_histx.yaxis.set_ticks_position('left')
+            #ax_histx.xaxis.set_ticks_position('bottom')
+            #print('  binsHistX:', len(binsHistX))
+        # y
+        if ax_histy is not None:
+            ax_histy.clear()
+            nHistY, binsHistY, patchesHistY = ax_histy.hist(y, bins=yBins, orientation='horizontal', facecolor='silver', edgecolor="gray")
+            ax_histy.tick_params(axis="y", labelleft=False)
+            #ax_histy.yaxis.set_ticks_position('left')
+            #ax_histy.xaxis.set_ticks_position('bottom')
+            #print('  binsHistY:', len(binsHistY))
+
+    def selectSpikeList(self):
+        """
+        """
+        logger.info(f'{self._myClassName()}')
+        
+        if self.xStatName is None or self.yStatName is None:
+            return
+
+        spikeList = self.getSelectedSpikes()
+
+        #if spikeList is not None:
+        if len(spikeList) > 0:
+            xData = [self.xData[spikeList]]
+            yData = [self.yData[spikeList]]
         else:
-            logger.warning(f"psdWindowStr not understood {self.psdWindowStr}")
+            xData = []
+            yData = []
+
+        # logger.info(f'!!! SET DATA {xData} {yData}')
+        self.spikeListSel.set_data(xData, yData)
+
+        # update a little info about first spike
+        _str = ''
+        if len(spikeList) > 0:
+            firstSpike = spikeList[0]
+            _oneDict = self.ba.getOneSpikeDict(firstSpike)
+            _str += f"Spike Number {_oneDict['spikeNumber']}"
+            _str += f" Sweep {_oneDict['sweep']}"
+            _str += f" Epoch {_oneDict['epoch']}"
+
+        self.spikeNumberLabel.setText(f'Spike: {_str}')
+
+        self.static_canvas.draw()
+        # was this
+        #self.repaint() # update the widget
+
+    def old_selectSpike(self, sDict=None):
+        """Select a spike
+
+        sDict (dict): NOT USED
         """
-		print('=== calling mpl psd()')
-		print('  nfft:', nfft)
-		print('  fs:', fs)
-		print('  myDetrend:', myDetrend)
-		print('  psdWindowStr:', self.psdWindowStr)
-		print('  psdWindow:', psdWindow)
-		"""
-        # default scale_by_freq=True
-        scale_by_freq = True
-        Pxx, freqs = self.psdAxes.psd(
-            yFiltered,
-            marker="",
-            linestyle="-",
-            NFFT=nfft,
-            Fs=fs,
-            scale_by_freq=scale_by_freq,
-            detrend=self.linearDetrend,
-            window=psdWindow,
-        )
 
-        #
-        # replot matplotlib psd
-        pxxLog10 = 10 * np.log10(Pxx)
+        #logger.info(sDict)
 
-        # pxxLog10 = Pxx # does this look better ???
+        #spikeNumber = sDict['spikeNumber']
+        #spikeList = [spikeNumber]
 
-        mask = (freqs >= minPlotFreq) & (freqs <= maxPlotFreq)
-        pxxLog10 = pxxLog10[mask]  # order matters
-        freqsLog10 = freqs[mask]  # order matters
-        self.psdAxes.clear()
-        self.psdAxes.plot(freqsLog10, pxxLog10, "-", linewidth=1)
-        self.psdAxes.set_xlim([0, self.maxPlotHz])  # x-axes is frequency
-        self.psdAxes.grid(True)
-        # self.psdAxes.set_ylabel('10*log10(Pxx)')
-        self.psdAxes.set_ylabel("PSD (dB)")
-        self.psdAxes.set_xlabel("Freq (Hz)")
+        spikeNumber = self.selectedSpike
 
-        #
-        # get peak frequency from psd, finding max peak with width
-        inflection = np.diff(np.sign(np.diff(pxxLog10)))
-        peaks = (inflection < 0).nonzero()[0] + 1
-        # excception ValueError
-        try:
-            peak0 = peaks[pxxLog10[peaks].argmax()]
-            maxFreq0 = round(freqsLog10[peak0], 3)  # Gives 0.05
-            maxPsd0 = round(pxxLog10[peak0], 3)  # Gives 0.05
-        except ValueError as e:
-            logger.error("BAD PEAK in pxx")
-            maxFreq0 = []
-            maxPsd0 = []
-        # print(f'1 Results: Peak Hz={round(maxFreq0,3)} Amplitude={round(maxPsd0,3)}')
-
-        # add to plot
-        self.psdAxes.plot(maxFreq0, maxPsd0, ".r")
-
-        # the absolute maximum in the psd
-        maxPsd = np.nanmax(pxxLog10)
-        maxPnt = np.argmax(pxxLog10)
-        maxFreq = freqsLog10[maxPnt]
-        # self.resultsLabel.setText(f'Results: Peak Hz={round(maxFreq,3)} Amplitude={round(maxPsd,3)}')
-        # print(f'2 Results: Peak Hz={round(maxFreq,3)} Amplitude={round(maxPsd,3)}')
+        if self.xStatName is None or self.yStatName is None:
+            return
 
-        #
-        # print results
-        # (file, startSec, stopSec, max psd amp, max psd freq)
-        pStart = round(startSec, 3)
-        pStop = round(stopSec, 3)
-        pMaxFreq = round(maxFreq, 3)
-        pMaxPsd = round(maxPsd, 3)
-
-        """
-		printStr = f'Type\tFile\tstartSec\tstopSec\tmaxFreqPsd\tmaxPsd'  #\tmaxFreqFft\tmaxFft'
-		#self.appendResultsStr(printStr)
-		print('=== FFT results are:')
-		print(printStr)
-		printStr = f'fftPlugin\t{self.ba.getFileName()}\t{pStart}\t{pStop}\t{pMaxFreq}\t{pMaxPsd}'
-		self.appendResultsStr(printStr, maxFreq=pMaxFreq, maxPsd=pMaxPsd, 
-								maxFreq0=maxFreq0, maxPsd0=maxPsd0,
-								freqs=freqsLog10, psd=pxxLog10)  # last 2 are not used
-		print(printStr)
-		"""
-
-        # 20220330, rms error of stim
-        tmpSweepC = sweepC[leftPoint:rightPoint]
-        rms = np.sqrt(np.mean(tmpSweepC**2))
-
-        resultDict = {
-            "file": self.ba.getFileName(),
-            "sweep": self.ba.currentSweep,
-            "startSec": self.getStartStop()[0],
-            "stopSec": self.getStartStop()[1],
-            "butterFilter": self.doButterFilter,
-            "butterOrder": self.butterOrder,
-            "lowFreqCutoff": self.butterCutoff[0],
-            "highFreqCutoff": self.butterCutoff[1],
-            # ultimate max
-            "maxFreq": pMaxFreq,
-            "maxPSD": pMaxPsd,
-            # max in peak
-            "maxFreq0": maxFreq0,
-            "maxPSD0": maxPsd0,
-            # TODO: max as stim freq
-            "maxFreq_at_stim": "",
-            "maxPSD_at_stim": "",
-            "rmsStim": rms,  # rms of injected current
-            #'freqs': freqs,
-            #'psd': psd,
-        }
-        self.appendResults2(resultDict)
+        xData = []
+        yData = []
+        if spikeNumber is not None:
+            try:
+                xData = [self.xData[spikeNumber]]
+                yData = [self.yData[spikeNumber]]
+            except (IndexError) as e:
+                logger.error(e)
+
+        self.spikeSel.set_data(xData, yData)
+        #self.spikeSel.set_offsets(xData, yData)
+
+        self.spikeNumberLabel.setText(f'Spike: {spikeNumber}')
+
+        self.static_canvas.draw()
+        #was this
+        #self.repaint() # update the widget
 
-        # TODO: make a dict of results and append to pandas df
+    def selectSpikesFromHighlighter(self, selectedSpikeList):
+        """User selected some spikes with Highlighter -->> Propogate to main
+        """
 
-        #
-        # plot np fft
-        # see: https://www.gw-openscience.org/tutorial05/
-        # blackman is supposed to correct for low freq signal ???
-        """
-		doBlackman = False
-		if doBlackman:
-			window = np.blackman(yFiltered.size)
-			windowed_yFiltered = yFiltered*window
-		else:
-			windowed_yFiltered = yFiltered
-
-		ft = np.fft.rfft(windowed_yFiltered)
-		# not sure to use diff b/w [1]-[0] or fs=10000 ???
-		tmpFs = t[1]-t[0]
-		fftFreqs = np.fft.rfftfreq(len(windowed_yFiltered), tmpFs) # Get frequency axis from the time axis
-		fftMags = abs(ft) # We don't care about the phase information here
-
-		# find max peak with width
-		inflection = np.diff(np.sign(np.diff(fftMags)))
-		peaks = (inflection < 0).nonzero()[0] + 1
-		peak = peaks[fftMags[peaks].argmax()]
-		signal_freq = round(fftFreqs[peak],3) # Gives 0.05
-		signal_mag = round(fftMags[peak],3) # Gives 0.05
-		#printStr = f'FFT\t{self.ba.getFileName()}\t{pStart}\t{pStop}\t{signal_freq}\t{signal_mag}'
-		#print(printStr)
-		printStr += f'\t{signal_freq}\t{signal_mag}'
-		print(printStr)
-		self.appendResultsStr(printStr)
-		#print(f'  fft signal frequency is:{signal_freq} with mag:{signal_mag}')
-
-		# strip down to min/ax x-plot of freq
-		mask = (fftFreqs>=minPlotFreq) & (fftFreqs<=maxPlotFreq)
-		fftMags = fftMags[mask] # order matters
-		fftFreqs = fftFreqs[mask] # order matters
-
-		fftMags = fftMags[2:-1]
-		fftFreqs = fftFreqs[2:-1]
-
-		self.fftAxes.clear()
-		self.fftAxes.semilogy(fftFreqs, fftMags, '-', linewidth=1)
-		self.fftAxes.set_xlim([minPlotFreq, maxPlotFreq])  # x-axes is frequency
-		self.fftAxes.set_xlabel('Freq (Hz)')
-		self.fftAxes.set_ylabel('FFT Mag')
-		self.fftAxes.grid(True)
-		self.fftAxes.semilogy(signal_freq, signal_mag, '.r')
-		"""
+        if len(selectedSpikeList) > 0:
+            self.setSelectedSpikes(selectedSpikeList)
+            sDict = {
+                'spikeList': self.getSelectedSpikes(),
+                'doZoom': False, # never zoom on multiple spike selection
+                'ba': self.ba,
+            }
+            self.signalSelectSpikeList.emit(sDict)
+
+    def toolbarHasSelection(self):
+        """Return true if either ['zoom rect', 'pan/zoom'] are selected
+        
+        This is needed to cancel mouse clicks in Highlighter and right click in SanPyPlugin
+        """
+        state = self.mplToolbar.mode
+        return state in ['zoom rect', 'pan/zoom']
 
-        stop = time.time()
-        # logger.info(f'Took {stop-start} seconds.')
+    def prependMenus(self, contextMenu):
+        """Prepend menus to context menu
+        """
+
+        noSpikesSelected = len(self.getSelectedSpikes()) == 0
+
+        includeAction = contextMenu.addAction("Accept")
+        includeAction.setDisabled(noSpikesSelected)  # disable if no spikes
+
+        rejectAction = contextMenu.addAction("Reject")
+        rejectAction.setDisabled(noSpikesSelected)
+
+        userType1_action = contextMenu.addAction("User Type 1")
+        userType1_action.setDisabled(noSpikesSelected)
+
+        userType2_action = contextMenu.addAction("User Type 2")
+        userType2_action.setDisabled(noSpikesSelected)
+
+        userType3_action = contextMenu.addAction("User Type 3")
+        userType3_action.setDisabled(noSpikesSelected)
+
+        userType4_action = contextMenu.addAction("Reset User Type")
+        userType4_action.setDisabled(noSpikesSelected)
+
+        contextMenu.addSeparator()
+
+    def handleContextMenu(self, action):
+        """
+        Returns:
+            True if handled, otherwise False
+        """
+        if action is None:
+            return False
+
+        text = action.text()
+        logger.info(f'Action text "{text}"')
+
+        _selectedSpikes = self.getSelectedSpikes()
+
+        handled = False
+        if text == 'Accept':
+            #print('Set selected spikes to include (not isbad)')
+            self.ba.setSpikeStat(_selectedSpikes, 'include', False)
+            self.replot()
+            handled = True
+        elif text == 'Reject':
+            #print('Set selected spikes to reject (isbad)')
+            self.ba.setSpikeStat(_selectedSpikes, 'include', True)
+            self.replot()
+            handled = True
+        elif text == 'User Type 1':
+            self.ba.setSpikeStat(_selectedSpikes, 'userType', 1)
+            self.replot()
+            handled = True
+        elif text == 'User Type 2':
+            self.ba.setSpikeStat(_selectedSpikes, 'userType', 2)
+            self.replot()
+            handled = True
+        elif text == 'User Type 3':
+            self.ba.setSpikeStat(_selectedSpikes, 'userType', 3)
+            self.replot()
+            handled = True
+        elif text == 'Reset User Type':
+            self.ba.setSpikeStat(_selectedSpikes, 'userType', 0)
+            self.replot()
+            handled = True
+        else:
+            #logger.info(f'Action not understood "{text}"')
+            pass
 
         #
-        # self.static_canvas.draw()
+        return handled
 
-        figFileName = self.getFigFileName()
-        self.fig.suptitle(figFileName)
+    def copyToClipboard(self):
+        """Copy current x/y stats to clipboard with some other book-keeping.
+        
+        For example: spike number, spike time (s), is bad, user type, and file name.
+        """
+        spikeNumber = self.getStat('spikeNumber')
+        spikeTimeSec = self.getStat('thresholdSec')
+        xStat = self.getStat(self.xStatName)
+        yStat = self.getStat(self.yStatName)
+        goodSpikes = self.getStat('include')
+        userType = self.getStat('userType')
+        file = self.getStat('file')
+
+        columns = ['Spike Number',
+                   'Spike Time(s)',
+                   self.xStatHumanName,
+                   self.yStatHumanName,
+                   'Include',
+                   'User Type',
+                   'File']
+        df = pd.DataFrame(columns=columns)
+        df['Spike Number'] = spikeNumber
+        df['Spike Time(s)'] = spikeTimeSec
+        df[self.xStatHumanName] = xStat
+        df[self.yStatHumanName] = yStat
+        df['Include'] = goodSpikes
+        df['User Type'] = userType
+        df['File'] = file
+
+        excel = True
+        sep = '\t'
+        df.to_clipboard(excel=excel, sep=sep)
 
-    def appendResults2(self, resultDict):
-        self._resultsDictList2.append(resultDict)
+        logger.info(f'Copied {len(df)} spikes to clipboard.')
 
-    def appendResultsStr(
-        self, str, maxFreq="", maxPsd="", maxFreq0="", maxPsd0="", freqs="", psd=""
-    ):
-        self._resultStr += str + "\n"
-        resultDict = {
-            "file": self.ba.getFileName(),
-            "sweep": self.ba.currentSweep,
-            "startSec": self.getStartStop()[0],
-            "stopSec": self.getStartStop()[1],
-            "butterFilter": self.doButterFilter,
-            "butterOrder": self.butterOrder,
-            "lowFreqCutoff": self.butterCutoff[0],
-            "highFreqCutoff": self.butterCutoff[1],
-            # ultimate max
-            "maxFreq": maxFreq,
-            "maxPSD": maxPsd,
-            # max in peak
-            "maxFreq0": maxFreq0,
-            "maxPSD0": maxPsd0,
-            #'freqs': freqs,
-            #'psd': psd,
-        }
-        self._resultsDictList.append(resultDict)
+class myStatListWidget(QtWidgets.QWidget):
+    """
+    Widget to display a table with selectable stats.
 
-    def getResultsDictList(self):
-        return self._resultsDictList
+    Gets list of stats from: sanpy.bAnalysisUtil.getStatList()
+    """
+    def __init__(self, myParent, statList=None, headerStr='Stat', parent=None):
+        """
+        Parameters
+        ----------
+        myParent : sanpy.interface.plugins.sanpyPlugin
+        """
+        super().__init__(parent)
 
-    def getResultStr(self):
-        return self._resultStr
+        self.myParent = myParent
+        if statList is not None:
+            self.statList = statList
+        else:
+            self.statList = sanpy.bAnalysisUtil.getStatList()
+        self._rowHeight = 9
 
+        self.myQVBoxLayout = QtWidgets.QVBoxLayout(self)
 
-def run():
-    # need to use colinAnalysis.bAnalysis2() to load stim file atf
-    # see how far I get without it, all I need from it is
-    # 	- (sin, noise) params per sweep
-    # 	- if a sweep is blank_re
-    # 	- try and scrip these things into a table and just use a regular bAnalysis
+        self.myTableWidget = QtWidgets.QTableWidget()
+        self.myTableWidget.setWordWrap(False)
+        self.myTableWidget.setRowCount(len(self.statList))
+        self.myTableWidget.setColumnCount(1)
+        self.myTableWidget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
+        self.myTableWidget.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
+        self.myTableWidget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
+        self.myTableWidget.cellClicked.connect(self.on_scatter_toolbar_table_click)
+
+        # set font size of table (default seems to be 13 point)
+        fnt = self.font()
+        fnt.setPointSize(self._rowHeight)
+        self.myTableWidget.setFont(fnt)
+
+        headerLabels = [headerStr]
+        self.myTableWidget.setHorizontalHeaderLabels(headerLabels)
+
+        header = self.myTableWidget.horizontalHeader()
+        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
+        # QHeaderView will automatically resize the section to fill the available space. The size cannot be changed by the user or programmatically.
+        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
+
+        for idx, stat in enumerate(self.statList):
+            item = QtWidgets.QTableWidgetItem(stat)
+            self.myTableWidget.setItem(idx, 0, item)
+            self.myTableWidget.setRowHeight(idx, self._rowHeight)
+
+        # assuming dark theme
+        # does not work
+        '''
+        p = self.myTableWidget.palette()
+        color1 = QtGui.QColor('#222222')
+        color2 = QtGui.QColor('#555555')
+        p.setColor(QtGui.QPalette.Base, color1)
+        p.setColor(QtGui.QPalette.AlternateBase, color2)
+        self.myTableWidget.setPalette(p)
+        self.myTableWidget.setAlternatingRowColors(True)
+        '''
+        self.myQVBoxLayout.addWidget(self.myTableWidget)
+
+        # select a default stat
+        self.myTableWidget.selectRow(0) # hard coding 'Spike Frequency (Hz)'
+
+    def getCurrentRow(self):
+        return self.myTableWidget.currentRow()
+
+    def getCurrentStat(self):
+        # assuming single selection
+        row = self.getCurrentRow()
+        humanStat = self.myTableWidget.item(row,0).text()
 
-    #
-    # if we were recorded with a stimulus file abf
-    # needed to assign stimulusWaveformFromFile
-    # tmpSweepC = ba.abf.sweepC
+        # convert from human readbale to backend
+        try:
+            stat = self.statList[humanStat]['name']
+        except (KeyError) as e:
+            logger.error(f'Did not find humanStat "{humanStat}" exception:{e}')
+            humanStat = None
+            stat = None
+            #for k,v in
 
-    from pprint import pprint
+        return humanStat, stat
 
-    masterDf = pd.DataFrame()
-    saveFolder = "/Users/cudmore/Desktop/stoch-plots"
+    @QtCore.pyqtSlot()
+    def on_scatter_toolbar_table_click(self):
+        """
+        replot the stat based on selected row
+        """
+        #print('*** on table click ***')
+        row = self.myTableWidget.currentRow()
+        if row == -1 or row is None:
+            return
+        #yStat = self.myTableWidget.item(row,0).text()
+        self.myParent.replot()
 
-    folderPath = (
-        "/Users/cudmore/Library/CloudStorage/Box-Box/data/stoch-res/new20220104"
-    )
+    '''
+    @QtCore.pyqtSlot()
+    def on_button_click(self, name):
+        print('=== myStatPlotToolbarWidget.on_button_click() name:', name)
+    '''
 
-    from sanpy.bAnalysisStim import bAnalysisStim
+class Highlighter(object):
+    """
+    See: https://stackoverflow.com/questions/31919765/choosing-a-box-of-data-points-from-a-plot
+    """
+    def __init__(self, parentPlot, ax, x, y):
+        self._parentPlot = parentPlot
+        self.ax = ax
+        self.canvas = ax.figure.canvas
+        
+        self.setData(x, y)
+        # self.x = x
+        # self.y = y
+
+        # mask will be set in self.setData
+        if x and y:
+            self.mask = np.zeros(x.shape, dtype=bool)
+        else:
+            self.mask = None
 
-    for file in sorted(os.listdir(folderPath)):
-        if not file.endswith(".abf"):
-            continue
+        markerSize = 50
+        self._highlight = ax.scatter([], [], s=markerSize, color='yellow', zorder=10)
 
-        fullPath = os.path.join(folderPath, file)
+        # here self is setting the callback and calls __call__
+        #self.selector = RectangleSelector(ax, self, useblit=True, interactive=False)
+        self.selector = RectangleSelector(ax, self._HighlighterReleasedEvent,
+                                            button=[1],
+                                            useblit=True, interactive=False)
+
+        self.mouseDownEvent = None
+        self.keyIsDown = None
+
+        self.ax.figure.canvas.mpl_connect('key_press_event', self._keyPressEvent)
+        self.ax.figure.canvas.mpl_connect('key_release_event', self._keyReleaseEvent)
+
+        # remember, sanpyPlugin is installing for key press and on pick
+        self.keepOnMotion = self.ax.figure.canvas.mpl_connect('motion_notify_event', self.on_mouse_move)
+        self.keepMouseDown = self.ax.figure.canvas.mpl_connect('button_press_event', self.on_button_press)
+        self._keepMouseDown = self.ax.figure.canvas.mpl_connect('button_release_event', self.on_button_release)
+
+    def _keyPressEvent(self, event):
+        #logger.info(event)
+        self.keyIsDown = event.key
+
+    def _keyReleaseEvent(self, event):
+        #logger.info(event)
+        self.keyIsDown = None
+
+    def on_button_release(self, event):
+        logger.info(event)
+
+        # don't take action on right-click
+        if event.button != 1:
+            # not the left button
+            #print('  rejecting not button 1')
+            return
 
-        ba = bAnalysisStim(
-            fullPath
-        )  # bAnalysis that loads my stim abf (with header from stimgen)
-        # ba = sanpy.bAnalysis(fullPath)
+        self.mouseDownEvent = None
 
-        if ba.numSweeps < 2:
-            print("!!! skipping file:", file)
-            continue
+    def on_button_press(self, event):
+        """
+        Args:
+            event (matplotlib.backend_bases.MouseEvent):
+        """
+        logger.info(event)
 
-        print(ba)
+        # don't take action on right-click
+        if event.button != 1:
+            # not the left button
+            #print('  rejecting not button 1')
+            return
 
-        dfStimFile = ba._stimFileDf
-        pprint(dfStimFile)
+        # do nothing in zoom or pan/zoom is active
+        # finding documentation on mpl toolbar is near impossible
+        # https://stackoverflow.com/questions/20711148/ignore-matplotlib-cursor-widget-when-toolbar-widget-selected
+        #state = self._parentPlot.static_canvas.manager.toolbar.mode  # manager is coming up None
+        if self._parentPlot.toolbarHasSelection():
+            return
+        # was this
+        #state = self._parentPlot.mplToolbar.mode
+        #if state in ['zoom rect', 'pan/zoom']:
+        #    logger.info(f'Ignoring because tool "{state}" is active')
+        #    return
+
+        self.mouseDownEvent = event
+
+        # if shift is down then add to mask
+        #print('  self.keyIsDown', self.keyIsDown)
+        if self.keyIsDown == 'shift':
+            pass
+        else:
+            self.mask = np.zeros(self.x.shape, dtype=bool)
 
-        sweep = 0
-        fftRecording = fftFromRecording(
-            ba=ba, sweepNumber=sweep, startSec=5, stopSec=25, doPlot=False
-        )
+    def on_mouse_move(self, event):
+        """When mouse is down, respond to movement and select points.
 
-        fftRecording.medianFilterPnts = 5
+        Args:
+            event (<class 'matplotlib.backend_bases.MouseEvent'>):
 
-        for sweep in range(ba.numSweeps):
-            print(f"{sweep} {ba}")
-            fftRecording.replot_fft2(sweepNumber=sweep)
-            fftRecording.saveFig(folderPath=saveFolder)
+        event contains:
+            motion_notify_event: xy=(113, 36)
+            xydata=(None, None)
+            button=None
+            dblclick=False
+            inaxes=None
+        """
 
-        # resultsDictList = fftRecording.getResultsDictList()
-        resultsDictList = fftRecording._resultsDictList2
-        df = pd.DataFrame(resultsDictList)
+        # self.ax is our main scatter plot axes
+        if event.inaxes != self.ax:
+            return
 
-        # add stim params to each sweep
-        df["stimFreq"] = dfStimFile["freq(Hz)"]
-        df["noiseAmp"] = dfStimFile["noise amp"]
+        # mouse is not down
+        if self.mouseDownEvent is None:
+            return
 
-        masterDf = pd.concat([masterDf, df], ignore_index=True)
+        #logger.info('')
 
-    #
-    pprint(masterDf)
+        event1 = self.mouseDownEvent
+        event2 = event
 
-    summaryFile = os.path.join(saveFolder, "stoch-summary.csv")
-    print("saving:", summaryFile)
-    masterDf.to_csv(summaryFile)
+        if event1 is None or event2 is None:
+            return
+
+        self.mask |= self.inside(event1, event2)
+        xy = np.column_stack([self.x[self.mask], self.y[self.mask]])
+        self._highlight.set_offsets(xy)
+        self.canvas.draw()
+
+    def setData(self, x, y):
+        """Set underlying highlighter data, call this when we replot() scatter
+        """
+        # convert list to np array
+        xArray = np.array(x)
+        yArray = np.array(y)
+
+        self.mask = np.zeros(xArray.shape, dtype=bool)
+        self.x = xArray
+        self.y = yArray
+
+    #def __call__(self, event1, event2):
+    def _HighlighterReleasedEvent(self, event1, event2):
+        """Callback when mouse is released
+
+        event1:
+            button_press_event: xy=(87.0, 136.99999999999991) xydata=(27.912559411227885, 538.8555851528383) button=1 dblclick=False inaxes=AxesSubplot(0.1,0.1;0.607046x0.607046)
+        event2:
+            button_release_event: xy=(131.0, 211.99999999999991) xydata=(48.83371692821588, 657.6677439956331) button=1 dblclick=False inaxes=AxesSubplot(0.1,0.1;0.607046x0.607046)
+        """
+
+        # logger.info(event1)
+        # logger.info(event2)
 
-    # plt.show()
+        self.mouseDownEvent = None
 
+        # emit the selected spikes
+        selectedSpikes = np.where(self.mask==True)
+        selectedSpikes = selectedSpikes[0]  # why does np do this ???
+
+        #logger.info(f'Num Spikes Select:{len(selectedSpikes)}')
+
+        selectedSpikesList = selectedSpikes.tolist()
+        self._parentPlot.selectSpikesFromHighlighter(selectedSpikesList)
+
+        # clear the selection user just made, will get 'reselected' in signal/slot
+        self._highlight.set_offsets([np.nan, np.nan])
+
+        return
+
+    def inside(self, event1, event2):
+        """Returns a boolean mask of the points inside the
+        rectangle defined by event1 and event2."""
+        # Note: Could use points_inside_poly, as well
+        x0, x1 = sorted([event1.xdata, event2.xdata])
+        y0, y1 = sorted([event1.ydata, event2.ydata])
+        mask = ((self.x > x0) & (self.x < x1) &
+                (self.y > y0) & (self.y < y1))
+        return mask
+
+def run():
+    path = '/Users/cudmore/Sites/SanPy/data/19114001.abf'
+    ba = sanpy.bAnalysis(path)
+    ba.spikeDetect()
+    print(ba)
+
+    import sys
+    app = QtWidgets.QApplication([])
+    sp = plotScatter(ba=ba)
+    sp.show()
+    sys.exit(app.exec_())
 
-if __name__ == "__main__":
-    run()
+if __name__ == '__main__':
+    run()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/epochTable.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/epochTable.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,140 +2,140 @@
 from pprint import pprint
 
 import pandas as pd
 
 import pyabf
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-class epochTable:
+class epochTable():
     """Load epoch/stimulation from abf file using 'sweepEpochs'.
 
     Values in epoch table are per sweep!
     """
-
-    def __init__(self, abf: pyabf.ABF):
+    def __init__(self, abf : pyabf.ABF):
+        
         self._epochList = []
 
         dataPointsPerMs = abf.dataPointsPerMs
         """To convert point to seconds"""
 
         try:
             _tmp = abf.sweepEpochs.p1s
-        except AttributeError as e:
+        except (AttributeError) as e:
             logger.error(e)
             return
 
         # sweepEpochs is type "pyabf.waveform.EpochSweepWaveform"
         for epochIdx, p1 in enumerate(abf.sweepEpochs.p1s):
             p2 = abf.sweepEpochs.p2s[epochIdx]  # stop point of each pulse
             epochLevel = abf.sweepEpochs.levels[epochIdx]
             epochType = abf.sweepEpochs.types[epochIdx]
             pulseWidth = abf.sweepEpochs.pulseWidths[epochIdx]
             pulsePeriod = abf.sweepEpochs.pulsePeriods[epochIdx]
             digitalState = abf.sweepEpochs.pulsePeriods[epochIdx]
             ##print(f"epoch index {epochIdx}: at point {p1} there is a {epochType} to level {epochLevel}")
-
+            
             p1_sec = p1 / abf.dataPointsPerMs / 1000
             p2_sec = p2 / abf.dataPointsPerMs / 1000
 
             epochDict = {
-                "sweepNumber": abf.sweepNumber,
-                "index": epochIdx,
-                "type": epochType,
-                "startPoint": p1,  # point the epoch starts
-                "stopPoint": p2,  # point the epoch ends
-                "startSec": p1_sec,
-                "stopSec": p2_sec,
-                "durSec": p2_sec - p1_sec,
-                "level": epochLevel,
-                "pulseWidth": pulseWidth,
-                "pulsePeriod": pulsePeriod,
-                "digitalState": digitalState,  # list of 0/1 for 8x digital states
+                'sweepNumber': abf.sweepNumber,
+                'index': epochIdx,
+                'type': epochType,
+                'startPoint': p1,  # point the epoch starts
+                'stopPoint': p2,  # point the epoch ends
+                'startSec': p1_sec,
+                'stopSec': p2_sec,
+                'durSec': p2_sec - p1_sec,
+                'level': epochLevel,
+                'pulseWidth': pulseWidth,
+                'pulsePeriod': pulsePeriod,
+                'digitalState': digitalState,  # list of 0/1 for 8x digital states
             }
             self._epochList.append(epochDict)
 
-    def getEpochList(self, asDataFrame: bool = False):
+    def getEpochList(self, asDataFrame : bool = False):
         if asDataFrame:
             return pd.DataFrame(self._epochList)
         else:
             return self._epochList
-
-    def findEpoch(self, pnt: int) -> Optional[int]:
+    
+    def findEpoch(self, pnt : int) -> Optional[int]:
         """Return epoch index for a point in recording.
 
         Stop points are always the same as next epoch start point.
         Be sure to use '<' like pnt<stopPnt to get epoch index correct.
 
         If not found, return None
 
         Parameters
         ----------
         pnt : int
             Point index into recording (within a sweep)
         """
         for epochIdx, epoch in enumerate(self._epochList):
-            startPoint = epoch["startPoint"]
-            stopPoint = epoch["stopPoint"]
+            startPoint = epoch['startPoint']
+            stopPoint = epoch['stopPoint']
             if pnt >= startPoint and pnt < stopPoint:
                 return epochIdx
         #
         # return None
 
     def getLevel(self, epoch):
-        """Given an epoch number return the 'level'"""
-        return self._epochList[epoch]["level"]
+        """Given an epoch number return the 'level'
+        """
+        return self._epochList[epoch]['level']
 
     def getStartSec(self, epoch):
-        """Given an epoch number return the 'startSec'"""
-        return self._epochList[epoch]["startSec"]
+        """Given an epoch number return the 'startSec'
+        """
+        return self._epochList[epoch]['startSec']
 
     def getStartSecs(self):
-        """Return all epoch start times."""
-        startSecs = [epoch["startSec"] for epoch in self._epochList]
+        """Return all epoch start times.
+        """
+        startSecs = [epoch['startSec'] for epoch in self._epochList]
         return startSecs
 
     def getEpochLines(self, yMin=0, yMax=1):
-        x = [float("nan")] * (self.numEpochs() * 3)
-        y = [float("nan")] * (self.numEpochs() * 3)
-
+        x = [float('nan')] * (self.numEpochs() * 3)
+        y = [float('nan')] * (self.numEpochs() * 3)
+        
         for epoch in range(self.numEpochs()):
             idx = epoch * 3
-            x[idx] = self._epochList[epoch]["startSec"]
-            x[idx + 1] = self._epochList[epoch]["startSec"]
-            x[idx + 2] = float("nan")
+            x[idx] = self._epochList[epoch]['startSec']
+            x[idx+1] = self._epochList[epoch]['startSec']
+            x[idx+2] = float('nan')
 
             y[idx] = yMin
-            y[idx + 1] = yMax
-            y[idx + 2] = float("nan")
+            y[idx+1] = yMax
+            y[idx+2] = float('nan')
 
         return x, y
 
     def numEpochs(self):
-        # print('qqq:', self._epochList)
+        #print('qqq:', self._epochList)
         return len(self._epochList)
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     import sanpy
 
-    # path = '/Users/cudmore/Sites/SanPy/data/19114000.abf'
-    path = "/Users/cudmore/data/theanne-griffith/07.28.21/2021_07_28_0001.abf"
+    #path = '/Users/cudmore/Sites/SanPy/data/19114000.abf'
+    path = '/Users/cudmore/data/theanne-griffith/07.28.21/2021_07_28_0001.abf'
 
     ba = sanpy.bAnalysis(path)
     print(ba)
 
     sweep = 13
 
     et = ba.getEpochTable(sweep)
     df = et.getEpochList(asDataFrame=True)
     pprint(df)
 
     testPnt = 1280
     epochIndex = et.findEpoch(testPnt)
-    print(f"testPnt:{testPnt} is in epoch index: {epochIndex}")
+    print(f'testPnt:{testPnt} is in epoch index: {epochIndex}')
 
-    print("getStartSecs:", et.getStartSecs())
-    print("getEpochLines:", et.getEpochLines())
+    print('getStartSecs:', et.getStartSecs())
+    print('getEpochLines:', et.getEpochLines())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_abf.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_abf.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,150 +2,130 @@
 import numpy as np
 import pyabf
 
 import sanpy
 from sanpy.fileloaders.fileLoader_base import fileLoader_base, recordingModes
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class fileLoader_abf(fileLoader_base):
-    loadFileType = "abf"
-
+    loadFileType = 'abf'
+    
     # @property
     # def loadFileType(self):
     #     return 'abf'
 
     def loadFile(self):
         self._loadAbf()
 
-    def _loadAbf(
-        self, byteStream=None, loadData: bool = True, stimulusFileFolder: str = None
-    ):
+    def _loadAbf(self, byteStream =  None, loadData : bool = True, stimulusFileFolder : str = None):
         """Load pyAbf from path."""
         try:
-            # logger.info(f'loadData:{loadData}')
+            #logger.info(f'loadData:{loadData}')
             if byteStream is not None:
-                logger.info("Loading byte stream")
+                logger.info('Loading byte stream')
                 self._abf = pyabf.ABF(byteStream)
                 self._isBytesIO = True
             else:
-                # logger.info(f'Loading file: {self.filepath}')
-                self._abf = pyabf.ABF(
-                    self.filepath,
-                    loadData=loadData,
-                    stimulusFileFolder=stimulusFileFolder,
-                )
-
-        except NotImplementedError as e:
-            logger.error(f"    did not load abf file: {self.filepath}")
-            logger.error(f"      NotImplementedError exception was: {e}")
+                #logger.info(f'Loading file: {self.filepath}')
+                self._abf = pyabf.ABF(self.filepath, loadData=loadData, stimulusFileFolder=stimulusFileFolder)
+
+        except (NotImplementedError) as e:
+            logger.error(f'    did not load abf file: {self.filepath}')
+            logger.error(f'      NotImplementedError exception was: {e}')
             self._loadError = True
             self._abf = None
 
-        except Exception as e:
+        except (Exception) as e:
             # some abf files throw: 'unpack requires a buffer of 234 bytes'
             # 'ABF' object has no attribute 'sweepEpochs'
-            logger.error(f"    did not load abf file: {self.filepath}")
-            logger.error(f"        unknown Exception was: {e}")
+            logger.error(f'    did not load abf file: {self.filepath}')
+            logger.error(f'        unknown Exception was: {e}')
             self._loadError = True
             self._abf = None
 
         if loadData:
             try:
                 _tmp = self._abf.sweepEpochs.p1s
-            except AttributeError as e:
-                logger.warning(
-                    f"    did not find epochTable loadData:{loadData}: {e} in file {self.filepath}"
-                )
+            except (AttributeError) as e:
+                logger.warning(f'    did not find epochTable loadData:{loadData}: {e} in file {self.filepath}')
             else:
                 _numSweeps = len(self._abf.sweepList)
                 self._epochTableList = [None] * _numSweeps
                 for _sweepIdx in range(_numSweeps):
                     self._abf.setSweep(_sweepIdx)
-                    self._epochTableList[_sweepIdx] = sanpy.fileloaders.epochTable(
-                        self._abf
-                    )
+                    self._epochTableList[_sweepIdx] = sanpy.fileloaders.epochTable(self._abf)
                 self._abf.setSweep(0)
 
             self._sweepList = self._abf.sweepList
-            self._sweepLengthSec = (
-                self._abf.sweepLengthSec
-            )  # assuming all sweeps have the same duration
+            self._sweepLengthSec = self._abf.sweepLengthSec  # assuming all sweeps have the same duration
 
             # on load, sweep is 0
             if loadData:
                 _numRows = self._abf.sweepX.shape[0]
                 numSweeps = len(self._sweepList)
-                self._sweepX = np.zeros((_numRows, 1))
-                self._sweepY = np.zeros((_numRows, numSweeps))
-                self._sweepC = np.zeros((_numRows, numSweeps))
+                self._sweepX = np.zeros((_numRows,1))
+                self._sweepY = np.zeros((_numRows,numSweeps))
+                self._sweepC = np.zeros((_numRows,numSweeps))
 
                 _channel = 0
                 for sweep in self._sweepList:
                     self._abf.setSweep(sweepNumber=sweep, channel=_channel)
                     if sweep == 0:
-                        self._sweepX[
-                            :, sweep
-                        ] = self._abf.sweepX  # <class 'numpy.ndarray'>, (60000,)
+                        self._sweepX[:, sweep] = self._abf.sweepX  # <class 'numpy.ndarray'>, (60000,)
                     self._sweepY[:, sweep] = self._abf.sweepY
                     try:
                         self._sweepC[:, sweep] = self._abf.sweepC
-                    except ValueError as e:
+                    except(ValueError) as e:
                         # pyabf will raise this error if it is an atf file
-                        logger.warning(
-                            f"    exception fetching sweepC for sweep {sweep} with {self.numSweeps}: {e}"
-                        )
+                        logger.warning(f'    exception fetching sweepC for sweep {sweep} with {self.numSweeps}: {e}')
                         #
                         # if we were recorded with a stimulus file abf
                         # needed to assign stimulusWaveformFromFile
                         try:
                             tmpSweepC = self._abf.sweepC
                             self._sweepC[:, sweep] = self._abf.sweepC
-                        except ValueError as e:
-                            logger.warning(f"ba has no sweep {sweep} sweepC ???")
+                        except (ValueError) as e:
+                            logger.warning(f'ba has no sweep {sweep} sweepC ???')
 
                 # not needed
                 self._abf.setSweep(0)
 
             # get v from pyAbf
             self._dataPointsPerMs = self._abf.dataPointsPerMs
 
             # turned back on when implementing Santana rabbit Ca kymographs
             abfDateTime = self._abf.abfDateTime  # 2019-01-14 15:20:48.196000
             self._acqDate = abfDateTime.strftime("%Y-%m-%d")
             self._acqTime = abfDateTime.strftime("%H:%M:%S")
 
             self._numChannels = len(self._abf.adcUnits)
             if self._numChannels > 1:
-                logger.warning(
-                    f"    SanPy does not work with multi-channel recordings numChannels is {self._numChannels} {self._path}"
-                )
+                logger.warning(f'    SanPy does not work with multi-channel recordings numChannels is {self._numChannels} {self._path}')
                 # logger.warning('    Will default to channel 0')
 
-            # self.sweepUnitsY = self.adcUnits[channel]
+            #self.sweepUnitsY = self.adcUnits[channel]
             channel = 0
-            # dacUnits = self._abf.dacUnits[channel]
+            #dacUnits = self._abf.dacUnits[channel]
             adcUnits = self._abf.adcUnits[channel]
-            # print('  adcUnits:', adcUnits)  # 'mV'
+            #print('  adcUnits:', adcUnits)  # 'mV'
             self._sweepLabelY = adcUnits
             self._sweepLabelX = "sec"
 
-            # self._sweepLabelX = self._abf.sweepLabelX
-            # self._sweepLabelY = self._abf.sweepLabelY
-            if self._sweepLabelY in ["pA", "nA"]:
+            #self._sweepLabelX = self._abf.sweepLabelX
+            #self._sweepLabelY = self._abf.sweepLabelY
+            if self._sweepLabelY in ['pA', 'nA']:
                 self._recordingMode = recordingModes.vclamp  # 'V-Clamp'
-                # self._sweepY_label = self._abf.sweepUnitsY
-            elif self._sweepLabelY in ["mV"]:
+                #self._sweepY_label = self._abf.sweepUnitsY
+            elif self._sweepLabelY in ['mV']:
                 self._recordingMode = recordingModes.iclamp  #'I-Clamp'
-                # self._sweepY_label = self._abf.sweepUnitsY
+                #self._sweepY_label = self._abf.sweepUnitsY
             else:
                 logger.warning(f'did not understand adcUnit "{adcUnits}"')
 
         #
-        self.myFileType = "abf"
+        self.myFileType = 'abf'
 
         # base sanpy does not keep the abf around
-        # logger.warning('[[[TURNED BACK ON]]] I turned off assigning self._abf=None for stoch-res stim file load')
+        #logger.warning('[[[TURNED BACK ON]]] I turned off assigning self._abf=None for stoch-res stim file load')
         self._abf = None
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_atf.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_atf.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,84 +1,80 @@
 import numpy as np
 
 import pyabf
 
 from sanpy.fileloaders.fileLoader_base import fileLoader_base, recordingModes
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class fileLoader_atf(fileLoader_base):
-    loadFileType = "atf"
-
+    loadFileType = 'atf'
+    
     def __init__(self, path):
         super().__init__(path)
         self._loadAtf()
 
     def _loadAtf(self, loadData):
         # We cant't get dataPointsPerMs without loading the data
         loadData = True
 
         self._abf = pyabf.ATF(self.filepath)  # , loadData=loadData)
-        print("  self._abf:", self._abf.sweepList)
-        # try:
+        print('  self._abf:', self._abf.sweepList)
+        #try:
         if 1:
             self._sweepList = self._abf.sweepList
             self._sweepLengthSec = self._abf.sweepLengthSec
             if loadData:
                 tmpRows = self._abf.sweepX.shape[0]
                 numSweeps = len(self._sweepList)
-                self._sweepX = np.zeros((tmpRows, numSweeps))
-                self._sweepY = np.zeros((tmpRows, numSweeps))
-                self._sweepC = np.zeros((tmpRows, numSweeps))
+                self._sweepX = np.zeros((tmpRows,numSweeps))
+                self._sweepY = np.zeros((tmpRows,numSweeps))
+                self._sweepC = np.zeros((tmpRows,numSweeps))
 
                 for sweep in self._sweepList:
                     self._abf.setSweep(sweep)
-                    self._sweepX[
-                        :, sweep
-                    ] = self._abf.sweepX  # <class 'numpy.ndarray'>, (60000,)
+                    self._sweepX[:, sweep] = self._abf.sweepX  # <class 'numpy.ndarray'>, (60000,)
                     self._sweepY[:, sweep] = self._abf.sweepY
-                    # self._sweepC[:, sweep] = self._abf.sweepC
+                    #self._sweepC[:, sweep] = self._abf.sweepC
                 # not needed
                 self._abf.setSweep(0)
 
-            logger.info(f"Loaded abf self._sweepX: {self._sweepX.shape}")
+            logger.info(f'Loaded abf self._sweepX: {self._sweepX.shape}')
             # get v from pyAbf
             if len(self.sweepX.shape) > 1:
                 t0 = self.sweepX[0][0]
                 t1 = self.sweepX[1][0]
             else:
                 t0 = self.sweepX[0]
                 t1 = self.sweepX[1]
-            dt = (t1 - t0) * 1000
+            dt = (t1-t0) * 1000
             dataPointsPerMs = 1 / dt
             dataPointsPerMs = round(dataPointsPerMs)
             self._dataPointsPerMs = dataPointsPerMs
 
-            """
+            '''
             channel = 0
             adcUnits = self._abf.adcUnits[channel]
             self._sweepLabelY = adcUnits
             self._sweepLabelX = "sec'"
-            """
-            self._sweepLabelY = "mV"
+            '''
+            self._sweepLabelY = 'mV'
             self._sweepLabelX = "sec'"
 
-            if self._sweepLabelY in ["pA"]:
+            if self._sweepLabelY in ['pA']:
                 self._recordingMode = recordingModes.vclamp  # 'V-Clamp'
-            elif self._sweepLabelY in ["mV"]:
+            elif self._sweepLabelY in ['mV']:
                 self._recordingMode = recordingModes.iclamp  #'I-Clamp'
 
-        """
+        '''
         except (Exception) as e:
             # some abf files throw: 'unpack requires a buffer of 234 bytes'
             logger.error(f'did not load ATF file: {self._path}')
             logger.error(f'  unknown Exception was: {e}')
             self.loadError = True
             self._abf = None
-        """
+        '''
 
-        self.myFileType = "atf"
+        self.myFileType = 'atf'
 
         # don't keep _abf, we grabbed every thing we needed
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_base.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_base.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,267 +8,257 @@
 
 import numpy as np
 import scipy.signal
 
 import sanpy.fileloaders
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-def getFileLoaders(verbose: bool = False) -> dict:
+def getFileLoaders(verbose : bool = False) -> dict:
     """Load file loaders from both
-
+        
     1) Module sanpy.fileloaders
-
+        
     2) Folder <user>/Documents/SanPy/File Loaders
-
+    
     Each file loader is a class derived from [fileLoader_base](../../api/fileloader/fileLoader_base.md)
 
     See: sanpy.interface.bPlugins.loadPlugins()
 
     Returns
     -------
     dict
         A dictionary of file loaders.
     """
     retDict = {}
 
-    ignoreModuleList = ["fileLoader_base", "recordingModes"]
+    ignoreModuleList = ['fileLoader_base', 'recordingModes']
 
     #
     # system file loaders from sanpy.fileloaders
     loadedList = []
     for moduleName, obj in inspect.getmembers(sanpy.fileloaders):
         if inspect.isclass(obj):
             if verbose:
-                logger.info(f"moduleName:{moduleName}")
+                logger.info(f'moduleName:{moduleName}')
             if moduleName in ignoreModuleList:
                 continue
             loadedList.append(moduleName)
-            fullModuleName = "sanpy.fileloaders." + moduleName
+            fullModuleName = 'sanpy.fileloaders.' + moduleName
             # filetype is a static str, e.g. the extension to load
             try:
                 filetype = obj.loadFileType
-            except AttributeError as e:
+            except(AttributeError) as e:
                 logger.warning(f'Did not load "{moduleName}", no "filetype" attribute')
                 continue
             oneLoaderDict = {
-                "fileLoaderClass": moduleName,
-                "type": "system",
-                "module": fullModuleName,
-                "path": "",
-                "constructor": obj,
+                'fileLoaderClass': moduleName,
+                'type': 'system',
+                'module': fullModuleName,
+                'path': '',
+                'constructor': obj,
                 #'filetype': filetype
             }
             if filetype in retDict.keys():
-                logger.warning(
-                    f'loader already added "{moduleName}" filetype:"{filetype}"'
-                )
-                logger.warning(f"  this loader will overwrite the previous loader.")
+                logger.warning(f'loader already added "{moduleName}" filetype:"{filetype}"')
+                logger.warning(f'  this loader will overwrite the previous loader.')
             retDict[filetype] = oneLoaderDict
 
     # logger.info(f'Loaded system file loaders:')
     # for k,v in retDict.keys():
     #     logger.info(f'    {k}:{v}')
     # # sort
     # retDict = dict(sorted(retDict.items()))
 
     #
     # user plugins from files in folder "<user>/SanPy/file loaders"
     fileLoaderFolder = sanpy._util._getUserFileLoaderFolder()
     loadedModuleList = []
     if os.path.isdir(fileLoaderFolder):
-        files = glob.glob(os.path.join(fileLoaderFolder, "*.py"))
+        files = glob.glob(os.path.join(fileLoaderFolder, '*.py'))
     else:
         # no user file loader folder ???
         files = []
-
+    
     for file in files:
-        if file.endswith("__init__.py"):
+        if file.endswith('__init__.py'):
             continue
 
         moduleName = os.path.split(file)[1]
         moduleName = os.path.splitext(moduleName)[0]
-        fullModuleName = "sanpy.fileloaders." + moduleName
+        fullModuleName = 'sanpy.fileloaders.' + moduleName
 
         loadedModule = sanpy._util._module_from_file(fullModuleName, file)
 
         try:
             oneConstructor = getattr(loadedModule, moduleName)
-        except AttributeError as e:
-            logger.error(
-                f'Did not load file loader, make sure file name and class name are the same:"{moduleName}"'
-            )
+        except (AttributeError) as e:
+            logger.error(f'Did not load file loader, make sure file name and class name are the same:"{moduleName}"')
         else:
             # filetype is a static str, e.g. the extension to load
             try:
                 filetype = oneConstructor.loadFileType
-            except AttributeError as e:
+            except(AttributeError) as e:
                 logger.warning(f'Did not load "{moduleName}", no "filetype" attribute')
                 continue
             oneLoaderDict = {
-                "fileLoaderClass": moduleName,
-                "type": "user",
-                "module": fullModuleName,
-                "path": file,
-                "constructor": oneConstructor,
+                'fileLoaderClass': moduleName,
+                'type': 'user',
+                'module': fullModuleName,
+                'path': file,
+                'constructor': oneConstructor,
                 #'filetype': filetype
-            }
+                }
             if filetype in retDict.keys():
-                logger.warning(
-                    f'loader already added "{moduleName}" handleExtension:"{filetype}"'
-                )
-                logger.warning(f"  this loader will overwrite the previous loader.")
+                logger.warning(f'loader already added "{moduleName}" handleExtension:"{filetype}"')
+                logger.warning(f'  this loader will overwrite the previous loader.')
             retDict[filetype] = oneLoaderDict
 
     if verbose:
-        logger.info(f"Loaded {len(retDict.keys())} file loaders:")
-        for k, v in retDict.items():
-            # logger.info(f'    {k}:{v}')
-            logger.info(f"  {k}")
+        logger.info(f'Loaded {len(retDict.keys())} file loaders:')
+        for k,v in retDict.items():
+            #logger.info(f'    {k}:{v}')
+            logger.info(f'  {k}')
             for k2, v2 in v.items():
-                logger.info(f"    {k2}: {v2}")
+                logger.info(f'    {k2}: {v2}')
 
     # sort
-    # retDict = dict(sorted(retDict.items()))
+    #retDict = dict(sorted(retDict.items()))
 
     return retDict
 
-
 class recordingModes(enum.Enum):
-    """Recording modes for I-Clamp, V-Clamp, and unknown."""
-
-    iclamp = "I-Clamp"
-    vclamp = "V-Clamp"
-    kymograph = "Kymograph"
-    unknown = "unknown"
-
+    """Recording modes for I-Clamp, V-Clamp, and unknown.
+    """
+    iclamp = 'I-Clamp'
+    vclamp = 'V-Clamp'
+    kymograph = 'Kymograph'
+    unknown = 'unknown'
 
 class fileLoader_base(ABC):
     """Abstract base class to derive file loaders.
 
     For some working examples of derived classes, see
     [fileLoader_abf](../../api/fileloader/fileLoader_abf.md) and
     [fileLoader_csv](../../api/fileloader/fileLoader_csv.md)
 
     To create a file loader
-
+    
     1) derive a class from fileLoader_base and define `loadFileType`
-
+        
         class myFileLoader(fileLoader_base):
             loadFileType = 'the_file_extension_this_will_load'
 
     2) Define a `loadFile` function
-
+    
         def loadFile(self):
             # load the data from self.filepath and create sweepX and sweepY
             # specify what was loaded
             self.setLoadedData(sweepX, sweepY)
-
-    """
-
-    loadFileType: str = ""
+    
+    """    
+    loadFileType : str = ''
     # @property
     # @abstractmethod
     # def loadFileType(self) -> str:
     #     """Derived classes must return the file type to handle.
     #     For example, 'csv', or 'm', or 'dat'
     #     """
     #     pass
 
     @abstractmethod
     def loadFile(self):
-        """Derived classes must load the data and call setLoadedData(sweepX, sweepY)."""
+        """Derived classes must load the data and call setLoadedData(sweepX, sweepY).
+        """
         pass
 
-    def __init__(self, filepath: str, loadData: bool = True):
+    def __init__(self, filepath : str, loadData : bool = True):
         """Base class to derive new file loaders.
-
+        
         Parameters
         ----------
         filepath : str
             File path to load. Will use different derived classes based on extension
         loadData : bool
             If True then load raw data, otherwise just load the header.
         """
-
+        
         super().__init__()
-
-        self._loadError = False
-
+        
         self._path = filepath
-
+        
         self._filteredY : np.ndarray = None  # set in _getDerivative
         self._filteredDeriv : np.ndarray = None
-        self._currentSweep: int = 0
+        self._currentSweep : int = 0
 
-        self._epochTableList: List[sanpy.fileloaders.epochTable] = None
+        self._epochTableList : List[sanpy.fileloaders.epochTable]  = None
 
         # load file from inherited class
         self.loadFile()
 
-        # check our work
-        self._checkLoadedData()
-
     def __str__(self):
-        """Get a short string representing this file."""
-        txt = f"file: {self.filename} sweeps: {self.numSweeps} dur (Sec):{self.recordingDur}"
+        """Get a short string representing this file.
+        """
+        txt = f'file: {self.filename} sweeps: {self.numSweeps} dur (Sec):{self.recordingDur}'
         return txt
 
     def isKymograph(self) -> bool:
         return isinstance(self, sanpy.fileloaders.fileLoader_tif)
-
+    
     @property
     def filepath(self) -> str:
-        """Get the full file path."""
+        """Get the full file path.
+        """
         return self._path
 
     @property
     def filename(self) -> str:
-        """Get the filename."""
+        """Get the filename.
+        """
         if self.filepath is None:
             return None
         else:
             return os.path.split(self.filepath)[1]
-
+        
     @property
     def numChannels(self) -> int:
         """Get the number of channels.
-
+        
         If more than one channel, must be defined in derived class.
         """
         return 1
 
     @property
     def currentSweep(self) -> int:
-        """Get the current sweep."""
+        """Get the current sweep.
+        """
         return self._currentSweep
-
-    def setSweep(self, currentSweep: int):
-        """Set the current sweep."""
+    
+    def setSweep(self, currentSweep : int):
+        """Set the current sweep.
+        """
         if currentSweep > self.numSweeps - 1:
-            logger.error(f"max sweep is {self.numSweeps-1}, got {currentSweep}")
+            logger.error(f'max sweep is {self.numSweeps-1}, got {currentSweep}')
             return
         self._currentSweep = currentSweep
 
     @property
     def recordingMode(self):
         return self._recordingMode
-
+        
     # feb 2023, uncommented
     @property
     def sweepLabelX(self):
         return self._sweepLabelX
-
+        
     @property
     def sweepLabelY(self):
         return self._sweepLabelY
-
+        
     @property
     def recordingDur(self):
         return self._sweepLengthSec
 
     @property
     def numSweeps(self):
         return len(self._sweepList)
@@ -288,55 +278,56 @@
     @property
     def acqTime(self):
         return self._acqTime
 
     @property
     def sweepX(self):
         """Get the X-Values for a sweep.
-
+        
         Notes
         -----
         All sweeps are assumed to have the same x-values (seconds).
         """
-        # return self._sweepX[:, self.currentSweep]
+        #return self._sweepX[:, self.currentSweep]
         return self._sweepX[:, 0]
 
     @property
     def sweepY(self):
-        """Get the Y values for the current sweep."""
+        """Get the Y values for the current sweep.
+        """
         return self._sweepY[:, self.currentSweep]
 
     @property
     def sweepC(self):
-        """Get the DAC command for the current sweep."""
+        """Get the DAC command for the current sweep.
+        """
         if self._sweepC is None:
-            # return np.zeros_like(self._sweepX[:, self.currentSweep])
+            #return np.zeros_like(self._sweepX[:, self.currentSweep])
             return np.zeros_like(self._sweepX[:, 0])
         return self._sweepC[:, self.currentSweep]
 
     def get_xUnits(self):
         return self._sweepLabelX
 
     def get_yUnits(self):
         return self._sweepLabelY
 
     @property
     def filteredDeriv(self) -> Optional[np.ndarray]:
-        """Get the filtered first derivative of sweepY."""
+        """Get the filtered first derivative of sweepY.
+        """
         if self._filteredDeriv is not None:
             return self._filteredDeriv[:, self.currentSweep]
         else:
             return None
 
-    def _getDerivative(
-        self,
-        medianFilter: int = 0,
-        SavitzkyGolay_pnts: int = 5,
-        SavitzkyGolay_poly: int = 2,
-    ):
+    def _getDerivative(self,
+                    medianFilter : int = 0,
+                    SavitzkyGolay_pnts : int = 5,
+                    SavitzkyGolay_poly : int = 2):
         """Get filtered version of recording and derivative of recording (used for I-Clamp).
 
             By default we will use a SavitzkyGolay filter with 5 points and a 2nd order polynomial.
 
         Parameters
         ----------
         medianFilter : int
@@ -348,129 +339,119 @@
         Notes
         -----
         Creates:
             self._filteredVm
             self._filteredDeriv
         """
 
-        # logger.info(f'{self.filename} medianFilter:{medianFilter} SavitzkyGolay_pnts:{SavitzkyGolay_pnts} SavitzkyGolay_poly:{SavitzkyGolay_poly}')
-
+        #logger.info(f'{self.filename} medianFilter:{medianFilter} SavitzkyGolay_pnts:{SavitzkyGolay_pnts} SavitzkyGolay_poly:{SavitzkyGolay_poly}')
+        
         if not isinstance(medianFilter, int):
-            logger.error(f"expecting int medianFilter, got: {medianFilter}")
+            logger.error(f'expecting int medianFilter, got: {medianFilter}')
 
         if medianFilter > 0:
             if not medianFilter % 2:
                 medianFilter += 1
-                logger.warning(
-                    "Please use an odd value for the median filter, set medianFilter: {medianFilter}"
-                )
+                logger.warning('Please use an odd value for the median filter, set medianFilter: {medianFilter}')
             medianFilter = int(medianFilter)
-            self._filteredY = scipy.signal.medfilt2d(self._sweepY, [medianFilter, 1])
+            self._filteredY = scipy.signal.medfilt2d(self._sweepY, [medianFilter,1])
         elif SavitzkyGolay_pnts > 0:
-            self._filteredY = scipy.signal.savgol_filter(
-                self._sweepY,
-                SavitzkyGolay_pnts,
-                SavitzkyGolay_poly,
-                axis=0,
-                mode="nearest",
-            )
+            self._filteredY = scipy.signal.savgol_filter(self._sweepY,
+                                SavitzkyGolay_pnts, SavitzkyGolay_poly,
+                                axis=0,
+                                mode='nearest')
         else:
             self._filteredY = self.sweepY
 
         self._filteredDeriv = np.diff(self._filteredY, axis=0)
 
         # filter the derivative
         if medianFilter > 0:
             if not medianFilter % 2:
                 medianFilter += 1
-                print(
-                    f"Please use an odd value for the median filter, set medianFilter: {medianFilter}"
-                )
+                print(f'Please use an odd value for the median filter, set medianFilter: {medianFilter}')
             medianFilter = int(medianFilter)
-            self._filteredDeriv = scipy.signal.medfilt2d(
-                self._filteredDeriv, [medianFilter, 1]
-            )
+            self._filteredDeriv = scipy.signal.medfilt2d(self._filteredDeriv, [medianFilter,1])
         elif SavitzkyGolay_pnts > 0:
-            self._filteredDeriv = scipy.signal.savgol_filter(
-                self._filteredDeriv,
-                SavitzkyGolay_pnts,
-                SavitzkyGolay_poly,
-                axis=0,
-                mode="nearest",
-            )
+            self._filteredDeriv = scipy.signal.savgol_filter(self._filteredDeriv,
+                                    SavitzkyGolay_pnts, SavitzkyGolay_poly,
+                                    axis = 0,
+                                    mode='nearest')
         else:
-            # self._filteredDeriv = self.filteredDeriv
+            #self._filteredDeriv = self.filteredDeriv
             pass
 
         # mV/ms
         dataPointsPerMs = self.dataPointsPerMs
-        self._filteredDeriv = self._filteredDeriv * dataPointsPerMs  # / 1000
+        self._filteredDeriv = self._filteredDeriv * dataPointsPerMs #/ 1000
 
         # insert an initial point (rw) so it is the same length as raw data in abf.sweepY
         # three options (concatenate, insert, vstack), could only get vstack working
         rowOfZeros = np.zeros(self.numSweeps)
 
         # logger.info(f' dataPointsPerMs:{dataPointsPerMs}')
         # logger.info(f' self.numSweeps:{self.numSweeps}')
         # logger.info(f' rowOfZeros:{rowOfZeros.shape}')
         # logger.info(f' 1 - _filteredDeriv:{self._filteredDeriv.shape}')
 
-        # rowZero = 0
+        #rowZero = 0
         self._filteredDeriv = np.vstack([rowOfZeros, self._filteredDeriv])
 
         # logger.info(f'  sweepX:{self.sweepX.shape}')
         # logger.info(f'  sweepY:{self.sweepY.shape}')
         # logger.info(f'  _filteredY:{self._filteredY.shape}')
         # logger.info(f'  2- _filteredDeriv:{self._filteredDeriv.shape}')
 
     @property
     def sweepY_filtered(self) -> np.ndarray:
-        """Get a filtered version of sweepY."""
+        """Get a filtered version of sweepY.
+        """
         if self._filteredY is not None:
             return self._filteredY[:, self.currentSweep]
 
     @property
     def recordingFrequency(self) -> int:
-        """Convenience for dataPointsPerMs, recording frequency in kHz."""
+        """Convenience for dataPointsPerMs, recording frequency in kHz.
+        """
         return self.dataPointsPerMs
 
-    def pnt2Sec_(self, pnt: int) -> float:
+    def pnt2Sec_(self, pnt : int) -> float:
         """Convert a point to seconds using dataPointsPerMs.
 
         Parameters
         ----------
         pnt : int
 
         Returns
         -------
         float
             The point in seconds (s)
         """
         if pnt is None:
-            # return math.isnan(pnt)
+            #return math.isnan(pnt)
             return math.nan
         else:
             return pnt / self.dataPointsPerMs / 1000
 
-    def pnt2Ms_(self, pnt: int) -> float:
+    def pnt2Ms_(self, pnt : int) -> float:
         """
         Convert a point to milliseconds (ms) using `self.dataPointsPerMs`
 
         Parameters
         ----------
         pnt : int
 
         Returns
         -------
         float
             The point in milliseconds (ms)
         """
         return pnt / self.dataPointsPerMs
 
-    def ms2Pnt_(self, ms: float) -> int:
+    def ms2Pnt_(self, ms : float) -> int:
         """
         Convert milliseconds (ms) to point in recording using `self.dataPointsPerMs`
 
         Parameters
         ----------
         ms : float
             The ms into the recording
@@ -480,50 +461,43 @@
         int
             The point in the recording corresponding to ms
         """
         theRet = ms * self.dataPointsPerMs
         theRet = round(theRet)
         return theRet
 
-    def getEpochTable(self, sweep: int):
+    def getEpochTable(self, sweep : int):
         """Only proper abf files will have an epoch table.
-
+        
         TODO: Make all file loders have an epoch table.
             Make API so derived file loaders can create their own
         """
         if self._epochTableList is not None:
             return self._epochTableList[sweep]
         else:
             return None
 
     @property
-    def numEpochs(self) -> Optional[int]:
+    def numEpochs(self):
         """Get the number of epochs.
-
+        
         Epochs are mostly for pClamp abf files. We are assuming each sweep has the same namber of epochs.
         """
         if self._epochTableList is not None:
             return self._epochTableList[0].numEpochs()
 
-    def _checkLoadedData(self):
-        # TODO: check all the member vraiables are correct
-        # set error if they are not
-        pass
-    
-    def setLoadedData(
-        self,
-        sweepX: np.ndarray,
-        sweepY: np.ndarray,
-        sweepC: Optional[np.ndarray] = None,
-        recordingMode: recordingModes = recordingModes.iclamp,
-        xLabel: str = "",
-        yLabel: str = "",
-    ):
+    def setLoadedData(self,
+            sweepX : np.ndarray,
+            sweepY : np.ndarray,
+            sweepC : Optional[np.ndarray] = None,
+            recordingMode : recordingModes = recordingModes.iclamp,
+            xLabel : str = '',
+            yLabel : str = ''):
         """Derived classes call this function once the data is loaded in loadFile().
-
+        
         Parameters
         ----------
         sweepX : np.ndarray
             Time values
         sweepY : np.ndarray
             Recording values, mV or pA
         sweepC : np.ndarray
@@ -541,27 +515,28 @@
         - Sweep Length (sec): sweepX[-1,0]
         - Data Points Per Millisecond: 1 / ((sweepX[1,0] - sweepX[0,0]) * 1000)
         """
         self._sweepX = sweepX
         self._sweepY = sweepY
         self._sweepC = sweepC
 
-        self._numSweeps: int = self._sweepY.shape[1]
-        self._sweepList: List[int] = list(range(self._numSweeps))
+        self._recordingMode : recordingModes = recordingMode
+        self._numSweeps : int = self._sweepY.shape[1]
+        self._sweepList : List[int] = list(range(self._numSweeps))
+        self._sweepLabelX : str = xLabel
+        self._sweepLabelY : str = yLabel
 
-        self._sweepLengthSec: float = self._sweepX[-1, 0]  # from 0 to last sample point
+        self._sweepLengthSec : float = self._sweepX[-1,0]  # from 0 to last sample point
 
-        dtSeconds = self._sweepX[1, 0] - self._sweepX[0, 0]  # seconds per sample
+        dtSeconds = self._sweepX[1,0] - self._sweepX[0,0]  # seconds per sample
         dtSeconds = float(dtSeconds)
         dtMilliseconds = dtSeconds * 1000
-        _dataPointsPerMs = int(1 / dtMilliseconds)
-        # logger.info(f'dtSeconds:{dtSeconds} dtMilliseconds:{dtMilliseconds} _dataPointsPerMs:{_dataPointsPerMs}')
-        self._dataPointsPerMs: int = _dataPointsPerMs
-
-        self._recordingMode: recordingModes = recordingMode
-        self._sweepLabelX: str = xLabel
-        self._sweepLabelY: str = yLabel
+        _dataPointsPerMs = int(1/dtMilliseconds)
+        #logger.info(f'dtSeconds:{dtSeconds} dtMilliseconds:{dtMilliseconds} _dataPointsPerMs:{_dataPointsPerMs}')
+        self._dataPointsPerMs : int = _dataPointsPerMs
+
+        # check our work
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     d = getFileLoaders()
     # for k,v in d.items():
-    #     print(k,v)
+    #     print(k,v)
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_csv.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_csv.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,84 +1,70 @@
 import numpy as np
 import pandas as pd
 
 from sanpy.fileloaders.fileLoader_base import fileLoader_base, recordingModes
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class fileLoader_csv(fileLoader_base):
-    loadFileType = "csv"
-
+    loadFileType = 'csv'
+    
     # @property
     # def loadFileType(self):
     #     return 'csv'
-
+    
     def loadFile(self):
         """Load file and call setLoadedData().
-
+        
         Use self.filepath for the file
-
+       
         Column 0 is seconds
         Column 1 is recording in ['mV', 'pA']
         """
         # load the csv file
-        try:
-            _df = pd.read_csv(self.filepath)
-        except (pd.errors.EmptyDataError):
-            self._loadError = True
-            return
-        
+        _df = pd.read_csv(self.filepath)
         _columns = _df.columns
         _numColumns = len(_columns)
         if _numColumns < 2:
-            logger.error(f"expecting 2 or more columns but got {_numColumns}")
-            self._loadError = True
-            return
+             logger.error(f'expecting 2 or more columns but got {_numColumns}')
 
         _numSamples = len(_df)
         _numSweeps = _numColumns - 1  # assuming no DAC columns
 
         # TODO: check that the columns we will read are float (not str or object)
-        #
+        #           
         # make sweepX (assuming all sweeps have the same sweepX)
-        sweepX = np.ndarray((_numSamples, 1))
+        sweepX = np.ndarray( (_numSamples,1))
         try:
-            sweepX[:, 0] = _df[_columns[0]].to_numpy()
-        except ValueError as e:
-            # raise ValueError
-            logger.error(f"ValueError assigning the first column")
-            self._loadError = True
-            return
-
+            sweepX[:,0] = _df[_columns[0]].to_numpy()
+        except (ValueError) as e:
+            raise ValueError
+        
         # make sweepY to hold (samples, sweeps) values, the values in each sweep are different
-        sweepY = np.ndarray((_numSamples, _numSweeps))
+        sweepY = np.ndarray( (_numSamples,_numSweeps))
         for sweep in range(_numSweeps):
             colIdx = sweep + 1
-            sweepY[:, sweep] = _df[_columns[colIdx]].to_numpy()
-
-        # sweepC = None  # not defined
+            sweepY[:,sweep] = _df[_columns[colIdx]].to_numpy()
+                
+        #sweepC = None  # not defined
 
         # determine recording mode from name of column 1
-        _tmpColName = _columns[1].replace("_0", "")
-        if _tmpColName in ["pA", "nA"]:
+        _tmpColName = _columns[1].replace('_0','')
+        if _tmpColName in ['pA', 'nA']:
             _recordingMode = recordingModes.vclamp
-        elif _tmpColName in ["mV", "mv"]:
+        elif _tmpColName in ['mV', 'mv']:
             _recordingMode = recordingModes.iclamp
         else:
-            logger.warning(
-                f"did not infer recording mode from column name {_tmpColName}"
-            )
+            logger.warning(f'did not infer recording mode from column name {_tmpColName}')
             _recordingMode = recordingModes.unknown
 
         xLabel = _columns[0]
-        yLabel = _tmpColName  # _columns[1]
-
+        yLabel = _tmpColName  #_columns[1]
+        
         self.setLoadedData(
-            sweepX=sweepX,
-            sweepY=sweepY,
-            # sweepC = sweepC,
-            xLabel=xLabel,
-            yLabel=yLabel,
-        )
+                sweepX = sweepX,
+                sweepY = sweepY,
+                #sweepC = sweepC,
+                xLabel = xLabel,
+                yLabel = yLabel,
+        )
```

### Comparing `sanpy-ephys-0.1.13/sanpy/fileloaders/fileLoader_tif.py` & `sanpy-ephys-0.1.6/sanpy/fileloaders/fileLoader_tif.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,45 +1,42 @@
 from typing import Union, Dict, List, Tuple
 import numpy as np
-
-# import pandas as pd
+#import pandas as pd
 
 import tifffile
 
 import sanpy
 from sanpy.fileloaders.fileLoader_base import fileLoader_base
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class fileLoader_tif(fileLoader_base):
-    loadFileType = "tif"
-
+    loadFileType = 'tif'
+    
     # @property
     # def loadFileType(self):
     #     return 'tif'
 
     def loadFile(self):
         # assuming pixels x line scan like (519, 10000)
         self._tif = tifffile.imread(self.filepath)
 
         dt = 0.001  # sec
 
         # using 'reshape(-1,1)' to convert shape from (n,) to (n,1)
-        sweepX = np.arange(0, self._tif.shape[1]).reshape(-1, 1)
-        sweepY = np.sum(self._tif, axis=0).reshape(-1, 1)
-
+        sweepX = np.arange(0, self._tif.shape[1]).reshape(-1,1)
+        sweepY = np.sum(self._tif, axis=0).reshape(-1,1)
+    
         self._dt = 1
         self._dy = 1
 
         self.setLoadedData(
-            sweepX=sweepX,
-            sweepY=sweepY,
+                sweepX = sweepX,
+                sweepY = sweepY,
         )
 
     #
     # need to pull/merge code from xxx
     # bAbfText._abfFromLineScanTif()
 
     def resetKymographRect(self):
@@ -63,7 +60,8 @@
         """
         Update the kymograph ROI
         """
         self._abf.updateTifRoi(theRect)
 
         self._sweepX[:, 0] = self._abf.sweepX
         self._sweepY[:, 0] = self._abf.sweepY
+
```

### Comparing `sanpy-ephys-0.1.13/sanpy/h5Util.py` & `sanpy-ephys-0.1.6/sanpy/h5Util.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,139 +2,137 @@
 import sys
 import time
 import pathlib
 import shutil
 
 import pandas as pd
 
-# april 5, removed (why did I remove???)
 import tables.scripts.ptrepack  # to save compressed .h5 file
 
+#import logging
+#logging.getLogger('numexpr').setLevel(logging.WARNING)
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 def listKeys(hdfPath, printData=False):
     """List all keys in h5 file."""
-    with pd.HDFStore(hdfPath, mode="r") as store:
-        logger.info(f'store: {store}')
+    with pd.HDFStore(hdfPath, mode='r') as store:
+        print(store)
         for key in store.keys():
-            print("    key:", key, "type:", type(store[key]))
+            print('    key:', key, 'type:', type(store[key]))
             if printData:
                 print(store[key])
 
-
 def _getTmpHdfFile(hdfPath):
     """Get temporary h5 file to write to.
-
+    
     We will always then compress with _rebuildHdf.
 
     Used in analysisDir to delete uuid from h5 file
     """
     if not os.path.isfile(hdfPath):
-        logger.error(f"File not found {hdfPath}")
+        logger.error(f'File not found {hdfPath}')
         return
 
-    logger.info("")
-
+    logger.info('')
+    
     _folder, _file = os.path.split(hdfPath)
-
-    tmpHdfFile = os.path.splitext(_file)[0] + "_tmp.h5"
+    
+    tmpHdfFile = os.path.splitext(_file)[0] + '_tmp.h5'
     tmpHdfPath = pathlib.Path(_folder) / tmpHdfFile
 
     # the compressed version from the last save
-    hdfFile = os.path.splitext(_file)[0] + ".h5"
+    hdfFile = os.path.splitext(_file)[0] + '.h5'
     hdfFilePath = pathlib.Path(_folder) / hdfFile
-
-    # hdfMode = 'w'
+    
+    #hdfMode = 'w'
     if os.path.isfile(hdfFilePath):
-        logger.info(f"    copying existing hdf file to tmp ")
-        logger.info(f"    hdfFilePath {hdfFilePath}")
-        logger.info(f"    tmpHdfPath {tmpHdfPath}")
-        shutil.copyfile(hdfFilePath, tmpHdfPath)
+        logger.info(f'    copying existing hdf file to tmp ')
+        logger.info(f'    hdfFilePath {hdfFilePath}')
+        logger.info(f'    tmpHdfPath {tmpHdfPath}')
+        shutil.copyfile(hdfFilePath,tmpHdfPath)
     else:
         pass
         # compressed file does not exist, just use tmp path
         # print('   does not exist:', hdfFilePath)
 
     return tmpHdfPath
 
-
 def _repackHdf(hdfPath):
+
     _folder, _file = os.path.split(hdfPath)
 
     # rebuild the file to remove old changes and reduce size
-    # tmpHdfFile = os.path.splitext(_file)[0] + '_tmp.h5'
-    # tmpHdfPath = pathlib.Path(_folder) / tmpHdfFile
-
+    #tmpHdfFile = os.path.splitext(_file)[0] + '_tmp.h5'
+    #tmpHdfPath = pathlib.Path(_folder) / tmpHdfFile
+    
     # always write to a tmp and then repack into hdfPath
     tmpHdfPath = _getTmpHdfFile(hdfPath)
 
-    hdfFile = os.path.splitext(_file)[0] + ".h5"
+    hdfFile = os.path.splitext(_file)[0] + '.h5'
     hdfPath = pathlib.Path(_folder) / hdfFile
-    logger.info(f"Rebuilding h5 to {hdfPath}")
-
+    logger.info(f'Rebuilding h5 to {hdfPath}')
+    
     # can't pass sys.argv a 'PosixPath' from pathlib.Path, needs to be a string
     tmpHdfPath = str(tmpHdfPath)
     hdfPath = str(hdfPath)
-
+    
     # when calling ptrepack, we need trailing ':' on each src/dst path
     # without this Windows fails to find the file
-    _tmpHdfPath = tmpHdfPath + ":"
-    _hdfPath = hdfPath + ":"
-
+    _tmpHdfPath = tmpHdfPath + ':'
+    _hdfPath = hdfPath + ':'
+    
     # The first item is normally the command line command name (not used)
     sys.argv = ["", "--overwrite", "--chunkshape=auto", _tmpHdfPath, _hdfPath]
 
-    logger.info("    running tables.scripts.ptrepack.main()")
-    logger.info(f"    sys.argv: {sys.argv}")
+    logger.info('    running tables.scripts.ptrepack.main()')
+    logger.info(f'    sys.argv: {sys.argv}')
     try:
+        
         tables.scripts.ptrepack.main()
 
         # delete the temporary (large file)
-        logger.info(f"    Deleting tmp file: {tmpHdfPath}")
+        logger.info(f'    Deleting tmp file: {tmpHdfPath}')
         os.remove(tmpHdfPath)
 
-        # self.signalApp(f'Saved compressed folder analysis with tables.scripts.ptrepack.main()')
+        #self.signalApp(f'Saved compressed folder analysis with tables.scripts.ptrepack.main()')
 
-    except FileNotFoundError as e:
-        logger.error("tables.scripts.ptrepack.main() failed ... file was not saved")
+    except(FileNotFoundError) as e:
+        logger.error('tables.scripts.ptrepack.main() failed ... file was not saved')
         logger.error(e)
-        # self.signalApp(f'ERROR in tables.scripts.ptrepack.main(): {e}')
-
+        #self.signalApp(f'ERROR in tables.scripts.ptrepack.main(): {e}')
 
 def _loadAnalysis(hdfPath):
     """Load all bAnalysis from h5"""
-    logger.info(f"hdfPath: {hdfPath}")
+    logger.info(f'hdfPath: {hdfPath}')
     start = time.time()
-    numLoaded = 0
-    with pd.HDFStore(hdfPath, mode="r") as store:
+    numLoaded =0
+    with pd.HDFStore(hdfPath, mode='r') as store:
         for key in store.keys():
             data = store[key]
             if isinstance(data, pd.DataFrame):
-                if "_sweepX" in data.columns:
+                if '_sweepX' in data.columns:
                     ba = sanpy.bAnalysis(fromDf=data)
-                    logger.info(f"loaded ba: {ba}")
+                    logger.info(f'loaded ba: {ba}')
                     numLoaded += 1
                 else:
                     # this is usually the file database
-                    print("Dur(s):")
-                    print(store[key]["Dur(s)"])
+                    print('Dur(s):')
+                    print(store[key]['Dur(s)'])
                     # the entire file db df
                     print(data)
     #
     stop = time.time()
-    print(f"Loading {numLoaded} bAnalysis took {round(stop-start,3)} seconds.")
-
+    print(f'Loading {numLoaded} bAnalysis took {round(stop-start,3)} seconds.')
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     import sanpy.bAnalysis
 
-    hdfPath = "/home/cudmore/Sites/SanPy/data/sanpy_recording_db.h5"
-    # listKeys(hdfPath)
+    hdfPath = '/home/cudmore/Sites/SanPy/data/sanpy_recording_db.h5'
+    #listKeys(hdfPath)
     _loadAnalysis(hdfPath)
 
     # the file befor compression
-    """
+    '''
     hdfPath = '/home/cudmore/Sites/SanPy/data/sanpy_recording_db_tmp.h5'
     loadAnalysis(hdfPath)
-    """
+    '''
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/__init__.py` & `sanpy-ephys-0.1.6/sanpy/interface/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,33 +1,31 @@
-# import os, sys;
-# sys.path.append(os.path.dirname(os.path.realpath(__file__)))
+#import os, sys;
+#sys.path.append(os.path.dirname(os.path.realpath(__file__)))
 
-# from . import *
+#from . import *
 
 from .sanpy_app import SanPyWindow
 
 from .bDetectionWidget import bDetectionWidget
 from .bScatterPlotWidget2 import bScatterPlotMainWindow
 from .bScatterPlotWidget2 import myTableView as myTableView_tmp  # used by fi plugin
 from .bExportWidget import bExportWidget
 from .bFileTable import *
 
 from .bTableView import bTableView
 from .fileListWidget import fileListWidget
 
 from .bErrorTable import *
 from .bDialog import *
-
-# from .bFileTable import *
+#from .bFileTable import *
 from .bPlugins import *
-
-# from .aPlugin import *
+#from .aPlugin import *
 
 # critical for plugins to be loaded dynamically
-# from .plugins import *
+#from .plugins import *
 
-# from .breeze_resources import *
+#from .breeze_resources import *
 
 from .bKymographWidget import kymographWidget
 from .kymographPlugin2 import kymographPlugin2
 
-from .preferences import preferences
+from .preferences import preferences
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bDetectionWidget.py` & `sanpy-ephys-0.1.6/sanpy/interface/bDetectionWidget.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,341 +1,316 @@
 import os
 import sys
 import math
 import time
-
-# import inspect # to print call stack
+#import inspect # to print call stack
 from functools import partial
-from typing import Union, Dict, List, Tuple, Optional
+from typing import Union, Dict, List, Tuple
 
 import numpy as np
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 import pyqtgraph as pg
 from pyqtgraph.exporters import ImageExporter
 
 import sanpy
 import sanpy.bDetection
 
-# import sanpy.interface.kymographWidget
+#import sanpy.interface.kymographWidget
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class bDetectionWidget(QtWidgets.QWidget):
-    signalSelectSpike = QtCore.pyqtSignal(object)  # spike number, doZoom
-    signalSelectSpikeList = QtCore.pyqtSignal(object)  # spike number, doZoom
+    signalSelectSpike = QtCore.pyqtSignal(object) # spike number, doZoom
+    signalSelectSpikeList = QtCore.pyqtSignal(object) # spike number, doZoom
     signalDetect = QtCore.pyqtSignal(object)  # ba
     signalSelectSweep = QtCore.pyqtSignal(object, object)  # (bAnalysis, sweepNumber)
-    # signalUpdateKymographROI = QtCore.pyqtSignal([])  # list of [left, top, right, bottom] in image pixels
+    #signalUpdateKymographROI = QtCore.pyqtSignal([])  # list of [left, top, right, bottom] in image pixels
 
-    def __init__(
-        self,
-        ba: sanpy.bAnalysis = None,
-        mainWindow: "sanpy.interface.SanPyWindow" = None,
-        parent=None,
-    ):
+    def __init__(self,ba : sanpy.bAnalysis = None,
+                 mainWindow : "sanpy.interface.SanPyWindow" = None,
+                 parent=None):
         """
         ba : sanpy.bAnalysis
             bAnalysis object
         mainWindow : sanpy.interface.SanPyWindow
         """
 
         super(bDetectionWidget, self).__init__(parent)
 
         self.ba : sanpy.bAnalysis = ba
-        self.myMainWindow: "sanpy.interface.SanPyWindow" = mainWindow
+        self.myMainWindow : "sanpy.interface.SanPyWindow" = mainWindow
 
-        self._pgPointSize = 10  # use +/- to increase decrease
+        self._blockSlots : bool = False
 
-        self._blockSlots: bool = False
+        #self.mySetTheme()
 
-        self._selectedSpikeList: List[int] = None
+        #self._sweepNumber = None  # 'All'
+
+        self._selectedSpikeList : List[int] = None
 
         self.dvdtLines = None
         self.dvdtLinesFiltered = None
         self.dacLines = None
         self.vmLines = None
         self.vmLinesFiltered = None
         self.vmLinesFiltered2 = None
         self.linearRegionItem2 = None  # rectangle over global Vm
         self.clipLines = None
         self.meanClipLine = None
 
-        self._showCrosshair = False
-
         self.myPlotList = []
 
         # a list of possible x/y plots (overlay over dvdt and Vm)
         # order here determines order in interface
         self.myPlots = [
             {
-                "humanName": "Global Threshold (mV)",
-                "x": "thresholdSec",
-                "y": "thresholdVal",
-                "convertx_tosec": False,  # some stats are in points, we need to convert to seconds
-                "color": "r",
-                "styleColor": "color: red",
-                "symbol": "o",
-                "plotOn": "vmGlobal",  # which plot to overlay (vm, dvdt)
-                "plotIsOn": True,
+                'humanName': 'Global Threshold (mV)',
+                'x': 'thresholdSec',
+                'y': 'thresholdVal',
+                'convertx_tosec': False,  # some stats are in points, we need to convert to seconds
+                'color': 'r',
+                'styleColor': 'color: red',
+                'symbol': 'o',
+                'plotOn': 'vmGlobal', # which plot to overlay (vm, dvdt)
+                'plotIsOn': True,
             },
-
             {
-                "humanName": "Threshold (dV/dt)",
-                "x": "thresholdSec",
-                "y": "thresholdVal_dvdt",
-                "convertx_tosec": False,  # some stats are in points, we need to convert to seconds
-                "color": "r",
-                "styleColor": "color: red",
-                "symbol": "o",
-                "plotOn": "dvdt",  # which plot to overlay (vm, dvdt)
-                "plotIsOn": True,
+                'humanName': 'Threshold (mV)',
+                'x': 'thresholdSec',
+                'y': 'thresholdVal',
+                'convertx_tosec': False,  # some stats are in points, we need to convert to seconds
+                'color': 'r',
+                'styleColor': 'color: red',
+                'symbol': 'o',
+                'plotOn': 'vm', # which plot to overlay (vm, dvdt)
+                'plotIsOn': True,
             },
-
             {
-                "humanName": "Threshold (mV)",
-                "x": "thresholdSec",
-                "y": "thresholdVal",
-                "convertx_tosec": False,  # some stats are in points, we need to convert to seconds
-                "color": "r",
-                "styleColor": "color: red",
-                "symbol": "o",
-                "plotOn": "vm",  # which plot to overlay (vm, dvdt)
-                "plotIsOn": True,
+                'humanName': 'Threshold (dV/dt)',
+                'x': 'thresholdSec',
+                'y': 'thresholdVal_dvdt',
+                'convertx_tosec': False,  # some stats are in points, we need to convert to seconds
+                'color': 'r',
+                'styleColor': 'color: red',
+                'symbol': 'o',
+                'plotOn': 'dvdt', # which plot to overlay (vm, dvdt)
+                'plotIsOn': True,
             },
-
             {
-                "humanName": "AP Peak (mV)",
-                "x": "peakSec",
-                "y": "peakVal",
-                "convertx_tosec": False,
-                "color": "g",
-                "styleColor": "color: green",
-                "symbol": "o",
-                "plotOn": "vm",
-                "plotIsOn": True,
+                'humanName': 'AP Peak (mV)',
+                'x': 'peakSec',
+                'y': 'peakVal',
+                'convertx_tosec': False,
+                'color': 'g',
+                'styleColor': 'color: green',
+                'symbol': 'o',
+                'plotOn': 'vm',
+                'plotIsOn': True,
             },
             {
-                "humanName": "Half-Widths",
-                "x": None,
-                "y": None,
-                "convertx_tosec": True,
-                "color": "y",
-                "styleColor": "color: yellow",
-                "symbol": "o",
-                "plotOn": "vm",
-                "plotIsOn": False,
+                'humanName': 'Half-Widths',
+                'x': None,
+                'y': None,
+                'convertx_tosec': True,
+                'color': 'y',
+                'styleColor': 'color: yellow',
+                'symbol': 'o',
+                'plotOn': 'vm',
+                'plotIsOn': False,
             },
             {
-                "humanName": "Epoch Lines",
-                "x": None,
-                "y": None,
-                "convertx_tosec": True,
-                "color": "gray",
-                "styleColor": "color: gray",
-                "symbol": "o",
-                "plotOn": "vm",
-                "plotIsOn": True,
+                'humanName': 'Epoch Lines',
+                'x': None,
+                'y': None,
+                'convertx_tosec': True,
+                'color': 'gray',
+                'styleColor': 'color: gray',
+                'symbol': 'o',
+                'plotOn': 'vm',
+                'plotIsOn': True,
             },
-            # removed april 15, 2023
-            # {
-            #     "humanName": "Pre AP Min (mV)",
-            #     "x": "preMinPnt",
-            #     "y": "preMinVal",
-            #     "convertx_tosec": True,
-            #     "color": "y",
-            #     "styleColor": "color: green",
-            #     "symbol": "o",
-            #     "plotOn": "vm",
-            #     "plotIsOn": False,
-            # },
-            
-            # {
+            {
+                'humanName': 'Pre AP Min (mV)',
+                'x': 'preMinPnt',
+                'y': 'preMinVal',
+                'convertx_tosec': True,
+                'color': 'y',
+                'styleColor': 'color: green',
+                'symbol': 'o',
+                'plotOn': 'vm',
+                'plotIsOn': False,
+            },
+            #{
             #    'humanName': 'Post AP Min (mV)',
             #    'x': 'postMinPnt',
             #    'y': 'postMinVal',
             #    'convertx_tosec': True,
             #    'color': 'b',
             #    'styleColor': 'color: blue',
             #    'symbol': 'o',
             #    'plotOn': 'vm',
             #    'plotIsOn': False,
-            # },
-
-            # removed april 15, 2023
-            # {
-            #     "humanName": "EDD",
-            #     "x": None,
-            #     "y": None,
-            #     "convertx_tosec": True,
-            #     "color": "m",
-            #     "styleColor": "color: megenta",
-            #     "symbol": "o",
-            #     "plotOn": "vm",
-            #     "plotIsOn": False,
-            # },
-
-            # removed april 15, 2023
-            # {
-            #     "humanName": "EDD Rate",
-            #     "x": None,
-            #     "y": None,
-            #     "convertx_tosec": False,
-            #     "color": "m",
-            #     "styleColor": "color: megenta",
-            #     "symbol": "--",
-            #     "plotOn": "vm",
-            #     "plotIsOn": False,
-            # },
-
+            #},
+            {
+                'humanName': 'EDD',
+                'x': None,
+                'y': None,
+                'convertx_tosec': True,
+                'color': 'm',
+                'styleColor': 'color: megenta',
+                'symbol': 'o',
+                'plotOn': 'vm',
+                'plotIsOn': False,
+            },
+            {
+                'humanName': 'EDD Rate',
+                'x': None,
+                'y': None,
+                'convertx_tosec': False,
+                'color': 'm',
+                'styleColor': 'color: megenta',
+                'symbol': '--',
+                'plotOn': 'vm',
+                'plotIsOn': False,
+            },
         ]
 
         # for kymograph
-        # self.myImageItem = None  # kymographImage
-        # self.myLineRoi = None
+        #self.myImageItem = None  # kymographImage
+        #self.myLineRoi = None
 
         self._buildUI()
 
         windowOptions = self.getMainWindowOptions()
         showDvDt = True
-        # showClips = False
-        # showScatter = True
+        #showClips = False
+        #showScatter = True
         if windowOptions is not None:
-            showDerivative = windowOptions["rawDataPanels"]["Derivative"]
-            showDAC = windowOptions["rawDataPanels"]["DAC"]
-            showFullRecording = windowOptions["rawDataPanels"]["Full Recording"]
-
-            self.toggleInterface("Full Recording", showFullRecording)
-            self.toggleInterface("Derivative", showDerivative)
-            self.toggleInterface("DAC", showDAC)
-            # self.toggleInterface('Clips', showClips)
+            showDerivative = windowOptions['rawDataPanels']['Derivative']
+            showDAC = windowOptions['rawDataPanels']['DAC']
+            showFullRecording = windowOptions['rawDataPanels']['Full Recording']
+
+            self.toggleInterface('Full Recording', showFullRecording)
+            self.toggleInterface('Derivative', showDerivative)
+            self.toggleInterface('DAC', showDAC)
+            #self.toggleInterface('Clips', showClips)
 
             #
             # toggle interface to myDetectionToolbarWidget
-            showPlotOption = windowOptions["detectionPanels"]["Detection"]
-            self.toggleInterface("Detection", showPlotOption)
+            showPlotOption = windowOptions['detectionPanels']['Detection']
+            self.toggleInterface('Detection', showPlotOption)
 
-            showPlotOption = windowOptions["detectionPanels"]["Display"]
-            self.toggleInterface("Display", showPlotOption)
+            showPlotOption = windowOptions['detectionPanels']['Display']
+            self.toggleInterface('Display', showPlotOption)
 
-            showPlotOption = windowOptions["detectionPanels"]["Plot Options"]
-            self.toggleInterface("Plot Options", showPlotOption)
+            showPlotOption = windowOptions['detectionPanels']['Plot Options']
+            self.toggleInterface('Plot Options', showPlotOption)
 
-            showPlotOption = windowOptions["detectionPanels"]["Set Spikes"]
-            self.toggleInterface("Set Spikes", showPlotOption)
+            showPlotOption = windowOptions['detectionPanels']['Set Spikes']
+            self.toggleInterface('Set Spikes', showPlotOption)
 
     @property
     def sweepNumber(self):
-        """Get the current sweep number (from bAnalysis)."""
+        """Get the current sweep number (from bAnalysis).
+        """
         if self.ba is None:
             return None
         else:
             return self.ba.fileLoader.currentSweep
 
-    def detect(
-        self,
-        detectionPresetStr: str,
-        detectionType: sanpy.bDetection.detectionTypes,
-        dvdtThreshold: float,
-        mvThreshold: float,
-        startSec: float = None,
-        stopSec: float = None,
-    ):
+    def detect(self,
+                detectionPresetStr : str,
+                detectionType : sanpy.bDetection.detectionTypes,
+                dvdtThreshold : float,
+                mvThreshold : float,
+                startSec :float = None, stopSec : float = None):
         """Detect spikes.
 
         Args:
             detectionPreset (str) corresponds to Enum sanpy.bDetection.detectionPresets_
             detectionType (sanpy.bDetection.detectionTypes): The type of detection (dvdt, vm)
         """
 
         _startSec = time.time()
 
         if self.ba is None:
-            str = "Please select a file to analyze."
+            str = 'Please select a file to analyze.'
             self.updateStatusBar(str)
             return
 
         if self.ba.loadError:
-            str = "Did not spike detect, the file was not loaded or may be corrupt?"
+            str = 'Did not spike detect, the file was not loaded or may be corrupt?'
             self.updateStatusBar(str)
             return
 
-        # logger.info(f'Detecting with dvdtThreshold:{dvdtThreshold} mvThreshold:{mvThreshold}')
-        self.updateStatusBar(
-            f"Detecting spikes detectionType:{detectionType.value} dvdt:{dvdtThreshold} minVm:{mvThreshold} start:{startSec} stop:{stopSec}"
-        )
+        #logger.info(f'Detecting with dvdtThreshold:{dvdtThreshold} mvThreshold:{mvThreshold}')
+        self.updateStatusBar(f'Detecting spikes detectionType:{detectionType.value} dvdt:{dvdtThreshold} minVm:{mvThreshold} start:{startSec} stop:{stopSec}')
 
         if startSec is None or stopSec is None:
             startSec = 0
             stopSec = self.ba.fileLoader.recordingDur
 
-        # TODO: replace with a member function
         _selectedDetection = self.detectToolbarWidget._selectedDetection
-        detectionDict = self.getMainWindowDetectionClass().getDetectionDict(
-            _selectedDetection
-        )
-        detectionDict[
-            "detectionType"
-        ] = detectionType.value  # set detection type to ('dvdt', 'vm')
-        detectionDict["dvdtThreshold"] = dvdtThreshold
-        detectionDict["mvThreshold"] = mvThreshold
+        detectionDict = self.getMainWindowDetectionClass().getDetectionDict(_selectedDetection)
+        detectionDict['detectionType'] = detectionType.value  # set detection type to ('dvdt', 'vm')
+        detectionDict['dvdtThreshold'] = dvdtThreshold
+        detectionDict['mvThreshold'] = mvThreshold
 
         # TODO: pass this function detection params and call from sanpy_app ???
         if self.myMainWindow is not None:
             # grab parameters from main interface table
-            logger.info("Grabbing detection parameters from main window table")
+            logger.info('Grabbing detection parameters from main window table')
 
             # problem is these k/v have v that are mixture of str/float/int ... hard to parse
             myDetectionDict = self.myMainWindow.getSelectedFileDict()
 
             #
             # fill in detectionDict from *this interface
-            detectionDict["startSeconds"] = startSec
-            detectionDict["stopSeconds"] = stopSec
+            detectionDict['startSeconds'] = startSec
+            detectionDict['stopSeconds'] = stopSec
 
             # mar 2023, I removed these from the table
             # detectionDict['cellType'] = myDetectionDict['Cell Type']
             # detectionDict['sex'] = myDetectionDict['Sex']
             # detectionDict['condition'] = myDetectionDict['Condition']
 
         #
         # detect
         self.ba.spikeDetect(detectionDict)
 
         # show dialog when num spikes is 0
-        """
+        '''
         if self.ba.numSpikes == 0:
             informativeText = f'dV/dt Threshold:{dvdtThreshold}\nVm Threshold (mV):{mvThreshold}'
             sanpy.interface.bDialog.okDialog('No Spikes Detected', informativeText=informativeText)
-        """
+        '''
 
         #
         # fill in our start/stop in the main table
         # this is done in analysisDir.xxx()
-        # setCellValue(self, rowIdx, colStr, value)
+        #setCellValue(self, rowIdx, colStr, value)
 
-        self.replotOverlays()  # replot statistics over traces
+        self.replot() # replot statistics over traces
 
         # 20210821
         # refresh spike clips
-        # self.refreshClips(None, None)
+        #self.refreshClips(None, None)
 
         self.signalDetect.emit(self.ba)
-        # if self.myMainWindow is not None:
+        #if self.myMainWindow is not None:
         #    # signal to main window so it can update (file list, scatter plot)
         #    self.myMainWindow.mySignal('detect') #, data=(dfReportForScatter, dfError))
 
         # report the number of spikes and the time it took
         _stopSec = time.time()
         numSpikes = self.ba.numSpikes
-        _elapsedSec = round(_stopSec - _startSec, 2)
-        updateStr = f"Detected {numSpikes} in {_elapsedSec} seconds"
+        _elapsedSec = round(_stopSec-_startSec,2)
+        updateStr = f'Detected {numSpikes} in {_elapsedSec} seconds'
         self.updateStatusBar(updateStr)
 
     def mySetTheme(self, doReplot=True):
         if self.myMainWindow is not None and self.myMainWindow.useDarkStyle:
             # pg.setConfigOption('background', 'k')
             # pg.setConfigOption('foreground', 'w')
             self.useDarkStyle = True
@@ -350,296 +325,283 @@
         theRet = None
         if self.myMainWindow is not None:
             theRet = self.myMainWindow.getOptions()
         return theRet
 
     def getMainWindowDetectionClass(self):
         """The detection class loads a number of json files.
-        When running SanPy app do this one.
+            When running SanPy app do this one.
         """
         theRet = None
         if self.myMainWindow is not None:
             theRet = self.myMainWindow.getDetectionClass()
         return theRet
 
     def getMainWindowFileLoaderDict(self):
         """The file loader dict loads and parses a number of .py files.
-        When running SanPy app do this one.
+            When running SanPy app do this one.
         """
         theRet = None
         if self.myMainWindow is not None:
             theRet = self.myMainWindow.getFileLoaderDict()
         return theRet
 
     def save(self, saveCsv=True):
-        """Prompt user for filename and save both xlsx and txt"""
-        if self.ba is None or self.ba.numSpikes == 0:
-            _warning = "No analysis to save"
+        """Prompt user for filename and save both xlsx and txt
+        """
+        if self.ba is None or self.ba.numSpikes==0:
+            _warning = 'No analysis to save'
             logger.warning(_warning)
             self.updateStatusBar(_warning)
             return
         xMin, xMax = self.getXRange()
-        xMinStr = "%.2f" % (xMin)
-        xMaxStr = "%.2f" % (xMax)
+        xMinStr = '%.2f'%(xMin)
+        xMaxStr = '%.2f'%(xMax)
 
-        lhs, rhs = xMinStr.split(".")
-        xMinStr = "_b" + lhs + "_" + rhs
+        lhs, rhs = xMinStr.split('.')
+        xMinStr = '_b' + lhs + '_' + rhs
 
-        lhs, rhs = xMaxStr.split(".")
-        xMaxStr = "_e" + lhs + "_" + rhs
+        lhs, rhs = xMaxStr.split('.')
+        xMaxStr = '_e' + lhs + '_' + rhs
 
         filePath, fileName = os.path.split(os.path.abspath(self.ba.fileLoader.filepath))
         fileBaseName, extension = os.path.splitext(fileName)
-        fileBaseName = f"{fileBaseName}{xMinStr}{xMaxStr}.csv"
+        fileBaseName = f'{fileBaseName}{xMinStr}{xMaxStr}.csv'
         csvFileName = os.path.join(filePath, fileBaseName)
 
         # ask user for file to save
-        savefile, tmp = QtWidgets.QFileDialog.getSaveFileName(
-            self, "Save CSV File", csvFileName
-        )
+        savefile, tmp = QtWidgets.QFileDialog.getSaveFileName(self, 'Save CSV File', csvFileName)
 
         if len(savefile) > 0:
-            logger.info(f"savefile: {savefile}")
-            logger.info(f"  xMin:{xMin} xMax:{xMax} alsoSaveTxt:{saveCsv}")
+            logger.info(f'savefile: {savefile}')
+            logger.info(f'  xMin:{xMin} xMax:{xMax} alsoSaveTxt:{saveCsv}')
             exportObj = sanpy.bExport(self.ba)
-            analysisName, df = exportObj.saveReport(
-                savefile, xMin, xMax, alsoSaveTxt=saveCsv
-            )
-            # if self.myMainWindow is not None:
+            analysisName, df = exportObj.saveReport(savefile, xMin, xMax, alsoSaveTxt=saveCsv)
+            #if self.myMainWindow is not None:
             #    self.myMainWindow.mySignal('saved', data=analysisName)
-            txt = f"Exported CSV file: {analysisName}"
+            txt = f'Exported CSV file: {analysisName}'
             self.updateStatusBar(txt)
         else:
             # user cancelled save
             pass
 
     def getXRange(self):
-        """Get the current range of X-Axis."""
-        rect = self.vmPlot.viewRect()  # get xaxis
+        """Get the current range of X-Axis.
+        """
+        rect = self.vmPlot.viewRect() # get xaxis
         xMin = rect.left()
         xMax = rect.right()
         return xMin, xMax
 
-    def _setAxis(self, start, stop, set_xyBoth="xAxis", whichPlot="vm"):
-        """Shared by (setAxisFull, setAxis)."""
+    def _setAxis(self, start, stop, set_xyBoth='xAxis', whichPlot='vm'):
+        """Shared by (setAxisFull, setAxis).
+        """
         # make sure start/stop are in correct order and swap if necc.
         if start is not None and stop is not None:
-            if stop < start:
+            if stop<start:
                 tmp = start
                 start = stop
                 stop = tmp
 
-        # logger.info(f'start:{start} stop:{stop} set_xyBoth:{set_xyBoth} whichPlot:{whichPlot}')
+        #logger.info(f'start:{start} stop:{stop} set_xyBoth:{set_xyBoth} whichPlot:{whichPlot}')
 
         padding = 0
-        if set_xyBoth == "xAxis":
+        if set_xyBoth == 'xAxis':
+
             if start is None or np.isnan(stop) or stop is None or np.isnan(stop):
                 start = 0
                 stop = self.ba.fileLoader.recordingDur
 
-            # self.derivPlot.setXRange(start, stop, padding=padding) # linked to Vm
-            self.vmPlot.setXRange(start, stop, padding=padding)  # linked to Vm
+            #self.derivPlot.setXRange(start, stop, padding=padding) # linked to Vm
+            self.vmPlot.setXRange(start, stop, padding=padding) # linked to Vm
 
-            # self.myKymWidget.kymographPlot.setXRange(
-            #     start, stop, padding=padding
-            # )  # row major is different
-
-        if set_xyBoth == "yAxis":
-            if whichPlot in ["dvdt", "dvdtFiltered"]:
-                self.derivPlot.setYRange(start, stop)  # linked to Vm
-            elif whichPlot in ["vm", "vmFiltered"]:
-                self.vmPlot.setYRange(start, stop)  # linked to Vm
+            self.myKymWidget.kymographPlot.setXRange(start, stop, padding=padding)  # row major is different
+    
+        if set_xyBoth == 'yAxis':
+            if whichPlot in ['dvdt', 'dvdtFiltered']:
+                self.derivPlot.setYRange(start, stop) # linked to Vm
+            elif whichPlot in ['vm', 'vmFiltered']:
+                self.vmPlot.setYRange(start, stop) # linked to Vm
             else:
-                logger.error(f"did not understand whichPlot: {whichPlot}")
+                logger.error(f'did not understand whichPlot: {whichPlot}')
 
         # update rectangle in vmPlotGlobal
-        self.linearRegionItem2.setRegion([start, stop])
+        self.linearRegionItem2.setRegion([start,stop])
 
         # update detection toolbar
-        if set_xyBoth == "xAxis":
-            # 20230419
-            # self.detectToolbarWidget.startSeconds.setValue(start)
-            # self.detectToolbarWidget.startSeconds.repaint()
-            # self.detectToolbarWidget.stopSeconds.setValue(stop)
-            # self.detectToolbarWidget.stopSeconds.repaint()
-            self.detectToolbarWidget._startSec = start
-            self.detectToolbarWidget._stopSec = stop
-
-        # else:
+        if set_xyBoth == 'xAxis':
+            self.detectToolbarWidget.startSeconds.setValue(start)
+            self.detectToolbarWidget.startSeconds.repaint()
+            self.detectToolbarWidget.stopSeconds.setValue(stop)
+            self.detectToolbarWidget.stopSeconds.repaint()
+        #else:
         #    print('todo: add interface for y range in bDetectionWidget._setAxis()')
 
-        # if set_xyBoth == 'xAxis':
+        #if set_xyBoth == 'xAxis':
         #    self.refreshClips(start, stop)
 
         return start, stop
 
-    def _old_setAxis_OnFileChange(self, startSec, stopSec):
-        if (
-            startSec is None
-            or stopSec is None
-            or math.isnan(startSec)
-            or math.isnan(stopSec)
-        ):
+    def old_setAxis_OnFileChange(self, startSec, stopSec):
+        if startSec is None or stopSec is None or math.isnan(startSec) or math.isnan(stopSec):
             startSec = 0
             stopSec = self.ba.fileLoader.recordingDur
 
         self.vmPlotGlobal.autoRange(items=[self.vmLinesFiltered2])  # always full view
         self.linearRegionItem2.setRegion([startSec, stopSec])
 
-        # padding = 0
-        # self.derivPlot.setXRange(startSec, stopSec, padding=padding) # linked to Vm
-        # self.myKymWidget.kymographPlot.autoRange()  # row major is different
+        #padding = 0
+        #self.derivPlot.setXRange(startSec, stopSec, padding=padding) # linked to Vm
+        #self.myKymWidget.kymographPlot.autoRange()  # row major is different
 
     def setAxisFull_y(self, thisAxis):
         """Set full y-axis.
 
         Args:
             thisAxis: Specifies the axis to set, like (vm, dvdt)
         """
-        # logger.info(f'thisAxis:"{thisAxis}"')
+        #logger.info(f'thisAxis:"{thisAxis}"')
         # y-axis is NOT shared
         # dvdt
-        if thisAxis in ["dvdt", "dvdtFiltered"]:
+        if thisAxis in ['dvdt', 'dvdtFiltered']:
             filteredDeriv = self.ba.fileLoader.filteredDeriv
             top = np.nanmax(filteredDeriv)
             bottom = np.nanmin(filteredDeriv)
-            start, stop = self._setAxis(
-                bottom, top, set_xyBoth="yAxis", whichPlot="dvdt"
-            )
-        elif thisAxis in ["vm", "vmFiltered"]:
+            start, stop = self._setAxis(bottom, top,
+                                    set_xyBoth='yAxis',
+                                    whichPlot='dvdt')
+        elif thisAxis in ['vm', 'vmFiltered']:
             sweepY = self.ba.fileLoader.sweepY
             top = np.nanmax(sweepY)
             bottom = np.nanmin(sweepY)
-            start, stop = self._setAxis(bottom, top, set_xyBoth="yAxis", whichPlot="vm")
+            start, stop = self._setAxis(bottom, top,
+                                    set_xyBoth='yAxis',
+                                    whichPlot='vm')
         else:
             logger.error(f'Did not understand thisAxis:"{thisAxis}"')
 
     def setAxisFull(self):
         """Set full axis for (deriv, daq, vm, clips).
         """
         if self.ba is None:
             return
 
         # 20220115
-        # self.vmPlot.autoRange(items=[self.vmLinesFiltered])
-        # self.vmPlot.enableAutoRange()
+        #self.vmPlot.autoRange(items=[self.vmLinesFiltered])
+        #self.vmPlot.enableAutoRange()
         self.vmPlot.autoRange()  # 20221003
 
         # these are linked to vmPlot
-        # self.derivPlot.autoRange()
-        # self.dacPlot.autoRange()
+        #self.derivPlot.autoRange()
+        #self.dacPlot.autoRange()
+
 
         self.vmPlotGlobal.autoRange(items=[self.vmLinesFiltered2])  # we never zoom this
 
-        # self.refreshClips(None, None)
-        # self.clipPlot.autoRange()
+        #self.refreshClips(None, None)
+        #self.clipPlot.autoRange()
 
         # rectangle region on vmPlotGlobal
         self.linearRegionItem2.setRegion([0, self.ba.fileLoader.recordingDur])
 
         # kymograph
-        # self.myKymWidget.kymographPlot.setXRange(start, stop, padding=padding)  # row major is different
-        #self.myKymWidget.kymographPlot.autoRange()  # row major is different
+        #self.myKymWidget.kymographPlot.setXRange(start, stop, padding=padding)  # row major is different
+        self.myKymWidget.kymographPlot.autoRange()  # row major is different
 
         #
         # update detection toolbar
         start = 0
         stop = self.ba.fileLoader.recordingDur
-        # removed 20230419
-        # self.detectToolbarWidget.startSeconds.setValue(start)
-        # self.detectToolbarWidget.startSeconds.repaint()
-        # self.detectToolbarWidget.stopSeconds.setValue(stop)
-        # self.detectToolbarWidget.stopSeconds.repaint()
-        self.detectToolbarWidget._startSec = start
-        self.detectToolbarWidget._stopSec = stop
-        
+        self.detectToolbarWidget.startSeconds.setValue(start)
+        self.detectToolbarWidget.startSeconds.repaint()
+        self.detectToolbarWidget.stopSeconds.setValue(stop)
+        self.detectToolbarWidget.stopSeconds.repaint()
+
         # todo: make this a signal, with slot in main window
         if self.myMainWindow is not None:
             # currently, this will just update scatte plot
             logger.info('calling myMainWindow "set full x axis"')
-            self.myMainWindow.mySignal("set full x axis")
+            self.myMainWindow.mySignal('set full x axis')
 
-    def setAxis(self, start, stop, set_xyBoth="xAxis", whichPlot="vm"):
-        """Called when user click+drag in a pyQtGraph plot.
+    def setAxis(self, start, stop, set_xyBoth='xAxis', whichPlot='vm'):
+        """
+        Called when user click+drag in a pyQtGraph plot.
 
         Args:
             start
             stop
             set_xyBoth: (xAxis, yAxis, Both)
             whichPlot: (dvdt, vm)
         """
-        # logger.info(f'start:{start} stop:{stop} set_xyBoth:{set_xyBoth} whichPlot:{whichPlot}')
-
-        start, stop = self._setAxis(
-            start, stop, set_xyBoth=set_xyBoth, whichPlot=whichPlot
-        )
-        # print('bDetectionWidget.setAxis()', start, stop)
-        if set_xyBoth == "xAxis":
+        #logger.info(f'start:{start} stop:{stop} set_xyBoth:{set_xyBoth} whichPlot:{whichPlot}')
+        
+        start, stop = self._setAxis(start, stop, set_xyBoth=set_xyBoth, whichPlot=whichPlot)
+        #print('bDetectionWidget.setAxis()', start, stop)
+        if set_xyBoth == 'xAxis':
             if self.myMainWindow is not None:
-                self.myMainWindow.mySignal("set x axis", data=[start, stop])
+                self.myMainWindow.mySignal('set x axis', data=[start,stop])
         # no need to emit change in y-axis, no other widgets change
-        """
+        '''
         elif set_xyBoth == 'yAxis':
             # todo: this needs to know which plot
             if self.myMainWindow is not None:
                 self.myMainWindow.mySignal('set y axis', data=[start,stop])
-        """
-        # elif set_xyBoth == 'both':
+        '''
+        #elif set_xyBoth == 'both':
         #    self.myMainWindow.mySignal('set y axis', data=[start,stop])
 
     def fillInDetectionParameters(self, tableRowDict):
-        """ """
-        # print('fillInDetectionParameters() tableRowDict:', tableRowDict)
+        """
+        """
+        #print('fillInDetectionParameters() tableRowDict:', tableRowDict)
         self.detectToolbarWidget.fillInDetectionParameters(tableRowDict)
 
     def updateStatusBar(self, text):
         if self.myMainWindow is not None:
             self.myMainWindow.slot_updateStatus(text)
         else:
             logger.info(text)
 
     def on_scatterClicked(self, item, points, ev=None):
         """
-
+        
         Parameters
         ----------
         item : PlotDataItem
             that was clicked
         points : list of points clicked (pyqtgraph.graphicsItems.ScatterPlotItem.SpotItem)
         """
 
-        """
+        '''
         print('=== bDetectionWidget.on_scatterClicked')
         print('  item:', item)
         print('  points:', points)
         print('  ev:', ev)
-        """
+        '''
         indexes = []
-        # print('item.data:', item.data())
-        # for idx, p in enumerate(points):
+        #print('item.data:', item.data())
+        #for idx, p in enumerate(points):
         #    print(f'    points[{idx}].data():{p.data()} p.index:{p.index()} p.pos:{p.pos()}')
 
         if len(points) > 0:
             # just one point
             # when showing a sweep, this is relative to sweep (not abs in all analysis)
             sweepSpikeNumber = points[0].index()
 
             # convert sweep spike index to absolute
-            _spikeNumber = self.ba.getStat("spikeNumber", sweepNumber=self.sweepNumber)
+            _spikeNumber = self.ba.getStat('spikeNumber', sweepNumber=self.sweepNumber)
             absSpikeNumber = _spikeNumber[sweepSpikeNumber]
 
-            logger.info(
-                f"self.sweepNumber:{self.sweepNumber} sweepSpikeNumber:{sweepSpikeNumber} absIndex:{absSpikeNumber}"
-            )
+            logger.info(f'self.sweepNumber:{self.sweepNumber} sweepSpikeNumber:{sweepSpikeNumber} absIndex:{absSpikeNumber}')
             eDict = {
-                "spikeNumber": absSpikeNumber,
-                "doZoom": False,
-                "ba": self.ba,
+                'spikeNumber': absSpikeNumber,
+                'doZoom': False,
+                'ba': self.ba,
             }
-            logger.info(f"    {eDict}")
+            logger.info(f'    {eDict}')
 
             self.signalSelectSpike.emit(eDict)
 
         """
         for p in points:
             p = p.pos()
             x, y = p.x(), p.y()
@@ -649,383 +611,317 @@
             indexes += i
         indexes = list(set(indexes))
         print('spike(s):', indexes)
         """
 
     def getEDD(self):
         # get x/y plot position of all EDD from all spikes
-        # print('bDetectionWidget.getEDD()')
+        #print('bDetectionWidget.getEDD()')
         x = []
         y = []
-        # for idx, spike in enumerate(self.ba.spikeDict:
+        #for idx, spike in enumerate(self.ba.spikeDict:
         spikeDictionaries = self.ba.getSpikeDictionaries(sweepNumber=self.sweepNumber)
         for idx, spike in enumerate(spikeDictionaries):
-            preLinearFitPnt0 = spike["preLinearFitPnt0"]
-            preLinearFitPnt1 = spike["preLinearFitPnt1"]
+
+            preLinearFitPnt0 = spike['preLinearFitPnt0']
+            preLinearFitPnt1 = spike['preLinearFitPnt1']
 
             if preLinearFitPnt0 is not None:
                 preLinearFitPnt0 = self.ba.fileLoader.pnt2Sec_(preLinearFitPnt0)
             else:
                 preLinearFitPnt0 = np.nan
 
             if preLinearFitPnt1 is not None:
                 preLinearFitPnt1 = self.ba.fileLoader.pnt2Sec_(preLinearFitPnt1)
             else:
                 preLinearFitPnt1 = np.nan
 
-            preLinearFitVal0 = spike["preLinearFitVal0"]
-            preLinearFitVal1 = spike["preLinearFitVal1"]
+            preLinearFitVal0 = spike['preLinearFitVal0']
+            preLinearFitVal1 = spike['preLinearFitVal1']
 
             x.append(preLinearFitPnt0)
             x.append(preLinearFitPnt1)
             x.append(np.nan)
 
             y.append(preLinearFitVal0)
             y.append(preLinearFitVal1)
             y.append(np.nan)
 
-        # print ('  returning', len(x), len(y))
+        #print ('  returning', len(x), len(y))
         return x, y
 
-    def _old_getHalfWidths(self):
+    def old_getHalfWidths(self):
         """Get x/y pair for plotting all half widths."""
         # defer until we know how many half-widths 20/50/80
         x = []
         y = []
         numPerSpike = 3  # rise/fall/nan
         numSpikes = self.ba.numSpikes
         xyIdx = 0
-        # for idx, spike in enumerate(self.ba.spikeDict):
+        #for idx, spike in enumerate(self.ba.spikeDict):
         spikeDictionaries = self.ba.getSpikeDictionaries(sweepNumber=self.sweepNumber)
         for idx, spike in enumerate(spikeDictionaries):
-            if idx == 0:
+            if idx ==0:
                 # make x/y from first spike using halfHeights = [20,50,80]
-                halfHeights = spike[
-                    "halfHeights"
-                ]  # will be same for all spike, like [20, 50, 80]
+                halfHeights = spike['halfHeights'] # will be same for all spike, like [20, 50, 80]
                 numHalfHeights = len(halfHeights)
                 # *numHalfHeights to account for rise/fall + padding nan
                 x = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
                 y = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
-                # print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
+                #print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
 
-            if "widths" not in spike:
+            if 'widths' not in spike:
                 print(f'=== Did not find "widths" key in spike {idx}')
-                # print(spike)
-            for idx2, width in enumerate(spike["widths"]):
-                halfHeight = width["halfHeight"]  # [20,50,80]
-                risingPnt = width["risingPnt"]
-                risingVal = width["risingVal"]
-                fallingPnt = width["fallingPnt"]
-                fallingVal = width["fallingVal"]
+                #print(spike)
+            for idx2, width in enumerate(spike['widths']):
+                halfHeight = width['halfHeight'] # [20,50,80]
+                risingPnt = width['risingPnt']
+                risingVal = width['risingVal']
+                fallingPnt = width['fallingPnt']
+                fallingVal = width['fallingVal']
 
                 if risingPnt is None or fallingPnt is None:
                     # half-height was not detected
                     continue
 
                 risingSec = self.ba.fileLoader.pnt2Sec_(risingPnt)
                 fallingSec = self.ba.fileLoader.pnt2Sec_(fallingPnt)
 
                 x[xyIdx] = risingSec
-                x[xyIdx + 1] = fallingSec
-                x[xyIdx + 2] = np.nan
+                x[xyIdx+1] = fallingSec
+                x[xyIdx+2] = np.nan
                 # y
-                y[xyIdx] = fallingVal  # risingVal, to make line horizontal
-                y[xyIdx + 1] = fallingVal
-                y[xyIdx + 2] = np.nan
+                y[xyIdx] = fallingVal  #risingVal, to make line horizontal
+                y[xyIdx+1] = fallingVal
+                y[xyIdx+2] = np.nan
 
                 # each spike has 3x pnts: rise/fall/nan
                 xyIdx += numPerSpike  # accounts for rising/falling/nan
             # end for width
         # end for spike
-        # print('  numSpikes:', numSpikes, 'xyIdx:', xyIdx)
+        #print('  numSpikes:', numSpikes, 'xyIdx:', xyIdx)
         #
         return x, y
 
-    def replotOverlays(self, oneIndex=None):
+    def replot(self, oneIndex=None):
         """Replot analysis results overlays.
-
+        
         Parameters
         ----------
         oneIndex : int
             If specified then replot just one overlay from self.myPlots
         """
         if self.ba is None:
             return
 
-        # get marker symbols once (for spikes we are plotting)
-        # if _spikeNumbers is None then no spikes
-        _spikeNumbers = self.ba.getStat('spikeNumber', sweepNumber=self.sweepNumber)
-        
-        _n = None
-        if _spikeNumbers is not None:
-            _n = len(_spikeNumbers)
-        logger.info(f'fetching {_n} markers and colors -- WILL  BE SLOW')
-        
-        _plotMarkerDict = sanpy.interface.plugins.getPlotMarkersAndColors(self.ba, _spikeNumbers)
-        markerList_pg = _plotMarkerDict['markerList_pg']
-        faceColors = _plotMarkerDict['faceColors']
-
         for idx, plot in enumerate(self.myPlots):
-            if oneIndex is not None and idx != oneIndex:
+            if oneIndex is not None and idx!=oneIndex:
                 continue
-            
-            #print(plot)
-            
             xPlot = []
             yPlot = []
-            markers = []
-            colors = []
-            plotIsOn = plot["plotIsOn"]
+            plotIsOn = plot['plotIsOn']
             #  TODO: fix the logic here, we are not calling replot() when user toggles plot radio checkboxes
-            # plotIsOn = True
-            if plotIsOn and plot["humanName"] == "Half-Widths":
-                spikeDictionaries = self.ba.getSpikeDictionaries(
-                    sweepNumber=self.sweepNumber
-                )
+            #plotIsOn = True
+            if plotIsOn and plot['humanName'] == 'Half-Widths':
+                spikeDictionaries = self.ba.getSpikeDictionaries(sweepNumber=self.sweepNumber)
                 sweepX = self.ba.fileLoader.sweepX
                 sweepY = self.ba.fileLoader.sweepY
-                # filteredVm = self.ba.filteredVm
-                # filteredVm = filteredVm[:,0]
-                xPlot, yPlot = sanpy.analysisUtil.getHalfWidthLines(
-                    sweepX, sweepY, spikeDictionaries
-                )
-                self.myPlotList[idx].setData(x=xPlot, y=yPlot)
-
-            elif plotIsOn and plot["humanName"] == "Epoch Lines":
+                #filteredVm = self.ba.filteredVm
+                #filteredVm = filteredVm[:,0]
+                xPlot, yPlot = sanpy.analysisUtil.getHalfWidthLines(sweepX, sweepY, spikeDictionaries)
+            elif plotIsOn and plot['humanName'] == 'Epoch Lines':
                 # vertical lines showing epoch within a sweep
                 _epochTable = self.ba.fileLoader.getEpochTable(self.sweepNumber)
                 if _epochTable is not None:
                     # happens when file is tif kymograph
                     sweepY = self.ba.fileLoader.sweepY
-                    # filteredVm = self.ba.filteredVm
-                    xPlot, yPlot = _epochTable.getEpochLines(
-                        yMin=np.nanmin(sweepY), yMax=np.nanmax(sweepY)
-                    )
-                self.myPlotList[idx].setData(x=xPlot, y=yPlot)
-
-            elif plotIsOn and plot["humanName"] == "EDD":
+                    #filteredVm = self.ba.filteredVm
+                    xPlot, yPlot =  _epochTable.getEpochLines(yMin=np.nanmin(sweepY), yMax=np.nanmax(sweepY))
+            elif plotIsOn and plot['humanName'] == 'EDD':
                 xPlot, yPlot = self.getEDD()
-                self.myPlotList[idx].setData(x=xPlot, y=yPlot)
-
-            elif plotIsOn and plot["humanName"] == "EDD Rate":
+            elif plotIsOn and plot['humanName'] == 'EDD Rate':
                 xPlot, yPlot = sanpy.analysisUtil.getEddLines(self.ba)
-                self.myPlotList[idx].setData(x=xPlot, y=yPlot)
-
             elif plotIsOn:
-                xPlot, yPlot = self.ba.getStat(
-                    plot["x"], plot["y"], sweepNumber=self.sweepNumber
-                )
-                if xPlot is not None and plot["convertx_tosec"]:
-                    xPlot = [
-                        self.ba.fileLoader.pnt2Sec_(x) for x in xPlot
-                    ]  # convert pnt to sec
-                
-                _brushList = [None] * len(xPlot)
-                #_penList = [None] * len(xPlot)
-                
-                #print('faceColors:', faceColors)
-                #print('markerList_pg:', markerList_pg)
-                
-                if faceColors is not None:
-                    for _idx in range(len(xPlot)):
-                        _brushList[_idx] = pg.mkBrush(faceColors[_idx])
-                        #_penList[_idx] = pg.mkPen(faceColors[_idx])
-                
-                # use symbolBrush, not brush
-                # see: https://stackoverflow.com/questions/41060163/pyqtgraph-scatterplotitem-setbrush
-                self.myPlotList[idx].setData(x=xPlot, y=yPlot,
-                                             symbolBrush=_brushList,
-                                             #brush=_brushList,
-                                             pen=None,
-                                             symbol=markerList_pg,
-                                             size=self._pgPointSize)
-
-            # self.togglePlot(idx, plot['plotIsOn'])
+                xPlot, yPlot = self.ba.getStat(plot['x'], plot['y'], sweepNumber=self.sweepNumber)
+                if xPlot is not None and plot['convertx_tosec']:
+                    xPlot = [self.ba.fileLoader.pnt2Sec_(x) for x in xPlot] # convert pnt to sec
+            #
+            # added connect='finite' to respect nan in half-width
+            # not sure how connect='finite' affect all other plots using scatter???
+            #print(f'{plot}')
+            #print('  ', xPlot, yPlot)
+            self.myPlotList[idx].setData(x=xPlot, y=yPlot)
+            #self.togglePlot(idx, plot['plotIsOn'])
 
         # update label with number of spikes detected
-        # print('todo: bDetectionWidget.replot(), make numSpikesLabel respond to signal/slot')
-        # numSpikesStr = str(self.ba.numSpikes)
-        # self.detectToolbarWidget.numSpikesLabel.setText("Spikes: " + numSpikesStr)
-        # self.detectToolbarWidget.numSpikesLabel.repaint()
+        #print('todo: bDetectionWidget.replot(), make numSpikesLabel respond to signal/slot')
+        numSpikesStr = str(self.ba.numSpikes)
+        self.detectToolbarWidget.numSpikesLabel.setText('Spikes: ' + numSpikesStr)
+        self.detectToolbarWidget.numSpikesLabel.repaint()
 
         # spike freq
-        # print('todo: bDetectionWidget.replot(), make spikeFreqLabel respond to signal/slot')
-        # meanSpikeFreq = self.ba.getStatMean(
-        #     "spikeFreq_hz", sweepNumber=self.sweepNumber
-        # )
-        # if meanSpikeFreq is not None:
-        #     meanSpikeFreq = round(meanSpikeFreq, 2)
-        # self.detectToolbarWidget.spikeFreqLabel.setText("Freq: " + str(meanSpikeFreq))
-        # self.detectToolbarWidget.spikeFreqLabel.repaint()
+        #print('todo: bDetectionWidget.replot(), make spikeFreqLabel respond to signal/slot')
+        meanSpikeFreq = self.ba.getStatMean('spikeFreq_hz', sweepNumber=self.sweepNumber)
+        if meanSpikeFreq is not None:
+            meanSpikeFreq = round(meanSpikeFreq,2)
+        self.detectToolbarWidget.spikeFreqLabel.setText('Freq: ' + str(meanSpikeFreq))
+        self.detectToolbarWidget.spikeFreqLabel.repaint()
 
         # num errors
-        # self.detectToolbarWidget.numErrorsLabel.setText(
-        #     "Errors: " + str(self.ba.numErrors())
-        # )
-        # self.detectToolbarWidget.numErrorsLabel.repaint()
+        self.detectToolbarWidget.numErrorsLabel.setText('Errors: ' + str(self.ba.numErrors()))
+        self.detectToolbarWidget.numErrorsLabel.repaint()
 
-    def togglePlot(self, idx: int, on: bool):
+    def togglePlot(self, idx : int, on : bool):
         """Toggle overlay of stats like (spike threshold, spike peak, ...).
 
         Arg:
             idx (int)
                 overlay index into self.myPlots
             on (bool):
                 if True then on
         """
         if isinstance(idx, str):
-            logger.error(
-                f'Unexpected type for parameter idx "{idx}" with type {type(idx)}'
-            )
+            logger.error(f'Unexpected type for parameter idx "{idx}" with type {type(idx)}')
             return
 
         # toggle the plot on/off
-        self.myPlots[idx]["plotIsOn"] = on
+        self.myPlots[idx]['plotIsOn'] = on
 
         if on:
-            # self.myPlotList[idx].setData(pen=pg.mkPen(width=5, color=plot['color'], symbol=plot['symbol']), size=2)
+            #self.myPlotList[idx].setData(pen=pg.mkPen(width=5, color=plot['color'], symbol=plot['symbol']), size=2)
             self.myPlotList[idx].show()
-            # self.myPlotList[idx].setPen(pg.mkPen(width=5, color=plot['color'], symbol=plot['symbol']))
+            #self.myPlotList[idx].setPen(pg.mkPen(width=5, color=plot['color'], symbol=plot['symbol']))
             # removed for half-width
-            # self.myPlotList[idx].setSize(2)
+            #self.myPlotList[idx].setSize(2)
         else:
-            # self.myPlotList[idx].setData(pen=pg.mkPen(width=0, color=plot['color'], symbol=plot['symbol']), size=0)
+            #self.myPlotList[idx].setData(pen=pg.mkPen(width=0, color=plot['color'], symbol=plot['symbol']), size=0)
             self.myPlotList[idx].hide()
-            # self.myPlotList[idx].setPen(pg.mkPen(width=0, color=plot['color'], symbol=plot['symbol']))
+            #self.myPlotList[idx].setPen(pg.mkPen(width=0, color=plot['color'], symbol=plot['symbol']))
             # removed for half-width
-            # self.myPlotList[idx].setSize(0)
+            #self.myPlotList[idx].setSize(0)
 
         # always replot everything
-        self.replotOverlays(oneIndex=idx)
+        self.replot(oneIndex=idx)
 
-    def selectSweep(
-        self, sweepNumber, startSec=None, stopSec=None, doEmit=True, doReplot=True
-    ):
+    def selectSweep(self, sweepNumber, startSec=None, stopSec=None,
+                    doEmit=True, doReplot=True):
         """
         Parameters
         ----------
         sweepNumber : str or int
             From ('All', 0, 1, 2, 3, ...)
         startSec : float or None
         stopSec : float or None
         doEmit : bool
             If True then emit signal signalSelectSweep
         doReplot : bool
             If True then call _replot()
         """
-        if sweepNumber == "":
-            logger.error("")
+        if sweepNumber == '':
+            logger.error('')
             return
 
-        if sweepNumber == "All":
+        if sweepNumber == 'All':
             sweepNumber = None
         else:
             sweepNumber = int(sweepNumber)
 
-        if sweepNumber is not None and (
-            sweepNumber < 0 or sweepNumber > self.ba.fileLoader.numSweeps - 1
-        ):
+        if sweepNumber is not None and (sweepNumber<0 or sweepNumber>self.ba.fileLoader.numSweeps-1):
             return
 
-        logger.info(
-            f'sweepNumber:"{sweepNumber}" {type(sweepNumber)} doEmit:{doEmit} startSec:"{startSec}" stopSec:"{stopSec}"'
-        )
+        logger.info(f'sweepNumber:"{sweepNumber}" {type(sweepNumber)} doEmit:{doEmit} startSec:"{startSec}" stopSec:"{stopSec}"')
 
-        # if self._sweepNumber == sweepNumber:
+        #if self._sweepNumber == sweepNumber:
         #    logger.info(f'Already showing sweep:{sweepNumber}      RETURNING')
         #    return
 
-        # self._sweepNumber = sweepNumber
+        #self._sweepNumber = sweepNumber
         self.ba.fileLoader.setSweep(sweepNumber)
 
-        # self.setAxisFull()
+        #self.setAxisFull()
 
         # cancel spike selection
         self.selectSpike(None)
 
         if doReplot:
             self._replot(startSec, stopSec)  # will set full axis
 
         if doEmit:
             self.signalSelectSweep.emit(self.ba, sweepNumber)
 
-    def setSpikeStat(self, stat: str = "condition", value: str = "xxx"):
-        """Set the selected spikes."""
+    def setSpikeStat(self, stat : str = 'condition', value : str = 'xxx'):
+        """Set the selected spikes.
+        """
         logger.info(f'setting spike stat "{stat}" to "{value}"')
         if self._selectedSpikeList is not None:
             self.ba.setSpikeStat(self._selectedSpikeList, stat, value)
 
-    def selectSpike(self, spikeNumber: int, doZoom: bool = False, doEmit: bool = False):
+    def selectSpike(self, spikeNumber : int, doZoom : bool = False, doEmit : bool = False):
         """
 
         Notes
         -----
         Will set the sweep if we are not looking at the sweep of spikeNumber
 
         Args:
             spikeNumber: absolute
             doZoom:
             doEmit: If True then emit signalSelectSpike signal
         """
-        logger.info(f"spikeNumber:{spikeNumber} doZoom:{doZoom} doEmit:{doEmit}")
-        logger.warning(f"  converting to spike list selection")
-
+        logger.info(f'spikeNumber:{spikeNumber} doZoom:{doZoom} doEmit:{doEmit}')
+        logger.warning(f'  converting to spike list selection')
+         
         # # march 11, 2023
 
         # if self._blockSlots:
         #     return
-
+    
         # self._blockSlots = True
 
         # if spikeNumber is None:
         #     spikeList = []
         # else:
         #     spikeList = [spikeNumber]
         # self.selectSpikeList(spikeList, doEmit=True)
 
         # self._blockSlots = False
 
         # return
-
+    
         # we will always use self.ba ('peakSec', 'peakVal')
         if self.ba is None:
             return
         if self.ba.numSpikes == 0:
             return
 
         spikeList = [spikeNumber]
 
         x = None
         y = None
 
         # potentially move on to a new sweep (while implementing Thian data)
         if spikeNumber is not None:
-            if spikeNumber < 0 or spikeNumber > self.ba.numSpikes - 1:
-                logger.error(
-                    f"Got spike {spikeNumber} but expecting range [0,{self.ba.numSpikes-1})"
-                )
+            if spikeNumber<0 or spikeNumber>self.ba.numSpikes-1:
+                logger.error(f'Got spike {spikeNumber} but expecting range [0,{self.ba.numSpikes-1})')
                 return
 
-            sweep = self.ba.getSpikeStat(spikeList, "sweep")
+            sweep = self.ba.getSpikeStat(spikeList, 'sweep')
             sweep = sweep[0]  # just the first
             if sweep != self.sweepNumber:
-                logger.info(
-                    f"!!! SWITCHING to sweep: {sweep} from self.sweepNumber:{self.sweepNumber}"
-                )
+                logger.info(f'!!! SWITCHING to sweep: {sweep} from self.sweepNumber:{self.sweepNumber}')
                 self.slot_selectSweep(sweep)
 
             # our plot is of ONE SWEEP, we need to convert abs spike number to
             # spike number within the sweep
-            logger.info(f"spikeNumber: {spikeNumber}, sweep {sweep}, doZoom {doZoom}")
+            logger.info(f'spikeNumber: {spikeNumber}, sweep {sweep}, doZoom {doZoom}')
             sweepSpikeNumber = self.ba.getSweepSpikeFromAbsolute(spikeNumber, sweep)
-
+            
             # removed mar 11
             # sweepSpikeList = [sweepSpikeNumber]
-            # logger.info(f'  sweepSpikeNumber:{sweepSpikeNumber} {type(sweepSpikeNumber)}')
+            #logger.info(f'  sweepSpikeNumber:{sweepSpikeNumber} {type(sweepSpikeNumber)}')
 
             # spikeList = [sweepSpikeNumber]
 
             # xPlot, yPlot = self.ba.getStat('peakSec', 'peakVal', sweepNumber=sweep)
             # xPlot = np.array(xPlot)
             # yPlot = np.array(yPlot)
             # try:
@@ -1033,219 +929,179 @@
             #     y = yPlot[sweepSpikeList]
             # except (IndexError) as e:
             #     logger.error(f'{e}')
 
         # removed mar 11 2023
         # self.mySingleSpikeScatterPlot.setData(x=x, y=y)
 
-        # zoom to one selected spike
+        # zoom
         if spikeNumber is not None and doZoom:
-            thresholdSeconds = self.ba.getStat(
-                "thresholdSec", sweepNumber=self.sweepNumber
-            )
+            thresholdSeconds = self.ba.getStat('thresholdSec', sweepNumber=self.sweepNumber)
             if sweepSpikeNumber < len(thresholdSeconds):
-                logger.info("    !!!! REMOVE HARD CODED ZOOM")
-                # thresholdSecond = thresholdSeconds[spikeNumber]
+                logger.info('    !!!! REMOVE HARD CODED ZOOM')
+                #thresholdSecond = thresholdSeconds[spikeNumber]
                 thresholdSecond = thresholdSeconds[sweepSpikeNumber]
                 thresholdSecond = round(thresholdSecond, 3)
-                
-                # TODO: replace with a member function
-                # _selectedDetection = self.detectToolbarWidget._selectedDetection
-                # detectionDict = self.getMainWindowDetectionClass().getDetectionDict(
-                #     _selectedDetection
-                # )
-
-                # if we get here, we assume we have a banalysis and it has been detected
-                detectionDict = self.ba.getDetectionDict()
-
-                #print(detectionDict.keys())
-                preSpikeClipWidth_ms = detectionDict['preSpikeClipWidth_ms']
-                preSpikeClipWidth_sec = preSpikeClipWidth_ms / 1000
-                
-                postSpikeClipWidth_ms = detectionDict['postSpikeClipWidth_ms']
-                postSpikeClipWidth_sec = postSpikeClipWidth_ms / 1000
-
-                logger.info(f'zooming to preSpikeClipWidth_sec:{preSpikeClipWidth_sec}, postSpikeClipWidth_sec:{postSpikeClipWidth_sec}')
-                
-                startSec = thresholdSecond - preSpikeClipWidth_sec
-                #startSec = round(startSec, 2)
-                stopSec = thresholdSecond + postSpikeClipWidth_sec
-                #stopSec = round(stopSec, 2)
-                # print('  spikeNumber:', spikeNumber, 'thresholdSecond:', thresholdSecond, 'startSec:', startSec, 'stopSec:', stopSec)
+                startSec = thresholdSecond - 0.5
+                startSec = round(startSec, 2)
+                stopSec = thresholdSecond + 0.5
+                stopSec = round(stopSec, 2)
+                #print('  spikeNumber:', spikeNumber, 'thresholdSecond:', thresholdSecond, 'startSec:', startSec, 'stopSec:', stopSec)
                 start = self.setAxis(startSec, stopSec)
 
         if doEmit:
             eDict = {
-                "spikeNumber": spikeNumber,
-                "doZoom": doZoom,
-                "ba": self.ba,
+                'spikeNumber': spikeNumber,
+                'doZoom': doZoom,
+                'ba': self.ba,
             }
-            logger.info(f"  -->> emit signalSelectSpike")
+            logger.info(f'  -->> emit signalSelectSpike')
             self.signalSelectSpike.emit(eDict)
 
         # march 11, 2023
         if self._blockSlots:
             return
-
+    
         self._blockSlots = True
 
         if spikeNumber is None:
             spikeList = []
         else:
             spikeList = [spikeNumber]
         self.selectSpikeList(spikeList, doEmit=True)
 
         self._blockSlots = False
 
-    def selectSpikeList(self,
-                        spikeList: List[int],
-                        doZoom: bool = False,
-                        doEmit: bool = False):
+    def selectSpikeList(self, spikeList : List[int],
+                        doZoom : bool = False,
+                        doEmit : bool = False):
         """Visually select a number of spikes.
-
+        
         Parameters
         ----------
         spikeList : list of int
             A list of spikes (absolute)
-
+        
         Notes
         -----
         spikeList is absolute but we are only plotting a subset (for one sweep).
         """
-
+        
         x = None
         y = None
-        markerList_pg = None
 
         if len(spikeList) > 0:
-            _xSweepSpikeNumber = self.ba.getStat(
-                "sweepSpikeNumber", sweepNumber=self.sweepNumber
-            )
-
+            _xSweepSpikeNumber = self.ba.getStat('sweepSpikeNumber', sweepNumber=self.sweepNumber)
+            
             # get the abs spike numbers we are showing
-            _xSpikeNumber = self.ba.getStat("spikeNumber", sweepNumber=self.sweepNumber)
-
+            _xSpikeNumber = self.ba.getStat('spikeNumber', sweepNumber=self.sweepNumber)
+            
             # convert abs spike number (across sweeps) to relative to one sweep
-            _sweepSpikeList = [
-                _sweepIdx for _sweepIdx, x in enumerate(_xSpikeNumber) if x in spikeList
-            ]
+            _sweepSpikeList = [_sweepIdx for _sweepIdx,x in enumerate(_xSpikeNumber) if x in spikeList]
 
             # logger.info('xxx')
             # print('spikeList:', spikeList)
             # print('_sweepSpikeList:', _sweepSpikeList)
 
-            xPlot, yPlot = self.ba.getStat(
-                "peakSec", "peakVal", sweepNumber=self.sweepNumber
-            )
+            xPlot, yPlot = self.ba.getStat('peakSec', 'peakVal', sweepNumber=self.sweepNumber)
             xPlot = np.array(xPlot)
             yPlot = np.array(yPlot)
-            # try:
+            #try:
             if 1:
                 x = xPlot[_sweepSpikeList]
                 y = yPlot[_sweepSpikeList]
             # except (IndexError) as e:
             #     # TODO: Cludge to handle spike selection (in a plugin) but we are not looking at that sweep
             #     # see selectSpike()
             #     # sweepSpikeNumber = self.ba.getSweepSpikeFromAbsolute(spikeNumber, sweep)
             #     logger.warning(f'  We are not looking at the correct sweep, self.sweepNumber:{self.sweepNumber}')
             #     return
 
-            # make selection symbol match user type
-            # remember, not all selected spikes are in the sweep we are showing
-            _plotMarkerDict = sanpy.interface.plugins.getPlotMarkersAndColors(self.ba, _sweepSpikeList)
-            markerList_pg = _plotMarkerDict['markerList_pg']
-
         self._selectedSpikeList = spikeList
 
         self.mySpikeListScatterPlot.setData(x=x, y=y)
-        
-        # set symbol for userType
-        if markerList_pg is not None:
-            self.mySpikeListScatterPlot.setSymbol(markerList_pg)
 
         # TODO: I don't think anybody is listening to this
         if doEmit:
             if self._blockSlots:
                 return
             self._blockSlots = True
             eDict = {
-                "spikeList": spikeList,
-                "doZoom": doZoom,
-                "ba": self.ba,
+                'spikeList': spikeList,
+                'doZoom': doZoom,
+                'ba': self.ba,
             }
-            logger.info(f"  -->> emit signalSelectSpikeList eDict")
+            logger.info(f'  -->> emit signalSelectSpikeList eDict:{eDict}')
             self.signalSelectSpikeList.emit(eDict)
             self._blockSlots = False
 
-    def _old_refreshClips(self, xMin=None, xMax=None):
+    def old_refreshClips(self, xMin=None, xMax=None):
+
         if not self.clipPlot.isVisible():
             # clips are not being displayed
-            # logger.info('Clips not visible --- RETURNING')
+            #logger.info('Clips not visible --- RETURNING')
             return
 
-        logger.info("")
+        logger.info('')
 
         # always remove existing
         # if there are no clips and we bail we will at least clear display
         self.clipPlot.clear()
 
-        # if self.clipLines is not None:
+        #if self.clipLines is not None:
         #    self.clipPlot.removeItem(self.clipLines)
-        # if self.meanClipLine is not None:
+        #if self.meanClipLine is not None:
         #    self.clipPlot.removeItem(self.meanClipLine)
 
         if self.ba is None:
             return
 
         if self.ba.numSpikes == 0:
             return
 
         # this returns x-axis in ms
-        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(
-            xMin, xMax, sweepNumber=self.sweepNumber
-        )
+        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(xMin, xMax, sweepNumber=self.sweepNumber)
 
         # convert clips to 2d ndarray ???
         xTmp = np.array(theseClips_x)
-        # xTmp /= self.ba.dataPointsPerMs # pnt to ms
+        #xTmp /= self.ba.dataPointsPerMs # pnt to ms
         xTmp /= self.ba.fileLoader.dataPointsPerMs * 1000  # pnt to seconds
         yTmp = np.array(theseClips)
 
-        # print('refreshClips() xTmp:', xTmp.shape)
-        # print('refreshClips() yTmp:', yTmp.shape)
+        #print('refreshClips() xTmp:', xTmp.shape)
+        #print('refreshClips() yTmp:', yTmp.shape)
 
-        self.clipLines = MultiLine(xTmp, yTmp, self, allowXAxisDrag=False, type="clip")
+        self.clipLines = MultiLine(xTmp, yTmp, self, allowXAxisDrag=False, type='clip')
         self.clipPlot.addItem(self.clipLines)
 
-        # print(xTmp.shape) # (num spikes, time)
+        #print(xTmp.shape) # (num spikes, time)
         self.xMeanClip = xTmp
         if len(self.xMeanClip) > 0:
-            self.xMeanClip = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+            self.xMeanClip = np.nanmean(xTmp, axis=0) # xTmp is in ms
         self.yMeanClip = yTmp
         if len(self.yMeanClip) > 0:
             self.yMeanClip = np.nanmean(yTmp, axis=0)
-        self.meanClipLine = MultiLine(
-            self.xMeanClip, self.yMeanClip, self, allowXAxisDrag=False, type="meanclip"
-        )
+        self.meanClipLine = MultiLine(self.xMeanClip, self.yMeanClip, self, allowXAxisDrag=False, type='meanclip')
         self.clipPlot.addItem(self.meanClipLine)
 
     def toggleInterface(self, item, on):
-        """Visually toggle different portions of interface"""
-        # print('toggle_Interface()', item, on)
-        # if item == 'Clips':
+        """Visually toggle different portions of interface
+        """
+        #print('toggle_Interface()', item, on)
+        #if item == 'Clips':
         #    #self.toggleClips(on)
         #    if self.myMainWindow is not None:
         #        #self.myMainWindow.toggleStatisticsPlot(on)
         #        self.myMainWindow.preferencesSet('display', 'showClips', on)
         #    if on:
         #        self.clipPlot.show()
         #        self.refreshClips() # refresh if they exist (e.g. analysis has been done)
         #    else:
         #        self.clipPlot.hide()
-        """
+        '''
         if item == 'dV/dt':
             #self.toggle_dvdt(on)
             if self.myMainWindow is not None:
                 #self.myMainWindow.toggleStatisticsPlot(on)
                 self.myMainWindow.preferencesSet('display', 'showDvDt', on)
             if on:
                 self.derivPlot.show()
@@ -1265,99 +1121,99 @@
             if self.myMainWindow is not None:
                 #self.myMainWindow.toggleStatisticsPlot(on)
                 self.myMainWindow.preferencesSet('display', 'showGlobalVm', on)
             if on:
                 self.vmPlotGlobal.show()
             else:
                 self.vmPlotGlobal.hide()
-        """
+        '''
 
-        if item == "Full Recording":
+        if item == 'Full Recording':
             if on:
                 self.vmPlotGlobal.show()
             else:
                 self.vmPlotGlobal.hide()
-        elif item == "Derivative":
+        elif item == 'Derivative':
             if on:
                 self.derivPlot.show()
             else:
                 self.derivPlot.hide()
-        elif item == "DAC":
+        elif item == 'DAC':
             if on:
                 self.dacPlot.show()
             else:
                 self.dacPlot.hide()
 
         # toggle in myDetectionToolbarWidget
-        elif item == "Detection Panel":
+        elif item == 'Detection Panel':
             if on:
                 self.detectToolbarWidget.show()
             else:
                 self.detectToolbarWidget.hide()
-        elif item == "Detection":
+        elif item == 'Detection':
             self.detectToolbarWidget.toggleInterface(item, on)
-        elif item == "Display":
+        elif item == 'Display':
             self.detectToolbarWidget.toggleInterface(item, on)
-        elif item == "Plot Options":
+        elif item == 'Plot Options':
             self.detectToolbarWidget.toggleInterface(item, on)
-        elif item == "Set Spikes":
+        elif item == 'Set Spikes':
             self.detectToolbarWidget.toggleInterface(item, on)
 
         else:
             # Toggle overlay of stats like (TOP, spike peak, half-width, ...)
-            self.togglePlot(item, on)  # assuming item is int !!!
+            self.togglePlot(item, on) # assuming item is int !!!
 
-    def _old_kymographChanged(self, event):
+    def old_kymographChanged(self, event):
         """
         User finished gragging the ROI
 
         Args:
             event (pyqtgraph.graphicsItems.ROI.ROI)
         """
-        logger.info("")
-        # print(event)
+        logger.info('')
+        #print(event)
         pos = event.pos()
         size = event.size()
-        # print(pos, size)
+        #print(pos, size)
 
-        # imagePos = self.myImageItem.mapFromScene(event.scenePos())
-        # imageSize = self.myImageItem.mapFromScene(event.size())
-        # print('  imagePos:', imagePos, 'imageSize:', imageSize)
+        #imagePos = self.myImageItem.mapFromScene(event.scenePos())
+        #imageSize = self.myImageItem.mapFromScene(event.size())
+        #print('  imagePos:', imagePos, 'imageSize:', imageSize)
 
         left, top, right, bottom = None, None, None, None
         handles = event.getSceneHandlePositions()
         for handle in handles:
             if handle[0] is not None:
                 imagePos = self.myImageItem.mapFromScene(handle[1])
                 x = imagePos.x()
                 y = imagePos.y()
                 # units are in image pixels !!!
-                # print(handle[0], 'x:', x, 'y:', y)
-                if handle[0] == "topleft":
+                #print(handle[0], 'x:', x, 'y:', y)
+                if handle[0] == 'topleft':
                     left = x
                     bottom = y
-                    # top = y
-                elif handle[0] == "bottomright":
+                    #top = y
+                elif handle[0] == 'bottomright':
                     right = x
                     top = y
-                    # bottom = y
+                    #bottom = y
         #
         left = int(left)
         top = int(top)
         right = int(right)
         bottom = int(bottom)
 
-        if left < 0:
+        if left<0:
             left = 0
 
-        print(f"  left:{left} top:{top} right:{right} bottom:{bottom}")
+        print(f'  left:{left} top:{top} right:{right} bottom:{bottom}')
 
         #  cludge
         if bottom > top:
-            logger.warning(f"fixing bad top/bottom")
+            logger.warning(f'fixing bad top/bottom')
             tmp = top
             top = bottom
             bottom = tmp
 
         theRect = [left, top, right, bottom]
         self.ba._updateTifRoi(theRect)
 
@@ -1372,52 +1228,51 @@
     def _buildUI(self):
         self.mySetTheme(doReplot=False)
 
         # left is toolbar, right is PYQtGraph (self.view)
         self.myHBoxLayout_detect = QtWidgets.QHBoxLayout(self)
         self.myHBoxLayout_detect.setAlignment(QtCore.Qt.AlignTop)
 
-        # hSplitter gets added to h layout
-        # then we add left/right widgets to the splitter
-        _hSplitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
-
         # detection widget toolbar
+        # abb 20201110, switching over to a better layout
+        #self.detectToolbarWidget = myDetectToolbarWidget(self.myPlots, self)
+        #self.myHBoxLayout_detect.addLayout(self.detectToolbarWidget, stretch=1) # stretch=10, not sure on the units???
         self.detectToolbarWidget = myDetectToolbarWidget2(self.myPlots, self)
         self.signalSelectSpike.connect(self.detectToolbarWidget.slot_selectSpike)
-        self.signalSelectSpikeList.connect(
-            self.detectToolbarWidget.slot_selectSpikeList
-        )
-
-        # v1
-        self.myHBoxLayout_detect.addWidget(self.detectToolbarWidget)
-        # v2
-        # _hSplitter.addWidget(self.detectToolbarWidget)
-        # self.myHBoxLayout_detect.addWidget(_hSplitter)
+        self.signalSelectSpikeList.connect(self.detectToolbarWidget.slot_selectSpikeList)
+        #if self.myMainWindow is not None:
+        #    self.detectToolbarWidget.signalSelectSpike.connect(self.myMainWindow.slotSelectSpike)
+
+        # was this
+        #self.myHBoxLayout_detect.addWidget(self.detectToolbarWidget, stretch=1) # stretch=10, not sure on the units???
+        self.myHBoxLayout_detect.addWidget(self.detectToolbarWidget) # stretch=10, not sure on the units???
 
         # kymograph, we need a vboxlayout to hollder (kym widget, self.view)
         vBoxLayoutForPlot = QtWidgets.QVBoxLayout(self)
 
-        # for publication, don't do kymographs
-        # make a branch and get this working
-        if 0:
-            self.myKymWidget = sanpy.interface.kymographWidget()
-            self.myKymWidget.signalKymographRoiChanged.connect(self.slot_kymographChanged)
-            self.myKymWidget.setVisible(False)
-            self.myKymWidget.showLineSlider(False)
-            vBoxLayoutForPlot.addWidget(self.myKymWidget)
+        self.myKymWidget = sanpy.interface.kymographWidget()
+        self.myKymWidget.signalKymographRoiChanged.connect(self.slot_kymographChanged)
+        self.myKymWidget.setVisible(False)
+        self.myKymWidget.showLineSlider(False)
+        vBoxLayoutForPlot.addWidget(self.myKymWidget)
 
         # was this
         self.view = pg.GraphicsLayoutWidget()
+
+        #self.view.scene().sigMouseClicked.connect(self.tmpOnClick)
+
+        # works but does not stick
+        #self.view.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
         self.view.show()
 
         row = 0
         colSpan = 1
 
         # Kymograph, always build (hidden) and show/hide in replot based on self.ba.isKymograph
-        """
+        '''
         rowSpan = 1
         self.kymographPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.kymographPlot.enableAutoRange()
         # turn off x/y dragging of deriv and vm
         self.kymographPlot.setMouseEnabled(x=False, y=False)
         # hide the little 'A' button to rescale axis
         self.kymographPlot.hideButtons()
@@ -1428,728 +1283,583 @@
 
         #if self.ba.isKymograph():
         #    myTif = self.ba.tifData
         #    self.myImageItem = kymographImage(myTif, axisOrder='row-major',
         #                        rect=[0,0, self.ba.recordingDur, self.ba.tifData.shape[0]])
 
         row += rowSpan
-        """
+        '''
 
-        # addPlot return a plotItem
+        #
         rowSpan = 1
-        self.vmPlotGlobal = self.view.addPlot(
-            row=row, col=0, rowSpan=rowSpan, colSpan=colSpan
-        )
-
+        self.vmPlotGlobal = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.vmPlotGlobal.enableAutoRange()
         row += rowSpan
         rowSpan = 1
-        self.derivPlot = self.view.addPlot(
-            row=row, col=0, rowSpan=rowSpan, colSpan=colSpan
-        )
-
+        self.derivPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.derivPlot.enableAutoRange()
         row += rowSpan
         rowSpan = 1
-        self.dacPlot = self.view.addPlot(
-            row=row, col=0, rowSpan=rowSpan, colSpan=colSpan
-        )
+        self.dacPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.dacPlot.enableAutoRange()
-
         row += rowSpan
         rowSpan = 2  # make Vm plot taller than others
-        self.vmPlot = self.view.addPlot(
-            row=row, col=0, rowSpan=rowSpan, colSpan=colSpan
-        )
+        self.vmPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.vmPlot.enableAutoRange()
-
-        # show hover text when showing crosshairs
-        self._displayHoverText= pg.TextItem(text='xxx hover', color=(200,200,200), anchor=(1,1))
-        self._displayHoverText.hide()
-        self.vmPlot.addItem(self._displayHoverText)
-
-        self._displayHoverText_deriv = pg.TextItem(text='xxx hover', color=(200,200,200), anchor=(1,1))
-        self._displayHoverText_deriv.hide()
-        self.derivPlot.addItem(self._displayHoverText_deriv)
-
-        # row += rowSpan
-        # rowSpan = 1
-        # self.clipPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
+        #row += rowSpan
+        #rowSpan = 1
+        #self.clipPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
 
         # link x-axis
-        # self.derivPlot.setXLink(self.vmPlot)
-        # self.dacPlot.setXLink(self.vmPlot)
-        # self.myKymWidget.kymographPlot.setXLink(self.vmPlot)  # row major is different
+        #self.derivPlot.setXLink(self.vmPlot)
+        #self.dacPlot.setXLink(self.vmPlot)
+        #self.myKymWidget.kymographPlot.setXLink(self.vmPlot)  # row major is different
 
         #
         # mouse crosshair
-        # crosshairPlots = ['derivPlot', 'dacPlot', 'vmPlot', 'clipPlot']
-        crosshairPlots = ["derivPlot", "dacPlot", "vmPlot"]
+        #crosshairPlots = ['derivPlot', 'dacPlot', 'vmPlot', 'clipPlot']
+        crosshairPlots = ['derivPlot', 'dacPlot', 'vmPlot']
         self.crosshairDict = {}
         for crosshairPlot in crosshairPlots:
             self.crosshairDict[crosshairPlot] = {
-                "h": pg.InfiniteLine(angle=0, movable=False),
-                "v": pg.InfiniteLine(angle=90, movable=False),
+                'h': pg.InfiniteLine(angle=0, movable=False),
+                'v': pg.InfiniteLine(angle=90, movable=False)
             }
             # start hidden
-            self.crosshairDict[crosshairPlot]["h"].hide()
-            self.crosshairDict[crosshairPlot]["v"].hide()
+            self.crosshairDict[crosshairPlot]['h'].hide()
+            self.crosshairDict[crosshairPlot]['v'].hide()
 
             # add h/v to appropriate plot
-            if crosshairPlot == "derivPlot":
-                self.derivPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["h"], ignoreBounds=True
-                )
-                self.derivPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["v"], ignoreBounds=True
-                )
-            elif crosshairPlot == "dacPlot":
-                self.dacPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["h"], ignoreBounds=True
-                )
-                self.dacPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["v"], ignoreBounds=True
-                )
-            elif crosshairPlot == "vmPlot":
-                self.vmPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["h"], ignoreBounds=True
-                )
-                self.vmPlot.addItem(
-                    self.crosshairDict[crosshairPlot]["v"], ignoreBounds=True
-                )
-            # elif crosshairPlot == 'clipPlot':
+            if crosshairPlot == 'derivPlot':
+                self.derivPlot.addItem(self.crosshairDict[crosshairPlot]['h'], ignoreBounds=True)
+                self.derivPlot.addItem(self.crosshairDict[crosshairPlot]['v'], ignoreBounds=True)
+            elif crosshairPlot == 'dacPlot':
+                self.dacPlot.addItem(self.crosshairDict[crosshairPlot]['h'], ignoreBounds=True)
+                self.dacPlot.addItem(self.crosshairDict[crosshairPlot]['v'], ignoreBounds=True)
+            elif crosshairPlot == 'vmPlot':
+                self.vmPlot.addItem(self.crosshairDict[crosshairPlot]['h'], ignoreBounds=True)
+                self.vmPlot.addItem(self.crosshairDict[crosshairPlot]['v'], ignoreBounds=True)
+            #elif crosshairPlot == 'clipPlot':
             #    self.clipPlot.addItem(self.crosshairDict[crosshairPlot]['h'], ignoreBounds=True)
             #    self.clipPlot.addItem(self.crosshairDict[crosshairPlot]['v'], ignoreBounds=True)
             else:
-                logger.error(f"case not taken for crosshairPlot: {crosshairPlot}")
+                logger.error(f'case not taken for crosshairPlot: {crosshairPlot}')
 
         #
         # epoch as vertical lines
         # we don't know the number of epochs until we have a ba?
 
         # trying to implement mouse moved events
-        self.myProxy = pg.SignalProxy(
-            self.vmPlot.scene().sigMouseMoved, rateLimit=60, slot=self._myMouseMoved
-        )
-        # self.vmPlot.scene().sigMouseMoved.connect(self._myMouseMoved)
+        self.myProxy = pg.SignalProxy(self.vmPlot.scene().sigMouseMoved, rateLimit=60, slot=self.myMouseMoved)
+        #self.vmPlot.scene().sigMouseMoved.connect(self.myMouseMoved)
 
         # does not have setStyleSheet
-        # self.derivPlot.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
+        #self.derivPlot.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
 
         # hide the little 'A' button to rescale axis
         self.vmPlotGlobal.hideButtons()
         self.derivPlot.hideButtons()
         self.dacPlot.hideButtons()
         self.vmPlot.hideButtons()
-        # self.clipPlot.hideButtons()
+        #self.clipPlot.hideButtons()
 
         # turn off right-click menu
         self.vmPlotGlobal.setMenuEnabled(False)
         self.derivPlot.setMenuEnabled(False)
         self.dacPlot.setMenuEnabled(False)
         self.vmPlot.setMenuEnabled(False)
+        #self.clipPlot.setMenuEnabled(False)
 
         # 20221003 just link everything to vmPlot
+        # link x-axis of deriv and vm
+        # self.derivPlot.setXLink(self.vmPlot)
+        # self.derivPlot.setXLink(self.dacPlot)
+        # self.dacPlot.setXLink(self.derivPlot)
+        # self.dacPlot.setXLink(self.vmPlot)
+        # self.vmPlot.setXLink(self.derivPlot)
+        # self.vmPlot.setXLink(self.dacPlot)
         self.derivPlot.setXLink(self.vmPlot)
         self.dacPlot.setXLink(self.vmPlot)
 
+        #self.myKymWidget.kymographPlot.setXLink(self.vmPlot)  # row major is different
+
+        #
+        #self.kymographPlot.setXLink(self.vmPlot)  # TODO: need to set scale of kymograph x-axis
+        #self.kymographPlot.setXLink(self.derivPlot)
+
         # turn off x/y dragging of deriv and vm
-        self.vmPlotGlobal.setMouseEnabled(x=True, y=False)
-        self.derivPlot.setMouseEnabled(x=True, y=False)
-        self.dacPlot.setMouseEnabled(x=True, y=False)
-        self.vmPlot.setMouseEnabled(x=True, y=False)
+        self.vmPlotGlobal.setMouseEnabled(x=False, y=False)
+        self.derivPlot.setMouseEnabled(x=False, y=False)
+        self.dacPlot.setMouseEnabled(x=False, y=False)
+        self.vmPlot.setMouseEnabled(x=False, y=False)
+        #self.clipPlot.setMouseEnabled(x=False, y=False)
 
+        #self.toggleClips(False)
 
         # single spike selection
         # removed mar 11 2023
         # color = 'y'
         # symbol = 'x'
         # size = 20
         # self.mySingleSpikeScatterPlot = pg.ScatterPlotItem(pen=pg.mkPen(width=2, color=color), symbol=symbol, size=size)
         # self.vmPlot.addItem(self.mySingleSpikeScatterPlot)
 
         # mult spike selection (spikeList)
         # TODO: make sure this on top of the plot of analysis results
-        color = "y"
-        symbol = "o"
+        color = 'y'
+        symbol = 'o'
         size = 12
-        self.mySpikeListScatterPlot = pg.ScatterPlotItem(
-            pen=pg.mkPen(width=2, color=color), symbol=symbol, size=size
-        )
+        self.mySpikeListScatterPlot = pg.ScatterPlotItem(pen=pg.mkPen(width=2, color=color), symbol=symbol, size=size)
         self.vmPlot.addItem(self.mySpikeListScatterPlot)
 
-        # TODO: add this to application options
-        _defaultScatterCircleSize = 8  # 6
-        
         # add all overlaid scatter plots
-        self.myPlotList = []  # list of pg.ScatterPlotItem
+        self.myPlotList = [] # list of pg.ScatterPlotItem
         for idx, plot in enumerate(self.myPlots):
-            color = plot["color"]
-            symbol = plot["symbol"]
-            humanName = plot["humanName"]
-            if humanName in ["Half-Widths"]:
+            color = plot['color']
+            symbol = plot['symbol']
+            humanName = plot['humanName']
+            if humanName in ['Half-Widths']:
                 # PlotCurveItem
                 # default is no symbol
-                myScatterPlot = pg.PlotDataItem(
-                    pen=pg.mkPen(width=2, color=color), connect="finite"
-                )
-            elif humanName in ["Epoch Lines"]:
-                # TODO: this is causing an error on linux after pip install sanpy-ephys[gui]
-                # TODO: clone sanpy repo on linux and troubleshoot (do not go through the whole PyPi workflow
-                myScatterPlot = pg.PlotDataItem(
-                    pen=pg.mkPen(width=2, color=color, style=QtCore.Qt.DashLine),
-                    connect="finite",
-                )  # default is no symbol
-            elif humanName == "EDD Rate":
+                myScatterPlot = pg.PlotDataItem(pen=pg.mkPen(width=2, color=color), connect='finite')
+            elif humanName in ['Epoch Lines']:
+                myScatterPlot = pg.PlotDataItem(pen=pg.mkPen(width=1, color=color, style=QtCore.Qt.DashLine), connect='finite') # default is no symbol
+            elif humanName == 'EDD Rate':
                 # edd rate is a dashed line showing slope/rate of edd
-                myScatterPlot = pg.PlotDataItem(
-                    pen=pg.mkPen(width=2, color=color, style=QtCore.Qt.DashLine),
-                    connect="finite",
-                )  # default is no symbol
-            else:
-                myScatterPlot = pg.PlotDataItem(
-                    pen=None,
-                    symbol=symbol,
-                    symbolSize=_defaultScatterCircleSize,
-                    symbolPen=None,
-                    symbolBrush=color,
-                )
-                myScatterPlot.setData(x=[], y=[])  # start empty
-                if humanName in ["Threshold (mV)", "AP Peak (mV)"]:
+                myScatterPlot = pg.PlotDataItem(pen=pg.mkPen(width=2, color=color, style=QtCore.Qt.DashLine), connect='finite') # default is no symbol
+            else:
+                myScatterPlot = pg.PlotDataItem(pen=None, symbol=symbol, symbolSize=6, symbolPen=None, symbolBrush=color)
+                myScatterPlot.setData(x=[], y=[]) # start empty
+                if humanName in ['Threshold (mV)', 'AP Peak (mV)']:
                     myScatterPlot.sigPointsClicked.connect(self.on_scatterClicked)
 
             self.myPlotList.append(myScatterPlot)
 
             # add plot to pyqtgraph
-            if plot["plotOn"] == "vm":
+            if plot['plotOn'] == 'vm':
                 self.vmPlot.addItem(myScatterPlot)
-            elif plot["plotOn"] == "vmGlobal":
+            elif plot['plotOn'] == 'vmGlobal':
                 self.vmPlotGlobal.addItem(myScatterPlot)
-            elif plot["plotOn"] == "dvdt":
+            elif plot['plotOn'] == 'dvdt':
                 self.derivPlot.addItem(myScatterPlot)
 
-        self.replotOverlays()
+        # axis labels
+        # TODO (cudmore) get the units correct, grab from y-axis of abf file
+        # 20221003 was this, on removal different y-axis label withs (x axis aligns correctly) ???
+        # self.vmPlotGlobal.getAxis('left').setLabel('mV')
+        # self.derivPlot.getAxis('left').setLabel('Derivative')
+        # self.dacPlot.getAxis('left').setLabel('DAC')
+        # self.vmPlot.getAxis('left').setLabel('mV')
+        # self.vmPlot.getAxis('bottom').setLabel('Seconds')
+
+        self.replot()
 
+        # kymograph
+        #tmpVLayout = QtWidgets.QVBoxLayout()
         vBoxLayoutForPlot.addWidget(self.view)
 
-        # v1
         self.myHBoxLayout_detect.addLayout(vBoxLayoutForPlot)
-        # v2
-        # _tmpSplitterWidget = QtWidgets.QWidget()
-        # _tmpSplitterWidget.setLayout(vBoxLayoutForPlot)
-        # _hSplitter.addWidget(_tmpSplitterWidget)
 
-    def toggleCrosshair(self, onOff):
-        """Toggle mouse crosshair on and off.
-        """
-        self._showCrosshair = onOff
-        if onOff:
-            self._displayHoverText.show()
-            self._displayHoverText_deriv.show()
-        else:
-            self._displayHoverText.hide()
-            self._displayHoverText_deriv.hide()
+        # was this, switchin to kym
+        #self.myHBoxLayout_detect.addWidget(self.view)
+
 
+    def toggleCrosshair(self, onOff):
         for plotName in self.crosshairDict.keys():
-            self.crosshairDict[plotName]["h"].setVisible(onOff)
-            self.crosshairDict[plotName]["v"].setVisible(onOff)
+            self.crosshairDict[plotName]['h'].setVisible(onOff)
+            self.crosshairDict[plotName]['v'].setVisible(onOff)
 
-    def _myMouseMoved(self, event):
+    def myMouseMoved(self, event):
         """Respond to mouse moves.
-
+        
             Update cursor position
             If crosshair is visible, update that too.
-
+        
         Args:
             event: PyQt5.QtCore.QPointF
         """
 
         # looking directly at checkbox in myDetectionToolbarWidget2
         # _crossHairIsOn = self.detectToolbarWidget.crossHairCheckBox.isChecked()
-       #if not self.detectToolbarWidget.crossHairCheckBox.isChecked():
-        if not self._showCrosshair:
+        if not self.detectToolbarWidget.crossHairCheckBox.isChecked():
             return
 
         pos = event[0]  ## using signal proxy turns original arguments into a tuple
 
         x = None
         y = None
         mousePoint = None
         inPlot = None
         if self.derivPlot.sceneBoundingRect().contains(pos):
             # deriv
-            inPlot = "derivPlot"
-            self.crosshairDict[inPlot]["h"].show()
-            self.crosshairDict[inPlot]["v"].show()
+            inPlot = 'derivPlot'
+            self.crosshairDict[inPlot]['h'].show()
+            self.crosshairDict[inPlot]['v'].show()
             mousePoint = self.derivPlot.vb.mapSceneToView(pos)
             # hide the horizontal in dacPlot
-            self.crosshairDict["dacPlot"]["v"].show()
-            self.crosshairDict["dacPlot"]["h"].hide()
+            self.crosshairDict['dacPlot']['v'].show()
+            self.crosshairDict['dacPlot']['h'].hide()
             # hide the horizontal in vmPlot
-            self.crosshairDict["vmPlot"]["v"].show()
-            self.crosshairDict["vmPlot"]["h"].hide()
-
-            x = mousePoint.x()
-            y = mousePoint.y()
-
-            x = round(x,4)
-            y = round(y,4)
-
-            if self._showCrosshair:
-                _hoverText = f'x:{x} \n y:{y}'
-                self._displayHoverText_deriv.setText(_hoverText)
-                self._displayHoverText_deriv.setPos(x, y)
+            self.crosshairDict['vmPlot']['v'].show()
+            self.crosshairDict['vmPlot']['h'].hide()
 
         elif self.dacPlot.sceneBoundingRect().contains(pos):
             # dac
-            inPlot = "dacPlot"
-            self.crosshairDict[inPlot]["h"].show()
-            self.crosshairDict[inPlot]["v"].show()
+            inPlot = 'dacPlot'
+            self.crosshairDict[inPlot]['h'].show()
+            self.crosshairDict[inPlot]['v'].show()
             mousePoint = self.dacPlot.vb.mapSceneToView(pos)
             # hide the horizontal in derivPlot
-            self.crosshairDict["derivPlot"]["v"].show()
-            self.crosshairDict["derivPlot"]["h"].hide()
+            self.crosshairDict['derivPlot']['v'].show()
+            self.crosshairDict['derivPlot']['h'].hide()
             # hide the horizontal in vmPlot
-            self.crosshairDict["vmPlot"]["v"].show()
-            self.crosshairDict["vmPlot"]["h"].hide()
+            self.crosshairDict['vmPlot']['v'].show()
+            self.crosshairDict['vmPlot']['h'].hide()
 
         elif self.vmPlot.sceneBoundingRect().contains(pos):
             # vm
-            inPlot = "vmPlot"
-            self.crosshairDict[inPlot]["h"].show()
-            self.crosshairDict[inPlot]["v"].show()
+            inPlot = 'vmPlot'
+            self.crosshairDict[inPlot]['h'].show()
+            self.crosshairDict[inPlot]['v'].show()
             mousePoint = self.vmPlot.vb.mapSceneToView(pos)
             # hide the horizontal in dacPlot
-            self.crosshairDict["dacPlot"]["v"].show()
-            self.crosshairDict["dacPlot"]["h"].hide()
+            self.crosshairDict['dacPlot']['v'].show()
+            self.crosshairDict['dacPlot']['h'].hide()
             # hide the horizontal in derivPlot
-            self.crosshairDict["derivPlot"]["v"].show()
-            self.crosshairDict["derivPlot"]["h"].hide()
-
-            #
-            # 20230419 implementing mouse hover tooltip
-            # moved to _buildUI()
-            # self._displayHoverText= pg.TextItem(text='444',color=(176,23,31),anchor=(1,1))
-            # self.vmPlot.addItem(self._displayHoverText)
-
-            if self._showCrosshair:
-                x = mousePoint.x()
-                y = mousePoint.y()
-
-                x = round(x,4)
-                y = round(y,4)
-
-                _hoverText = f'x:{x} \n y:{y}'
-                self._displayHoverText.setText(_hoverText)
-                self._displayHoverText.setPos(x, y)
+            self.crosshairDict['derivPlot']['v'].show()
+            self.crosshairDict['derivPlot']['h'].hide()
 
-        # elif self.clipPlot.sceneBoundingRect().contains(pos):
+        #elif self.clipPlot.sceneBoundingRect().contains(pos):
         #    # clip
         #    inPlot = 'clipPlot'
         #    self.crosshairDict[inPlot]['h'].show()
         #    self.crosshairDict[inPlot]['v'].show()
         #    mousePoint = self.clipPlot.vb.mapSceneToView(pos)
         #    # hide the horizontal/vertical in both derivPlot and vmPlot
 
         if inPlot is not None and mousePoint is not None:
-            self.crosshairDict[inPlot]["h"].setPos(mousePoint.y())
-            self.crosshairDict[inPlot]["v"].setPos(mousePoint.x())
+            self.crosshairDict[inPlot]['h'].setPos(mousePoint.y())
+            self.crosshairDict[inPlot]['v'].setPos(mousePoint.x())
 
-        if inPlot == "derivPlot":
-            self.crosshairDict["dacPlot"]["v"].setPos(mousePoint.x())
-            self.crosshairDict["vmPlot"]["v"].setPos(mousePoint.x())
-            if self._showCrosshair:
-                self._displayHoverText_deriv.show()
-                self._displayHoverText.hide()
-
-        elif inPlot == "dacPlot":
-            self.crosshairDict["derivPlot"]["v"].setPos(mousePoint.x())
-            self.crosshairDict["vmPlot"]["v"].setPos(mousePoint.x())
-            self._displayHoverText.hide()
-            if self._showCrosshair:
-                self._displayHoverText_deriv.hide()
-                self._displayHoverText.hide()
-
-        if inPlot == "vmPlot":
-            self.crosshairDict["derivPlot"]["v"].setPos(mousePoint.x())
-            self.crosshairDict["dacPlot"]["v"].setPos(mousePoint.x())
-            if self._showCrosshair:
-                self._displayHoverText_deriv.hide()
-                self._displayHoverText.show()
-
-        # if mousePoint is not None:
-        #     x = mousePoint.x()
-        #     y = mousePoint.y()
+        if inPlot == 'derivPlot':
+            self.crosshairDict['dacPlot']['v'].setPos(mousePoint.x())
+            self.crosshairDict['vmPlot']['v'].setPos(mousePoint.x())
+        elif inPlot == 'dacPlot':
+            self.crosshairDict['derivPlot']['v'].setPos(mousePoint.x())
+            self.crosshairDict['vmPlot']['v'].setPos(mousePoint.x())
+        if inPlot == 'vmPlot':
+            self.crosshairDict['derivPlot']['v'].setPos(mousePoint.x())
+            self.crosshairDict['dacPlot']['v'].setPos(mousePoint.x())
 
-        # x/y can still be None
-        # removed 20230419 on adding _displayHoverText
-        # self.detectToolbarWidget.setMousePositionLabel(x, y)
+        if mousePoint is not None:
+            x = mousePoint.x()
+            y = mousePoint.y()
 
-        # _hoverText = f'x:{x} \n y:{y}'
-        # self._displayHoverText.setText(_hoverText)
-        # self._displayHoverText.setPos(mousePoint.x(), mousePoint.y())
+        # x/y can still be None
+        self.detectToolbarWidget.setMousePositionLabel(x,y)
 
     def keyPressEvent(self, event):
         """Respond to user key press.
-
+        
         Parameters
         ----------
         event : PyQt5.QtGui.QKeyEvent
         """
         key = event.key()
         text = event.text()
-        logger.info(f"bDetectionWidget key:{key} text:{text}")
+        logger.info(f'bDetectionWidget key:{key} text:{text}')
 
         # handled in 'View' menu
-        # if text == 'h':
+        #if text == 'h':
         # if key == QtCore.Qt.Key_H:
         #     if self.detectToolbarWidget.isVisible():
         #         self.detectToolbarWidget.hide()
         #     else:
         #         self.detectToolbarWidget.show()
 
         # if text == 'a':
         if key in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]:
-            # self.detectToolbarWidget.keyPressEvent(event)
+            #self.detectToolbarWidget.keyPressEvent(event)
             self.setAxisFull()
 
         elif key == QtCore.Qt.Key.Key_Escape:
-            self.myMainWindow.mySignal("cancel all selections")
+            self.myMainWindow.mySignal('cancel all selections')
 
-        elif key in [QtCore.Qt.Key.Key_Plus, QtCore.Qt.Key.Key_Equal]:
-            self._pgPointSize *= 5
-            logger.info(f'_pgPointSize:{self._pgPointSize}')
-            self._replot()
-        elif key in [QtCore.Qt.Key.Key_Minus]:
-            self._pgPointSize -= 10
-            if self._pgPointSize < 0:
-                self._pgPointSize = 0
-            logger.info(f'_pgPointSize:{self._pgPointSize}')
-            self._replot()
-
-        # elif key == QtCore.Qt.Key_C:
-        #     logger.warning("what was this for ??? responding to keyboard C ???")
-        #     # self.setSpikeStat()
+        elif key == QtCore.Qt.Key_C:
+            logger.warning('what was this for ??? responding to keyboard C ???')
+            #self.setSpikeStat()
 
-    def slot_setSpikeStat(self, setSpikeStatEvent: dict):
+    def slot_setSpikeStat(self, setSpikeStatEvent : dict):
         """Respond to changes from setSpikeStack plugin.
 
         Notes
         -----
         setSpikeStatEvent = {}
         setSpikeStatEvent['spikeList'] = self.getSelectedSpikes()
         setSpikeStatEvent['colStr'] = colStr
         setSpikeStatEvent['value'] = value
         """
-        logger.info(f"setSpikeStatEvent: {setSpikeStatEvent}")
-
-        spikeList = setSpikeStatEvent["spikeList"]
-        colStr = setSpikeStatEvent["colStr"]
-        value = setSpikeStatEvent["value"]
+        logger.info(f'setSpikeStatEvent: {setSpikeStatEvent}')
+        
+        spikeList = setSpikeStatEvent['spikeList']
+        colStr = setSpikeStatEvent['colStr']
+        value = setSpikeStatEvent['value']
 
         # set the stat
         self.ba.setSpikeStat(spikeList, colStr, value)
+        
+        logger.info(f'  -->> emit signalDetect')
+        self.signalDetect.emit(self.ba)  # underlying _abf has new rect
 
-        # logger.info(f"  -->> emit signalDetect")
-        # self.signalDetect.emit(self.ba)  # underlying _abf has new rect
 
-    def slot_selectSweep(self, sweep: int):
-        """Fake slot, not ising in emit/connect."""
+    def slot_selectSweep(self, sweep : int):
+        """Fake slot, not ising in emit/connect.
+        """
         self.selectSweep(sweep)
         self.detectToolbarWidget.slot_selectSweep(sweep)
 
     def slot_selectSpike(self, sDict):
-        logger.info(f"detection widget {sDict}")
-
-        spikeNumber = sDict["spikeNumber"]
-        doZoom = sDict["doZoom"]
+        logger.info(f'detection widget {sDict}')
 
+        spikeNumber = sDict['spikeNumber']
+        doZoom = sDict['doZoom']
+        
         # march 11, 2023 was this
         # this will set the correct sweep
         self.selectSpike(spikeNumber, doZoom=doZoom)
 
         if spikeNumber is None:
             spikeList = []
         else:
             spikeList = [spikeNumber]
-
-        spikeListDict = {"spikeList": spikeList, "doZoom": doZoom}
+        
+        spikeListDict = {
+            'spikeList': spikeList,
+            'doZoom': doZoom
+        }
         self.slot_selectSpikeList(spikeListDict)
 
     def slot_selectSpikeList(self, sDict):
-        # print('detectionWidget.slotSelectSpike() sDict:', sDict)
-        spikeList = sDict["spikeList"]
-        doZoom = sDict["doZoom"]
+        #print('detectionWidget.slotSelectSpike() sDict:', sDict)
+        spikeList = sDict['spikeList']
+        doZoom = sDict['doZoom']
         self.selectSpikeList(spikeList, doZoom=doZoom, doEmit=True)
 
         # mar 11
         # if spikeList == []:
         #     spikeNumber = 0
         # else:
         #     spikeNumber = spikeList[0]
         # self.selectSpike(spikeNumber, doZoom=doZoom)
 
-    def slot_switchFile(self, ba: sanpy.bAnalysis = None, tableRowDict: dict = None):
+    def slot_switchFile(self,
+                        ba : sanpy.bAnalysis = None,
+                        tableRowDict : dict = None):
         """Switch to a new file.
 
         Set self.ba to new bAnalysis object ba
 
         Can fail if .abf file is corrupt
 
         Parameters
         ----------
         tableRowDict :dict
         ba : sanpy.bAnalysis
 
         Returns: True/False
         """
-        logger.info(f"tableRowDict:{tableRowDict}")
-        logger.info(f"ba:{ba}")
+        logger.info(f'tableRowDict:{tableRowDict}')
+        logger.info(f'ba:{ba}')
 
         # bAnalysis object
         self.ba = ba
 
         if self.ba.loadError:
-            self.replotOverlays()
+            self.replot()
             fileName = self.ba.fileLoader.filename()  # tableRowDict['File']
             errStr = f'The bAnalysis file was flagged with loadError ... aborting: "{fileName}".'
             logger.error(errStr)
             self.updateStatusBar(errStr)
             return False
 
         # fill in detection parameters (dvdt, vm, start, stop)
-        startSec = ""
-        stopSec = ""
+        startSec = ''
+        stopSec = ''
         if tableRowDict is not None:
             self.detectToolbarWidget.slot_selectFile(tableRowDict)
-            self.fillInDetectionParameters(tableRowDict)  # fills in controls
-            # self.updateStatusBar(f'Plotting file {path}')
-            startSec = tableRowDict["Start(s)"]
-            stopSec = tableRowDict["Stop(s)"]
+            self.fillInDetectionParameters(tableRowDict) # fills in controls
+            #self.updateStatusBar(f'Plotting file {path}')
+            startSec = tableRowDict['Start(s)']
+            stopSec = tableRowDict['Stop(s)']
 
-        if startSec == "" or stopSec == "" or np.isnan(startSec) or np.isnan(stopSec):
+        if startSec=='' or stopSec=='' or np.isnan(startSec) or np.isnan(stopSec):
             startSec = 0
             stopSec = self.ba.fileLoader.recordingDur
 
         # cancel spike selection
-        self.selectSpikeList([])
-        # self.selectSpike(None)
-        # self.selectSpikeList(self._selectedSpikeList)
+        self.selectSpike(None)
 
         # set sweep to 0
-        self.selectSweep(0, startSec, stopSec, doEmit=False, doReplot=False)
+        self.selectSweep(0, startSec, stopSec, doEmit=False, doReplot=False) 
 
         # set full axis
         # abb 20220615
-        # self.setAxisFull()
+        #self.setAxisFull()
 
         # abb implement sweep, move to function()
-        # abb 20220615
+        #abb 20220615
         self._replot(startSec, stopSec)
 
-        # self.refreshClips(startSec, stopSec)
+        #self.refreshClips(startSec, stopSec)
 
         # update x/y axis labels
         yLabel = self.ba.fileLoader._sweepLabelY
-        self.dacPlot.getAxis("left").setLabel("DAC")
-        self.derivPlot.getAxis("left").setLabel("Derivative")
-        self.vmPlotGlobal.getAxis("left").setLabel(yLabel)
-        # self.vmPlotGlobal.getAxis('bottom').setLabel('Seconds')
-        self.vmPlot.getAxis("left").setLabel(yLabel)
-        self.vmPlot.getAxis("bottom").setLabel("Seconds")
+        self.dacPlot.getAxis('left').setLabel('DAC')
+        self.derivPlot.getAxis('left').setLabel('Derivative')
+        self.vmPlotGlobal.getAxis('left').setLabel(yLabel)
+        #self.vmPlotGlobal.getAxis('bottom').setLabel('Seconds')
+        self.vmPlot.getAxis('left').setLabel(yLabel)
+        self.vmPlot.getAxis('bottom').setLabel('Seconds')
 
-        #self.myKymWidget.slot_switchFile(ba, startSec, stopSec)
+        self.myKymWidget.slot_switchFile(ba, startSec, stopSec)
 
         # reconnect relink x-axis
-        # self.myKymWidget.kymographPlot.setXLink(self.vmPlot)  # row major is different
-
+        #self.myKymWidget.kymographPlot.setXLink(self.vmPlot)  # row major is different
+ 
         return True
 
     def slot_dataChanged(self, columnName, value, rowDict):
         """User has edited main file table."""
         self.detectToolbarWidget.slot_dataChanged(columnName, value, rowDict)
 
-    def slot_updateAnalysis(self, sDict : dict):
-        logger.info('')
-        self.replotOverlays()  # replot statistics over traces
-        
-        # reselect selected spikes on analysis changed
-        # this is needed to refresh the symbols of the selection
-        self.selectSpikeList(self._selectedSpikeList)
-
-    def _slot_x_range_changed(self, viewbox, range_):
-        """Respond to changes in x-axis
-
-        Parameters
-        ----------
-        viewbox : pyqtgraph.graphicsItems.ViewBox.ViewBox.ViewBox
-        range_ : (float, float)
-            The current x-axis range
-        Notes
-        -----
-        Trying to connect but not working yet
-
-        self.vmPlot.sigXRangeChanged.connect(self._slot_x_range_changed)
+    def slot_updateAnalysis(self):
+        self.replot() # replot statistics over traces
+        # refresh spike clips
+        #self.refreshClips(None, None)
 
-        """
-        # logger.info(event)
-        # logger.info(f'v:{v}')
-        #logger.info(f'range_:{range_}')
-        
-        # set glbal vm to this range
-        # update rectangle in vmPlotGlobal
-        start = range_[0]
-        stop = range_[1]
-        self.linearRegionItem2.setRegion([start, stop])
-
-    def _replot(self, startSec : Optional[float] = None,
-                stopSec : Optional[float] = None,
-                userUpdate : bool = False):
+    def _replot(self, startSec, stopSec, userUpdate=False):
         """Full replot.
-
+        
         Parameters
         ----------
         startSec : float or None
         stopSec : float or None
         userUpdate : bool
             Depreciated, not used
         """
-        logger.info(f"startSec:{startSec} stopSec:{stopSec} userUpdate:{userUpdate}")
-
+        logger.info(f'startSec:{startSec} stopSec:{stopSec} userUpdate:{userUpdate}')
+        
         if startSec is None or stopSec is None:
             startSec, stopSec = self.getXRange()
-
-        # remove vm/dvdt/clip items (even when abf file is corrupt)
-        # if self.dvdtLines is not None:
+            
+        #remove vm/dvdt/clip items (even when abf file is corrupt)
+        #if self.dvdtLines is not None:
         #    self.derivPlot.removeItem(self.dvdtLines)
         if self.dvdtLinesFiltered is not None:
             self.derivPlot.removeItem(self.dvdtLinesFiltered)
         if self.dacLines is not None:
             self.dacPlot.removeItem(self.dacLines)
         if self.vmLinesFiltered is not None:
             self.vmPlot.removeItem(self.vmLinesFiltered)
         if self.vmLinesFiltered2 is not None:
             self.vmPlotGlobal.removeItem(self.vmLinesFiltered2)
         if self.linearRegionItem2 is not None:
             self.vmPlotGlobal.removeItem(self.linearRegionItem2)
-        # if self.clipLines is not None:
+        #if self.clipLines is not None:
         #    self.clipPlot.removeItem(self.clipLines)
 
         # update lines
-        # self.dvdtLines = MultiLine(self.ba.abf.sweepX, self.ba.deriv,
+        #self.dvdtLines = MultiLine(self.ba.abf.sweepX, self.ba.deriv,
         #                    self, type='dvdt')
 
         if self.ba is None:
             return
-
+        
         # shared by all plot
         sweepX = self.ba.fileLoader.sweepX
         filteredDeriv = self.ba.fileLoader.filteredDeriv  # dec 2022, check if exists
         sweepC = self.ba.fileLoader.sweepC
-        # filteredVm = self.ba.filteredVm
+        #filteredVm = self.ba.filteredVm
         sweepY = self.ba.fileLoader.sweepY
-
+        
         #
         if sweepX.shape != filteredDeriv.shape:
-            logger.error(f"shapes do not match")
-
-        self.dvdtLinesFiltered = MultiLine(
-            sweepX,
-            filteredDeriv,
-            self,
-            forcePenColor=None,
-            type="dvdtFiltered",
-            columnOrder=True,
-        )
-        # self.derivPlot.addItem(self.dvdtLines)
+            logger.error(f'shapes do not match')
+            
+        self.dvdtLinesFiltered = MultiLine(sweepX, filteredDeriv,
+                            self, forcePenColor=None, type='dvdtFiltered',
+                            columnOrder=True)
+        #self.derivPlot.addItem(self.dvdtLines)
         self.derivPlot.addItem(self.dvdtLinesFiltered)
 
-        self.dacLines = MultiLine(
-            sweepX, sweepC, self, forcePenColor=None, type="dac", columnOrder=True
-        )
+        self.dacLines = MultiLine(sweepX, sweepC,
+                            self, forcePenColor=None, type='dac',
+                            columnOrder=True)
         self.dacPlot.addItem(self.dacLines)
 
-        self.vmLinesFiltered = MultiLine(
-            sweepX,
-            sweepY,
-            self,
-            forcePenColor=None,
-            type="vmFiltered",
-            allowXAxisDrag=True,  #default is True
-            columnOrder=True,
-        )
+        self.vmLinesFiltered = MultiLine(sweepX, sweepY,
+                            self, forcePenColor=None, type='vmFiltered',
+                            columnOrder=True)
         self.vmPlot.addItem(self.vmLinesFiltered)
 
-        # april 30, 2023
-        self.vmPlot.sigXRangeChanged.connect(self._slot_x_range_changed)
-
         # can't add a multi line to 2 different plots???
-        self.vmLinesFiltered2 = MultiLine(
-            sweepX, sweepY, self, forcePenColor="b", type="vmFiltered", columnOrder=True
-        )
+        self.vmLinesFiltered2 = MultiLine(sweepX, sweepY,
+                            self, forcePenColor='b', type='vmFiltered',
+                            columnOrder=True)
         self.vmPlotGlobal.addItem(self.vmLinesFiltered2)
-        self.linearRegionItem2 = pg.LinearRegionItem(
-            values=(0, self.ba.fileLoader.recordingDur),
-            orientation=pg.LinearRegionItem.Vertical,
-            brush=pg.mkBrush(150, 150, 150, 100),
-            pen=pg.mkPen(None),
-        )
+        self.linearRegionItem2 = pg.LinearRegionItem(values=(0,self.ba.fileLoader.recordingDur),
+                                    orientation=pg.LinearRegionItem.Vertical,
+                                    brush=pg.mkBrush(100,100,100,100),
+                                    pen=pg.mkPen(None))
         self.linearRegionItem2.setMovable(False)
         self.vmPlotGlobal.addItem(self.linearRegionItem2)
 
         # Kymograph
-        # isKymograph = self.ba.fileLoader.isKymograph()
-        # self.myKymWidget.setVisible(isKymograph)
-        # self.kymographPlot.hide()
+        isKymograph = self.ba.fileLoader.isKymograph()
+        self.myKymWidget.setVisible(isKymograph)
+        #self.kymographPlot.hide()
 
         #
         # remove and re-add plot overlays
         for idx, plot in enumerate(self.myPlots):
             plotItem = self.myPlotList[idx]
-            
-            # moved to rpelotOverlays
-            # adjust symbol size
-            # plotItem.setSymbolSize(self._pgPointSize)
-            # plotItem.setSymbol(_pg_symbols)
-
-            if plot["plotOn"] == "vm":
+            if plot['plotOn'] == 'vm':
                 self.vmPlot.removeItem(plotItem)
                 self.vmPlot.addItem(plotItem)
-            elif plot["plotOn"] == "vmGlobal":
+            elif plot['plotOn'] == 'vmGlobal':
                 self.vmPlotGlobal.removeItem(plotItem)
                 self.vmPlotGlobal.addItem(plotItem)
-            elif plot["plotOn"] == "dvdt":
+            elif plot['plotOn'] == 'dvdt':
                 self.derivPlot.removeItem(plotItem)
                 self.derivPlot.addItem(plotItem)
 
         # single spike selection
-        """
+        '''
         self.vmPlotGlobal.removeItem(self.mySingleSpikeScatterPlot)
         self.vmPlotGlobal.addItem(self.mySingleSpikeScatterPlot)
         self.vmPlot.removeItem(self.mySingleSpikeScatterPlot)
         self.vmPlot.addItem(self.mySingleSpikeScatterPlot)
-        """
+        '''
 
         # set full axis
         # setAxisFull was causing start/stop to get over-written
-        # self.setAxisFull()
+        #self.setAxisFull()
         # 20221003 was this
-        # self.setAxis_OnFileChange(startSec, stopSec)
+        #self.setAxis_OnFileChange(startSec, stopSec)
         self.setAxisFull()
-        # self.detectToolbarWidget.on_start_stop()
+        #self.detectToolbarWidget.on_start_stop()
         self._setAxis(start=startSec, stop=stopSec)
 
         #
         # critical, replot() is inherited
-        self.replotOverlays()
-
+        self.replot()
 
 class kymographImage(pg.ImageItem):
     def mouseClickEvent(self, event):
-        # print("Click", event.pos())
+        #print("Click", event.pos())
         x = event.pos().x()
         y = event.pos().y()
 
     def mouseDragEvent(self, event):
         return
 
         if event.isStart():
@@ -2162,48 +1872,34 @@
     def hoverEvent(self, event):
         if not event.isExit():
             # the mouse is hovering over the image; make sure no other items
             # will receive left click/drag events from here.
             event.acceptDrags(pg.QtCore.Qt.LeftButton)
             event.acceptClicks(pg.QtCore.Qt.LeftButton)
 
-
 class myImageExporter(ImageExporter):
     def __init__(self, item):
         pg.exporters.ImageExporter.__init__(self, item)
-        print(
-            "QtGui.QImageWriter.supportedImageFormats():",
-            QtGui.QImageWriter.supportedImageFormats(),
-        )
+        print('QtGui.QImageWriter.supportedImageFormats():', QtGui.QImageWriter.supportedImageFormats())
 
     def widthChanged(self):
         sr = self.getSourceRect()
         ar = float(sr.height()) / sr.width()
-        myHeight = int(self.params["width"] * ar)
-        self.params.param("height").setValue(myHeight, blockSignal=self.heightChanged)
+        myHeight = int(self.params['width'] * ar)
+        self.params.param('height').setValue(myHeight, blockSignal=self.heightChanged)
 
     def heightChanged(self):
         sr = self.getSourceRect()
         ar = float(sr.width()) / sr.height()
-        myWidth = int(self.params["height"] * ar)
-        self.params.param("width").setValue(myWidth, blockSignal=self.widthChanged)
-
+        myWidth = int(self.params['height'] * ar)
+        self.params.param('width').setValue(myWidth, blockSignal=self.widthChanged)
 
-# class MultiLine(pg.QtGui.QGraphicsPathItem):
+#class MultiLine(pg.QtGui.QGraphicsPathItem):
 class MultiLine(QtWidgets.QGraphicsPathItem):
-    def __init__(
-        self,
-        x,
-        y,
-        detectionWidget,
-        type,
-        forcePenColor=None,
-        allowXAxisDrag=True,
-        columnOrder=False,
-    ):
+    def __init__(self, x, y, detectionWidget, type, forcePenColor=None, allowXAxisDrag=True, columnOrder=False):
         """Display a time-series whole-cell recording efficiently
         It does this by converting the array of points to a QPath
 
         see: https://stackoverflow.com/questions/17103698/plotting-large-arrays-in-pyqtgraph/17108463#17108463
 
         Args:
             x and y are 2D arrays of shape (Nplots, Nsamples)
@@ -2218,786 +1914,713 @@
 
         self.x = x
         self.y = y
         self.detectionWidget = detectionWidget
         self.myType = type
         self.allowXAxisDrag = allowXAxisDrag
 
-        self.xDrag = None  # if true, user is dragging x-axis, otherwise y-axis
+        self.xDrag = None # if true, user is dragging x-axis, otherwise y-axis
         self.xStart = None
         self.xCurrent = None
         self.linearRegionItem = None
 
         if len(x.shape) == 2:
             connect = np.ones(x.shape, dtype=bool)
             if columnOrder:
-                connect[-1, :] = 0  # don't draw the segment between each trace
+                connect[-1,:] = 0 # don't draw the segment between each trace
             else:
-                connect[:, -1] = 0  # don't draw the segment between each trace
+                connect[:,-1] = 0 # don't draw the segment between each trace
             self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect.flatten())
         else:
-            self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect="all")
-        # pg.QtGui.QGraphicsPathItem.__init__(self, self.path)
+            self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect='all')
+        #pg.QtGui.QGraphicsPathItem.__init__(self, self.path)
         super().__init__(self.path)
 
-        # this is bad, without this the app becomes non responsive???
+        # holy shit, this is bad, without this the app becomes non responsive???
         # if width > 1.0 then this whole app STALLS
-        # default theme
-        # self.setPen(pg.mkPen(color='k', width=1))
+        # default heme
+        #self.setPen(pg.mkPen(color='k', width=1))
         # dark theme
         if forcePenColor is not None:
             penColor = forcePenColor
         elif self.detectionWidget.myMainWindow is None:
-            penColor = "k"
+            penColor = 'k'
         else:
             if self.detectionWidget.myMainWindow.useDarkStyle:
-                penColor = "w"
+                penColor = 'w'
             else:
-                penColor = "k"
+                penColor = 'k'
         #
         width = 1
-        if self.myType == "meanclip":
-            penColor = "r"
+        if self.myType == 'meanclip':
+            penColor = 'r'
             width = 3
 
         #
         self.setPen(pg.mkPen(color=penColor, width=width))
 
     def shape(self):
         # override because QGraphicsPathItem.shape is too expensive.
-        # print(time.time(), 'MultiLine.shape()', pg.QtGui.QGraphicsItem.shape(self))
-
+        #print(time.time(), 'MultiLine.shape()', pg.QtGui.QGraphicsItem.shape(self))
+        
         # removed mar 26 2023
         # gives error in pyqtgraph-0.13.2
         # return pg.QtGui.QGraphicsItem.shape(self)
-
+        
         # now this
         return super().shape()
 
     def boundingRect(self):
-        # print(time.time(), 'MultiLine.boundingRect()', self.path.boundingRect())
+        #print(time.time(), 'MultiLine.boundingRect()', self.path.boundingRect())
         return self.path.boundingRect()
 
     def mouseClickEvent(self, event):
         if event.button() == QtCore.Qt.RightButton:
-            logger.info(f"mouseClickEvent() right click {self.myType}")
+            logger.info(f'mouseClickEvent() right click {self.myType}')
             self.contextMenuEvent(event)
 
     def mouseDragEvent(self, ev):
-        """Default is to drag x-axis, use alt+drag for y-axis (option+drag on macOS).
-
+        """Default is to drag x-axis, use alt+drag for y-axis.
+        
         TODO: implement option+drag to select spike point from scatter
-
+        
         see:
             https://gist.github.com/eyllanesc/f305119027ae3b85dfcf8a3ef8c00238
         """
-        # print('MultiLine.mouseDragEvent():', type(ev), ev)
-
-        # if we do nothing here, we recover pyqtgraph click+drag to pan
-        # return
-    
-        # april 30, only allow this on isAlt so user can zoom into y-axis
+        #print('MultiLine.mouseDragEvent():', type(ev), ev)
 
         if ev.button() != QtCore.Qt.LeftButton:
             ev.ignore()
             return
 
-        # modifiers = QtWidgets.QApplication.keyboardModifiers()
-        # isAlt = modifiers == QtCore.Qt.AltModifier
-        # alt on macOS is 'option'
+        #modifiers = QtWidgets.QApplication.keyboardModifiers()
+        #isAlt = modifiers == QtCore.Qt.AltModifier
         isAlt = ev.modifiers() == QtCore.Qt.AltModifier
-        #logger.info(f'isAlt:{isAlt}')
 
-        # april 30, only allow this on isAlt so user can zoom into y-axis
-        if not isAlt:
-            return
-        
-        # xDrag = not isAlt # x drag is dafault, when alt is pressed, xDrag==False
+        #xDrag = not isAlt # x drag is dafault, when alt is pressed, xDrag==False
 
         # allowXAxisDrag is now used for both x and y
         if not self.allowXAxisDrag:
-            ev.accept()  # this prevents click+drag of plot
+            ev.accept() # this prevents click+drag of plot
             return
 
         if ev.isStart():
             self.xDrag = not isAlt
             if self.xDrag:
                 self.xStart = ev.buttonDownPos()[0]
-                self.linearRegionItem = pg.LinearRegionItem(
-                    values=(self.xStart, 0), orientation=pg.LinearRegionItem.Vertical
-                )
+                self.linearRegionItem = pg.LinearRegionItem(values=(self.xStart,0), orientation=pg.LinearRegionItem.Vertical)
             else:
                 # in y-drag, we need to know (vm, dvdt)
                 self.xStart = ev.buttonDownPos()[1]
-                self.linearRegionItem = pg.LinearRegionItem(
-                    values=(0, self.xStart), orientation=pg.LinearRegionItem.Horizontal
-                )
-            # self.linearRegionItem.sigRegionChangeFinished.connect(self.update_x_axis)
+                self.linearRegionItem = pg.LinearRegionItem(values=(0,self.xStart), orientation=pg.LinearRegionItem.Horizontal)
+            #self.linearRegionItem.sigRegionChangeFinished.connect(self.update_x_axis)
             # add the LinearRegionItem to the parent widget (Cannot add to self as it is an item)
             self.parentWidget().addItem(self.linearRegionItem)
         elif ev.isFinish():
             if self.xDrag:
-                set_xyBoth = "xAxis"
+                set_xyBoth = 'xAxis'
             else:
-                set_xyBoth = "yAxis"
-            # self.parentWidget().setXRange(self.xStart, self.xCurrent)
-            self.detectionWidget.setAxis(
-                self.xStart, self.xCurrent, set_xyBoth=set_xyBoth, whichPlot=self.myType
-            )
+                set_xyBoth = 'yAxis'
+            #self.parentWidget().setXRange(self.xStart, self.xCurrent)
+            self.detectionWidget.setAxis(self.xStart, self.xCurrent, set_xyBoth=set_xyBoth, whichPlot=self.myType)
 
             self.xDrag = None
             self.xStart = None
             self.xCurrent = None
 
             # 20210821, not sure ???
-            # if self.myType == 'clip':
+            #if self.myType == 'clip':
             #    if self.xDrag:
             #        self.clipPlot.setXRange(self.xStart, self.xCurrent, padding=padding)
             #    else:
             #        self.clipPlot.setYRange(self.xStart, self.xCurrent, padding=padding)
-            # else:
+            #else:
             #    self.parentWidget().removeItem(self.linearRegionItem)
             self.parentWidget().removeItem(self.linearRegionItem)
 
             # was getting QGraphicsScene::removeItem: item 0x55f2844ff8e0's scene (0x0) is different from this scene (0x55f282051690)
-            # self.parentWidget().removeItem(self.linearRegionItem)
+            #self.parentWidget().removeItem(self.linearRegionItem)
 
             self.linearRegionItem = None
 
             return
 
         if self.xDrag:
             self.xCurrent = ev.pos()[0]
-            # print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
+            #print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
             self.linearRegionItem.setRegion((self.xStart, self.xCurrent))
         else:
             self.xCurrent = ev.pos()[1]
-            # print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
+            #print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
             self.linearRegionItem.setRegion((self.xStart, self.xCurrent))
         ev.accept()
 
     def contextMenuEvent(self, event):
-        """Show popup context menu in response to right(command)+click.
-        
-        This is inherited from QWidget.
-        """
         myType = self.myType
 
-        """
+        '''
         if myType == 'clip':
             logger.warning('No export for clips, try clicking again')
             return
-        """
+        '''
 
         contextMenu = QtWidgets.QMenu()
-
-        showCrosshairAction = contextMenu.addAction(f"Crosshair")
-        showCrosshairAction.setCheckable(True)
-        showCrosshairAction.setChecked(self.detectionWidget._showCrosshair)
-        
-        contextMenu.addSeparator()
-
-        exportTraceAction = contextMenu.addAction(f"Export Trace {myType}")
+        exportTraceAction = contextMenu.addAction(f'Export Trace {myType}')
         contextMenu.addSeparator()
-
-        resetAllAxisAction = contextMenu.addAction(f"Reset All Axis")
-        resetYAxisAction = contextMenu.addAction(f"Reset Y-Axis")
-        # openAct = contextMenu.addAction("Open")
-        # quitAct = contextMenu.addAction("Quit")
-        # action = contextMenu.exec_(self.mapToGlobal(event.pos()))
-
-        # show menu
+        resetAllAxisAction = contextMenu.addAction(f'Reset All Axis')
+        resetYAxisAction = contextMenu.addAction(f'Reset Y-Axis')
+        #openAct = contextMenu.addAction("Open")
+        #quitAct = contextMenu.addAction("Quit")
+        #action = contextMenu.exec_(self.mapToGlobal(event.pos()))
         posQPoint = QtCore.QPoint(event.screenPos().x(), event.screenPos().y())
         action = contextMenu.exec_(posQPoint)
         if action is None:
             return
-        
         actionText = action.text()
-        if actionText == f"Export Trace {myType}":
+        if actionText == f'Export Trace {myType}':
             #
             # See: plugins/exportTrace.py
             #
 
-            # print('Opening Export Trace Window')
+            #print('Opening Export Trace Window')
 
             # todo: pass xMin,xMax to constructor
-            if self.myType == "vmFiltered":
-                xyUnits = ("Time (sec)", "Vm (mV)")
-            elif self.myType == "dvdtFiltered":
-                xyUnits = ("Time (sec)", "dV/dt (mV/ms)")
-            elif self.myType == "meanclip":
-                xyUnits = ("Time (ms)", "Vm (mV)")
+            if self.myType == 'vmFiltered':
+                xyUnits = ('Time (sec)', 'Vm (mV)')
+            elif self.myType == 'dvdtFiltered':
+                xyUnits = ('Time (sec)', 'dV/dt (mV/ms)')
+            elif self.myType == 'meanclip':
+                xyUnits = ('Time (ms)', 'Vm (mV)')
             else:
                 logger.error(f'Unknown myType: "{self.myType}"')
-                xyUnits = ("error time", "error y")
+                xyUnits = ('error time', 'error y')
 
             path = self.detectionWidget.ba.fileLoader.filepath
 
+            # xMin = None
+            # xMax = None
+            #if self.myType in ['clip', 'meanclip']:
+            #    xMin, xMax = self.detectionWidget.clipPlot.getAxis('bottom').range
+            #else:
+            #    xMin, xMax = self.detectionWidget.getXRange()
             xMin, xMax = self.detectionWidget.getXRange()
+            #print('  xMin:', xMin, 'xMax:', xMax)
 
-            if self.myType in ["vm", "dvdt"]:
-                xMargin = 2  # seconds
+            if self.myType in ['vm', 'dvdt']:
+                xMargin = 2 # seconds
             else:
                 xMargin = 2
 
-            exportWidget = sanpy.interface.bExportWidget(
-                self.x,
-                self.y,
-                xyUnits=xyUnits,
-                path=path,
-                xMin=xMin,
-                xMax=xMax,
-                xMargin=xMargin,
-                type=self.myType,
-                darkTheme=self.detectionWidget.useDarkStyle,
-            )
+            exportWidget = sanpy.interface.bExportWidget(self.x, self.y,
+                            xyUnits=xyUnits,
+                            path=path,
+                            xMin=xMin, xMax=xMax,
+                            xMargin = xMargin,
+                            type=self.myType,
+                            darkTheme=self.detectionWidget.useDarkStyle)
 
             exportWidget.myCloseSignal.connect(self.slot_closeChildWindow)
             exportWidget.show()
 
             self.exportWidgetList.append(exportWidget)
-
-        elif actionText == "Reset All Axis":
-            # print('Reset Y-Axis', self.myType)
+        elif actionText == 'Reset All Axis':
+            #print('Reset Y-Axis', self.myType)
             self.detectionWidget.setAxisFull()
-
-        elif actionText == "Reset Y-Axis":
-            # print('Reset Y-Axis', self.myType)
+        elif actionText == 'Reset Y-Axis':
+            #print('Reset Y-Axis', self.myType)
             self.detectionWidget.setAxisFull_y(self.myType)
-
-        elif actionText == 'Crosshair':
-            isChecked = action.isChecked()
-            #isChecked = not isChecked
-            logger.info(f'{actionText} {isChecked}')
-            self.detectionWidget.toggleCrosshair(isChecked)
-            
         else:
-            logger.warning(f"action not taken: {action}")
+            logger.warning(f'action not taken: {action}')
 
     def slot_closeChildWindow(self, windowPointer):
-        # print('closeChildWindow()', windowPointer)
-        # print('  exportWidgetList:', self.exportWidgetList)
+        #print('closeChildWindow()', windowPointer)
+        #print('  exportWidgetList:', self.exportWidgetList)
 
         idx = self.exportWidgetList.index(windowPointer)
         if idx is not None:
             popedItem = self.exportWidgetList.pop(idx)
-            # print('  popedItem:', popedItem)
+            #print('  popedItem:', popedItem)
         else:
-            print(" slot_closeChildWindow() did not find", windowPointer)
-
+            print(' slot_closeChildWindow() did not find', windowPointer)
 
 class myDetectToolbarWidget2(QtWidgets.QWidget):
-    # signalSelectSpike = QtCore.Signal(object, object) # spike number, doZoom
+    #signalSelectSpike = QtCore.Signal(object, object) # spike number, doZoom
 
-    def __init__(self, myPlots, detectionWidget: bDetectionWidget, parent=None):
+    def __init__(self, myPlots, detectionWidget : bDetectionWidget, parent=None):
         super(myDetectToolbarWidget2, self).__init__(parent)
 
         self.myPlots = myPlots
-        self.detectionWidget = detectionWidget  # parent detection widget
+        self.detectionWidget = detectionWidget # parent detection widget
 
         self._startSec = None
         self._stopSec = None
 
         self._selectedDetection = None
 
-        self._buildUI()
+        self.buildUI()
 
     def fillInDetectionParameters(self, tableRowDict):
         """
         Set detection widget interface (mostly QSpinBox) to match values from table
         """
 
-        """
+        '''
         print('fillInDetectionParameters()')
         print('  tableRowDict:')
         for k,v in tableRowDict.items():
             print('  ', k, ':', v, type(v))
-        """
+        '''
 
         try:
-            dvdtThreshold = tableRowDict["dvdtThreshold"]
-            mvThreshold = tableRowDict["mvThreshold"]
-            startSeconds = tableRowDict["Start(s)"]
-            stopSeconds = tableRowDict["Stop(s)"]
-        except KeyError as e:
+            dvdtThreshold = tableRowDict['dvdtThreshold']
+            mvThreshold = tableRowDict['mvThreshold']
+            startSeconds = tableRowDict['Start(s)']
+            stopSeconds = tableRowDict['Stop(s)']
+        except (KeyError) as e:
             logger.error(e)
             return
-        # logger.info(f'startSeconds:{startSeconds} stopSeconds:{stopSeconds}')
+        #logger.info(f'startSeconds:{startSeconds} stopSeconds:{stopSeconds}')
 
         # in table we specify 'nan' but float spin box will not show that
         if math.isnan(dvdtThreshold):
             windowOptions = self.detectionWidget.getMainWindowOptions()
-            dvdtThreshold = windowOptions["detect"]["detectDvDt"]
+            dvdtThreshold = windowOptions['detect']['detectDvDt']
 
         if math.isnan(mvThreshold):
             windowOptions = self.detectionWidget.getMainWindowOptions()
-            mvThreshold = windowOptions["detect"]["detectMv"]
+            mvThreshold = windowOptions['detect']['detectMv']
 
         # print('=== fillInDetectionParameters dvdtThreshold:', dvdtThreshold)
         # print('=== fillInDetectionParameters mvThreshold:', mvThreshold)
-
+        
         self.dvdtThreshold.setValue(dvdtThreshold)
         self.mvThreshold.setValue(mvThreshold)
 
         if math.isnan(startSeconds):
             startSeconds = 0
         if math.isnan(stopSeconds):
-            # stopSeconds = self.detectionWidget.ba.sweepX[-1]
+            #stopSeconds = self.detectionWidget.ba.sweepX[-1]
             stopSeconds = self.detectionWidget.ba.fileLoader.recordingDur
 
-        # removed 20230419
-        # self.startSeconds.setValue(startSeconds)
-        # self.stopSeconds.setValue(stopSeconds)
+        self.startSeconds.setValue(startSeconds)
+        self.stopSeconds.setValue(stopSeconds)
 
-    """
+    '''
     def sweepSelectionChange(self,i):
         sweepNumber = int(self.cb.currentText())
         print('    todo: implement sweep number:', sweepNumber)
-    """
+    '''
 
     def on_detection_preset_change(self, detectionTypeStr):
         """User selected a preset detection.
-
+        
         Fill in preset dv/dt and mV.
         Use this detection preset when user hits detect
         """
-        logger.info("")
+        logger.info('')
 
         # grab default (dv/dt, mv) from preset
-        # detectionPreset = sanpy.bDetection.detectionPresets(detectionTypeStr)
-        # detectionClass = sanpy.bDetection(detectionPreset=detectionPreset)
+        #detectionPreset = sanpy.bDetection.detectionPresets(detectionTypeStr)
+        #detectionClass = sanpy.bDetection(detectionPreset=detectionPreset)
 
         self._selectedDetection = detectionTypeStr
-        detectionDict = (
-            self.detectionWidget.getMainWindowDetectionClass().getDetectionDict(
-                self._selectedDetection
-            )
-        )
-        dvdtThreshold = detectionDict["dvdtThreshold"]
-        mvThreshold = detectionDict["mvThreshold"]
-        logger.info(f"    dvdtThreshold:{dvdtThreshold} mvThreshold:{mvThreshold}")
-
+        detectionDict = self.detectionWidget.getMainWindowDetectionClass().getDetectionDict(self._selectedDetection)
+        dvdtThreshold = detectionDict['dvdtThreshold']
+        mvThreshold = detectionDict['mvThreshold']
+        logger.info(f'    dvdtThreshold:{dvdtThreshold} mvThreshold:{mvThreshold}')
+        
         # set interface
         self.dvdtThreshold.setValue(dvdtThreshold)
         self.mvThreshold.setValue(mvThreshold)
 
     def on_sweep_change(self, sweepNumber):
         """
         Args:
             sweepNumber (str): The current selected item, from ('All', 0, 1, 2, ...)
         """
-        # logger.debug(f'sweepNumber:"{sweepNumber}" {type(sweepNumber)}')
-        if sweepNumber == "":
+        #logger.debug(f'sweepNumber:"{sweepNumber}" {type(sweepNumber)}')
+        if sweepNumber == '':
             # we receive this as we rebuild xxx on switching file
-            # logger.error('Got empty sweep -- ABORTING')
+            #logger.error('Got empty sweep -- ABORTING')
             return
-        logger.info(f"Calling selectSweep() {sweepNumber}")
+        logger.info(f'Calling selectSweep() {sweepNumber}')
         self.detectionWidget.selectSweep(sweepNumber)
 
-    def on_sweep_change_2(self, prevNext: str):
+    def on_sweep_change_2(self, prevNext : str):
         if self.detectionWidget.ba is None:
             return
 
-        if prevNext == "previous":
+        if prevNext == 'previous':
             inc = -1
         else:
             inc = +1
         newSweep = self.detectionWidget.sweepNumber
         if newSweep is None:
             return
         else:
             newSweep += inc
-
-        if newSweep < 0 or newSweep > self.detectionWidget.ba.fileLoader.numSweeps - 1:
+        
+        if newSweep<0 or newSweep > self.detectionWidget.ba.fileLoader.numSweeps-1:
             return
-
+        
         self.detectionWidget.slot_selectSweep(newSweep)
-        # self.detectionWidget.selectSweep(newSweep)
+        #self.detectionWidget.selectSweep(newSweep)
 
         # update combobox
-        # self.sweepComboBox.setCurrentIndex(newSweep+1)
+        #self.sweepComboBox.setCurrentIndex(newSweep+1)
 
-    def _old_on_start_stop(self):
-        """Respond to user changing start/stop seconds
-        """
+    #@QtCore.pyqtSlot()
+    def on_start_stop(self):
         start = self.startSeconds.value()
         stop = self.stopSeconds.value()
-
+        
         if (start != self._startSec) or (stop != self._stopSec):
             self._startSec = start
             self._stopSec = stop
-
-            logger.info(f"start:{start}, stop:{stop}")
+            
+            logger.info(f'start:{start}, stop:{stop}')
             self.detectionWidget.setAxis(start, stop)
 
     def on_plot_every(self):
-        logger.info("TODO: update plots with plot every.")
+        logger.info('TODO: update plots with plot every.')
 
-    def _on_button_click(self, name):
-        """User clicked a button."""
+    #@QtCore.pyqtSlot()
+    def on_button_click(self, name):
+        """User clicked a button.
+        """
         logger.info(f'User clicked button "{name}"')
 
         modifiers = QtWidgets.QApplication.keyboardModifiers()
         isShift = modifiers == QtCore.Qt.ShiftModifier
 
-        if name == "Detect dV/dt":
+        if name == 'Detect dV/dt':
             detectionPreset = self.detectionPresets.currentText()
-
+            
             dvdtThreshold = self.dvdtThreshold.value()
-            # print(f'  dvdtThreshold:', dvdtThreshold, type(dvdtThreshold))
+            #print(f'  dvdtThreshold:', dvdtThreshold, type(dvdtThreshold))
             mvThreshold = self.mvThreshold.value()
-            # print('    dvdtThreshold:', dvdtThreshold)
-            # print('    mvThreshold:', mvThreshold)
-            if dvdtThreshold == 0:
+            #print('    dvdtThreshold:', dvdtThreshold)
+            #print('    mvThreshold:', mvThreshold)
+            if dvdtThreshold==0:
                 # 0 is special value shown as 'None'
-                str = "Please set a threshold greater than 0"
+                str = 'Please set a threshold greater than 0'
                 self.detectionWidget.updateStatusBar(str)
                 return
-            
-            # removed 20230419
-            # startSec = self.startSeconds.value()
-            # stopSec = self.stopSeconds.value()
-            startSec = self._startSec
-            stopSec = self._stopSec
-
+            startSec = self.startSeconds.value()
+            stopSec = self.stopSeconds.value()
             #
             detectionType = sanpy.bDetection.detectionTypes.dvdt
-            self.detectionWidget.detect(
-                detectionPreset,
-                detectionType,
-                dvdtThreshold,
-                mvThreshold,
-                startSec,
-                stopSec,
-            )
+            self.detectionWidget.detect(detectionPreset, detectionType, dvdtThreshold, mvThreshold, startSec, stopSec)
 
-        elif name == "Detect mV":
+        elif name =='Detect mV':
             detectionPreset = self.detectionPresets.currentText()
 
             dvdtThreshold = self.dvdtThreshold.value()
             mvThreshold = self.mvThreshold.value()
-            # print('    mvThreshold:', mvThreshold)
+            #print('    mvThreshold:', mvThreshold)
             # passing dvdtThreshold=None we will detect suing mvThreshold
 
             # was this, switching to detection class
-            # dvdtThreshold = None
-
-            # startSec = self.startSeconds.value()
-            # stopSec = self.stopSeconds.value()
-            startSec = self._startSec
-            stopSec = self._stopSec
+            #dvdtThreshold = None
 
+            #print('    dvdtThreshold:', dvdtThreshold)
+            #print('    mvThreshold:', mvThreshold)
+            startSec = self.startSeconds.value()
+            stopSec = self.stopSeconds.value()
             #
             detectionType = sanpy.bDetection.detectionTypes.mv
-            self.detectionWidget.detect(
-                detectionPreset,
-                detectionType,
-                dvdtThreshold,
-                mvThreshold,
-                startSec,
-                stopSec,
-            )
+            self.detectionWidget.detect(detectionPreset, detectionType, dvdtThreshold, mvThreshold, startSec, stopSec)
 
-        elif name == "[]":
+        elif name == '[]':
             # Reset Axes
             self.detectionWidget.setAxisFull()
 
-        elif name == "Export Spike Report":
-            # self.detectionWidget.save(alsoSaveTxt=isShift)
+        elif name == 'Export Spike Report':
+            #self.detectionWidget.save(alsoSaveTxt=isShift)
             self.detectionWidget.save(saveCsv=True)
 
         # next/previous sweep
-        elif name == "<":
-            self.on_sweep_change_2("previous")
-        elif name == ">":
-            self.on_sweep_change_2("next")
+        elif name == '<':
+            self.on_sweep_change_2('previous')
+        elif name == '>':
+            self.on_sweep_change_2('next')
+
+        #elif name == 'Explore':
+        #    # open bScatterPlot2 for one recording
+        #    self.detectionWidget.exploreSpikes()
+
+        #elif name == 'Error':
+        #    self.detectionWidget.ba.errorReport()
 
-        elif name == "Go":
+        elif name == 'Go':
             spikeNumber = self.spikeNumber.value()
             doZoom = isShift
             self.detectionWidget.selectSpike(spikeNumber, doZoom, doEmit=True)
 
-        elif name == "<<":
+        elif name == '<<':
             spikeNumber = self.spikeNumber.value()
             spikeNumber -= 1
             if spikeNumber < 0:
                 spikeNumber = 0
             doZoom = isShift
             self.detectionWidget.selectSpike(spikeNumber, doZoom, doEmit=True)
 
-        elif name == ">>":
+        elif name == '>>':
             if self.detectionWidget.ba is None:
                 return
             spikeNumber = self.spikeNumber.value()
             spikeNumber += 1
             if spikeNumber > self.detectionWidget.ba.numSpikes - 1:
                 spikeNumber = self.detectionWidget.ba.numSpikes - 1
             doZoom = isShift
             self.detectionWidget.selectSpike(spikeNumber, doZoom, doEmit=True)
 
         else:
             logger.warning(f'Did not understand button: "{name}"')
 
     def on_check_click(self, checkbox, idx):
         isChecked = checkbox.isChecked()
-        # print('on_check_click() text:', checkbox.text(), 'isChecked:', isChecked, 'idx:', idx)
+        #print('on_check_click() text:', checkbox.text(), 'isChecked:', isChecked, 'idx:', idx)
         self.detectionWidget.toggleInterface(idx, isChecked)
 
-    def _old_on_crosshair_clicked(self, value):
-        # print('on_crosshair_clicked() value:', value)
+    def on_crosshair_clicked(self, value):
+        #print('on_crosshair_clicked() value:', value)
         onOff = value == 2
         self.detectionWidget.toggleCrosshair(onOff)
 
-    def toggleInterface(self, panelName: str, onoff: bool):
-        """Toggle interface panels on/off."""
+    def toggleInterface(self, panelName : str, onoff : bool):
+        """Toggle interface panels on/off.
+        """
 
-        if panelName == "Detection":
+        if panelName == 'Detection':
             if onoff:
                 self.detectionGroupBox.show()
             else:
                 self.detectionGroupBox.hide()
-        elif panelName == "Display":
+        elif panelName == 'Display':
             if onoff:
                 self.displayGroupBox.show()
             else:
                 self.displayGroupBox.hide()
+        elif panelName == 'Plot Options':
+            if onoff:
+                self.plotGroupBox.show()
+            else:
+                self.plotGroupBox.hide()
         # mar 11
-        elif panelName == "Set Spikes":
+        elif panelName == 'Set Spikes':
             if onoff:
                 self.setSpikeGroupBox.show()
             else:
                 self.setSpikeGroupBox.hide()
-        elif panelName == "Plot Options":
-            if onoff:
-                self.plotGroupBox.show()
-            else:
-                self.plotGroupBox.hide()
 
         else:
             logger.warning(f'did not understand panelName "{panelName}"')
 
-    def _buildUI(self):
-        """
-        Notes
-        -----
-        Using setFixedWidth()
-        """
+    def buildUI(self):
+        #self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
+
         myPath = os.path.dirname(os.path.abspath(__file__))
 
         windowOptions = self.detectionWidget.getMainWindowOptions()
         detectDvDt = 20
         detectMv = -20
         showGlobalVm = True
         showDvDt = True
         showDAC = True
+        #showClips = False
+        #showScatter = True
         if windowOptions is not None:
-            detectDvDt = windowOptions["detect"]["detectDvDt"]
-            detectMv = windowOptions["detect"]["detectMv"]
+            detectDvDt = windowOptions['detect']['detectDvDt']
+            detectMv = windowOptions['detect']['detectMv']
 
-            showDvDt = windowOptions["rawDataPanels"]["Derivative"]
-            showDAC = windowOptions["rawDataPanels"]["DAC"]
-            showGlobalVm = windowOptions["rawDataPanels"]["Full Recording"]
-
-        # April 15, 2023, removed when adding horizontal splitter
-        #self.setFixedWidth(280)
-        self.setFixedWidth(280)
+            showDvDt = windowOptions['rawDataPanels']['Derivative']
+            showDAC = windowOptions['rawDataPanels']['DAC']
+            showGlobalVm = windowOptions['rawDataPanels']['Full Recording']
+            #showClips = windowOptions['display']['showClips']
+            #showScatter = windowOptions['display']['showScatter']
+            #showErrors = windowOptions['display']['showErrors']
+
+        self.setFixedWidth(300)
 
         # why do I need self here?
         self.mainLayout = QtWidgets.QVBoxLayout()
-        self.mainLayout.setAlignment(QtCore.Qt.AlignTop)
 
-        self.mainLayout.setContentsMargins(0,0,0,0)
+        self.mainLayout.setAlignment(QtCore.Qt.AlignTop)
 
         # Show selected file
-        # self.mySelectedFileLabel = QtWidgets.QLabel("None")
-        # self.mySelectedFileLabel.setContentsMargins(0,0,0,0)
-        # self.mainLayout.addWidget(self.mySelectedFileLabel)
+        self.mySelectedFileLabel = QtWidgets.QLabel('None')
+        self.mainLayout.addWidget(self.mySelectedFileLabel)
 
         #
         # detection parameters group
-        self.detectionGroupBox = QtWidgets.QGroupBox("Detection")
+        self.detectionGroupBox = QtWidgets.QGroupBox('Detection')
 
         # breeze
-        # detectionGroupBox.setStyleSheet(myStyleSheet)
+        #detectionGroupBox.setStyleSheet(myStyleSheet)
 
-        # detectionGroupBox.setAlignment(QtCore.Qt.AlignTop)
+        #detectionGroupBox.setAlignment(QtCore.Qt.AlignTop)
 
         detectionGridLayout = QtWidgets.QGridLayout()
-        # detectionGridLayout.setAlignment(QtCore.Qt.AlignTop)
+        #detectionGridLayout.setAlignment(QtCore.Qt.AlignTop)
 
         row = 0
         rowSpan = 1
         columnSpan = 2
 
-        aComboLabel = QtWidgets.QLabel("Presets")
-
+        aComboLabel = QtWidgets.QLabel('Presets')
+        
         # get list of detection presets
-        # detectionTypes = sanpy.bDetection.getDetectionPresetList()
+        #detectionTypes = sanpy.bDetection.getDetectionPresetList()
         detectionClass = self.detectionWidget.getMainWindowDetectionClass()
         detectionTypes = detectionClass.getDetectionPresetList()
-
+        
         self._selectedDetection = detectionTypes[0]  # set to the first detection type
 
         self.detectionPresets = QtWidgets.QComboBox()
         for detectionType in detectionTypes:
             self.detectionPresets.addItem(detectionType)
-        self.detectionPresets.currentTextChanged.connect(
-            self.on_detection_preset_change
-        )
+        self.detectionPresets.currentTextChanged.connect(self.on_detection_preset_change)
 
         columnSpan = 1
         detectionGridLayout.addWidget(aComboLabel, row, 0, rowSpan, columnSpan)
         columnSpan = 3
-        detectionGridLayout.addWidget(
-            self.detectionPresets, row, 1, rowSpan, columnSpan
-        )
+        detectionGridLayout.addWidget(self.detectionPresets, row, 1, rowSpan, columnSpan)
         row += 1
 
         #
-        buttonName = "Detect dV/dt"
+        buttonName = 'Detect dV/dt'
         button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Detect spikes using dV/dt threshold.")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
+        button.setToolTip('Detect spikes using dV/dt threshold.')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
 
-        # row = 0
+        #row = 0
         rowSpan = 1
         columnSpan = 2
         detectionGridLayout.addWidget(button, row, 0, rowSpan, columnSpan)
 
         self.dvdtThreshold = QtWidgets.QDoubleSpinBox()
-        self.dvdtThreshold.setToolTip("dV/dt threshold.")
         self.dvdtThreshold.setMinimum(0)
         self.dvdtThreshold.setMaximum(+1e6)
         self.dvdtThreshold.setValue(detectDvDt)
         self.dvdtThreshold.setSpecialValueText("None")
-        # self.dvdtThreshold.setValue(np.nan)
+        #self.dvdtThreshold.setValue(np.nan)
         detectionGridLayout.addWidget(self.dvdtThreshold, row, 2, rowSpan, columnSpan)
 
         row += 1
         rowSpan = 1
         columnSpan = 2
-        buttonName = "Detect mV"
+        buttonName = 'Detect mV'
         button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Detect spikes using mV threshold.")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
+        button.setToolTip('Detect spikes using mV threshold.')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
         detectionGridLayout.addWidget(button, row, 0, rowSpan, columnSpan)
 
         # Vm Threshold (mV)
-        # mvThresholdLabel = QtWidgets.QLabel('Vm Threshold (mV)')
-        # self.addWidget(mvThresholdLabel, row, 1)
+        #mvThresholdLabel = QtWidgets.QLabel('Vm Threshold (mV)')
+        #self.addWidget(mvThresholdLabel, row, 1)
 
-        # row += 1
+        #row += 1
         self.mvThreshold = QtWidgets.QDoubleSpinBox()
-        self.mvThreshold.setToolTip("mV threshold.")
         self.mvThreshold.setMinimum(-1e6)
         self.mvThreshold.setMaximum(+1e6)
         self.mvThreshold.setValue(detectMv)
         detectionGridLayout.addWidget(self.mvThreshold, row, 2, rowSpan, columnSpan)
 
-        # removed 20230419
-        # decided to not show start/stop seconds ???
+        #tmpRowSpan = 1
+        #tmpColSpan = 2
+        row += 1
+        startSeconds = QtWidgets.QLabel('From (s)')
+        detectionGridLayout.addWidget(startSeconds, row, 0)
         #
+        self.startSeconds = QtWidgets.QDoubleSpinBox()
+        self.startSeconds.setMinimum(-1e6)
+        self.startSeconds.setMaximum(+1e6)
+        self.startSeconds.setKeyboardTracking(False)
+        self.startSeconds.setValue(0)
+        #self.startSeconds.valueChanged.connect(self.on_start_stop)
+        self.startSeconds.editingFinished.connect(self.on_start_stop)
+        detectionGridLayout.addWidget(self.startSeconds, row, 1)
+        #
+        stopSeconds = QtWidgets.QLabel('To (s)')
+        detectionGridLayout.addWidget(stopSeconds, row, 2)
+
+        self.stopSeconds = QtWidgets.QDoubleSpinBox()
+        self.stopSeconds.setMinimum(-1e6)
+        self.stopSeconds.setMaximum(+1e6)
+        self.stopSeconds.setKeyboardTracking(False)
+        self.stopSeconds.setValue(0)
+        #self.stopSeconds.valueChanged.connect(self.on_start_stop)
+        self.stopSeconds.editingFinished.connect(self.on_start_stop)
+        detectionGridLayout.addWidget(self.stopSeconds, row, 3)
 
-        self._startSeconds = 0
-        self._stopSeconds = 0
+        row += 1
+        tmpHLayout = QtWidgets.QHBoxLayout()
 
-        # instead, we need a member variable to keep track of this
-        # see
-        # self._startSec and self._stopSec
-        
-        # row += 1
-
-        # startSeconds = QtWidgets.QLabel("From (s)")
-        # detectionGridLayout.addWidget(startSeconds, row, 0)
-
-        # self.startSeconds = QtWidgets.QDoubleSpinBox()
-        # self.startSeconds.setMinimum(-1e6)
-        # self.startSeconds.setMaximum(+1e6)
-        # self.startSeconds.setKeyboardTracking(False)
-        # self.startSeconds.setValue(0)
-        # self.startSeconds.editingFinished.connect(self._on_start_stop)
-        # detectionGridLayout.addWidget(self.startSeconds, row, 1)
-
-        # stopSeconds = QtWidgets.QLabel("To (s)")
-        # detectionGridLayout.addWidget(stopSeconds, row, 2)
-
-        # self.stopSeconds = QtWidgets.QDoubleSpinBox()
-        # self.stopSeconds.setMinimum(-1e6)
-        # self.stopSeconds.setMaximum(+1e6)
-        # self.stopSeconds.setKeyboardTracking(False)
-        # self.stopSeconds.setValue(0)
-        # # self.stopSeconds.valueChanged.connect(self.on_start_stop)
-        # self.stopSeconds.editingFinished.connect(self._on_start_stop)
-        # detectionGridLayout.addWidget(self.stopSeconds, row, 3)
-
-        # removed april 15, 2023 to conserve space
-        # row += 1
-        # tmpHLayout = QtWidgets.QHBoxLayout()
-
-        # self.numSpikesLabel = QtWidgets.QLabel("Spikes: None")
-        # tmpHLayout.addWidget(self.numSpikesLabel)
-
-        # self.spikeFreqLabel = QtWidgets.QLabel("Freq: None")
-        # tmpHLayout.addWidget(self.spikeFreqLabel)
-
-        # self.numErrorsLabel = QtWidgets.QLabel("Errors: None")
-        # tmpHLayout.addWidget(self.numErrorsLabel)
-        # col = 0
-        # rowSpan = 1
-        # colSpan = 4
-        # detectionGridLayout.addLayout(tmpHLayout, row, col, rowSpan, colSpan)
+        self.numSpikesLabel = QtWidgets.QLabel('Spikes: None')
+        tmpHLayout.addWidget(self.numSpikesLabel)
+        #detectionGridLayout.addWidget(self.numSpikesLabel, row, 0, tmpRowSpan, tmpColSpan)
+
+        self.spikeFreqLabel = QtWidgets.QLabel('Freq: None')
+        tmpHLayout.addWidget(self.spikeFreqLabel)
+        #detectionGridLayout.addWidget(self.spikeFreqLabel, row, 1, tmpRowSpan, tmpColSpan)
+
+        self.numErrorsLabel = QtWidgets.QLabel('Errors: None')
+        tmpHLayout.addWidget(self.numErrorsLabel)
+        #detectionGridLayout.addWidget(self.numErrorsLabel, row, 2, tmpRowSpan, tmpColSpan)
+        col = 0
+        rowSpan=1
+        colSpan = 4
+        detectionGridLayout.addLayout(tmpHLayout, row, col, rowSpan, colSpan)
 
         row += 1
-        buttonName = "Export Spike Report"
+        buttonName = 'Export Spike Report'
         button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Save Detected Spikes to csv file")
-        # button.setStyleSheet("background-color: green")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
-        rowSpan = 1
+        button.setToolTip('Save Detected Spikes to Excel file')
+        #button.setStyleSheet("background-color: green")
+        button.clicked.connect(partial(self.on_button_click,buttonName))
+        rowSpan=1
         colSpan = 4
-        detectionGridLayout.addWidget(button, row, 0, rowSpan, colSpan)
+        detectionGridLayout.addWidget(button, row , 0, rowSpan, colSpan)
 
         # finalize
         self.detectionGroupBox.setLayout(detectionGridLayout)
         self.mainLayout.addWidget(self.detectionGroupBox)
 
         #
         # display group
-        self.displayGroupBox = QtWidgets.QGroupBox("Display")
-
+        self.displayGroupBox = QtWidgets.QGroupBox('Display')
+        
         displayGridLayout = QtWidgets.QGridLayout()
 
         row = 0
 
         # channel, we only support one channel
         # _tmpChannelLabel = QtWidgets.QLabel('Channel')
         # _channelComboBox = QtWidgets.QComboBox()
         # # add channels from abf
         # _fakeChannels = ['1', '2', '3', 'bizarre']
         # for channel in _fakeChannels:
         #     _channelComboBox.addItem(channel)
 
         # sweeps
-        tmpSweepLabel = QtWidgets.QLabel("Sweep")
-        buttonName = "<"
+        tmpSweepLabel = QtWidgets.QLabel('Sweep')
+        buttonName = '<'
         self.previousSweepButton = QtWidgets.QPushButton(buttonName)
-        self.previousSweepButton.setToolTip("Previous Sweep")
-        self.previousSweepButton.clicked.connect(
-            partial(self._on_button_click, buttonName)
-        )
-        buttonName = ">"
+        self.previousSweepButton.setToolTip('Previous Sweep')
+        self.previousSweepButton.clicked.connect(partial(self.on_button_click,buttonName))
+        buttonName = '>'
         self.nextSweepButton = QtWidgets.QPushButton(buttonName)
-        self.nextSweepButton.setToolTip("Next Sweep")
-        self.nextSweepButton.clicked.connect(partial(self._on_button_click, buttonName))
+        self.nextSweepButton.setToolTip('Next Sweep')
+        self.nextSweepButton.clicked.connect(partial(self.on_button_click,buttonName))
 
         self.sweepComboBox = QtWidgets.QComboBox()
-        self.sweepComboBox.setToolTip("Select Sweep")
         self.sweepComboBox.currentTextChanged.connect(self.on_sweep_change)
         # will be set in self.slot_selectFile()
-        # for sweep in range(self.detectionWidget.ba.numSweeps):
+        #for sweep in range(self.detectionWidget.ba.numSweeps):
         #    self.sweepComboBox.addItem(str(sweep))
         hSweepLayout = QtWidgets.QHBoxLayout()
 
         # hSweepLayout.addWidget(_tmpChannelLabel)
         # hSweepLayout.addWidget(_channelComboBox)
 
         hSweepLayout.addWidget(tmpSweepLabel)
@@ -3009,46 +2632,41 @@
         displayGridLayout.addLayout(hSweepLayout, row, 0, tmpRowSpan, tmpColSpan)
         # displayGridLayout.addWidget(tmpSweepLabel, row, 0, tmpRowSpan, tmpColSpan)
         # displayGridLayout.addWidget(previousSweepButton, row, 1, tmpRowSpan, tmpColSpan)
         # displayGridLayout.addWidget(self.sweepComboBox, row, 2, tmpRowSpan, tmpColSpan)
         # displayGridLayout.addWidget(nextSweepButton, row, 3, tmpRowSpan, tmpColSpan)
 
         # plot every x th pnts, value of 10 would plot every 10th point
-        """
+        '''
         row += 1
         tmpPlotEveryLabel = QtWidgets.QLabel('Plot Every')
 
         self.plotEverySpinBox = QtWidgets.QSpinBox()
         self.plotEverySpinBox.setMinimum(1)
         self.plotEverySpinBox.setMaximum(20)
         self.plotEverySpinBox.setKeyboardTracking(False)
         self.plotEverySpinBox.setValue(1)
         #self.stopSeconds.valueChanged.connect(self.on_start_stop)
         self.plotEverySpinBox.editingFinished.connect(self.on_plot_every)
 
         displayGridLayout.addWidget(tmpPlotEveryLabel, row, 0, tmpRowSpan, tmpColSpan)
         displayGridLayout.addWidget(self.plotEverySpinBox, row, 1, tmpRowSpan, tmpColSpan)
-        """
+        '''
 
-        # removed in favor of showing tooltip on mouse move
-        # row += 1
-        # self.crossHairCheckBox = QtWidgets.QCheckBox("Crosshair")
-        # self.crossHairCheckBox.setChecked(False)
-        # self.crossHairCheckBox.stateChanged.connect(self.on_crosshair_clicked)
-        # tmpRowSpan = 1
-        # tmpColSpan = 1
-        # displayGridLayout.addWidget(
-        #     self.crossHairCheckBox, row, 0, tmpRowSpan, tmpColSpan
-        # )
-
-        # # x/y coordinates of mouse in each of derivPlot, vmPlot, clipPlot)
-        # self.mousePositionLabel = QtWidgets.QLabel("x:None\ty:None")
-        # displayGridLayout.addWidget(
-        #     self.mousePositionLabel, row, 1, tmpRowSpan, tmpColSpan
-        # )
+        row += 1
+        self.crossHairCheckBox = QtWidgets.QCheckBox('Crosshair')
+        self.crossHairCheckBox.setChecked(False)
+        self.crossHairCheckBox.stateChanged.connect(self.on_crosshair_clicked)
+        tmpRowSpan = 1
+        tmpColSpan = 1
+        displayGridLayout.addWidget(self.crossHairCheckBox, row, 0, tmpRowSpan, tmpColSpan)
+
+        # x/y coordinates of mouse in each of derivPlot, vmPlot, clipPlot)
+        self.mousePositionLabel = QtWidgets.QLabel('x:None\ty:None')
+        displayGridLayout.addWidget(self.mousePositionLabel, row, 1, tmpRowSpan, tmpColSpan)
 
         hBoxSpikeBrowser = self._buildSpikeBrowser()  # includes (Spike, Go, <<, >>, [])
         row += 1
         rowSpan = 1
         columnSpan = 2
         displayGridLayout.addLayout(hBoxSpikeBrowser, row, 0, rowSpan, columnSpan)
 
@@ -3056,171 +2674,180 @@
         self.displayGroupBox.setLayout(displayGridLayout)
         self.mainLayout.addWidget(self.displayGroupBox)
 
         #
         # mar 11 set spike group box
         #
         # set spike group
-        self.setSpikeGroupBox = QtWidgets.QGroupBox("Set Spikes")
-        self.setContentsMargins(0,0,0,0)
+        self.setSpikeGroupBox = QtWidgets.QGroupBox('Set Spikes')
         setSpikeLayout = QtWidgets.QHBoxLayout()
-        setSpikeLayout.setContentsMargins(0,0,0,0)
 
         # mar 11, created a setSpikestat plugin
-        setSpikeStatWidget = sanpy.interface.plugins.SetSpikeStat(
-            ba=self.detectionWidget.ba,
-            bPlugin=self.detectionWidget.myMainWindow.myPlugins,
-        )
-
-        # signalSetSpikeStat is now in sanpyPlugin base class
-        # setSpikeStatWidget.signalSetSpikeStat.connect(
-        #     self.detectionWidget.slot_setSpikeStat
-        # )
-
+        setSpikeStatWidget = \
+            sanpy.interface.plugins.SetSpikeStat(ba=self.detectionWidget.ba,
+                                                 bPlugin=self.detectionWidget.myMainWindow.myPlugins)
+        setSpikeStatWidget.signalSetSpikeStat.connect(self.detectionWidget.slot_setSpikeStat)
+        # connect signal/slot
         setSpikeLayout.addWidget(setSpikeStatWidget)
 
         self.setSpikeGroupBox.setLayout(setSpikeLayout)
         self.mainLayout.addWidget(self.setSpikeGroupBox)
 
         #
         # plots  group
-        self.plotGroupBox = QtWidgets.QGroupBox("Plot Options")
-        # self.plotGroupBox.setContentsMargins(0,0,0,0)
+        self.plotGroupBox = QtWidgets.QGroupBox('Plot Options')
+
+        # breeze
+        #plotGroupBox.setStyleSheet(myStyleSheet)
 
         plotGridLayout = QtWidgets.QGridLayout()
-        plotGridLayout.setContentsMargins(4,4,0,0)
 
         row = 0
 
         # add widgets
+        '''
+        row = 0
+        col = 0
+        aCheckbox = QtWidgets.QCheckBox('Global Vm')
+        aCheckbox.setChecked(showGlobalVm)
+        aCheckbox.stateChanged.connect(partial(self.on_check_click,aCheckbox,'Global Vm'))
+        plotGridLayout.addWidget(aCheckbox, row, col)
+        '''
+
+        '''
+        row = 0
+        col += 1
+        show_dvdt_checkbox = QtWidgets.QCheckBox('dV/dt')
+        show_dvdt_checkbox.setChecked(showDvDt)
+        show_dvdt_checkbox.stateChanged.connect(partial(self.on_check_click,show_dvdt_checkbox,'dV/dt'))
+        plotGridLayout.addWidget(show_dvdt_checkbox, row, col)
+        '''
+
+        '''
+        row = 0
+        col += 1
+        show_dac_checkbox = QtWidgets.QCheckBox('DAC')
+        show_dac_checkbox.setChecked(showDAC)
+        show_dac_checkbox.stateChanged.connect(partial(self.on_check_click,show_dac_checkbox,'DAC'))
+        plotGridLayout.addWidget(show_dac_checkbox, row, col)
+        '''
+
         # a number of stats that will get overlaid on dv/dt and Vm
-        # row += 1
+        #row += 1
         row += 1
         col = 0
         for idx, plot in enumerate(self.myPlots):
-            # print('humanName:', plot['humanName'])
-            humanName = plot["humanName"]
-            isChecked = plot["plotIsOn"]
-            styleColor = plot["styleColor"]
+            #print('humanName:', plot['humanName'])
+            humanName = plot['humanName']
+            isChecked = plot['plotIsOn']
+            styleColor = plot['styleColor']
             checkbox = QtWidgets.QCheckBox(humanName)
             checkbox.setChecked(isChecked)
-            # checkbox.setStyleSheet(styleColor) # looks really ugly
-            # checkbox.stateChanged.connect(lambda:self.on_check_click(checkbox))
-            checkbox.stateChanged.connect(partial(self.on_check_click, checkbox, idx))
+            #checkbox.setStyleSheet(styleColor) # looks really ugly
+            #checkbox.stateChanged.connect(lambda:self.on_check_click(checkbox))
+            checkbox.stateChanged.connect(partial(self.on_check_click,checkbox,idx))
             # append
             plotGridLayout.addWidget(checkbox, row, col)
             # increment
             col += 1
-            if col == 2:  # we only have col 0/1, nx2 grid
+            if col == 2: # we only have col 0/1, nx2 grid
                 col = 0
                 row += 1
 
-        """
+        '''
         row = 0
         col += 1
         checkbox = QtWidgets.QCheckBox('Clips')
         checkbox.setChecked(showClips)
         checkbox.stateChanged.connect(partial(self.on_check_click,checkbox,'Clips'))
         plotGridLayout.addWidget(checkbox, row, col)
-        """
+        '''
 
-        """
+        '''
         row = 0
         col += 1
         checkbox = QtWidgets.QCheckBox('Scatter')
         checkbox.setChecked(showScatter)
         checkbox.stateChanged.connect(partial(self.on_check_click,checkbox,'Scatter'))
         plotGridLayout.addWidget(checkbox, row, col)
-        """
+        '''
 
-        """
+        '''
         row = 0
         col += 1
         checkbox = QtWidgets.QCheckBox('Errors')
         checkbox.setChecked(showErrors)
         checkbox.stateChanged.connect(partial(self.on_check_click,checkbox,'Errors'))
         plotGridLayout.addWidget(checkbox, row, col)
-        """
+        '''
 
         # finalize
         self.plotGroupBox.setLayout(plotGridLayout)
         self.mainLayout.addWidget(self.plotGroupBox)
 
+
         # finalize
         self.setLayout(self.mainLayout)
 
-    def _on_spike_number(self, spikeNumber):
-        """Respond to user setting spike number.
-        """
-        modifiers = QtWidgets.QApplication.keyboardModifiers()
-        isShift = modifiers == QtCore.Qt.ShiftModifier
-
-        self.detectionWidget.selectSpike(spikeNumber, isShift, doEmit=True)
-
-        # spikeNumber = self.spikeNumber.value()
-        # doZoom = isShift
-        # self.detectionWidget.selectSpike(spikeNumber, doZoom, doEmit=True)
+    def on_spike_number(self, spikeNumber):
+        logger.info(f'!!! THIS IS A PROBLEM spikeNumber:{spikeNumber}')
+        doZoom = False
+        self.detectionWidget.selectSpike(spikeNumber, doZoom, doEmit=True)
 
     def _buildSpikeBrowser(self):
         """Build interface to go to spike number, previous <<, and next >>"""
         hBoxSpikeBrowser = QtWidgets.QHBoxLayout()
 
         # aLabel = QtWidgets.QLabel('Spike')
         # hBoxSpikeBrowser.addWidget(aLabel)
 
         # absolute spike number
-        aLabel = QtWidgets.QLabel('Spike')
-        hBoxSpikeBrowser.addWidget(aLabel)
-
-        buttonName = "<<"
-        button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Previous Spike")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
-        hBoxSpikeBrowser.addWidget(button)
-
         self.spikeNumber = QtWidgets.QSpinBox()
-        self.spikeNumber.setToolTip("Go To Spike")
         self.spikeNumber.setMinimum(0)
         self.spikeNumber.setMaximum(2**16)
         self.spikeNumber.setKeyboardTracking(False)
         self.spikeNumber.setValue(0)
-        self.spikeNumber.valueChanged.connect(self._on_spike_number)
-        # self.spikeNumber.editingFinished.connect(self.on_spike_number)
-        # self.spikeNumber.setKeyboardTracking(False)
+        self.spikeNumber.valueChanged.connect(self.on_spike_number)
+        #self.spikeNumber.editingFinished.connect(self.on_spike_number)
+        #self.spikeNumber.setKeyboardTracking(False)
+
         hBoxSpikeBrowser.addWidget(self.spikeNumber)
 
-        # 20230419 removing Go, <<, >>
-        # condense everything into self.spikeNumber QtWidgets.QSpinBox
-        
-        # buttonName = "Go"
-        # button = QtWidgets.QPushButton(buttonName)
-        # button.setToolTip("Go To Spike Number")
-        # button.clicked.connect(partial(self.on_button_click, buttonName))
-        # hBoxSpikeBrowser.addWidget(button)
+        buttonName = 'Go'
+        button = QtWidgets.QPushButton(buttonName)
+        button.setToolTip('Go To Spike Number')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
+        hBoxSpikeBrowser.addWidget(button)
 
-        buttonName = ">>"
+        buttonName = '<<'
         button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Next Spike")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
+        button.setToolTip('Previous Spike')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
         hBoxSpikeBrowser.addWidget(button)
 
-        buttonName = "[]"
+        buttonName = '>>'
         button = QtWidgets.QPushButton(buttonName)
-        button.setToolTip("Display Full Recording")
-        button.clicked.connect(partial(self._on_button_click, buttonName))
+        button.setToolTip('Next Spike')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
+        hBoxSpikeBrowser.addWidget(button)
+
+        buttonName = '[]'
+        button.setToolTip('Display Full Recording')
+        button = QtWidgets.QPushButton(buttonName)
+        button.clicked.connect(partial(self.on_button_click,buttonName))
         hBoxSpikeBrowser.addWidget(button)
 
         return hBoxSpikeBrowser
 
     def setMousePositionLabel(self, x, y):
         if x is not None:
-            x = round(x, 4)  # 4 to get 10kHz precision, 0.0001
+            x = round(x,4) # 4 to get 10kHz precision, 0.0001
         if y is not None:
-            y = round(y, 2)
-        labelStr = f"x:{x}   y:{y}"
+            y = round(y,2)
+        labelStr = f'x:{x}   y:{y}'
         self.mousePositionLabel.setText(labelStr)
         self.mousePositionLabel.repaint()
 
     # def slot_setSpikeStat(self, setDict : dict):
     #     """Respond to changes from setSpikeStack plugin.
 
     #     Notes
@@ -3229,96 +2856,98 @@
     #     setSpikeStatEvent['spikeList'] = self.getSelectedSpikes()
     #     setSpikeStatEvent['colStr'] = colStr
     #     setSpikeStatEvent['value'] = value
     #     """
     #     logger.info(setDict)
     #     self.detectionWidget.slot_setSpikeStat(setDict)
 
-    def slot_selectSweep(self, sweep: int):
-        """Fake slot, not ising in emit/connect."""
-        self.sweepComboBox.setCurrentIndex(sweep + 1)
+    def slot_selectSweep(self, sweep : int):
+        """Fake slot, not ising in emit/connect.
+        """
+        self.sweepComboBox.setCurrentIndex(sweep+1)
 
-        # self.spikeNumber.setMaximum(+1e6)
-        # self.spikeNumber.setValue(0)
+        #self.spikeNumber.setMaximum(+1e6)
+        #self.spikeNumber.setValue(0)
 
     def slot_selectSpike(self, sDict):
-        logger.info(f"detectiontoolbar widget: sDict:{sDict}")
-        spikeNumber = sDict["spikeNumber"]
+        logger.info(f'detectiontoolbar widget: sDict:{sDict}')
+        spikeNumber = sDict['spikeNumber']
         # don't respond to a list of spikes
         if isinstance(spikeNumber, list):
             return
         # arbitrarily chosing spike 0 when no spike selection
         # spin boxes can not have 'no value'
         if spikeNumber is None:
             spikeNumber = 0
-
+        
         # convert absolute to sweep
-        # sweepSpike = self.detectionWidget.ba.getSweepSpikeFromAbsolute(spikeNumber, self.detectionWidget.sweepNumber)
-
-        """
+        #sweepSpike = self.detectionWidget.ba.getSweepSpikeFromAbsolute(spikeNumber, self.detectionWidget.sweepNumber)
+        
+        '''
         print('    !!!! self.detectionWidget.sweepNumber:', self.detectionWidget.sweepNumber)
         print('    !!!! spikeNumber:', spikeNumber)
         print('    !!!! sweepSpike:', sweepSpike)
-        """
+        '''
 
         # need to blockSignal or else this emits to callback
         self.spikeNumber.blockSignals(True)
         self.spikeNumber.setValue(spikeNumber)
         self.spikeNumber.blockSignals(False)
 
         self.spikeNumber.update()
 
     def slot_selectSpikeList(self, sDict):
-        logger.warning(f"mar 1, added and converting to select 1st spike")
-        # print('detectionWidget.slotSelectSpike() sDict:', sDict)
-        spikeList = sDict["spikeList"]
-        doZoom = sDict["doZoom"]
-
+        logger.warning(f'mar 1, added and converting to select 1st spike')
+        #print('detectionWidget.slotSelectSpike() sDict:', sDict)
+        spikeList = sDict['spikeList']
+        doZoom = sDict['doZoom']
+        
         # mar 11, detection toolbar does not select multiple spikes
         # self.selectSpikeList(spikeList, doZoom=doZoom)
 
         # mar 11
         if spikeList == []:
             spikeNumber = 0
         else:
             spikeNumber = spikeList[0]
-        sDict = {"spikeNumber": spikeNumber}
+        sDict = {
+            'spikeNumber': spikeNumber
+        }
         # self.selectSpike(spikeNumber, doZoom=doZoom)
         self.slot_selectSpike(sDict)
 
     def slot_selectFile(self, rowDict):
-        file = rowDict["File"]
-        
-        #self.mySelectedFileLabel.setText(file)
+        file = rowDict['File']
+        self.mySelectedFileLabel.setText(file)
 
         # handled in fill in detection parameters
         # set start(s) stop(s)
-        """
+        '''
         startSec = rowDict['Start(s)']
         stopSec = rowDict['Stop(s)']
         logger.info(f'setting startSec:"{stopSec}" {type(startSec)}')
         logger.info(f'setting stopSec:"{stopSec}" {type(stopSec)}')
         if isinstance(startSec, float):
             self.startSeconds.setValue(startSec)
         if isinstance(stopSec, float):
             self.stopSeconds.setValue(stopSec)
-        """
+        '''
 
         # block signals as we update
         self.sweepComboBox.blockSignals(True)
         #
 
         # populate sweep combo box
         self.sweepComboBox.clear()
-        # self.sweepComboBox.addItem('All')
+        #self.sweepComboBox.addItem('All')
         for sweep in range(self.detectionWidget.ba.fileLoader.numSweeps):
             self.sweepComboBox.addItem(str(sweep))
         # always select sweep 0
         self.sweepComboBox.setCurrentIndex(1)
-        # if self.detectionWidget.ba.numSweeps == 1:
+        #if self.detectionWidget.ba.numSweeps == 1:
         #    # select sweep 0
         #    self.sweepComboBox.setCurrentIndex(1)
 
         # turn off sweep combo box if just one sweep
         enableSweepButtons = self.detectionWidget.ba.fileLoader.numSweeps > 1
         self.sweepComboBox.setEnabled(enableSweepButtons)
         self.previousSweepButton.setEnabled(enableSweepButtons)
@@ -3326,77 +2955,73 @@
 
         #
         self.sweepComboBox.blockSignals(False)
         #
 
         # TODO: Fix this, we need to set this when user performs new analysis
         # self.spikeNumber.setMaximum(self.detectionWidget.ba.numSpikes - 1)
-
+        
         self.spikeNumber.blockSignals(True)
         self.spikeNumber.setValue(0)
         self.spikeNumber.blockSignals(False)
 
     def slot_dataChanged(self, columnName, value, rowDict):
         """User has edited main file table.
 
         Update detection widget for columns (Start(s), Stop(s), dvdtThreshold, mvThreshold)
         """
-        logger.info(f"{columnName} {value} {type(value)}")
+        logger.info(f'{columnName} {value} {type(value)}')
 
-        # for k,v in rowDict.items():
+        #for k,v in rowDict.items():
         #    print(f'  {k}:"{v}" {type(v)}')
 
         if columnName is not None:
             # user has made a change in one cell
-            if columnName == "dvdtThreshold":
+            if columnName == 'dvdtThreshold':
                 if value is None or math.isnan(value):
                     value = -1
                 self.dvdtThreshold.setValue(value)
-            elif columnName == "mvThreshold":
+            elif columnName == 'mvThreshold':
                 self.mvThreshold.setValue(value)
-            # removed 20230419
-            # elif columnName == "Start(s)" and not math.isnan(value):
-            #     self.startSeconds.setValue(value)
-            # elif columnName == "Stop(s)" and not math.isnan(value):
-            #     self.stopSeconds.setValue(value)
+            elif columnName == 'Start(s)' and not math.isnan(value):
+                self.startSeconds.setValue(value)
+            elif columnName == 'Stop(s)' and not math.isnan(value):
+                self.stopSeconds.setValue(value)
         else:
             # entire row has updated
-            dvdtThreshold = rowDict["dvdtThreshold"]
+            dvdtThreshold = rowDict['dvdtThreshold']
             # I really need to make 'no value' np.nan
             if dvdtThreshold is None or math.isnan(dvdtThreshold):
                 dvdtThreshold = 0  # 0 corresponds to 'None'
             self.dvdtThreshold.setValue(dvdtThreshold)
-            mvThreshold = rowDict["mvThreshold"]
+            mvThreshold = rowDict['mvThreshold']
             self.mvThreshold.setValue(mvThreshold)
-            
-            # removed 20230419
-            # startSeconds = rowDict["Start(s)"]
-            # if not math.isnan(startSeconds):
-            #     self.startSeconds.setValue(startSeconds)
-            # stopSeconds = rowDict["Stop(s)"]
-            # if not math.isnan(stopSeconds):
-            #     self.stopSeconds.setValue(stopSeconds)
-
+            startSeconds = rowDict['Start(s)']
+            if not math.isnan(startSeconds):
+                self.startSeconds.setValue(startSeconds)
+            stopSeconds = rowDict['Stop(s)']
+            if not math.isnan(stopSeconds):
+                self.stopSeconds.setValue(stopSeconds)
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     # load a bAnalysis file
 
-    # abfFile = '/Users/cudmore/Sites/bAnalysis/data/19221021.abf'
-    # abfFile = '/Users/cudmore/Sites/bAnalysis/data/19114001.abf'
-    path = "/media/cudmore/data/Laura-data/manuscript-data/2020_06_23_0006.abf"
-    path = "../data/19114001.abf"
-    path = "/media/cudmore/data/rabbit-ca-transient/Control/220110n_0003.tif.frames/220110n_0003.tif"
+    #abfFile = '/Users/cudmore/Sites/bAnalysis/data/19221021.abf'
+    #abfFile = '/Users/cudmore/Sites/bAnalysis/data/19114001.abf'
+    path = '/media/cudmore/data/Laura-data/manuscript-data/2020_06_23_0006.abf'
+    path = '../data/19114001.abf'
+    path = '/media/cudmore/data/rabbit-ca-transient/Control/220110n_0003.tif.frames/220110n_0003.tif'
 
     ba = sanpy.bAnalysis(path)
 
     app = QtWidgets.QApplication(sys.argv)
     w = bDetectionWidget()
     w.slot_switchFile(ba=ba)
 
     detectionType = sanpy.bDetection.detectionTypes.mv
     dvdtThreshold = 10
     mvThreshold = 1000  # -20
-    # w.detect(detectionType, dvdtThreshold, mvThreshold)
+    #w.detect(detectionType, dvdtThreshold, mvThreshold)
 
     w.show()
 
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bErrorTable.py` & `sanpy-ephys-0.1.6/sanpy/interface/bErrorTable.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,155 +1,117 @@
 from typing import List
 
 from PyQt5 import QtCore, QtGui, QtWidgets
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class errorTableView(QtWidgets.QTableView):
     """
     Display a per spike error table (one row per spike eror)
     """
-
-    signalSelectSpike = QtCore.Signal(object)  # spike number, doZoom
+    signalSelectSpike = QtCore.Signal(object) # spike number, doZoom
 
     def __init__(self, parent=None):
         super(errorTableView, self).__init__(parent)
 
-        # self.setFont(QtGui.QFont('Arial', 10))
+        #self.setFont(QtGui.QFont('Arial', 10))
 
         self._blockTableUpdate = False
 
         self.setSortingEnabled(True)
 
-        # self.setSizePolicy(
-        #     QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        # )
-
-        _hHeader = self.horizontalHeader()
-        _hHeader.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
-        # _hHeader.setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
-
-        # see
-        # https://stackoverflow.com/questions/38098763/pyside-pyqt-how-to-make-set-qtablewidget-column-width-as-proportion-of-the-a
-        # _hHeader = self.horizontalHeader()       
-        # _hHeader.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.Stretch)
-        # _hHeader.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
-        # _hHeader.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
-
+        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                  QtWidgets.QSizePolicy.Expanding)
+        
         self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
+        
+        #self.setSelectionMode(QtWidgets.QTableView.SingleSelection)
 
-        # self.setSelectionMode(QtWidgets.QTableView.SingleSelection)
-
-        self.setEditTriggers(
-            QtWidgets.QAbstractItemView.NoEditTriggers
-            | QtWidgets.QAbstractItemView.DoubleClicked
-        )
+        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers |
+                             QtWidgets.QAbstractItemView.DoubleClicked)
 
         # equally stretchs each columns so that they fit the table's width.
-        # self.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch);
+        #self.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch);
         self.horizontalHeader().setStretchLastSection(True)
 
         # removed mar 2023
         # rowHeight = 11
         # fnt = self.font()
         # fnt.setPointSize(rowHeight)
         # self.setFont(fnt)
         # self.verticalHeader().setDefaultSectionSize(rowHeight);
 
-        # self.resizeColumnsToContents()
+        #self.resizeColumnsToContents()
 
         self.clicked.connect(self.errorTableClicked)
-        self.doubleClicked.connect(self._on_doubleClick)
 
-    def mySelectRows(self, rows: List[int]):
+    def mySelectRows(self, rows : List[int]):
         """Select rows in the table
-
+        
         TODO: Hold off on this, we need to define a sort proxy. See PyMapManager tables.
         """
         return
-
-        logger.info(f"rows:{rows}")
+    
+        logger.info(f'rows:{rows}')
 
         # to stop event recursion
         self._blockTableUpdate = True
-
+        
         selectionModel = self.selectionModel()
         if selectionModel:
             selectionModel.clear()
-
+        
             if rows:
                 indexes = [self.model().index(r, 0) for r in rows]  # [QModelIndex]
-                visualRows = [
-                    self.proxy.mapFromSource(modelIndex) for modelIndex in indexes
-                ]
-
-                mode = (
-                    QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows
-                )
+                visualRows = [self.proxy.mapFromSource(modelIndex) for modelIndex in indexes]
+
+                mode = QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows
                 [self.selectionModel().select(i, mode) for i in visualRows]
 
                 # scroll so first row in rows is visible
                 # TODO (cudmore) does not work if list is filtered
                 column = 0
                 row = list(rows)[0]
                 index = self.model().index(row, column)
-                self.scrollTo(
-                    index, QtWidgets.QAbstractItemView.PositionAtTop
-                )  # EnsureVisible
+                self.scrollTo(index, QtWidgets.QAbstractItemView.PositionAtTop)  # EnsureVisible
             else:
-                # print('  CLEARING SELECTION')
+                #print('  CLEARING SELECTION')
                 self.clearSelection()
-
+        
         #
         self._blockTableUpdate = False
-
-    def _on_doubleClick(self, index):
-        """
-        Parameters
-        ----------
-        index : QtCore.QModelIndex
-        """
-        row = self.model()._data.index[index.row()]  # take sorting into account
-        logger.info(index.row())
-        self.errorTableClicked(index, doubleClick=True)
-
-    def errorTableClicked(self, index, doubleClick=False):
-        """
-        Parameters
-        ----------
-        index : QtCore.QModelIndex
-        """
-        row = self.model()._data.index[index.row()]  # take sorting into account
-
-        doZoom = doubleClick
-        # modifiers = QtWidgets.QApplication.keyboardModifiers()
-        # if modifiers == QtCore.Qt.ShiftModifier:
-        #     # zoomm on shift+click
-        #     doZoom = True
+        
+    def errorTableClicked(self, index):
+        row = self.model()._data.index[index.row()] # take sorting into account
+
+        doZoom = False
+        modifiers = QtWidgets.QApplication.keyboardModifiers()
+        if modifiers == QtCore.Qt.ShiftModifier:
+            # zoomm on shift+click
+            doZoom = True
 
         try:
             # .loc[i,'col'] gets from index label (correct)
             # .iloc[i,j] gets absolute row (wrong)
-            spikeNumber = self.model()._data.loc[row, "Spike"]
-        except KeyError as e:
+            spikeNumber = self.model()._data.loc[row, 'Spike']
+        except (KeyError) as e:
             # for results plugin
             try:
-                spikeNumber = self.model()._data.loc[row, "spikeNumber"]
-            except KeyError as e:
+                spikeNumber = self.model()._data.loc[row, 'spikeNumber']
+            except (KeyError) as e:
                 logger.warning(f'KeyError looking for column "Spike" or "spikeNumber"')
                 return
         spikeNumber = int(spikeNumber)
 
         dDict = {
-            "spikeNumber": spikeNumber,
-            "doZoom": doZoom,
+            'spikeNumber': spikeNumber,
+            'doZoom': doZoom,
         }
-        logger.info(f"  -->> emit signalSelectSpike with dDict")
+        logger.info(f'  -->> emit signalSelectSpike with dDict')
         logger.info(dDict)
-
-        # self._blockSlots = True
+        
+        #self._blockSlots = True
         self.signalSelectSpike.emit(dDict)
+        
+        #self._blockSlots = False
 
-        # self._blockSlots = False
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bExportWidget.py` & `sanpy-ephys-0.1.6/sanpy/interface/bExportWidget.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,121 +5,103 @@
 import numpy as np
 import scipy.signal
 from PyQt5 import QtWidgets, QtGui, QtCore
 import matplotlib
 import matplotlib.figure
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
-import matplotlib.pyplot as plt  # abb 202012 added to set theme
+import matplotlib.pyplot as plt # abb 202012 added to set theme
 import matplotlib.ticker as ticker
 
-# import qdarkstyle
+#import qdarkstyle
 
 # abb 20200718
 # needed to import from SanPy which is one folder up
-# sys.path.append("..")
+#sys.path.append("..")
 
-# from SanPy import bAnalysis
-# from SanPy import bAnalysisPlot
-# import bAnalysis
-# import bAnalysisPlot
+#from SanPy import bAnalysis
+#from SanPy import bAnalysisPlot
+#import bAnalysis
+#import bAnalysisPlot
 from sanpy import bAnalysis
-
-# import sanpy.bAnalysis
+#import sanpy.bAnalysis
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class CustomStyle(QtWidgets.QProxyStyle):
     def styleHint(self, hint, option=None, widget=None, returnData=None):
         if hint == QtWidgets.QStyle.SH_SpinBox_KeyPressAutoRepeatRate:
             return 10**10
         elif hint == QtWidgets.QStyle.SH_SpinBox_ClickAutoRepeatRate:
             return 10**10
         elif hint == QtWidgets.QStyle.SH_SpinBox_ClickAutoRepeatThreshold:
             # You can use only this condition to avoid the auto-repeat,
             # but better safe than sorry ;-)
             return 10**10
         else:
             return super().styleHint(hint, option, widget, returnData)
 
-
 class draggable_lines:
-    def __init__(
-        self,
-        ax,
-        xPos,
-        yPos,
-        hLength=5,
-        vLength=20,
-        linewidth=3,
-        color="k",
-        doPick=False,
-    ):
+    def __init__(self, ax, xPos, yPos,
+                    hLength=5, vLength=20,
+                    linewidth=3, color='k', doPick=False):
         self.ax = ax
         self.c = ax.get_figure().canvas
 
         self.xPos = xPos
         self.yPos = yPos
 
         self.hLineLength = hLength
         self.vLineLength = vLength
 
         # horz line (user can drag this)
-        x = [xPos, xPos + hLength]
+        x = [xPos, xPos+hLength]
         y = [yPos, yPos]
-        (self.hLine,) = self.ax.plot(
-            x,
-            y,
-            "-",
-            label="xScaleBar",
-            linewidth=linewidth,
-            c=color,
-            clip_on=False,
-            picker=5,
-        )
-        """
+        self.hLine, = self.ax.plot(x, y, '-',
+                                label='xScaleBar',
+                                linewidth=linewidth, c=color,
+                                clip_on = False,
+                                picker=5)
+        '''
         self.hLine = matplotlib.lines.Line2D(x, y, label='xScaleBar',
                                 marker=None,
                                 linewidth=linewidth, c=color,
                                 clip_on = False,
                                 picker=5)
         self.ax.add_line(self.hLine)
-        """
+        '''
 
         # vert line
         x = [xPos, xPos]
-        y = [yPos, yPos + vLength]
-        (self.vLine,) = self.ax.plot(
-            x, y, "-", label="yScaleBar", linewidth=linewidth, c=color, clip_on=False
-        )
-        # picker=None)
-        """
+        y = [yPos, yPos+vLength]
+        self.vLine, = self.ax.plot(x, y, '-',
+                                label='yScaleBar',
+                                linewidth=linewidth, c=color,
+                                clip_on = False)
+                                #picker=None)
+        '''
         self.vLine = matplotlib.lines.Line2D(x, y, label='yScaleBar',
                                 marker=None,
                                 linewidth=linewidth, c=color,
                                 clip_on = False,
                                 picker=None)
         self.ax.add_line(self.vLine)
-        """
+        '''
 
         self.c.draw_idle()
-        self.sid = self.c.mpl_connect("pick_event", self.clickonline)
+        self.sid = self.c.mpl_connect('pick_event', self.clickonline)
 
     def clickonline(self, event):
-        # print('clickonline()')
+        #print('clickonline()')
         if event.artist == self.hLine:
-            # print("  line selected ", event.artist)
+            #print("  line selected ", event.artist)
             self.follower = self.c.mpl_connect("motion_notify_event", self.followmouse)
-            # self.releaser = self.c.mpl_connect("button_press_event", self.releaseonclick)
-            self.releaser = self.c.mpl_connect(
-                "button_release_event", self.releaseonclick
-            )
+            #self.releaser = self.c.mpl_connect("button_press_event", self.releaseonclick)
+            self.releaser = self.c.mpl_connect("button_release_event", self.releaseonclick)
 
     def hideScaleBar(self, xChecked, yChecked):
         xPos = np.nan
         yPos = np.nan
 
         if xChecked:
             self.hLine.set_ydata([self.yPos, self.yPos])
@@ -157,561 +139,551 @@
     def setPos(self, xPos=None, yPos=None, fromMax=False):
         """
         use this while (i) user-drag and (2) set x/y scale
 
         fromMax: USe this when setting from x/y axes max and we will shift position
 
         """
-        # print('draggable_lines.setPos()', 'xPos:', xPos, 'yPos:', yPos, 'fromMax:', fromMax)
+        #print('draggable_lines.setPos()', 'xPos:', xPos, 'yPos:', yPos, 'fromMax:', fromMax)
 
         if xPos is None:
             pass
-            # xPos = self.xPos
+            #xPos = self.xPos
         else:
             if fromMax:
                 self.xPos = xPos - 1.5 * self.hLineLength
             else:
                 self.xPos = xPos
         if yPos is None:
             pass
-            # yPos = self.yPos
+            #yPos = self.yPos
         else:
             if fromMax:
                 self.yPos = yPos - 1.5 * self.vLineLength
             else:
                 self.yPos = yPos
 
         xPos = self.xPos
         yPos = self.yPos
 
-        # print('  xPos:', xPos, 'yPos:', yPos)
+        #print('  xPos:', xPos, 'yPos:', yPos)
 
         self.hLine.set_ydata([yPos, yPos])
         self.hLine.set_xdata([xPos, xPos + self.hLineLength])
         # a second line print('Vline is vertical')
         self.vLine.set_xdata([xPos, xPos])
         self.vLine.set_ydata([yPos, yPos + self.vLineLength])
 
         self.c.draw_idle()
 
     def followmouse(self, event):
-        # print('followmouse()')
+        #print('followmouse()')
         self.setPos(event.xdata, event.ydata)
 
     def releaseonclick(self, event):
-        # print('releaseonclick()')
+        #print('releaseonclick()')
         self.c.mpl_disconnect(self.releaser)
         self.c.mpl_disconnect(self.follower)
 
-
 class bExportWidget(QtWidgets.QWidget):
     """
     Open a window and display the raw Vm of a bAnalysis abf file
     """
 
     myCloseSignal = QtCore.Signal(object)
 
-    def __init__(
-        self,
-        sweepX,
-        sweepY,
-        xyUnits=("", ""),
-        path="",
-        darkTheme=False,
-        xMin=None,
-        xMax=None,
-        xMargin=0,
-        type="vm",  # (vm, dvdt, meanclip)
-        parent=None,
-    ):
-        """ """
+    def __init__(self,
+                    sweepX, sweepY,
+                    xyUnits=('',''),
+                    path='',
+                    darkTheme=False,
+                    xMin=None,
+                    xMax=None,
+                    xMargin=0,
+                    type='vm', # (vm, dvdt, meanclip)
+                    parent=None,
+                    ):
+        """
+        """
         super(bExportWidget, self).__init__(parent)
 
         self._inCallback = False
 
         self.shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+w"), self)
         self.shortcut.activated.connect(self.myCloseAction)
 
-        # self.setFont(QtGui.QFont("Helvetica", 11, QtGui.QFont.Normal, italic=False))
-
-        self.myType = type  # use this to size defaults for scale bar
+        #self.setFont(QtGui.QFont("Helvetica", 11, QtGui.QFont.Normal, italic=False))
 
-        # self.myParent = parent
+        self.myType = type # use this to size defaults for scale bar
+        
+        #self.myParent = parent
 
         self.mySweepX = sweepX
         self.mySweepY = sweepY
         self.mySweepX_Downsample = self.mySweepX
         self.mySweepY_Downsample = self.mySweepY
 
-        # okGo = self.setFile(file)
+        #okGo = self.setFile(file)
         self.path = path
         self.xyUnits = xyUnits
 
         self.darkTheme = darkTheme
 
         if self.darkTheme:
-            plt.style.use("dark_background")
+            plt.style.use('dark_background')
         else:
             plt.rcParams.update(plt.rcParamsDefault)
 
         self.scaleBarDict = {}
-        self.scaleBarDict["hLength"] = 5
-        self.scaleBarDict["vLength"] = 20
-        self.scaleBarDict["lineWidth"] = 5
+        self.scaleBarDict['hLength'] = 5
+        self.scaleBarDict['vLength'] = 20
+        self.scaleBarDict['lineWidth'] = 5
         if self.darkTheme:
-            self.scaleBarDict["color"] = "w"
+            self.scaleBarDict['color'] = 'w'
         else:
-            self.scaleBarDict["color"] = "k"
-        if self.myType == "vm":
-            self.scaleBarDict["hLength"] = 1  # second
-            self.scaleBarDict["vLength"] = 20  # mv
-        elif self.myType == "dvdt":
-            self.scaleBarDict["hLength"] = 1  # second
-            self.scaleBarDict["vLength"] = 10
-        elif self.myType == "meanclip":
-            self.scaleBarDict["hLength"] = 5  # ms
-            self.scaleBarDict["vLength"] = 20  # mv
+            self.scaleBarDict['color'] = 'k'
+        if self.myType == 'vm':
+            self.scaleBarDict['hLength'] = 1 # second
+            self.scaleBarDict['vLength'] = 20 # mv
+        elif self.myType == 'dvdt':
+            self.scaleBarDict['hLength'] = 1 # second
+            self.scaleBarDict['vLength'] = 10
+        elif self.myType == 'meanclip':
+            self.scaleBarDict['hLength'] = 5 # ms
+            self.scaleBarDict['vLength'] = 20 # mv
 
-        self.xMargin = xMargin  # seconds
+        self.xMargin = xMargin # seconds
         self.internalUpdate = False
 
         self.initUI()
 
         if xMin is not None and xMax is not None:
             pass
-            # self.xMin = xMin
-            # self.xMax = xMax
+            #self.xMin = xMin
+            #self.xMax = xMax
         else:
             xMin = np.nanmin(self.mySweepX_Downsample)
             xMax = np.nanmax(self.mySweepX_Downsample)
         #
         self.myAxis.set_xlim(xMin, xMax)
 
-        # self._setXAxis(xMin, xMax)
+        #self._setXAxis(xMin, xMax)
 
-    def switchFile(self, ba: bAnalysis, x, y):
-        self.mySweepX = x  # ba.fileLoader.sweepX
-        self.mySweepY = y  # ba.fileLoader.sweepY
+    def switchFile(self, ba : bAnalysis, x, y):
+        
+        self.mySweepX = x  #ba.fileLoader.sweepX
+        self.mySweepY = y  #ba.fileLoader.sweepY
         self.mySweepX_Downsample = self.mySweepX
         self.mySweepY_Downsample = self.mySweepY
 
         self.path = ba.fileLoader.filepath
 
         if self.path:
             windowTitle = os.path.split(self.path)[1]
-            # print('windowTitle:', windowTitle)
-            self.setWindowTitle("Export Trace: " + windowTitle)
+            #print('windowTitle:', windowTitle)
+            self.setWindowTitle('Export Trace: ' + windowTitle)
         else:
-            self.setWindowTitle("Export Trace: " + "None")
+            self.setWindowTitle('Export Trace: ' + 'None')
 
         self.plotRaw()
 
         # TODO: put in plot()
         xMin = np.nanmin(self.mySweepX_Downsample)
         xMax = np.nanmax(self.mySweepX_Downsample)
-        logger.info(f"xMin:{xMin} xMax:{xMax}")
+        logger.info(f'xMin:{xMin} xMax:{xMax}')
         self.myAxis.set_xlim(xMin, xMax)
 
         try:
             self.myAxis.relim()  # causing exception: ValueError: array of sample points is empty
-        except ValueError as e:
-            logger.warning(f"relim triggered ValueError?")
+        except (ValueError) as e:
+            logger.warning(f'relim triggered ValueError?')
 
-        self.myAxis.autoscale_view(True, True, True)
-        # plt.draw()
+        self.myAxis.autoscale_view(True,True,True)
+        #plt.draw()
 
     def myCloseAction(self):
         self.closeEvent()
 
     def closeEvent(self, event=None):
         """
         in Qt, close only hides the widget!
         """
-        # print('bExportWidget.closeEvent()')
+        #print('bExportWidget.closeEvent()')
         self.deleteLater()
         self.myCloseSignal.emit(self)
 
     def initUI(self):
-        # self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
 
-        """
+        #self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
+
+        '''
         myPath = os.path.dirname(os.path.abspath(__file__))
         mystylesheet_css = os.path.join(myPath, 'css', 'mystylesheet.css')
         myStyleSheet = None
         if os.path.isfile(mystylesheet_css):
             with open(mystylesheet_css) as f:
                 myStyleSheet = f.read()
 
         if myStyleSheet is not None:
             self.setStyleSheet(myStyleSheet)
-        """
+        '''
 
-        # self.setGeometry(100, 100, 1000, 600)
+        #self.setGeometry(100, 100, 1000, 600)
         self.center()
 
         if self.path:
             windowTitle = os.path.split(self.path)[1]
-            self.setWindowTitle("Export Trace: " + windowTitle)
+            self.setWindowTitle('Export Trace: ' + windowTitle)
         else:
-            self.setWindowTitle("Export Trace: " + "None")
+            self.setWindowTitle('Export Trace: ' + 'None')
 
         myAlignLeft = QtCore.Qt.AlignLeft
         myAlignTop = QtCore.Qt.AlignTop
 
         hMasterLayout = QtWidgets.QHBoxLayout()
         hMasterLayout.setAlignment(QtCore.Qt.AlignTop)
         self.setLayout(hMasterLayout)
 
         left_container = QtWidgets.QWidget(self)
         left_container.setFixedWidth(350)
 
         hMasterLayout.addWidget(left_container, myAlignTop)
 
-        vBoxLayout = QtWidgets.QVBoxLayout(left_container)  # VBox for controls
+        vBoxLayout = QtWidgets.QVBoxLayout(left_container) # VBox for controls
         vBoxLayout.setAlignment(QtCore.Qt.AlignTop)
 
         hBoxRow0 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow0, myAlignTop)
 
         #
         # first row of controls
 
         # x axis on/off (todo: does not need self)
-        self.xAxisCheckBox = QtWidgets.QCheckBox("")
-        self.xAxisCheckBox.setToolTip("Toggle X-Axis On/Off")
+        self.xAxisCheckBox = QtWidgets.QCheckBox('')
+        self.xAxisCheckBox.setToolTip('Toggle X-Axis On/Off')
         self.xAxisCheckBox.setChecked(True)
         self.xAxisCheckBox.stateChanged.connect(self.xAxisToggle)
         hBoxRow0.addWidget(self.xAxisCheckBox, myAlignLeft)
 
         # x min
-        xMinLabel = QtWidgets.QLabel("X-Min")
+        xMinLabel = QtWidgets.QLabel('X-Min')
         hBoxRow0.addWidget(xMinLabel, myAlignLeft)
         self.xMinSpinBox = QtWidgets.QDoubleSpinBox()
-        self.xMinSpinBox.setToolTip("X-Axis Minimum")
+        self.xMinSpinBox.setToolTip('X-Axis Minimum')
         self.xMinSpinBox.setSingleStep(0.1)
         self.xMinSpinBox.setMinimum(-1e6)
         self.xMinSpinBox.setMaximum(1e6)
         self.xMinSpinBox.setValue(0)
-        self.xMinSpinBox.setToolTip("X-Axis Minimum")
+        self.xMinSpinBox.setToolTip('X-Axis Minimum')
         self.xMinSpinBox.setKeyboardTracking(False)
         self.xMinSpinBox.valueChanged.connect(self._setXAxis)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow0.addWidget(self.xMinSpinBox, myAlignLeft)
 
         # x max
         xMax = np.nanmax(self.mySweepX_Downsample)  # self.mySweepX_Downsample[-1]
-        xMaxLabel = QtWidgets.QLabel("X-Max")
+        xMaxLabel = QtWidgets.QLabel('X-Max')
         hBoxRow0.addWidget(xMaxLabel, myAlignLeft)
         self.xMaxSpinBox = QtWidgets.QDoubleSpinBox()
-        self.xMaxSpinBox.setToolTip("X-Axis Maximum")
+        self.xMaxSpinBox.setToolTip('X-Axis Maximum')
         self.xMaxSpinBox.setSingleStep(0.1)
         self.xMaxSpinBox.setMinimum(-1e6)
         self.xMaxSpinBox.setMaximum(1e6)
         self.xMaxSpinBox.setValue(xMax)
-        self.xMaxSpinBox.setToolTip("X-Axis Maximum")
+        self.xMaxSpinBox.setToolTip('X-Axis Maximum')
         self.xMaxSpinBox.setKeyboardTracking(False)
         self.xMaxSpinBox.valueChanged.connect(self._setXAxis)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow0.addWidget(self.xMaxSpinBox, myAlignLeft)
 
         #
         # second row
         hBoxRow1 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow1)
 
         # y axis
-        self.yAxisCheckBox = QtWidgets.QCheckBox("")
-        self.yAxisCheckBox.setToolTip("Toggle Y-Axis On/Off")
+        self.yAxisCheckBox = QtWidgets.QCheckBox('')
+        self.yAxisCheckBox.setToolTip('Toggle Y-Axis On/Off')
         self.yAxisCheckBox.setChecked(True)
         self.yAxisCheckBox.stateChanged.connect(self.yAxisToggle)
         hBoxRow1.addWidget(self.yAxisCheckBox)
 
         # y min
-        yMinLabel = QtWidgets.QLabel("Y-Min")
+        yMinLabel = QtWidgets.QLabel('Y-Min')
         hBoxRow1.addWidget(yMinLabel)
         yMinValue = np.nanmin(self.mySweepY_Downsample)
         self.yMinSpinBox = QtWidgets.QDoubleSpinBox()
         self.yMinSpinBox.setSingleStep(0.1)
         self.yMinSpinBox.setMinimum(-1e6)
         self.yMinSpinBox.setMaximum(1e6)
-        self.yMinSpinBox.setValue(yMinValue)  # flipped
-        self.yMinSpinBox.setToolTip("Y-Axis Minimum")
+        self.yMinSpinBox.setValue(yMinValue) # flipped
+        self.yMinSpinBox.setToolTip('Y-Axis Minimum')
         self.yMinSpinBox.setKeyboardTracking(False)
         self.yMinSpinBox.valueChanged.connect(self._setYAxis)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow1.addWidget(self.yMinSpinBox)
 
         # y max
-        yMaxLabel = QtWidgets.QLabel("Y-Max")
+        yMaxLabel = QtWidgets.QLabel('Y-Max')
         hBoxRow1.addWidget(yMaxLabel)
         yMaxValue = np.nanmax(self.mySweepY_Downsample)
         self.yMaxSpinBox = QtWidgets.QDoubleSpinBox()
         self.yMaxSpinBox.setSingleStep(0.1)
         self.yMaxSpinBox.setMinimum(-1e6)
         self.yMaxSpinBox.setMaximum(1e6)
-        self.yMaxSpinBox.setValue(yMaxValue)  # flipped
-        self.yMaxSpinBox.setToolTip("Y-Axis Maximum")
+        self.yMaxSpinBox.setValue(yMaxValue) # flipped
+        self.yMaxSpinBox.setToolTip('Y-Axis Maximum')
         self.yMaxSpinBox.setKeyboardTracking(False)
         self.yMaxSpinBox.valueChanged.connect(self._setYAxis)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow1.addWidget(self.yMaxSpinBox)
 
         #
         # one 1/2 row
         hBoxRow1_5 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow1_5)
 
         # x-tick major
-        lineWidthLabel = QtWidgets.QLabel("X-Tick Major")
+        lineWidthLabel = QtWidgets.QLabel('X-Tick Major')
         hBoxRow1_5.addWidget(lineWidthLabel)
         self.xTickIntervalSpinBox = QtWidgets.QDoubleSpinBox()
         self.xTickIntervalSpinBox.setSingleStep(0.1)
         self.xTickIntervalSpinBox.setMinimum(0.0)
         self.xTickIntervalSpinBox.setMaximum(1e6)
         self.xTickIntervalSpinBox.setValue(10)
-        self.xTickIntervalSpinBox.setToolTip("Major Tick Interval, 0 To Turn Off")
+        self.xTickIntervalSpinBox.setToolTip('Major Tick Interval, 0 To Turn Off')
         self.xTickIntervalSpinBox.setKeyboardTracking(False)
         self.xTickIntervalSpinBox.valueChanged.connect(self._setTickMajorInterval)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow1_5.addWidget(self.xTickIntervalSpinBox)
 
         # x-tick minor
-        lineWidthLabel = QtWidgets.QLabel("Minor")
+        lineWidthLabel = QtWidgets.QLabel('Minor')
         hBoxRow1_5.addWidget(lineWidthLabel)
         self.xTickMinorIntervalSpinBox = QtWidgets.QDoubleSpinBox()
         self.xTickMinorIntervalSpinBox.setSingleStep(0.1)
         self.xTickMinorIntervalSpinBox.setMinimum(0.0)
         self.xTickMinorIntervalSpinBox.setMaximum(1e6)
         self.xTickMinorIntervalSpinBox.setValue(10)
-        self.xTickMinorIntervalSpinBox.setToolTip("Minor Tick Interval, 0 To Turn Off")
+        self.xTickMinorIntervalSpinBox.setToolTip('Minor Tick Interval, 0 To Turn Off')
         self.xTickMinorIntervalSpinBox.setKeyboardTracking(False)
         self.xTickMinorIntervalSpinBox.valueChanged.connect(self._setTickMinorInterval)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow1_5.addWidget(self.xTickMinorIntervalSpinBox)
 
         #
         # one 3/4 row
         hBoxRow1_ytick = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow1_ytick)
 
         # y-tick major
-        lineWidthLabel = QtWidgets.QLabel("Y-Tick Major")
+        lineWidthLabel = QtWidgets.QLabel('Y-Tick Major')
         hBoxRow1_ytick.addWidget(lineWidthLabel)
         self.yTickIntervalSpinBox = QtWidgets.QDoubleSpinBox()
         self.yTickIntervalSpinBox.setSingleStep(0.1)
         self.yTickIntervalSpinBox.setMinimum(0.0)
         self.yTickIntervalSpinBox.setMaximum(1e6)
         self.yTickIntervalSpinBox.setValue(20)
-        self.yTickIntervalSpinBox.setToolTip("Major Y-Tick Interval, 0 To Turn Off")
+        self.yTickIntervalSpinBox.setToolTip('Major Y-Tick Interval, 0 To Turn Off')
         self.yTickIntervalSpinBox.setKeyboardTracking(False)
         self.yTickIntervalSpinBox.valueChanged.connect(self._setYTickMajorInterval)
-        # todo: FIX THIS RECURSION WITH USING UP/DOWN ARROWS
-        # self.yTickIntervalSpinBox.editingFinished.connect(self._setYTickMajorInterval)
+        #todo: FIX THIS RECURSION WITH USING UP/DOWN ARROWS
+        #self.yTickIntervalSpinBox.editingFinished.connect(self._setYTickMajorInterval)
         hBoxRow1_ytick.addWidget(self.yTickIntervalSpinBox)
 
         # y-tick minor
-        lineWidthLabel = QtWidgets.QLabel("Minor")
+        lineWidthLabel = QtWidgets.QLabel('Minor')
         hBoxRow1_ytick.addWidget(lineWidthLabel)
         self.yTickMinorIntervalSpinBox = QtWidgets.QDoubleSpinBox()
         self.yTickMinorIntervalSpinBox.setSingleStep(0.1)
         self.yTickMinorIntervalSpinBox.setMinimum(0.0)
         self.yTickMinorIntervalSpinBox.setMaximum(1e6)
         self.yTickMinorIntervalSpinBox.setValue(20)
-        self.yTickMinorIntervalSpinBox.setToolTip(
-            "Minor Y-Tick Interval, 0 To Turn Off"
-        )
+        self.yTickMinorIntervalSpinBox.setToolTip('Minor Y-Tick Interval, 0 To Turn Off')
         self.yTickMinorIntervalSpinBox.setKeyboardTracking(False)
         self.yTickMinorIntervalSpinBox.valueChanged.connect(self._setYTickMinorInterval)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow1_ytick.addWidget(self.yTickMinorIntervalSpinBox)
 
         #
         # third row
         hBoxRow2 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow2)
 
         # x margin
-        xMaxLabel = QtWidgets.QLabel("X-Margin")
+        xMaxLabel = QtWidgets.QLabel('X-Margin')
         hBoxRow2.addWidget(xMaxLabel)
         self.xMarginSpinBox = QtWidgets.QDoubleSpinBox()
-        self.xMarginSpinBox.setToolTip("X-Axis Maximum")
+        self.xMarginSpinBox.setToolTip('X-Axis Maximum')
         self.xMarginSpinBox.setSingleStep(0.1)
         self.xMarginSpinBox.setMinimum(0)
         self.xMarginSpinBox.setMaximum(1e6)
         self.xMarginSpinBox.setValue(self.xMargin)
         self.xMarginSpinBox.setKeyboardTracking(False)
         self.xMarginSpinBox.valueChanged.connect(self._setXMargin)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow2.addWidget(self.xMarginSpinBox)
 
         #
         # fourth row
         hBoxRow3 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow3)
 
         # line width
-        lineWidthLabel = QtWidgets.QLabel("Line Width")
+        lineWidthLabel = QtWidgets.QLabel('Line Width')
         hBoxRow3.addWidget(lineWidthLabel)
         self.lineWidthSpinBox = QtWidgets.QDoubleSpinBox()
         self.lineWidthSpinBox.setSingleStep(0.1)
         self.lineWidthSpinBox.setMinimum(0.01)
         self.lineWidthSpinBox.setMaximum(100.0)
         self.lineWidthSpinBox.setValue(0.5)
         self.lineWidthSpinBox.setKeyboardTracking(False)
         self.lineWidthSpinBox.valueChanged.connect(self._setLineWidth)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         hBoxRow3.addWidget(self.lineWidthSpinBox)
 
+
         # color
-        colorList = [
-            "red",
-            "green",
-            "blue",
-            "cyan",
-            "magenta",
-            "yellow",
-            "black",
-            "white",
-        ]
-        wIdx = colorList.index("white")
-        kIdx = colorList.index("black")
-        colorLabel = QtWidgets.QLabel("Line Color")
+        colorList = ['red', 'green', 'blue', 'cyan', 'magenta', 'yellow', 'black', 'white']
+        wIdx = colorList.index('white')
+        kIdx = colorList.index('black')
+        colorLabel = QtWidgets.QLabel('Line Color')
         hBoxRow3.addWidget(colorLabel)
         self.colorDropdown = QtWidgets.QComboBox()
         self.colorDropdown.addItems(colorList)
         self.colorDropdown.setCurrentIndex(wIdx if self.darkTheme else kIdx)
         self.colorDropdown.currentIndexChanged.connect(self._setLineColor)
         hBoxRow3.addWidget(self.colorDropdown)
 
         #
         # fifth row
         hBoxRow4 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow4)
 
         # downsample
-        downsampleLabel = QtWidgets.QLabel("Downsample")
+        downsampleLabel = QtWidgets.QLabel('Downsample')
         hBoxRow4.addWidget(downsampleLabel)
         self.downSampleSpinBox = QtWidgets.QSpinBox()
         self.downSampleSpinBox.setSingleStep(1)
         self.downSampleSpinBox.setMinimum(1)
         self.downSampleSpinBox.setMaximum(200)
         self.downSampleSpinBox.setValue(1)
         self.downSampleSpinBox.setKeyboardTracking(False)
         self.downSampleSpinBox.valueChanged.connect(self._setDownSample)
-        # self.downSampleSpinBox.editingFinished.connect(self._setDownSample)
+        #self.downSampleSpinBox.editingFinished.connect(self._setDownSample)
         hBoxRow4.addWidget(self.downSampleSpinBox)
 
         # meadianFilter
-        medianFilterLabel = QtWidgets.QLabel("Median Filter (points)")
+        medianFilterLabel = QtWidgets.QLabel('Median Filter (points)')
         hBoxRow4.addWidget(medianFilterLabel)
         self.medianFilterSpinBox = QtWidgets.QSpinBox()
-        # self.medianFilterSpinBox.setStyle(CustomStyle())
+        #self.medianFilterSpinBox.setStyle(CustomStyle())
         self.medianFilterSpinBox.setSingleStep(2)
         self.medianFilterSpinBox.setMinimum(1)
         self.medianFilterSpinBox.setMaximum(1000)
         self.medianFilterSpinBox.setValue(1)
         self.medianFilterSpinBox.setKeyboardTracking(False)
         self.medianFilterSpinBox.valueChanged.connect(self._setDownSample)
-        # self.medianFilterSpinBox.editingFinished.connect(self._setDownSample)
+        #self.medianFilterSpinBox.editingFinished.connect(self._setDownSample)
         hBoxRow4.addWidget(self.medianFilterSpinBox)
 
         #
         # fifth row
         hBoxRow4_5 = QtWidgets.QHBoxLayout()
         vBoxLayout.addLayout(hBoxRow4_5, myAlignTop)
 
         # dark theme
-        self.darkThemeCheckBox = QtWidgets.QCheckBox("Dark Theme")
+        self.darkThemeCheckBox = QtWidgets.QCheckBox('Dark Theme')
         self.darkThemeCheckBox.setChecked(self.darkTheme)
         self.darkThemeCheckBox.stateChanged.connect(self._changeTheme)
         hBoxRow4_5.addWidget(self.darkThemeCheckBox)
 
         #
         # sixth row
-        scaleBarGroupBox = QtWidgets.QGroupBox("Scale Bar")
+        scaleBarGroupBox = QtWidgets.QGroupBox('Scale Bar')
         scaleBarGroupBox.setAlignment(myAlignTop)
         vBoxLayout.addWidget(scaleBarGroupBox, myAlignTop)
 
         gridBoxScaleBar = QtWidgets.QGridLayout()
         scaleBarGroupBox.setLayout(gridBoxScaleBar)
 
-        hLength = self.scaleBarDict["hLength"]
-        vLength = self.scaleBarDict["vLength"]
-        lineWidth = self.scaleBarDict["lineWidth"]
+        hLength = self.scaleBarDict['hLength']
+        vLength = self.scaleBarDict['vLength']
+        lineWidth = self.scaleBarDict['lineWidth']
 
         # scale bar width (length)
-        scaleBarWidthLabel = QtWidgets.QLabel("Width")
+        scaleBarWidthLabel = QtWidgets.QLabel('Width')
         gridBoxScaleBar.addWidget(scaleBarWidthLabel, 0, 0)
         self.scaleBarWidthSpinBox = QtWidgets.QDoubleSpinBox()
-        self.scaleBarWidthSpinBox.setToolTip("X Scale Bar Width (0 to remove)")
+        self.scaleBarWidthSpinBox.setToolTip('X Scale Bar Width (0 to remove)')
         self.scaleBarWidthSpinBox.setSingleStep(0.1)
         self.scaleBarWidthSpinBox.setMinimum(-1e6)
         self.scaleBarWidthSpinBox.setMaximum(1e6)
         self.scaleBarWidthSpinBox.setValue(hLength)
         self.scaleBarWidthSpinBox.setKeyboardTracking(False)
         self.scaleBarWidthSpinBox.valueChanged.connect(self._setScaleBarSize)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         gridBoxScaleBar.addWidget(self.scaleBarWidthSpinBox, 0, 1)
 
         # scale bar height (length)
-        scaleBarHeightLabel = QtWidgets.QLabel("Height")
+        scaleBarHeightLabel = QtWidgets.QLabel('Height')
         gridBoxScaleBar.addWidget(scaleBarHeightLabel, 1, 0)
         self.scaleBarHeightSpinBox = QtWidgets.QDoubleSpinBox()
-        self.scaleBarHeightSpinBox.setToolTip("Y Scale Bar Height (0 to remove)")
+        self.scaleBarHeightSpinBox.setToolTip('Y Scale Bar Height (0 to remove)')
         self.scaleBarHeightSpinBox.setSingleStep(0.1)
         self.scaleBarHeightSpinBox.setMinimum(-1e6)
         self.scaleBarHeightSpinBox.setMaximum(1e6)
         self.scaleBarHeightSpinBox.setValue(vLength)
         self.scaleBarHeightSpinBox.setKeyboardTracking(False)
         self.scaleBarHeightSpinBox.valueChanged.connect(self._setScaleBarSize)
-        # self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
+        #self.lineWidthSpinBox.editingFinished.connect(self._setLineWidth)
         gridBoxScaleBar.addWidget(self.scaleBarHeightSpinBox, 1, 1)
 
         # scale bar line thickness
-        scaleBarThicknessLabel = QtWidgets.QLabel("Thickness")
+        scaleBarThicknessLabel = QtWidgets.QLabel('Thickness')
         gridBoxScaleBar.addWidget(scaleBarThicknessLabel, 2, 0)
         self.scaleBarThicknessSpinBox = QtWidgets.QDoubleSpinBox()
-        self.scaleBarThicknessSpinBox.setToolTip("Scale Bar Thickness")
+        self.scaleBarThicknessSpinBox.setToolTip('Scale Bar Thickness')
         self.scaleBarThicknessSpinBox.setSingleStep(1)
         self.scaleBarThicknessSpinBox.setMinimum(0.1)
         self.scaleBarThicknessSpinBox.setMaximum(1e6)
         self.scaleBarThicknessSpinBox.setValue(lineWidth)
         self.scaleBarThicknessSpinBox.setKeyboardTracking(False)
         self.scaleBarThicknessSpinBox.valueChanged.connect(self._setScaleBarThickness)
         gridBoxScaleBar.addWidget(self.scaleBarThicknessSpinBox, 2, 1)
 
         # save button
-        saveButton = QtWidgets.QPushButton("Save", self)
+        saveButton = QtWidgets.QPushButton('Save', self)
         saveButton.resize(saveButton.sizeHint())
         saveButton.clicked.connect(self.save)
         vBoxLayout.addWidget(saveButton)
 
-        # vBoxLayout.addStretch()
+        #vBoxLayout.addStretch()
 
         self.figure = matplotlib.figure.Figure()
         self.canvas = FigureCanvas(self.figure)
 
         # set defaullt save name
-        baseName = "export"
+        baseName = 'export'
         if self.path:
             baseName = os.path.splitext(self.path)[0]
-        self.canvas.get_default_filename = lambda: f"{baseName}"
+        self.canvas.get_default_filename = lambda: f'{baseName}'
 
         # matplotlib navigation toolbar
         self.toolbar = NavigationToolbar(self.canvas, self)
-        # self.toolbar.zoom()
+        #self.toolbar.zoom()
 
         # need self. here to set theme
         self.plotVBoxLayout = QtWidgets.QVBoxLayout()
         self.plotVBoxLayout.addWidget(self.toolbar)
         self.plotVBoxLayout.addWidget(self.canvas)
 
-        hMasterLayout.addLayout(self.plotVBoxLayout)  # , stretch=8)
+        hMasterLayout.addLayout(self.plotVBoxLayout) #, stretch=8)
 
-        # self.myAxis = None
+        #self.myAxis = None
         self.plotRaw(firstPlot=True)
 
         self.show()
 
     def _changeTheme(self):
         """
         to change the theme, we need to redraw everything
@@ -725,46 +697,46 @@
         # remove
         self.plotVBoxLayout.removeWidget(self.toolbar)
         self.plotVBoxLayout.removeWidget(self.canvas)
 
         self.toolbar.setParent(None)
         self.canvas.setParent(None)
 
-        self.figure = None  # ???
+        self.figure = None # ???
         self.toolbar = None
         self.canvas = None
 
-        # self.canvas.draw()
-        # self.repaint()
+        #self.canvas.draw()
+        #self.repaint()
 
         # set theme
         if checked:
-            plt.style.use("dark_background")
+            plt.style.use('dark_background')
             self.darkTheme = True
         else:
             plt.rcParams.update(plt.rcParamsDefault)
             self.darkTheme = False
 
         self.figure = matplotlib.figure.Figure()
         self.canvas = FigureCanvas(self.figure)
 
         # matplotlib navigation toolbar
         self.toolbar = NavigationToolbar(self.canvas, self)
-        # self.toolbar.zoom()
+        #self.toolbar.zoom()
 
         self.plotVBoxLayout.addWidget(self.toolbar)
         self.plotVBoxLayout.addWidget(self.canvas)
         # self.grid.addWidget(self.toolbar, ??)
 
         if self.darkTheme:
-            self.scaleBarDict["color"] = "w"
+            self.scaleBarDict['color'] = 'w'
         else:
-            self.scaleBarDict["color"] = "k"
+            self.scaleBarDict['color'] = 'k'
 
-        # self.myAxis = None
+        #self.myAxis = None
         self.plotRaw(firstPlot=True)
 
         # restore original x/y axes
         self.myAxis.set_xlim(xMin, xMax)
         self.myAxis.set_ylim(yMin, yMax)
 
     def _setXMargin(self):
@@ -781,25 +753,25 @@
         """
         self.xMinSpinBox.setEnabled(False)
         self.xMaxSpinBox.setEnabled(False)
 
         xMin = self.xMinSpinBox.value()
         xMax = self.xMaxSpinBox.value()
 
-        # print('_setXAxis() calling self.myAxis.set_xlim()', xMin, xMax)
+        #print('_setXAxis() calling self.myAxis.set_xlim()', xMin, xMax)
         xMin -= self.xMargin
         xMax += self.xMargin
 
         self.internalUpdate = True
         self.myAxis.set_xlim(xMin, xMax)
         self.internalUpdate = False
 
         self.scaleBars.setPos(xPos=xMax, fromMax=True)
 
-        # self.plotRaw(xMin=xMin, xMax=xMax)
+        #self.plotRaw(xMin=xMin, xMax=xMax)
         self.plotRaw()
 
         self.xMinSpinBox.setEnabled(True)
         self.xMaxSpinBox.setEnabled(True)
 
     def _setYAxis(self):
         """
@@ -824,73 +796,72 @@
         matplotlib callback
         """
 
         if self.internalUpdate:
             return
 
         xLim = mplEvent.get_xlim()
-        # print('on_xlims_change() xLim:', xLim)
+        #print('on_xlims_change() xLim:', xLim)
 
         xMin = xLim[0]
         xMax = xLim[1]
 
         self.xMinSpinBox.setValue(xMin)
         self.xMaxSpinBox.setValue(xMax)
 
         self.plotRaw()
 
-        # self.canvas.draw_idle()
+        #self.canvas.draw_idle()
 
     def _setDownSample(self):
         self.downSampleSpinBox.setEnabled(False)
         self.medianFilterSpinBox.setEnabled(False)
 
         try:
             downSample = self.downSampleSpinBox.value()
             medianFilter = self.medianFilterSpinBox.value()
 
             if (medianFilter % 2) == 0:
                 medianFilter += 1
 
-            # print('_setDownSample() downSample:', downSample, 'medianFilter:', medianFilter)
+            #print('_setDownSample() downSample:', downSample, 'medianFilter:', medianFilter)
 
-            # print('downSample ... please wait')
+            #print('downSample ... please wait')
             self.mySweepX_Downsample = self.mySweepX[::downSample]
             self.mySweepY_Downsample = self.mySweepY[::downSample]
 
             if medianFilter > 1:
-                # print('medianFilter ... please wait')
-                self.mySweepY_Downsample = scipy.signal.medfilt(
-                    self.mySweepY_Downsample, kernel_size=medianFilter
-                )
+                #print('medianFilter ... please wait')
+                self.mySweepY_Downsample = scipy.signal.medfilt(self.mySweepY_Downsample,
+                                            kernel_size=medianFilter)
 
             #
             self.plotRaw()
 
             # refresh scale-bar
             xPos = np.nanmax(self.mySweepX_Downsample)  # self.mySweepX_Downsample[-1]
             yPos = np.nanmax(self.mySweepY_Downsample)
-            # self.scaleBars.setPos(xPos, yPos, fromMax=True)
+            #self.scaleBars.setPos(xPos, yPos, fromMax=True)
 
-        except Exception as e:
-            logger.exceptiion("EXCEPTION in _setDownSample():", e)
+        except (Exception) as e:
+            logger.exceptiion('EXCEPTION in _setDownSample():', e)
 
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
         self.downSampleSpinBox.setEnabled(True)
         self.medianFilterSpinBox.setEnabled(True)
 
     def xAxisToggle(self):
         checked = self.xAxisCheckBox.isChecked()
-        self._toggleAxis("bottom", checked)
+        self._toggleAxis('bottom', checked)
 
     def yAxisToggle(self):
         checked = self.yAxisCheckBox.isChecked()
-        self._toggleAxis("left", checked)
+        self._toggleAxis('left', checked)
 
     def scaleBarToggle(self):
         xChecked = self.xScaleBarCheckBox.isChecked()
         yChecked = self.yScaleBarCheckBox.isChecked()
         self._toggleScaleBar(xChecked, yChecked)
 
     def _setScaleBarSize(self):
@@ -898,145 +869,146 @@
         self.scaleBarHeightSpinBox.setEnabled(False)
 
         width = self.scaleBarWidthSpinBox.value()
         height = self.scaleBarHeightSpinBox.value()
         self.scaleBars.setWidthHeight(width=width, height=height)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
         self.scaleBarWidthSpinBox.setEnabled(True)
         self.scaleBarHeightSpinBox.setEnabled(True)
 
     def _setScaleBarThickness(self):
         self.scaleBarThicknessSpinBox.setEnabled(False)
 
         thickness = self.scaleBarThicknessSpinBox.value()
         self.scaleBars.setThickness(thickness)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
         self.scaleBarThicknessSpinBox.setEnabled(True)
 
-    def _setYTickMajorInterval(self):  # , interval):
+    def _setYTickMajorInterval(self): #, interval):
         self.yTickIntervalSpinBox.setEnabled(False)
         interval = self.yTickIntervalSpinBox.value()
         if interval == 0:
             ml = ticker.NullLocator()
         else:
             ml = ticker.MultipleLocator(interval)
         self.myAxis.yaxis.set_major_locator(ml)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
         self.yTickIntervalSpinBox.setEnabled(True)
 
     def _setYTickMinorInterval(self, interval):
         self.yTickMinorIntervalSpinBox.setEnabled(False)
         if interval == 0:
             ml = ticker.NullLocator()
         else:
             ml = ticker.MultipleLocator(interval)
         self.myAxis.yaxis.set_minor_locator(ml)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
         self.yTickMinorIntervalSpinBox.setEnabled(True)
 
     def _setTickMajorInterval(self, interval):
         self.xTickIntervalSpinBox.setEnabled(False)
         if interval == 0:
             ml = ticker.NullLocator()
         else:
             ml = ticker.MultipleLocator(interval)
         self.myAxis.xaxis.set_major_locator(ml)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
         self.xTickIntervalSpinBox.setEnabled(True)
 
     def _setTickMinorInterval(self, interval):
         self.xTickMinorIntervalSpinBox.setEnabled(False)
         if interval == 0:
             ml = ticker.NullLocator()
         else:
             ml = ticker.MultipleLocator(interval)
         self.myAxis.xaxis.set_minor_locator(ml)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
         self.xTickMinorIntervalSpinBox.setEnabled(True)
 
     def _toggleAxis(self, leftBottom, onOff):
-        if leftBottom == "bottom":
+        if leftBottom == 'bottom':
             self.myAxis.get_xaxis().set_visible(onOff)
-            self.myAxis.spines["bottom"].set_visible(onOff)
-        elif leftBottom == "left":
+            self.myAxis.spines['bottom'].set_visible(onOff)
+        elif leftBottom == 'left':
             self.myAxis.get_yaxis().set_visible(onOff)
-            self.myAxis.spines["left"].set_visible(onOff)
+            self.myAxis.spines['left'].set_visible(onOff)
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
     def _toggleScaleBar(self, xChecked, yChecked):
         self.scaleBars.hideScaleBar(xChecked, yChecked)
 
     def _setLineColor(self, colorStr):
+
         colorStr = self.colorDropdown.currentText()
 
         self.myTraceLine.set_color(colorStr)
-        """
+        '''
         for line in self.myAxis.lines:
             print('_setLineColor:', line.get_label())
             line.set_color(colorStr)
-        """
+        '''
 
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
     def _setLineWidth(self):
         self.lineWidthSpinBox.setEnabled(False)
 
         lineWidth = self.lineWidthSpinBox.value()
 
-        # print('bExportWidget._setLineWidth() lineWidth:', lineWidth)
+        #print('bExportWidget._setLineWidth() lineWidth:', lineWidth)
 
         self.myTraceLine.set_linewidth(lineWidth)
-        """
+        '''
         for line in self.myAxis.lines:
             line.set_linewidth(lineWidth)
-        """
+        '''
         #
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
         self.lineWidthSpinBox.setEnabled(True)
 
     def plotRaw(self, xMin=None, xMax=None, firstPlot=False):
         if firstPlot:
             self.figure.clf()
 
             self.myAxis = self.figure.add_subplot(111)
-            """
+            '''
             left = .2 #0.05
             bottom = 0.05
             width = 0.7 #0.9
             height = 0.9
             self.myAxis = self.figure.add_axes([left, bottom, width, height])
-            """
+            '''
 
-            self.myAxis.spines["right"].set_visible(False)
-            self.myAxis.spines["top"].set_visible(False)
+            self.myAxis.spines['right'].set_visible(False)
+            self.myAxis.spines['top'].set_visible(False)
 
             if self.darkTheme:
-                color = "w"
+                color = 'w'
             else:
-                color = "k"
+                color = 'k'
 
             lineWidth = self.lineWidthSpinBox.value()
 
         sweepX = self.mySweepX_Downsample
         sweepY = self.mySweepY_Downsample
 
         if firstPlot:
@@ -1052,146 +1024,134 @@
         if xMin is not None and xMax is not None:
             minClip = xMin + xClip
             maxClip = xMax - xClip
         else:
             minClip = xMinOrig + xClip
             maxClip = xMaxOrig - xClip
 
-        sweepX = np.ma.masked_where((sweepX < minClip), sweepX)
-        sweepY = np.ma.masked_where((sweepX < minClip), sweepY)
+        sweepX = np.ma.masked_where( (sweepX<minClip), sweepX)
+        sweepY = np.ma.masked_where( (sweepX<minClip), sweepY)
 
-        sweepX = np.ma.masked_where((sweepX > maxClip), sweepX)
-        sweepY = np.ma.masked_where((sweepX > maxClip), sweepY)
+        sweepX = np.ma.masked_where( (sweepX>maxClip), sweepX)
+        sweepY = np.ma.masked_where( (sweepX>maxClip), sweepY)
 
-        # print('sweepX:', sweepX.shape, type(sweepX))
-        # print('sweepY:', sweepY.shape, type(sweepY))
+        #print('sweepX:', sweepX.shape, type(sweepX))
+        #print('sweepY:', sweepY.shape, type(sweepY))
 
         if firstPlot:
             # using label 'myTrace' to differentiate from x/y scale bar
-            (self.myTraceLine,) = self.myAxis.plot(
-                sweepX,
-                sweepY,
-                "-",  # fmt = '[marker][line][color]'
-                c=color,
-                linewidth=lineWidth,
-                label="myTrace",
-            )
-            # matplotlib.lines.Line2D
+            self.myTraceLine, = self.myAxis.plot(sweepX, sweepY,
+                                    '-', # fmt = '[marker][line][color]'
+                                    c=color, linewidth=lineWidth,
+                                    label='myTrace')
+            #matplotlib.lines.Line2D
 
-            self.myAxis.callbacks.connect("xlim_changed", self.on_xlims_change)
+            self.myAxis.callbacks.connect('xlim_changed', self.on_xlims_change)
 
             # scale bar
-            hLength = self.scaleBarDict["hLength"]
-            vLength = self.scaleBarDict["vLength"]
-            scaleBarLineWidth = self.scaleBarDict["lineWidth"]
-            scaleBarColor = self.scaleBarDict["color"]
-            xPos = xMaxOrig  # sweepX[-1]
-            yPos = yMaxOrig  # np.nanmax(sweepY)
-            self.scaleBars = draggable_lines(
-                self.myAxis,
-                xPos,
-                yPos,
-                hLength=hLength,
-                vLength=vLength,
-                linewidth=scaleBarLineWidth,
-                color=scaleBarColor,
-                doPick=True,
-            )
+            hLength = self.scaleBarDict['hLength']
+            vLength = self.scaleBarDict['vLength']
+            scaleBarLineWidth = self.scaleBarDict['lineWidth']
+            scaleBarColor = self.scaleBarDict['color']
+            xPos = xMaxOrig #sweepX[-1]
+            yPos = yMaxOrig #np.nanmax(sweepY)
+            self.scaleBars = draggable_lines(self.myAxis, xPos, yPos,
+                                hLength=hLength, vLength=vLength,
+                                linewidth=scaleBarLineWidth,
+                                color=scaleBarColor,
+                                doPick=True)
             self.scaleBars.setPos(xPos, yPos, fromMax=True)
 
         else:
             self.myTraceLine.set_xdata(sweepX)
             self.myTraceLine.set_ydata(sweepY)
-            """
+            '''
             for line in self.myAxis.lines:
                 print('plotRaw() is updating with set_xdata/set_ydata')
                 line.set_xdata(sweepX)
                 line.set_ydata(sweepY)
-            """
+            '''
 
-        # self.myAxis.use_sticky_edges = False
-        # self.myAxis.margins(self.xMargin, tight=None)
+        #self.myAxis.use_sticky_edges = False
+        #self.myAxis.margins(self.xMargin, tight=None)
 
         if firstPlot:
-            # self.myAxis.set_ylabel('Vm (mV)')
-            # self.myAxis.set_xlabel('Time (sec)')
+            #self.myAxis.set_ylabel('Vm (mV)')
+            #self.myAxis.set_xlabel('Time (sec)')
             self.myAxis.set_ylabel(self.xyUnits[1])
             self.myAxis.set_xlabel(self.xyUnits[0])
 
         self.canvas.draw_idle()
-        # self.repaint()
+        #self.repaint()
 
     def save(self):
         """
         Save the current view to a pdf file
         """
 
         # get min/max of x-axis
         [xMin, xMax] = self.myAxis.get_xlim()
-        # if xMin < 0:
+        #if xMin < 0:
         #    xMin = 0
 
         xMin += self.xMargin
         xMax -= self.xMargin
 
-        xMin = "%.2f" % (xMin)
-        xMax = "%.2f" % (xMax)
+        xMin = '%.2f'%(xMin)
+        xMax = '%.2f'%(xMax)
 
-        lhs, rhs = xMin.split(".")
-        xMin = "b" + lhs + "_" + rhs
 
-        lhs, rhs = xMax.split(".")
-        xMax = "e" + lhs + "_" + rhs
+        lhs, rhs = xMin.split('.')
+        xMin = 'b' + lhs + '_' + rhs
+
+        lhs, rhs = xMax.split('.')
+        xMax = 'e' + lhs + '_' + rhs
 
         # construct a default save file name
-        saveFilePath = ""
+        saveFilePath = ''
         if self.path:
             parentPath, filename = os.path.split(self.path)
             baseFilename, file_extension = os.path.splitext(filename)
-            # saveFileName = baseFilename + '_' + self.myType + '_' + xMin + '_' + xMax + '.svg'
-            saveFileName = f"{baseFilename}_{self.myType}_{xMin}_{xMax}.svg"
-            # saveFileName = baseFilename + '.svg'
-            saveFilePath = os.path.join(parentPath, saveFileName)
+            #saveFileName = baseFilename + '_' + self.myType + '_' + xMin + '_' + xMax + '.svg'
+            saveFileName = f'{baseFilename}_{self.myType}_{xMin}_{xMax}.svg'
+            #saveFileName = baseFilename + '.svg'
+            saveFilePath = os.path.join(parentPath,saveFileName)
 
         # file save dialog
-        # fullSavePath, ignore = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', saveFilePath, "pdf Files (*.pdf)")
-        fullSavePath, ignore = QtWidgets.QFileDialog.getSaveFileName(
-            self, "Save File", saveFilePath
-        )
+        #fullSavePath, ignore = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', saveFilePath, "pdf Files (*.pdf)")
+        fullSavePath, ignore = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', saveFilePath)
 
         # do actual save
         if len(fullSavePath) > 0:
-            logger.info(f"saving: {fullSavePath}")
+            logger.info(f'saving: {fullSavePath}')
             self.figure.savefig(fullSavePath)
 
     def center(self):
         """
         Center the window on the screen
         """
         qr = self.frameGeometry()
         cp = QtWidgets.QDesktopWidget().availableGeometry().center()
         qr.moveCenter(cp)
         self.move(qr.topLeft())
 
-
 def run():
-    path = "../data/19114001.abf"
+    path = '../data/19114001.abf'
 
     ba = bAnalysis(path)
     if ba.loadError:
-        logger.error(f"Error loading file: {path}")
+        logger.error(f'Error loading file: {path}')
     else:
         app = QtWidgets.QApplication(sys.argv)
         app.aboutToQuit.connect(app.deleteLater)
 
         sweepX = ba.fileLoader.sweepX
         sweepY = ba.fileLoader.sweepY
-        xyUnits = ("Time (sec)", "Vm (mV)")
-        type = "vm"
+        xyUnits = ('Time (sec)', 'Vm (mV)')
+        type = 'vm'
         GUI = bExportWidget(sweepX, sweepY, path=path, xyUnits=xyUnits, type=type)
         GUI.show()
 
         sys.exit(app.exec_())
 
-
-if __name__ == "__main__":
-    run()
+if __name__ == '__main__':
+    run()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bFileTable.py` & `sanpy-ephys-0.1.6/sanpy/interface/bFileTable.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-# created 20210212
+# 20210212
 import os, math
 
 import numpy as np
 import pandas as pd
 
 from PyQt5 import QtCore, QtGui, QtWidgets
 
+# using sanpy.analysisDir in pandasModel.__init__()
 import sanpy.analysisDir
 import sanpy.bDetection
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 def old_loadDatabase(path):
     """
     Load a csv/xls/xlsx file as a pandas dataframe.
 
     Args:
         path (Str): full path to .csv file generated with reanalyze.py
 
@@ -25,168 +24,161 @@
         pandas dataframe
     """
     masterDf = None
     if path is None:
         pass
     elif not os.path.isfile(path):
         print(f'error: bUtil.loadDatabase() did not find file: "{path}"')
-    elif path.endswith(".csv"):
-        masterDf = pd.read_csv(
-            path, header=0, index_col=False
-        )  # , dtype={'ABF File': str})
-    elif path.endswith(".xls"):
+    elif path.endswith('.csv'):
+        masterDf = pd.read_csv(path, header=0, index_col=False)  # , dtype={'ABF File': str})
+    elif path.endswith('.xls'):
         masterDf = pd.read_excel(path, header=0)  # , dtype={'ABF File': str})
-    elif path.endswith(".xlsx"):
-        masterDf = pd.read_excel(
-            path, header=0, engine="openpyxl"
-        )  # , dtype={'ABF File': str})
+    elif path.endswith('.xlsx'):
+        masterDf = pd.read_excel(path, header=0, engine='openpyxl')  # , dtype={'ABF File': str})
     else:
-        print("error: file type not supported. Expecting csv/xls/xlsx. Path:", path)
+        print('error: file type not supported. Expecting csv/xls/xlsx. Path:', path)
     #
     return masterDf
 
-
 def printDict(d, withType=False):
-    for k, v in d.items():
+    for k,v in d.items():
         if withType:
-            print(f"  {k}: {v} {type(v)}")
+            print(f'  {k}: {v} {type(v)}')
         else:
-            print(f"  {k}: {v}")
-
+            print(f'  {k}: {v}')
 
 class myTableView(QtWidgets.QTableView):
     """Table view to display list of files.
 
     TODO: Try and implement the first column (filename) as a frozen column.
 
     See: https://doc.qt.io/qt-5/qtwidgets-itemviews-frozencolumn-example.html
     """
 
-    signalDuplicateRow = QtCore.pyqtSignal(object)  # row index
-    signalDeleteRow = QtCore.pyqtSignal(object)  # row index
-    # signalRefreshTabe = QtCore.pyqtSignal(object) # row index
+    signalDuplicateRow = QtCore.pyqtSignal(object) # row index
+    signalDeleteRow = QtCore.pyqtSignal(object) # row index
+    #signalRefreshTabe = QtCore.pyqtSignal(object) # row index
     signalCopyTable = QtCore.pyqtSignal()
     signalFindNewFiles = QtCore.pyqtSignal()
     signalSaveFileTable = QtCore.pyqtSignal()
 
     def __init__(self, parent=None):
-        """ """
+        """
+        """
         super(myTableView, self).__init__(parent)
 
         self.doIncludeCheckbox = False  # todo: turn this on
         # need a local reference to delegate else 'segmentation fault'
-        # self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
+        #self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
 
-        # self.setFont(QtGui.QFont('Arial', 10))
-
-        self.setSizePolicy(
-            QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        )
+        #self.setFont(QtGui.QFont('Arial', 10))
+        
+        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                            QtWidgets.QSizePolicy.Expanding)
         self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
 
-        self.setEditTriggers(
-            QtWidgets.QAbstractItemView.NoEditTriggers
-            | QtWidgets.QAbstractItemView.DoubleClicked
-        )
+        self.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers
+                            | QtWidgets.QAbstractItemView.DoubleClicked)
 
         # removed mar 26 2023
-        """
+        '''
         rowHeight = 11
         fnt = self.font()
         fnt.setPointSize(rowHeight)
         self.setFont(fnt)
         self.verticalHeader().setDefaultSectionSize(rowHeight)
-        """
-
-        """
+        '''
+    
+        '''
         p = self.palette()
         color1 = QtGui.QColor('#dddddd')
         color2 = QtGui.QColor('#ffffff')
         p.setColor(QtGui.QPalette.Base, color1)
         p.setColor(QtGui.QPalette.AlternateBase, color2)
         self.setPalette(p)
         self.setAlternatingRowColors(True)
-        """
+        '''
 
-    # def keyPressEvent(self, event): #Reimplement the event here, in your case, do nothing
+    #def keyPressEvent(self, event): #Reimplement the event here, in your case, do nothing
     #    return
 
     def mySetModel(self, model):
         """
         Set the model. Needed so we can show/hide columns
         """
         self.setModel(model)
 
-        # print('---trying to hide columns')
-        # self.hideColumn(1)
-        # self.setColumnHidden(1,True);
-        # self.setColumnHidden(1, True)
-        # self.horizontalHeader().hideSection(1)
+        #print('---trying to hide columns')
+        #self.hideColumn(1)
+        #self.setColumnHidden(1,True);
+        #self.setColumnHidden(1, True)
+        #self.horizontalHeader().hideSection(1)
 
-    """
+    '''
     # trying to use this to remove tooltip when it comes up as empty ''
     def viewportEvent(self, event):
         logger.info('')
         return True
-    """
+    '''
 
     def contextMenuEvent(self, event):
-        """Handle right mouse click"""
+        """Handle right mouse click
+        """
         contextMenu = QtWidgets.QMenu(self)
-
+        
         duplicateRow = contextMenu.addAction("Duplicate Row")
         contextMenu.addSeparator()
-
+        
         # deleteRow = contextMenu.addAction("Delete Row")
         # contextMenu.addSeparator()
-
+        
         copyTable = contextMenu.addAction("Copy Table")
         contextMenu.addSeparator()
-
+        
         findNewFiles = contextMenu.addAction("Sync With Folder")
         contextMenu.addSeparator()
-
+        
         saveTable = contextMenu.addAction("Save Table")
-
+        
         #
         action = contextMenu.exec_(self.mapToGlobal(event.pos()))
-        # logger.info(f'  action:{action}')
+        #logger.info(f'  action:{action}')
         if action == duplicateRow:
-            # print('  todo: duplicateRow')
+            #print('  todo: duplicateRow')
             tmp = self.selectedIndexes()
-            if len(tmp) > 0:
+            if len(tmp)>0:
                 selectedRow = tmp[0].row()
                 self.signalDuplicateRow.emit(selectedRow)
 
         # elif action == deleteRow:
         #     #print('  todo: deleteRow')
         #     tmp = self.selectedIndexes()
         #     if len(tmp)>0:
         #         selectedRow = tmp[0].row()
         #         self.signalDeleteRow.emit(selectedRow)
         #     else:
         #         logger.warning('no selection?')
 
         elif action == copyTable:
-            # print('  todo: copyTable')
+            #print('  todo: copyTable')
             self.signalCopyTable.emit()
 
         elif action == findNewFiles:
-            # print('  todo: findNewFiles')
+            #print('  todo: findNewFiles')
             self.signalFindNewFiles.emit()
 
         elif action == saveTable:
-            # print('  todo: saveTable')
+            #print('  todo: saveTable')
             self.signalSaveFileTable.emit()
 
         else:
             logger.warning(f'action not taken "{action}"')
 
-
 class pandasModel(QtCore.QAbstractTableModel):
+
     signalMyDataChanged = QtCore.pyqtSignal(object, object, object)
     """Emit on user editing a cell."""
 
     def __init__(self, data):
         """
         Data model for a pandas dataframe or sanpy.analysisDir.
 
@@ -200,125 +192,121 @@
         # data is either DataFrame or analysisDir
         self.isAnalysisDir = False
         if isinstance(data, pd.core.frame.DataFrame):
             self.isAnalysisDir = False
         elif isinstance(data, sanpy.analysisDir):
             self.isAnalysisDir = True
         else:
-            logger.error("Expecting data in (DataFrame, sanpy.analysisDir)")
+            logger.error('Expecting data in (DataFrame, sanpy.analysisDir)')
         self._data = data
 
-        # self.setSortingEnabled(True)
+        #self.setSortingEnabled(True)
 
-    """
+    '''
     def modelReset(self):
         print('modelReset()')
-    """
+    '''
 
     def rowCount(self, parent=None):
         return self._data.shape[0]
 
     def columnCount(self, parnet=None):
         return self._data.shape[1]
 
     def data(self, index, role=QtCore.Qt.DisplayRole):
         if index.isValid():
             if role == QtCore.Qt.ToolTipRole:
                 # removed
                 # swapped sanpy.bDetection.defaultDetection to a class
                 # do not want to instantiate every time
-                """
+                '''
                 # get default value from bAnalysis
                 defaultDetection = sanpy.bDetection.defaultDetection
                 columnName = self._data.columns[index.column()]
                 toolTip = QtCore.QVariant()  # empty tooltip
                 try:
                     toolTip = str(defaultDetection[columnName]['defaultValue'])
                     toolTip += ': ' + defaultDetection[columnName]['description']
                 except (KeyError):
                     pass
                 return toolTip
-                """
+                '''
             elif role in [QtCore.Qt.DisplayRole, QtCore.Qt.EditRole]:
                 columnName = self._data.columns[index.column()]
-                if self.isAnalysisDir and columnName == "I":
-                    return ""
+                if self.isAnalysisDir and columnName == 'I':
+                    return ''
 
                 # don't get col from index, get from name
-                # retVal = self._data.iloc[index.row(), index.column()]
-                # retVal = self._data.loc[index.row(), columnName]
+                #retVal = self._data.iloc[index.row(), index.column()]
+                #retVal = self._data.loc[index.row(), columnName]
                 realRow = self._data.index[index.row()]
-                # retVal = self._data.iloc[realRow, index.column()]
+                #retVal = self._data.iloc[realRow, index.column()]
                 retVal = self._data.loc[realRow, columnName]
                 if isinstance(retVal, np.float64):
                     retVal = float(retVal)
                 elif isinstance(retVal, np.int64):
                     retVal = int(retVal)
-                elif isinstance(retVal, str) and retVal == "nan":
-                    retVal = ""
+                elif isinstance(retVal, str) and retVal == 'nan':
+                    retVal = ''
 
                 if isinstance(retVal, float) and math.isnan(retVal):
                     # don't show 'nan' in table
-                    retVal = ""
+                    retVal = ''
                 return retVal
 
             elif role == QtCore.Qt.CheckStateRole:
                 columnName = self._data.columns[index.column()]
                 realRow = self._data.index[index.row()]
-                # retVal = self._data.iloc[index.row(), index.column()]
+                #retVal = self._data.iloc[index.row(), index.column()]
                 retVal = self._data.loc[realRow, columnName]
-                if columnName == "I":
+                if columnName == 'I':
                     if retVal:
                         return QtCore.Qt.Checked
                     else:
                         return QtCore.Qt.Unchecked
                 return QtCore.QVariant()
 
             elif role == QtCore.Qt.FontRole:
                 realRow = self._data.index[index.row()]
                 columnName = self._data.columns[index.column()]
-                if columnName == "L":
+                if columnName == 'L':
                     if self._data.isLoaded(realRow):  # or self._data.isSaved(realRow):
-                        return QtCore.QVariant(QtGui.QFont("Arial", pointSize=32))
-                elif columnName == "A":
-                    if self._data.isAnalyzed(
-                        realRow
-                    ):  # or self._data.isSaved(realRow):
-                        return QtCore.QVariant(QtGui.QFont("Arial", pointSize=32))
-                elif columnName == "S":
+                        return QtCore.QVariant(QtGui.QFont('Arial', pointSize=32))
+                elif columnName == 'A':
+                    if self._data.isAnalyzed(realRow):  # or self._data.isSaved(realRow):
+                        return QtCore.QVariant(QtGui.QFont('Arial', pointSize=32))
+                elif columnName == 'S':
                     if self._data.isSaved(realRow):
-                        return QtCore.QVariant(QtGui.QFont("Arial", pointSize=32))
+                        return QtCore.QVariant(QtGui.QFont('Arial', pointSize=32))
                 return QtCore.QVariant()
             elif role == QtCore.Qt.ForegroundRole:
                 if self.isAnalysisDir:
                     realRow = self._data.index[index.row()]
                     columnName = self._data.columns[index.column()]
-                    if columnName == "L":
+                    if columnName == 'L':
                         if self._data.isLoaded(realRow):
-                            return QtCore.QVariant(QtGui.QColor("#4444EE"))
-                    elif columnName == "A":
+                            return QtCore.QVariant(QtGui.QColor('#4444EE'))
+                    elif columnName == 'A':
                         if self._data.analysisIsDirty(realRow):
                             # has been analyzed but not saved
-                            return QtCore.QVariant(QtGui.QColor("#994444"))  # red
+                            return QtCore.QVariant(QtGui.QColor('#994444'))  # red
                         elif self._data.isAnalyzed(realRow):
-                            return QtCore.QVariant(QtGui.QColor("#449944"))  # green
-                    elif columnName == "S":
+                            return QtCore.QVariant(QtGui.QColor('#449944'))  # green
+                    elif columnName == 'S':
                         if self._data.isSaved(realRow):
-                            return QtCore.QVariant(
-                                QtGui.QColor("#999944")
-                            )  # mustard yellow
+                            return QtCore.QVariant(QtGui.QColor('#999944'))  # mustard yellow
                 return QtCore.QVariant()
             elif role == QtCore.Qt.BackgroundRole:
                 # set colors of alternating background
                 # if index.row() % 2 == 0:
                 #     return QtCore.QVariant(QtGui.QColor('#444444'))
                 # else:
                 #     return QtCore.QVariant(QtGui.QColor('#666666'))
                 pass
-
+            
         #
         return QtCore.QVariant()
 
     # def update(self, dataIn):
     #     print('  pandasModel.update() dataIn:', dataIn)
 
     def setData(self, index, value, role=QtCore.Qt.EditRole):
@@ -341,126 +329,120 @@
                     if not isEditable:
                         return False
 
                 # in general, DO NOT USE iLoc, use loc as it is absolute (i,j)
                 columnName = self._data.columns[index.column()]
                 realRow = self._data.index[index.row()]
                 v = self._data.loc[realRow, columnName]
-                # logger.info(f'Existing value for column "{columnName}" is v: "{v}" {type(v)}')
-                # logger.info(f'  proposed value:"{value}" {type(value)}')
+                #logger.info(f'Existing value for column "{columnName}" is v: "{v}" {type(v)}')
+                #logger.info(f'  proposed value:"{value}" {type(value)}')
                 if isinstance(v, np.float64):
                     try:
-                        if value == "":
+                        if value == '':
                             value = np.nan
                         else:
                             value = float(value)
-                    except ValueError as e:
-                        logger.info("  No action -->> please enter a number")
-                        # self.signalUpdateStatus.emit('Please enter a number')
+                    except (ValueError) as e:
+                        logger.info('  No action -->> please enter a number')
+                        #self.signalUpdateStatus.emit('Please enter a number')
                         return False
 
                 # set
-                # logger.info(f'  New value for column "{columnName}" is "{value}" {type(value)}')
+                #logger.info(f'  New value for column "{columnName}" is "{value}" {type(value)}')
                 self._data.loc[realRow, columnName] = value
-                # self._data.iloc[rowIdx, columnIdx] = value
+                #self._data.iloc[rowIdx, columnIdx] = value
 
                 # emit change
                 emitRowDict = self.myGetRowDict(realRow)
                 self.signalMyDataChanged.emit(columnName, value, emitRowDict)
 
                 self.isDirty = True
                 return True
             elif role == QtCore.Qt.CheckStateRole:
                 rowIdx = index.row()
                 columnIdx = index.column()
                 columnName = self._data.columns[index.column()]
                 realRow = self._data.index[index.row()]
-                logger.info(f"CheckStateRole column:{columnName} value:{value}")
-                if columnName == "I":
+                logger.info(f'CheckStateRole column:{columnName} value:{value}')
+                if columnName == 'I':
                     self._data.loc[realRow, columnName] = value == 2
                     self.dataChanged.emit(index, index)
                     return QtCore.Qt.Checked
 
         #
         return QtCore.QVariant()
 
     def flags(self, index):
         if not index.isValid():
-            logger.warning("index is not valid")
+            logger.warning('index is not valid')
 
         rowIdx = index.row()
         columnIdx = index.column()
 
         # use to check isEditable
         try:
             columnName = self._data.columns[columnIdx]
-        except IndexError as e:
-            logger.warning(
-                f"IndexError for columnIdx:{columnIdx} len:{len(self._data.columns)}"
-            )
-            print("self._data.columns:", self._data.columns)
+        except(IndexError) as e:
+            logger.warning(f'IndexError for columnIdx:{columnIdx} len:{len(self._data.columns)}')
+            print('self._data.columns:', self._data.columns)
             raise
 
         theRet = QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable
         isEditable = False
         isCheckbox = False
         if self.isAnalysisDir:
             # columnsDict is a big dict, one key for each column, in analysisDir.sanpyColumns
             isEditable = self._data.columnIsEditable(columnName)
             isCheckbox = self._data.columnIsCheckBox(columnName)
         if isEditable:
             theRet |= QtCore.Qt.ItemIsEditable
         if isCheckbox:
-            # logger.info(f'isCheckbox {columnIdx}')
+            #logger.info(f'isCheckbox {columnIdx}')
             theRet |= QtCore.Qt.ItemIsUserCheckable
         #
         return theRet
 
         # flags |= QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsUserCheckable | Qt.ItemIsEnabled
 
     def headerData(self, col, orientation, role):
         if role == QtCore.Qt.DisplayRole:
             if orientation == QtCore.Qt.Horizontal:
                 try:
                     return self._data.columns[col]
-                except IndexError as e:
-                    logger.warning(
-                        f"IndexError for col:{col} len:{len(self._data.columns)}, shape:{self._data.shape}"
-                    )
-                    # raise
+                except(IndexError) as e:
+                    logger.warning(f'IndexError for col:{col} len:{len(self._data.columns)}, shape:{self._data.shape}')
+                    #raise
             elif orientation == QtCore.Qt.Vertical:
                 # this is to show pandas 'index' column
                 return col
 
         return QtCore.QVariant()
 
     def sort(self, Ncol, order):
-        # logger.info(f'Ncol:{Ncol} order:{order}')
+        #logger.info(f'Ncol:{Ncol} order:{order}')
         self.layoutAboutToBeChanged.emit()
         if self.isAnalysisDir:
             self._data.sort_values(Ncol, order)
         else:
-            self._data = self._data.sort_values(
-                self._data.columns[Ncol], ascending=not order
-            )
+            self._data = self._data.sort_values(self._data.columns[Ncol], ascending=not order)
         self.layoutChanged.emit()
 
     def myCopyTable(self):
         """
         Copy model data to clipboard.
         """
         dfCopy = self._data.copy()
-        dfCopy.to_clipboard(sep="\t", index=False)
+        dfCopy.to_clipboard(sep='\t', index=False)
 
     def myGetValue(self, rowIdx, colStr):
         val = None
         if colStr not in self._data.columns:  #  columns is a list
             logger.error(f'Got bad column name: "{colStr}"')
-        elif len(self._data) - 1 < rowIdx:
-            logger.error(f"Got bad row:{rowIdx} from possible {len(self._data)}")
+        elif len(self._data)-1 < rowIdx:
+            logger.error(f'Got bad row:{rowIdx} from possible {len(self._data)}')
         else:
             val = self._data.loc[rowIdx, colStr]
         return val
 
     def myGetRowDict(self, rowIdx):
         """
         return a dict with selected row as dict (includes detection parameters)
@@ -492,15 +474,15 @@
         self.endInsertRows()
 
     def old_myDeleteRow(self, rowIdx):
         msg = QtWidgets.QMessageBox()
         msg.setStandardButtons(QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel)
         msg.setDefaultButton(QtWidgets.QMessageBox.Ok)
         msg.setIcon(QtWidgets.QMessageBox.Warning)
-        msg.setText(f"Are you sure you want to delete row {rowIdx}?")
+        msg.setText(f'Are you sure you want to delete row {rowIdx}?')
         msg.setWindowTitle("Delete Row")
         returnValue = msg.exec_()
         if returnValue == QtWidgets.QMessageBox.Ok:
             #
             #
             rowIdx = self._data.index[rowIdx]  # assume rows are sorted
             self.beginRemoveRows(QtCore.QModelIndex(), rowIdx, rowIdx)
@@ -513,93 +495,94 @@
                 df = df.drop([rowIdx])
                 df = df.reset_index(drop=True)
                 self._data = df
             #
             self.endRemoveRows()
 
     def myUnloadRow(self, rowIdx):
-        """Unload raw data by setting column ['_ba'] = None"""
+        """Unload raw data by setting column ['_ba'] = None
+        """
         rowIdx = self._data.index[rowIdx]  # assume rows are sorted
-        # self._data.loc[rowIdx, '_ba'] = None
+        #self._data.loc[rowIdx, '_ba'] = None
         if self.isAnalysisDir:
             # if using analysis dir, azll actions are in-place
             self._data.unloadRow(rowIdx)
 
             # we changed the model, we need to emit dataChanged
             indexStart = self.createIndex(rowIdx, 0)
-            indexStop = self.createIndex(rowIdx + 1, 0)
+            indexStop = self.createIndex(rowIdx+1, 0)
             self.dataChanged.emit(indexStart, indexStop)
 
     def myRemoveFromDatabase(self, rowIdx):
-        """Remove bAnalysis from h5 database"""
+        """Remove bAnalysis from h5 database
+        """
         rowIdx = self._data.index[rowIdx]  # assume rows are sorted
-        # self.beginInsertRows(QtCore.QModelIndex(), rowIdx, rowIdx)
+        #self.beginInsertRows(QtCore.QModelIndex(), rowIdx, rowIdx)
         if self.isAnalysisDir:
             # if using analysis dir, azll actions are in-place
             # self.beginResetModel()
             self._data.removeRowFromDatabase(rowIdx)
             # self.endResetModel()
 
             # we changed the model, we need to emit dataChanged
             indexStart = self.createIndex(rowIdx, 0)
-            indexStop = self.createIndex(rowIdx + 1, 0)
+            indexStop = self.createIndex(rowIdx+1, 0)
             self.dataChanged.emit(indexStart, indexStop)
-        # self.endInsertRows()
+        #self.endInsertRows()
 
     def myDuplicateRow(self, rowIdx):
         rowIdx = self._data.index[rowIdx]  # assume rows are sorted
-        self.beginInsertRows(QtCore.QModelIndex(), rowIdx + 1, rowIdx + 1)
+        self.beginInsertRows(QtCore.QModelIndex(), rowIdx+1, rowIdx+1)
         #
         # duplicate rowIdx
 
         if self.isAnalysisDir:
-            df = self._data._df  # either Dataframe or analysisDir
+            df = self._data._df # either Dataframe or analysisDir
             self._data.duplicateRow(rowIdx)
         else:
             # make copy
             rowDict = self.myGetRowDict(rowIdx)
             newIdx = rowIdx + 0.5
             dfRow = pd.DataFrame(rowDict, index=[newIdx])
 
-            df = self._data  # either Dataframe or analysisDir
+            df = self._data # either Dataframe or analysisDir
 
             # append dfRow to the end
             df = df.append(dfRow, ignore_index=True)
 
             # sort by file name
-            df = df.sort_values(
-                by=["File"], axis="index", ascending=True, inplace=False
-            )
+            df = df.sort_values(by=['File'], axis='index', ascending=True, inplace=False)
             df = df.reset_index(drop=True)
             #
             self._data = df
         #
         self.endInsertRows()
 
     def mySetRow(self, rowIdx, rowDict):
-        """Only set keys already in self._data.columns"""
+        """Only set keys already in self._data.columns
+        """
         rowIdx = self._data.index[rowIdx]  # assume rows are sorted
-        # rowSeries = pd.Series(rowDict)
-        # self._data.loc[rowIdx] = rowSeries
-        # self._data = self._data.reset_index(drop=True)
-        for k, v in rowDict.items():
+        #rowSeries = pd.Series(rowDict)
+        #self._data.loc[rowIdx] = rowSeries
+        #self._data = self._data.reset_index(drop=True)
+        for k,v in rowDict.items():
             if k in self._data.columns:
                 self._data.at[rowIdx, k] = v
 
     def mySaveDb(self, path):
-        # print('pandasModel.mySaveDb() path:', path)
-        # logger.info(f'Saving csv {path}')
+        #print('pandasModel.mySaveDb() path:', path)
+        #logger.info(f'Saving csv {path}')
         self._data.to_csv(path, index=False)
         self.isDirty = False
 
-    """
+    '''
     def saveHdf(self):
         if self.isAnalysisDir:
             self._data.saveHdf()
-    """
+    '''
 
     def mySave(self):
         if self.isAnalysisDir:
             self._data.save()
 
     def mySyncDfWithPath(self):
         if self.isAnalysisDir:
@@ -610,95 +593,85 @@
     def myUpdateLoadedAnalyzed(self, ba, rowIdx):
         if self.isAnalysisDir:
             rowIdx = self._data.index[rowIdx]  # assume rows are sorted
             self._data._updateLoadedAnalyzed(rowIdx)
 
             # we changed the model, we need to emit dataChanged
             indexStart = self.createIndex(rowIdx, 0)
-            indexStop = self.createIndex(rowIdx + 1, 0)
+            indexStop = self.createIndex(rowIdx+1, 0)
             self.dataChanged.emit(indexStart, indexStop)
 
     def _old_mySetDetectionParams(self, rowIdx, cellType):
         """Set predefined detection paramers.
-
+        
         For example: SA Node, Neuron, Subthreshold, etc
         """
-        logger.info(f"rowIdx:{rowIdx} cellType:{cellType}")
+        logger.info(f'rowIdx:{rowIdx} cellType:{cellType}')
         rowDict = self.myGetRowDict(rowIdx)
-        # print('  [1] rowDict:', rowDict)
+        #print('  [1] rowDict:', rowDict)
         # get defaults
         dDict = sanpy.bAnalysis.getDefaultDetection(cellType=cellType)
-        for k, v in dDict.items():
+        for k,v in dDict.items():
             if k in rowDict.keys():
                 rowDict[k] = v
-        # print('  [2] rowDict:', rowDict)
+        #print('  [2] rowDict:', rowDict)
         self.mySetRow(rowIdx, rowDict)
-        # print(self._data._df['_ba'])
+        #print(self._data._df['_ba'])
 
         # signal data change
         indexStart = self.createIndex(rowIdx, 0)
-        indexStop = self.createIndex(rowIdx + 1, 0)
+        indexStop = self.createIndex(rowIdx+1, 0)
         self.dataChanged.emit(indexStart, indexStop)
 
         # detection widget needs to update (dvdtThreshold, mVThreshold, ...)
-        # emitRowDict = self.myGetRowDict(rowIdx)
+        #emitRowDict = self.myGetRowDict(rowIdx)
         self.signalMyDataChanged.emit(None, None, rowDict)
 
     '''
     def mySetColumns(self, columnsDict):
         """
         When used as a file table, set with: sanpy.analysisDir.sanpyColumns
         """
         self.sanpyColumns = columnsDict
     '''
 
-
 # see: https://stackoverflow.com/questions/17748546/pyqt-column-of-checkboxes-in-a-qtableview
 class old_myCheckBoxDelegate(QtWidgets.QItemDelegate):
     """
     A delegate that places a fully functioning QCheckBox cell of the column to which it's applied.
     """
-
     def __init__(self, parent):
         QtWidgets.QItemDelegate.__init__(self, parent)
 
     def createEditor(self, parent, option, index):
         """
         Important, otherwise an editor is created if the user clicks in this cell.
         """
         return None
 
     def paint(self, painter, option, index):
         """
         Paint a checkbox without the label.
         """
-        self.drawCheck(
-            painter,
-            option,
-            option.rect,
-            QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked,
-        )
+        self.drawCheck(painter, option, option.rect, QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked)
 
     def editorEvent(self, event, model, option, index):
-        """
+        '''
         Change the data in the model and the state of the checkbox
         if the user presses the left mousebutton and this cell is editable. Otherwise do nothing.
-        """
+        '''
         if not int(index.flags() & QtCore.Qt.ItemIsEditable) > 0:
             return False
 
-        if (
-            event.type() == QtCore.QEvent.MouseButtonRelease
-            and event.button() == QtCore.Qt.LeftButton
-        ):
+        if event.type() == QtCore.QEvent.MouseButtonRelease and event.button() == QtCore.Qt.LeftButton:
             # Change the checkbox-state
             self.setModelData(None, model, index)
             return True
 
         return False
 
-    def setModelData(self, editor, model, index):
-        """
+    def setModelData (self, editor, model, index):
+        '''
         The user wanted to change the old state in the opposite.
-        """
-        print("myCheckBoxDelegate.setModelData()")
+        '''
+        print('myCheckBoxDelegate.setModelData()')
         model.setData(index, 1 if int(index.data()) == 0 else 0, QtCore.Qt.EditRole)
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bKymographWidget.py` & `sanpy-ephys-0.1.6/sanpy/interface/bKymographWidget.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,122 +10,115 @@
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 import pyqtgraph as pg
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class myCustomDialog(QtWidgets.QDialog):
     def __init__(self, parent=None):
         super().__init__(parent)
 
         self.setWindowTitle("Set Kymograph Scale!")
 
         QBtn = QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
 
         self.buttonBox = QtWidgets.QDialogButtonBox(QBtn)
         self.buttonBox.accepted.connect(self.accept)
         self.buttonBox.rejected.connect(self.reject)
 
         hLayout = QtWidgets.QHBoxLayout()
 
-        xScaleLabel = QtWidgets.QLabel("Seconds/Line")
+        xScaleLabel = QtWidgets.QLabel('Seconds/Line')
         self.xScale = QtWidgets.QDoubleSpinBox()
         self.xScale.setDecimals(4)
 
-        yScaleLabel = QtWidgets.QLabel("Microns/Pixel")
+        yScaleLabel = QtWidgets.QLabel('Microns/Pixel')
         self.yScale = QtWidgets.QDoubleSpinBox()
         self.yScale.setDecimals(4)
 
         hLayout.addWidget(xScaleLabel)
         hLayout.addWidget(self.xScale)
 
         hLayout.addWidget(yScaleLabel)
         hLayout.addWidget(self.yScale)
 
         self.layout = QtWidgets.QVBoxLayout()
-        # message = QtWidgets.QLabel("Set Kymograph Scale")
-        # self.layout.addWidget(message)
-
+        #message = QtWidgets.QLabel("Set Kymograph Scale")
+        #self.layout.addWidget(message)
+        
         self.layout.addLayout(hLayout)
-
+        
         self.layout.addWidget(self.buttonBox)
         self.setLayout(self.layout)
 
     def getResults(self) -> dict:
-        """Get values from user input."""
+        """Get values from user input.
+        """
         xScale = self.xScale.value()
         yScale = self.yScale.value()
         retDict = {
-            "secondsPerLine": xScale,
-            "umPerPixel": yScale,
+            'secondsPerLine': xScale,
+            'umPerPixel': yScale,
         }
         return retDict
 
-
 def showdialog():
     d = QtWidgets.QDialog()
     b1 = QtWidgets.QPushButton("ok", d)
-    b1.move(50, 50)
+    b1.move(50,50)
     d.setWindowTitle("Set Kymograph Scale")
     d.setWindowModality(QtCore.Qt.ApplicationModal)
     d.exec_()
 
-
 class kymographImage(pg.ImageItem):
     """
     Utility class to inherit and redefine some functions.
     """
-
     def mouseClickEvent(self, event):
-        # print("Click", event.pos())
+        #print("Click", event.pos())
         x = event.pos().x()
         y = event.pos().y()
 
     def mouseDragEvent(self, event):
         return
 
         if event.isStart():
             print("Start drag", event.pos())
         elif event.isFinish():
             print("Stop drag", event.pos())
         else:
             print("Drag", event.pos())
 
     def old_hoverEvent(self, event):
-        logger.info("")
+        logger.info('')
         if not event.isExit():
             # the mouse is hovering over the image; make sure no other items
             # will receive left click/drag events from here.
             event.acceptDrags(pg.QtCore.Qt.LeftButton)
             event.acceptClicks(pg.QtCore.Qt.LeftButton)
 
-
 class kymographWidget(QtWidgets.QWidget):
-    """Display a kymograph with contrast controls."""
-
+    """Display a kymograph with contrast controls.
+    """
     signalKymographRoiChanged = QtCore.pyqtSignal(object)  # list of [l, t, r, b]
-    signalSwitchToMolar = QtCore.pyqtSignal(
-        object, object, object
-    )  # (boolean, kd, caConc)
+    signalSwitchToMolar = QtCore.pyqtSignal(object, object, object)  # (boolean, kd, caConc)
     signalScaleChanged = QtCore.pyqtSignal(object)  # dict with x/y scale
     signalLineSliderChanged = QtCore.pyqtSignal(object)  # int, new line selected
 
     def __init__(self, ba=None, parent=None):
         """
         ba: bAnalysis
         """
         super().__init__(parent)
 
-        logger.info(f"{type(ba)}")
-
+        logger.info(f'{type(ba)}')
+        
         bitDepth = 8
         self._minContrast = 0
         self._maxContrast = 2**bitDepth
 
         self.ba = ba
 
         self.myImageItem = None  # kymographImage
@@ -133,144 +126,145 @@
         self.myLineRoiBackground = None
         self.myColorBarItem = None
 
         self._buildUI()
         self._replot()
 
     def on_convert_to_nm_clicked(self, value):
-        onOff = value == 2
-        # self.detectionWidget.toggleCrosshair(onOff)
+        onOff = value==2
+        #self.detectionWidget.toggleCrosshair(onOff)
         self.signalSwitchToMolar.emit(onOff)
 
     def on_button_click(self, name):
         logger.info(name)
-        if name == "Reset ROI":
+        if name == 'Reset ROI':
             newRect = self.ba.fileLoader.resetKymographRect()
-            # self.ba._updateTifRoi(newRect)
+            #self.ba._updateTifRoi(newRect)
             self._replot()
             self.signalKymographRoiChanged.emit(newRect)  # underlying _abf has new rect
 
         else:
-            logger.info(f"Case not taken: {name}")
+            logger.info(f'Case not taken: {name}')
 
     def _buildMolarLayout(self):
         """Layout to conver sum intensity (for each line scan) into molar.
-
+       
         Seems a bit silly.
         """
         molarLayout = QtWidgets.QHBoxLayout()
 
         # todo: add checkbox to turn kn/rest calculation on off
         #            need signal
-        convertToMolarCheckBox = QtWidgets.QCheckBox("Convert to Molar")
+        convertToMolarCheckBox = QtWidgets.QCheckBox('Convert to Molar')
         convertToMolarCheckBox.setChecked(False)
         convertToMolarCheckBox.stateChanged.connect(self.on_convert_to_nm_clicked)
         convertToMolarCheckBox.setDisabled(True)
         molarLayout.addWidget(convertToMolarCheckBox)
 
         #
         # kd
-        kdLabel = QtWidgets.QLabel("kd")
+        kdLabel = QtWidgets.QLabel('kd')
         molarLayout.addWidget(kdLabel)
 
         kdDefault = 22.1
         self.kdSpinBox = QtWidgets.QDoubleSpinBox()
         self.kdSpinBox.setMinimum(0)
         self.kdSpinBox.setMaximum(+1e6)
         self.kdSpinBox.setValue(kdDefault)
         self.kdSpinBox.setDisabled(True)
-        # self.kdSpinBox.setSpecialValueText("None")
+        #self.kdSpinBox.setSpecialValueText("None")
         molarLayout.addWidget(self.kdSpinBox)
 
         #
         # resting Ca
-        restingCaLabel = QtWidgets.QLabel("Resting Ca")
+        restingCaLabel = QtWidgets.QLabel('Resting Ca')
         molarLayout.addWidget(restingCaLabel)
 
         restingCaDefault = 113.7
         self.restingCaSpinBox = QtWidgets.QDoubleSpinBox()
         self.restingCaSpinBox.setMinimum(0)
         self.restingCaSpinBox.setMaximum(+1e6)
         self.restingCaSpinBox.setValue(restingCaDefault)
         self.restingCaSpinBox.setDisabled(True)
-        # self.kdSpinBox.setSpecialValueText("None")
+        #self.kdSpinBox.setSpecialValueText("None")
         molarLayout.addWidget(self.restingCaSpinBox)
 
         return molarLayout
 
     def _buildControlBarLayout(self):
+
         # get underlying scale from sanpy.bAbfText tif header
-        xScale = "None"
-        yScale = "None"
+        xScale = 'None'
+        yScale = 'None'
         xPixels = None
         yPixels = None
         _fileName = None
         if self.ba is not None:
-            xScale = self.ba._abf.tifHeader["secondsPerLine"]
-            yScale = self.ba._abf.tifHeader["umPerPixel"]
-
+            xScale = self.ba._abf.tifHeader['secondsPerLine']
+            yScale = self.ba._abf.tifHeader['umPerPixel']
+        
             yPixels, xPixels = self.ba.tifData.shape  # numpy order is (y,x)
 
             _fileName = self.ba.getFileName()
 
         controlBarLayout = QtWidgets.QHBoxLayout()
 
-        self._fileNameLabel = QtWidgets.QLabel(f"{_fileName}")
+        self._fileNameLabel = QtWidgets.QLabel(f'{_fileName}')
         controlBarLayout.addWidget(self._fileNameLabel)
 
         # pixels
-
-        aLabel = QtWidgets.QLabel(f"Pixels X:")
+        
+        aLabel = QtWidgets.QLabel(f'Pixels X:')
         controlBarLayout.addWidget(aLabel)
 
-        self.xPixelLabel = QtWidgets.QLabel(f"{xPixels}")
+        self.xPixelLabel = QtWidgets.QLabel(f'{xPixels}')
         controlBarLayout.addWidget(self.xPixelLabel)
 
-        aLabel = QtWidgets.QLabel(f"Y:")
+        aLabel = QtWidgets.QLabel(f'Y:')
         controlBarLayout.addWidget(aLabel)
 
-        self.yPixelLabel = QtWidgets.QLabel(f"{yPixels}")
+        self.yPixelLabel = QtWidgets.QLabel(f'{yPixels}')
         controlBarLayout.addWidget(self.yPixelLabel)
 
         # scale
-
-        aLabel = QtWidgets.QLabel(f"Scale X:")
+        
+        aLabel = QtWidgets.QLabel(f'Scale X:')
         controlBarLayout.addWidget(aLabel)
 
-        self.xScaleLabel = QtWidgets.QLabel(f"{xScale}")
+        self.xScaleLabel = QtWidgets.QLabel(f'{xScale}')
         controlBarLayout.addWidget(self.xScaleLabel)
 
-        aLabel = QtWidgets.QLabel(f"Y:")
+        aLabel = QtWidgets.QLabel(f'Y:')
         controlBarLayout.addWidget(aLabel)
 
-        self.yScaleLabel = QtWidgets.QLabel(f"{yScale}")
+        self.yScaleLabel = QtWidgets.QLabel(f'{yScale}')
         controlBarLayout.addWidget(self.yScaleLabel)
 
         # reset
-
-        buttonName = "Reset ROI"
+        
+        buttonName = 'Reset ROI'
         button = QtWidgets.QPushButton(buttonName)
-        # button.setToolTip('Detect spikes using dV/dt threshold.')
-        button.clicked.connect(partial(self.on_button_click, buttonName))
+        #button.setToolTip('Detect spikes using dV/dt threshold.')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
         controlBarLayout.addWidget(button)
 
         return controlBarLayout
 
     def _buildUI(self):
         # one row of controls and then kymograph image
         self.myVBoxLayout = QtWidgets.QVBoxLayout(self)
         self.myVBoxLayout.setAlignment(QtCore.Qt.AlignTop)
 
         if 0:
             molarLayout = self._buildMolarLayout()
-            self.myVBoxLayout.addLayout(molarLayout)  #
+            self.myVBoxLayout.addLayout(molarLayout) #
 
         #
         controlBarLayout = self._buildControlBarLayout()
-        self.myVBoxLayout.addLayout(controlBarLayout)  #
+        self.myVBoxLayout.addLayout(controlBarLayout) #
 
         # #
         # # display the (min, max, cursor) intensity
         # controlBarLayout0 = QtWidgets.QHBoxLayout()
         # # min
         # self.tifMinLabel = QtWidgets.QLabel('Min:')
         # controlBarLayout0.addWidget(self.tifMinLabel)
@@ -288,111 +282,105 @@
         # self.backgroundRoiMinLabel = QtWidgets.QLabel('Background Min:')
         # controlBarLayout0.addWidget(self.backgroundRoiMinLabel)
         # background max
         # self.backgroundRoiMaxLabel = QtWidgets.QLabel('Background Max:')
         # controlBarLayout0.addWidget(self.backgroundRoiMaxLabel)
 
         # # cursor
-        self.tifCursorLabel = QtWidgets.QLabel("Cursor:")
+        self.tifCursorLabel = QtWidgets.QLabel('Cursor:')
         # controlBarLayout0.addWidget(self.tifCursorLabel)
 
         #
         # self.myVBoxLayout.addLayout(controlBarLayout0) #
 
         #
         # contrast sliders
         bitDepth = 8
 
         # min
         minContrastLayout = QtWidgets.QHBoxLayout()
 
-        minLabel = QtWidgets.QLabel("Min")
+        minLabel = QtWidgets.QLabel('Min')
         minContrastLayout.addWidget(minLabel)
 
         self.minContrastSpinBox = QtWidgets.QSpinBox()
         self.minContrastSpinBox.setMinimum(0)
         self.minContrastSpinBox.setMaximum(2**bitDepth)
         minContrastLayout.addWidget(self.minContrastSpinBox)
 
         minContrastSlider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
         minContrastSlider.setMinimum(0)
         minContrastSlider.setMaximum(2**bitDepth)
         minContrastSlider.setValue(0)
-        # myLambda = lambda chk, item=canvasName: self._userSelectCanvas(chk, item)
-        minContrastSlider.valueChanged.connect(
-            lambda val, name="min": self._onContrastSliderChanged(val, name)
-        )
+        #myLambda = lambda chk, item=canvasName: self._userSelectCanvas(chk, item)
+        minContrastSlider.valueChanged.connect(lambda val,name='min': self._onContrastSliderChanged(val, name))
         minContrastLayout.addWidget(minContrastSlider)
 
         # image min
-        self.tifMinLabel = QtWidgets.QLabel("Min:")
+        self.tifMinLabel = QtWidgets.QLabel('Min:')
         minContrastLayout.addWidget(self.tifMinLabel)
 
         # roi min
-        self.roiMinLabel = QtWidgets.QLabel("ROI Min:")
+        self.roiMinLabel = QtWidgets.QLabel('ROI Min:')
         minContrastLayout.addWidget(self.roiMinLabel)
 
-        self.myVBoxLayout.addLayout(minContrastLayout)  #
+        self.myVBoxLayout.addLayout(minContrastLayout) #
 
         # max
         maxContrastLayout = QtWidgets.QHBoxLayout()
 
-        maxLabel = QtWidgets.QLabel("Max")
+        maxLabel = QtWidgets.QLabel('Max')
         maxContrastLayout.addWidget(maxLabel)
 
         self.maxContrastSpinBox = QtWidgets.QSpinBox()
         self.maxContrastSpinBox.setMinimum(0)
         self.maxContrastSpinBox.setMaximum(2**bitDepth)
         maxContrastLayout.addWidget(self.maxContrastSpinBox)
 
         maxContrastSlider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
         maxContrastSlider.setMinimum(0)
         maxContrastSlider.setMaximum(2**bitDepth)
         maxContrastSlider.setValue(2**bitDepth)
-        maxContrastSlider.valueChanged.connect(
-            lambda val, name="max": self._onContrastSliderChanged(val, name)
-        )
+        maxContrastSlider.valueChanged.connect(lambda val,name='max': self._onContrastSliderChanged(val, name))
         maxContrastLayout.addWidget(maxContrastSlider)
 
         # image max
-        self.tifMaxLabel = QtWidgets.QLabel("Max:")
+        self.tifMaxLabel = QtWidgets.QLabel('Max:')
         maxContrastLayout.addWidget(self.tifMaxLabel)
 
         # roi max
-        self.roiMaxLabel = QtWidgets.QLabel("ROI Max:")
+        self.roiMaxLabel = QtWidgets.QLabel('ROI Max:')
         maxContrastLayout.addWidget(self.roiMaxLabel)
 
-        self.myVBoxLayout.addLayout(maxContrastLayout)  #
+        self.myVBoxLayout.addLayout(maxContrastLayout) #
 
         #
         # kymograph
         self.view = pg.GraphicsLayoutWidget()
-        # self.view.show()
-        # self.kymographWindow = pg.PlotWidget()
+        #self.view.show()
+        #self.kymographWindow = pg.PlotWidget()
 
         row = 0
         colSpan = 1
         rowSpan = 1
-        self.kymographPlot = self.view.addPlot(
-            row=row, col=0, rowSpan=rowSpan, colSpan=colSpan
-        )
+        self.kymographPlot = self.view.addPlot(row=row, col=0, rowSpan=rowSpan, colSpan=colSpan)
         self.kymographPlot.enableAutoRange()
         # turn off x/y dragging of deriv and vm
         self.kymographPlot.setMouseEnabled(x=False, y=True)
         # hide the little 'A' button to rescale axis
         self.kymographPlot.hideButtons()
         # turn off right-click menu
         self.kymographPlot.setMenuEnabled(False)
         # hide by default
         self.kymographPlot.hide()  # show in _replot() if self.ba.isKymograph()
 
         # TODO: add show/hide, we do not want this in the main interface
         # vertical line to show selected line scan (adjusted/changed with slider)
         self._sliceLine = pg.InfiniteLine(pos=0, angle=90)
-        # self._sliceLinesList.append(sliceLine) # keep a list of vertical slice lines so we can update all at once
+        #self._sliceLinesList.append(sliceLine) # keep a list of vertical slice lines so we can update all at once
         self.kymographPlot.addItem(self._sliceLine)
 
         self.myVBoxLayout.addWidget(self.view)
 
         #
         # # add scatter plot for rising/falling diameter detection
         # color = 'g'
@@ -413,299 +401,275 @@
         self._profileSlider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)
         self._profileSlider.setMinimum(0)
         # TODO: cludge, fix
         _numLineScans = 0
         if self.ba is not None:
             _numLineScans = len(self.ba.fileLoader.sweepX) - 1
         self._profileSlider.setMaximum(_numLineScans)
-        # self._profileSlider.setMaximum(self._kymographAnalysis.numLineScans())
+        #self._profileSlider.setMaximum(self._kymographAnalysis.numLineScans())
         self._profileSlider.valueChanged.connect(self._on_line_slider_changed)
         self.myVBoxLayout.addWidget(self._profileSlider)
 
     def showLineSlider(self, visible):
-        """Toggle line slider and vertical line (on image) on/off."""
+        """Toggle line slider and vertical line (on image) on/off.
+        """
         self._profileSlider.setVisible(visible)
 
-    def _on_line_slider_changed(self, lineNumber: int):
+    def _on_line_slider_changed(self, lineNumber :int):
         """Respond to user dragging the line slider.
-
+        
         Args:
             lineNumber: Int line number, needs to be converted to 'seconds'
         """
 
-        lineSeconds = lineNumber * self.ba._abf.tifHeader["secondsPerLine"]
+        lineSeconds = lineNumber * self.ba._abf.tifHeader['secondsPerLine']
 
-        logger.info(f"lineNumber:{lineNumber} lineSeconds:{lineSeconds}")
+        logger.info(f'lineNumber:{lineNumber} lineSeconds:{lineSeconds}')
 
         # set the vertical line
         self._sliceLine.setValue(lineSeconds)
 
         self.signalLineSliderChanged.emit(lineNumber)
-
-    def _onContrastSliderChanged(self, val: int, name: str):
+    
+    def _onContrastSliderChanged(self, val:int, name:str):
         """Respond to either the min or max contrast slider.
-
+        
         Args:
             val: new value
             name: Name of slider, in ('min', 'max')
         """
-        logger.info(f"{name} {val}")
-        if name == "min":
+        logger.info(f'{name} {val}')
+        if name == 'min':
             self._minContrast = val
             self.minContrastSpinBox.setValue(val)
-        elif name == "max":
+        elif name == 'max':
             self._maxContrast = val
             self.maxContrastSpinBox.setValue(val)
         self._replot()
 
     def getContrastEnhance(self, theMin=None, theMax=None):
-        """Get contrast enhanced image."""
+        """Get contrast enhanced image.
+        """
         bitDepth = 8
-
+        
         if theMin is None:
             theMin = self._minContrast
         if theMax is None:
             theMax = self._maxContrast
-
-        lut = np.arange(2**bitDepth, dtype="uint8")
-        lut = self._getContrastedImage(lut, theMin, theMax)  # get a copy of the image
+        
+        lut = np.arange(2**bitDepth, dtype='uint8')
+        lut = self._getContrastedImage(lut, theMin, theMax) # get a copy of the image
         theRet = np.take(lut, self.ba.tifData)
         return theRet
 
-    def _getContrastedImage(
-        self, image, display_min, display_max
-    ):  # copied from Bi Rico
+    def _getContrastedImage(self, image, display_min, display_max): # copied from Bi Rico
         # Here I set copy=True in order to ensure the original image is not
         # modified. If you don't mind modifying the original image, you can
         # set copy=False or skip this step.
         bitDepth = 8
-
+        
         image = np.array(image, dtype=np.uint8, copy=True)
         image.clip(display_min, display_max, out=image)
         image -= display_min
-        np.floor_divide(
-            image,
-            (display_max - display_min + 1) / (2**bitDepth),
-            out=image,
-            casting="unsafe",
-        )
-        # np.floor_divide(image, (display_max - display_min + 1) / 256,
+        np.floor_divide(image, (display_max - display_min + 1) / (2**bitDepth), out=image, casting='unsafe')
+        #np.floor_divide(image, (display_max - display_min + 1) / 256,
         #                out=image, casting='unsafe')
-        # return image.astype(np.uint8)
+        #return image.astype(np.uint8)
         return image
 
     def _replot(self, startSec=None, stopSec=None):
-        logger.info("")
+        logger.info('')
 
         if self.ba is None:
             return
 
         self.kymographPlot.clear()
         self.kymographPlot.show()
 
         myTif = self.getContrastEnhance()
-
-        logger.info(
-            f"  startSec:{startSec} stopSec:{stopSec} myTif.shape:{myTif.shape}"
-        )  # like (519, 10000)
-
-        # self.myImageItem = pg.ImageItem(myTif, axisOrder='row-major')
+        
+        logger.info(f'  startSec:{startSec} stopSec:{stopSec} myTif.shape:{myTif.shape}')  # like (519, 10000)
+        
+        #self.myImageItem = pg.ImageItem(myTif, axisOrder='row-major')
         #  TODO: set height to micro-meters
-        axisOrder = "row-major"
-
+        axisOrder='row-major'
+        
         # todo: get from tifHeader
-        umLength = self.ba.tifData.shape[0] * self.ba._abf.tifHeader["umPerPixel"]
-
-        rect = [0, 0, self.ba.fileLoader.recordingDur, umLength]  # x, y, w, h
+        umLength = self.ba.tifData.shape[0] * self.ba._abf.tifHeader['umPerPixel']
 
+        rect=[0,0, self.ba.fileLoader.recordingDur, umLength]  # x, y, w, h
+        
         if self.myImageItem is None:
             # first time build
-            self.myImageItem = kymographImage(myTif, axisOrder=axisOrder, rect=rect)
+            self.myImageItem = kymographImage(myTif, axisOrder=axisOrder,
+                            rect=rect)
             # redirect hover to self (to display intensity
             self.myImageItem.hoverEvent = self.hoverEvent
         else:
             # second time update
-            # myTif = self.ba.tifData
+            #myTif = self.ba.tifData
             myTif = self.getContrastEnhance()
-            self.myImageItem.setImage(myTif, axisOrder=axisOrder, rect=rect)
+            self.myImageItem.setImage(myTif, axisOrder=axisOrder,
+                            rect=rect)
         self.kymographPlot.addItem(self.myImageItem)
-
+        
         padding = 0
         if startSec is not None and stopSec is not None:
-            self.kymographPlot.setXRange(
-                startSec, stopSec, padding=padding
-            )  # row major is different
+            self.kymographPlot.setXRange(startSec, stopSec, padding=padding)  # row major is different
 
         # re-add the vertical line
         self.kymographPlot.addItem(self._sliceLine)
 
         #
         # plot of diameter detection
         self._leftFitScatter = pg.ScatterPlotItem(
-            size=3, brush=pg.mkBrush(50, 255, 50, 120)
-        )
+                                size=3, brush=pg.mkBrush(50, 255, 50, 120))
         _xFake = []  # self.ba.sweepX
         _yFake = []  # [200 for x in self.ba.sweepX]
         self._leftFitScatter.setData(_xFake, _yFake)
         self.kymographPlot.addItem(self._leftFitScatter)
-
+            
         self._rightFitScatter = pg.ScatterPlotItem(
-            size=3, brush=pg.mkBrush(255, 50, 50, 120)
-        )
+                                size=3, brush=pg.mkBrush(255, 50, 50, 120))
         _xFake = []  # self.ba.sweepX
         _yFake = []  # [350 for x in self.ba.sweepX]
         self._rightFitScatter.setData(_xFake, _yFake)
         self.kymographPlot.addItem(self._rightFitScatter)
 
         #
         # color bar with contrast !!!
-        if myTif.dtype == np.dtype("uint8"):
+        if myTif.dtype == np.dtype('uint8'):
             bitDepth = 8
-        elif myTif.dtype == np.dtype("uint16"):
+        elif myTif.dtype == np.dtype('uint16'):
             bitDepth = 16
         else:
             bitDepth = 16
-            logger.error(f"Did not recognize tif dtype: {myTif.dtype}")
+            logger.error(f'Did not recognize tif dtype: {myTif.dtype}')
 
-        cm = pg.colormap.get(
-            "Greens_r", source="matplotlib"
-        )  # prepare a linear color map
-        # values = (0, 2**bitDepth)
-        # values = (0, maxTif)
+        cm = pg.colormap.get('Greens_r', source='matplotlib') # prepare a linear color map
+        #values = (0, 2**bitDepth)
+        #values = (0, maxTif)
         values = (0, 2**12)
         limits = (0, 2**12)
-        # logger.info(f'color bar bit depth is {bitDepth} with values in {values}')
+        #logger.info(f'color bar bit depth is {bitDepth} with values in {values}')
         doColorBar = False
         if doColorBar:
             if self.myColorBarItem == None:
-                self.myColorBarItem = pg.ColorBarItem(
-                    values=values,
-                    limits=limits,
-                    interactive=True,
-                    label="",
-                    cmap=cm,
-                    orientation="horizontal",
-                )
+                self.myColorBarItem = pg.ColorBarItem( values=values, limits=limits,
+                                                interactive=True,
+                                                label='', cmap=cm, orientation='horizontal' )
             # Have ColorBarItem control colors of img and appear in 'plot':
-            self.myColorBarItem.setImageItem(
-                self.myImageItem, insert_in=self.kymographPlot
-            )
+            self.myColorBarItem.setImageItem( self.myImageItem, insert_in=self.kymographPlot )
             self.myColorBarItem.setLevels(values=values)
 
         kymographRect = self.ba.fileLoader.getKymographRect()
         if kymographRect is not None:
             # TODO: I guess we always have a rect, o.w. this would be a runtime error
             xRoiPos = kymographRect[0]
             yRoiPos = kymographRect[3]
             top = kymographRect[1]
             right = kymographRect[2]
             bottom = kymographRect[3]
             widthRoi = right - xRoiPos + 1
-            # heightRoi = bottom - yRoiPos + 1
+            #heightRoi = bottom - yRoiPos + 1
             heightRoi = top - yRoiPos + 1
-        """
+        '''
         else:
             #  TODO: Put this logic into function in bAbfText
             pos, size = self.ba.defaultTifRoi()
 
             xRoiPos = 0  # startSeconds
             yRoiPos = 0  # pixels
             widthRoi = myTif.shape[1]
             heightRoi = myTif.shape[0]
             tifHeightPercent = myTif.shape[0] * 0.2
             #print('tifHeightPercent:', tifHeightPercent)
             yRoiPos += tifHeightPercent
             heightRoi -= 2 * tifHeightPercent
-        """
+        '''
         # TODO: get this out of replot, recreating the ROI is causing runtime error
         # update the rect roi
-        pos = (xRoiPos, yRoiPos)
-        size = (widthRoi, heightRoi)
+        pos = (xRoiPos,yRoiPos)
+        size = (widthRoi,heightRoi)
         if self.myLineRoi is None:
             movable = False
-            self.myLineRoi = pg.ROI(
-                pos=pos, size=size, parent=self.myImageItem, movable=movable
-            )
-            # self.myLineRoi.addScaleHandle((0,0), (1,1), name='topleft')  # at origin
-            self.myLineRoi.addScaleHandle(
-                (0.5, 0), (0.5, 1), name="top center"
-            )  # top center
-            self.myLineRoi.addScaleHandle(
-                (0.5, 1), (0.5, 0), name="bottom center"
-            )  # bottom center
-            # self.myLineRoi.addScaleHandle((0,0.5), (1,0.5))  # left center
-            # self.myLineRoi.addScaleHandle((1,0.5), (0,0.5))  # right center
-            # self.myLineRoi.addScaleHandle((1,1), (0,0), name='bottomright')  # bottom right
+            self.myLineRoi = pg.ROI(pos=pos, size=size,
+                                    parent=self.myImageItem,
+                                    movable=movable)
+            #self.myLineRoi.addScaleHandle((0,0), (1,1), name='topleft')  # at origin
+            self.myLineRoi.addScaleHandle((0.5,0), (0.5,1), name='top center')  # top center
+            self.myLineRoi.addScaleHandle((0.5,1), (0.5,0), name='bottom center')  # bottom center
+            #self.myLineRoi.addScaleHandle((0,0.5), (1,0.5))  # left center
+            #self.myLineRoi.addScaleHandle((1,0.5), (0,0.5))  # right center
+            #self.myLineRoi.addScaleHandle((1,1), (0,0), name='bottomright')  # bottom right
             self.myLineRoi.sigRegionChangeFinished.connect(self.kymographChanged)
         else:
             self.myLineRoi.setPos(pos, finish=False)
             self.myLineRoi.setSize(size, finish=False)
 
         #
         # background kymograph ROI
-        backgroundRect = (
-            self.ba.fileLoader.getKymographBackgroundRect()
-        )  # keep this in the backend
+        backgroundRect = self.ba.fileLoader.getKymographBackgroundRect()  # keep this in the backend
         if backgroundRect is not None:
             xRoiPos = backgroundRect[0]
             yRoiPos = backgroundRect[3]
             top = backgroundRect[1]
             right = backgroundRect[2]
             bottom = backgroundRect[3]
             widthRoi = right - xRoiPos + 1
-            # heightRoi = bottom - yRoiPos + 1
+            #heightRoi = bottom - yRoiPos + 1
             heightRoi = top - yRoiPos + 1
-        pos = (xRoiPos, yRoiPos)
-        size = (widthRoi, heightRoi)
+        pos = (xRoiPos,yRoiPos)
+        size = (widthRoi,heightRoi)
 
         if 0:
             if self.myLineRoiBackground is None:
                 # TODO: get this out of replot, recreating the ROI is causing runtime error
-                self.myLineRoiBackground = pg.ROI(
-                    pos=pos, size=size, parent=self.myImageItem
-                )
+                self.myLineRoiBackground = pg.ROI(pos=pos, size=size, parent=self.myImageItem)
             else:
                 self.myLineRoiBackground.setPos(pos, finish=False)
                 self.myLineRoiBackground.setSize(size, finish=False)
-
+        
         # update min/max labels
         # TODO: only set this once on switch file
         myTifOrig = self.ba.fileLoader.tifData
         minTif = np.nanmin(myTifOrig)
         maxTif = np.nanmax(myTifOrig)
-        # print(type(dtype), dtype)  # <class 'numpy.dtype[uint16]'> uint16
-        self.tifMinLabel.setText(f"Min:{minTif}")
-        self.tifMaxLabel.setText(f"Max:{maxTif}")
+        #print(type(dtype), dtype)  # <class 'numpy.dtype[uint16]'> uint16
+        self.tifMinLabel.setText(f'Min:{minTif}')
+        self.tifMaxLabel.setText(f'Max:{maxTif}')
 
         # update min/max displayed to user
         self._updateRoiMinMax(kymographRect)
         self._updateBackgroundRoiMinMax(backgroundRect)
 
     def updateLeftRightFit(self, yLeft, yRight, visible=True):
-        """ """
-
+        """
+        
+        """
+    
         self._leftFitScatter.setVisible(visible)
         self._rightFitScatter.setVisible(visible)
 
         if visible:
             x = self.ba.fileLoader.sweepX
-            # TODO: check that len(y) == len(x)
+            #TODO: check that len(y) == len(x)
             self._leftFitScatter.setData(x, yLeft)
             self._rightFitScatter.setData(x, yRight)
-
+    
     def _updateBackgroundRoiMinMax(self, backgroundRect=None):
         """
         update background roi
 
         TODO: Add self.ba.fileLoader.getBackGroundStats()
 
         """
-        logger.warning(f"Need to add interface for user to adjust background roi")
+        logger.warning(f'Need to add interface for user to adjust background roi')
         return
-
+        
         if backgroundRect is None:
             backgroundRect = self.ba.fileLoader.getKymographBackgroundRect()
 
         left = backgroundRect[0]
         top = backgroundRect[1]
         right = backgroundRect[2]
         bottom = backgroundRect[3]
@@ -721,103 +685,103 @@
 
     def _updateRoiMinMax(self, theRect):
         left = theRect[0]
         top = theRect[1]
         right = theRect[2]
         bottom = theRect[3]
 
-        logger.info(f"left:{left} top:{top} right:{right} bottom:{bottom}")
-
+        logger.info(f'left:{left} top:{top} right:{right} bottom:{bottom}')
+        
         myTif = self.ba.fileLoader.tifData
         tifClip = myTif[bottom:top, left:right]
 
         roiMin = np.nanmin(tifClip)
         roiMax = np.nanmax(tifClip)
 
-        self.roiMinLabel.setText(f"ROI Min:{roiMin}")
-        self.roiMaxLabel.setText(f"ROI Max:{roiMax}")
+        self.roiMinLabel.setText(f'ROI Min:{roiMin}')
+        self.roiMaxLabel.setText(f'ROI Max:{roiMax}')
 
     def kymographChanged(self, event):
         """
         User finished gragging the ROI
 
         Args:
             event (pyqtgraph.graphicsItems.ROI.ROI)
         """
-        logger.info("")
+        logger.info('')
         # pos = event.pos()
         # size = event.size()
 
         _kymographRect = self.ba.fileLoader.getKymographRect()  # (l, t, r, b)
 
         left = _kymographRect[0]
         top = _kymographRect[1]
         right = _kymographRect[2]
         bottom = _kymographRect[3]
-
+        
         handles = event.getSceneHandlePositions()
         for _idx, handle in enumerate(handles):
-            logger.info(f"{_idx} handle: {handle}")
+            logger.info(f'{_idx} handle: {handle}')
             if handle[0] is not None:
-                # imagePos = self.myImageItem.mapFromScene(handle[1])
+                #imagePos = self.myImageItem.mapFromScene(handle[1])
                 imagePos = self.myImageItem.mapFromScene(handle[1])
                 x = imagePos.x()
                 y = imagePos.y()
                 # units are in image pixels !!!
                 # if handle[0] == 'topleft':
                 #     left = x
                 #     bottom = y
                 # elif handle[0] == 'bottomright':
                 #     right = x
                 #     top = y
-                if handle[0] == "top center":
+                if handle[0] == 'top center':
                     top = y
-                elif handle[0] == "bottom center":
+                elif handle[0] == 'bottom center':
                     bottom = y
 
         #
         left = int(left)
         top = int(top)
         right = int(right)
         bottom = int(bottom)
 
-        if left < 0:
+        if left<0:
             left = 0
-        if bottom < 0:
+        if bottom<0:
             bottom = 0
 
         # force left and right
         _kymographRect = self.ba.fileLoader.getKymographRect()  # (l, t, r, b)
         left = 0
         right = _kymographRect[2]
 
-        logger.info(f"  left:{left} top:{top} right:{right} bottom:{bottom}")
+        logger.info(f'  left:{left} top:{top} right:{right} bottom:{bottom}')
 
         #  cludge
         if bottom > top:
-            logger.warning(f"fixing bad top/bottom")
+            logger.warning(f'fixing bad top/bottom')
             tmp = top
             top = bottom
             bottom = tmp
 
         theRect = [left, top, right, bottom]
 
         self._updateRoiMinMax(theRect)
 
         # TODO: detection widget needs a slot to (i) analyze and then replot
-        # self.ba._updateTifRoi(theRect)
-        # self._replot(startSec=None, stopSec=None, userUpdate=True)
-        # self.signalDetect.emit(self.ba)  # underlying _abf has new rect
+        #self.ba._updateTifRoi(theRect)
+        #self._replot(startSec=None, stopSec=None, userUpdate=True)
+        #self.signalDetect.emit(self.ba)  # underlying _abf has new rect
         self.ba.fileLoader._updateTifRoi(theRect)
         self.signalKymographRoiChanged.emit(theRect)  # underlying _abf has new rect
 
     def slot_switchFile(self, ba=None, startSec=None, stopSec=None):
         if ba is not None and ba.fileLoader.isKymograph():
             self.ba = ba
-            # self._updateRoiMinMax(theRect)
+            #self._updateRoiMinMax(theRect)
             self._replot(startSec=startSec, stopSec=stopSec)
 
             # update line scan slider
             _numLineScans = len(self.ba.fileLoader.sweepX) - 1
             self._profileSlider.setMaximum(_numLineScans)
 
     def hoverEvent(self, event):
@@ -829,27 +793,26 @@
 
         xPos = int(xPos)
         yPos = int(yPos)
 
         myTif = self.ba.fileLoader.tifData
         intensity = myTif[yPos, xPos]  # flipped
 
-        # logger.info(f'x:{xPos} y:{yPos} intensity:{intensity}')
+        #logger.info(f'x:{xPos} y:{yPos} intensity:{intensity}')
 
-        self.tifCursorLabel.setText(f"Cursor:{intensity}")
+        self.tifCursorLabel.setText(f'Cursor:{intensity}')
         self.tifCursorLabel.update()
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     app = QtWidgets.QApplication(sys.argv)
 
     if 1:
-        path = "/media/cudmore/data/rabbit-ca-transient/jan-12-2022/Control/220110n_0003.tif.frames/220110n_0003.tif"
-        path = "/Users/cudmore/data/rosie/test-data/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif"
-
+        path = '/media/cudmore/data/rabbit-ca-transient/jan-12-2022/Control/220110n_0003.tif.frames/220110n_0003.tif'
+        path = '/Users/cudmore/data/rosie/test-data/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif'
+        
         ba = sanpy.bAnalysis(path)
         print(ba)
 
         kw = kymographWidget(ba)
         kw.show()
 
     # test dialog
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bPlugins.py` & `sanpy-ephys-0.1.6/sanpy/interface/bPlugins.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,231 +1,218 @@
 # 20210610
 
 import os
 import sys
-
-# import pathlib
+#import pathlib
 import glob
 import importlib
 import inspect
 
 from typing import Union, Dict, List, Tuple, Optional
 
 import sanpy
-
-# import sanpy.interface
+#import sanpy.interface
 import sanpy.interface.plugins
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-class bPlugins:
+class bPlugins():
     """Generate a dict of plugins.
 
     Populate the dict by looking in
         - package, sanpy.interface.plugins
         - folder, <user>/sanpy_plugins
     """
-
-    def __init__(self, sanpyApp: Optional["sanpy.interface.SanPyWindow"] = None):
+    def __init__(self, sanpyApp : Optional["sanpy.interface.SanPyWindow"] = None):
+        
         self._sanpyApp = sanpyApp
 
-        self.userPluginFolder: str = sanpy._util._getUserPluginFolder()
+        self.userPluginFolder : str = sanpy._util._getUserPluginFolder()
         if not os.path.isdir(self.userPluginFolder):
             self.userPluginFolder = None
         """path to <user>/plugin_dir"""
 
         self.pluginDict = {}
         """dict of pointers to open plugins"""
 
         self._openSet = set()
         """set of open plugins"""
 
         self.loadPlugins()
 
     def getSanPyApp(self) -> Optional["sanpy.interface.SanPyWindow"]:
-        """Get the underlying SanPy app."""
+        """Get the underlying SanPy app.
+        """
         return self._sanpyApp
 
     def loadPlugins(self):
         """Load plugins from both:
          - Package: sanpy.interface.plugins
          - Folder: <user>/sanpy_plugins
-
+        
         See: sanpy.fileLoaders.fileLoader_base.getFileLoader()
         """
         self.pluginDict = {}
 
         # Enum is to ignore bPlugins.py class ResponseType(Enum)
-        ignoreModuleList = [
-            "sanpyPlugin",
-            "myWidget",
-            "ResponseType",
-            "SpikeSelectEvent",
-            "basePlotTool",
-            "NavigationToolbar2QT",
-            "myStatListWidget",
-        ]
+        ignoreModuleList = ['sanpyPlugin', 'myWidget',
+                            'ResponseType', 'SpikeSelectEvent',
+                            'basePlotTool',
+                            'NavigationToolbar2QT',
+                            'myStatListWidget']
 
         #
         # system plugins from sanpy.interface.plugins
-        # print('loadPlugins sanpy.interface.plugins:', sanpy.interface.plugins)
+        #print('loadPlugins sanpy.interface.plugins:', sanpy.interface.plugins)
         loadedList = []
         for moduleName, obj in inspect.getmembers(sanpy.interface.plugins):
-            # print('moduleName:', moduleName, 'obj:', obj)
+            #print('moduleName:', moduleName, 'obj:', obj)
             if inspect.isclass(obj):
-                # logger.info(f'moduleName: {moduleName}')
+                #logger.info(f'moduleName: {moduleName}')
                 if moduleName in ignoreModuleList:
                     # our base plugin class
                     continue
                 loadedList.append(moduleName)
-                fullModuleName = "sanpy.interface.plugins." + moduleName
+                fullModuleName = 'sanpy.interface.plugins.' + moduleName
                 humanName = obj.myHumanName  # myHumanName is a static str
                 showInMenu = obj.showInMenu  # showInMenu is a static bool
                 pluginDict = {
-                    "pluginClass": moduleName,
-                    "type": "system",
-                    "module": fullModuleName,
-                    "path": "",
-                    "constructor": obj,
-                    "humanName": humanName,
-                    "showInMenu": showInMenu,
+                    'pluginClass': moduleName,
+                    'type': 'system',
+                    'module': fullModuleName,
+                    'path': '',
+                    'constructor': obj,
+                    'humanName': humanName,
+                    'showInMenu': showInMenu,
                 }
                 if humanName in self.pluginDict.keys():
-                    logger.warning(
-                        f'Plugin already added "{moduleName}" humanName:"{humanName}"'
-                    )
+                    logger.warning(f'Plugin already added "{moduleName}" humanName:"{humanName}"')
                 else:
                     self.pluginDict[humanName] = pluginDict
 
         # print the loaded plugins
-        logger.info(f"Loaded plugins:")
+        logger.info(f'Loaded plugins:')
         for loaded in loadedList:
-            logger.info(f"    {loaded}")
+            logger.info(f'    {loaded}')
         # sort
         self.pluginDict = dict(sorted(self.pluginDict.items()))
 
         #
         # user plugins from files in folder <user>/SanPy/plugins
         loadedModuleList = []
         if self.userPluginFolder is not None:
-            files = glob.glob(os.path.join(self.userPluginFolder, "*.py"))
+            files = glob.glob(os.path.join(self.userPluginFolder, '*.py'))
         else:
             files = []
-
+        
         for file in files:
-            if file.endswith("__init__.py"):
+            if file.endswith('__init__.py'):
                 continue
 
             moduleName = os.path.split(file)[1]
             moduleName = os.path.splitext(moduleName)[0]
-            fullModuleName = "sanpy.interface.plugins." + moduleName
+            fullModuleName = 'sanpy.interface.plugins.' + moduleName
 
             loadedModule = self._module_from_file(fullModuleName, file)
 
             try:
                 oneConstructor = getattr(loadedModule, moduleName)
-            except AttributeError as e:
-                logger.error(
-                    f'Did not load user plugin, make sure file name and class name are the same:"{moduleName}"'
-                )
+            except (AttributeError) as e:
+                logger.error(f'Did not load user plugin, make sure file name and class name are the same:"{moduleName}"')
             else:
                 humanName = oneConstructor.myHumanName
                 showInMenu = oneConstructor.showInMenu
                 pluginDict = {
-                    "pluginClass": moduleName,
-                    "type": "user",
-                    "module": fullModuleName,
-                    "path": file,
-                    "constructor": oneConstructor,
-                    "humanName": humanName,
-                    "showInMenu": showInMenu,
-                }
+                    'pluginClass': moduleName,
+                    'type': 'user',
+                    'module': fullModuleName,
+                    'path': file,
+                    'constructor': oneConstructor,
+                    'humanName': humanName,
+                    'showInMenu': showInMenu,
+                    }
                 if humanName in self.pluginDict.keys():
-                    logger.warning(
-                        f'Plugin already added "{moduleName}" humanName:"{humanName}"'
-                    )
+                    logger.warning(f'Plugin already added "{moduleName}" humanName:"{humanName}"')
                 else:
                     self.pluginDict[humanName] = pluginDict
                     loadedModuleList.append(moduleName)
 
         # print the loaded plugins
-        logger.info(f"Loaded {len(loadedModuleList)} user plugin(s)")
+        logger.info(f'Loaded {len(loadedModuleList)} user plugin(s)')
         for loaded in loadedModuleList:
-            logger.info(f"    {loaded}")
+            logger.info(f'    {loaded}')
 
-    def runPlugin(self, pluginName: str, ba: sanpy.bAnalysis, show: bool = True):
+    def runPlugin(self,
+                  pluginName : str,
+                  ba : sanpy.bAnalysis,
+                  show : bool = True):
         """Run one plugin with given a bAnalysis.
 
         Args:
             pluginName (str):
             ba (bAnalysis): object
             show:
         """
         if not pluginName in self.pluginDict.keys():
             logger.error(f'Did not find plugin: "{pluginName}"')
             return
         else:
-            humanName = self.pluginDict[pluginName]["constructor"].myHumanName
+            humanName = self.pluginDict[pluginName]['constructor'].myHumanName
 
             ltwhTuple = None
-
+            
             # get the visible x-axis from main app
             startStop = None
             app = self.getSanPyApp()
             _pluginDict = None
             if app is not None:
                 startSec = app.startSec
                 stopSec = app.stopSec
                 if startSec is None and stopSec is None:
-                    startStop = None
+                    startStop= None
                 else:
                     startStop = [startSec, stopSec]
 
                 # has keys for (l, t, w, h)
-                _pluginDict = app.getOptions().preferencesGet("pluginPanels", humanName)
+                _pluginDict = app.getOptions().preferencesGet('pluginPanels', humanName)
                 # ltwhTuple = None
                 # if _pluginDict is not None:
                 #     ltwhTuple = tuple(
                 #         _pluginDict['l'],
                 #         _pluginDict['t'],
                 #         _pluginDict['w'],
                 #         _pluginDict['h'],
                 #     )
-            logger.info(f"Running plugin:")
-            logger.info(f"  pluginName:{pluginName}")
-            logger.info(f"  humanName:{humanName}")
-            logger.info(f"  startStop:{startStop}")
+            logger.info(f'Running plugin:')
+            logger.info(f'  pluginName:{pluginName}')
+            logger.info(f'  humanName:{humanName}')
+            logger.info(f'  startStop:{startStop}')
             if _pluginDict is not None:
-                logger.info(f"  _pluginDict:{_pluginDict}")
-            logger.info(f"  TODO: put try except back in !!!")
+                logger.info(f'  _pluginDict:{_pluginDict}')
+            logger.info(f'  TODO: put try except back in !!!')
             # TODO: to open PyQt windows, we need to keep a local (persistent) variable
-            # try:
+            #try:
             if 1:
-                # print(1)
-                newPlugin = self.pluginDict[pluginName]["constructor"](
-                    ba=ba, bPlugin=self, startStop=startStop
-                )
-                # print(2)
+                #print(1)
+                newPlugin = \
+                    self.pluginDict[pluginName]['constructor'](ba=ba, bPlugin=self, startStop=startStop)
+                #print(2)
                 if not newPlugin.getInitError() and show:
                     if _pluginDict is not None:
-                        newPlugin.setGeometry(
-                            _pluginDict["l"],
-                            _pluginDict["t"],
-                            _pluginDict["w"],
-                            _pluginDict["h"],
-                        )
+                        newPlugin.setGeometry(_pluginDict['l'],
+                                            _pluginDict['t'],
+                                            _pluginDict['w'],
+                                            _pluginDict['h'])
                     newPlugin.getWidget().show()
                     # newPlugin.getWidget().raise_()  # bring to front, raise is a python keyword
                     # newPlugin.getWidget().activateWindow()  # bring to front
 
                 # add the plugin to open next time we run
-
+                
             # except(TypeError) as e:
             #     logger.error(f'Error opening plugin "{pluginName}": {e}')
             #     return
             if not newPlugin.getInitError():
                 self._openSet.add(newPlugin)
 
             return newPlugin
@@ -234,43 +221,43 @@
         """
         returns one of ('system', 'user')
         """
         if not pluginName in self.pluginDict.keys():
             logger.error(f'Did not find plugin: "{pluginName}"')
             return None
         else:
-            theRet = self.pluginDict[pluginName]["type"]
+            theRet = self.pluginDict[pluginName]['type']
             return theRet
 
     def pluginList(self, forMenu=True):
         """Get list of names of loaded plugins
 
         Pay attention to showInMenu
         """
         retList = []
-        for k, v in self.pluginDict.items():
+        for k,v in self.pluginDict.items():
             # k is the name of the plugin
             # v is a dict with its current state
             # print(' QANON ', k)
             # print('     v:', v)
-            if not v["showInMenu"]:
+            if not v['showInMenu']:
                 continue
             retList.append(k)
         return retList
 
     def getHumanNames(self):
         retList = []
-        for k, v in self.pluginDict.items():
-            myHumanName = v["myHumanName"]
+        for k,v in self.pluginDict.items():
+            myHumanName = v['myHumanName']
             retList.append(myHumanName)
         return retList
 
-    def _module_from_file(self, module_name: str, file_path: str):
+    def _module_from_file(self, module_name : str, file_path : str):
         """
-
+        
         Args:
             module_name: Is like sanpy.interface.plugins.onePluginFile
             file_path: Full path to onePluginFile source code (onePluginFile.py)
         """
         spec = importlib.util.spec_from_file_location(module_name, file_path)
         module = importlib.util.module_from_spec(spec)
         spec.loader.exec_module(module)
@@ -282,80 +269,78 @@
         Args:
             pluginObj (object): The running plugin object reference.
 
         Important:
             Need to disconnect signal/slot using _disconnectSignalSlot().
             Mostly connections to main SanPy app signals
         """
-        # logger.info(pluginObj)
+        #logger.info(pluginObj)
         try:
             logger.info(f'Removing plugin from _openSet: "{pluginObj.getHumanName()}"')
             # Critical to detatch signal/slot, removing from set does not seem to do this?
             pluginObj._disconnectSignalSlot()
             self._openSet.remove(pluginObj)
 
             # remove from preferences
             if pluginObj is not None and self.getSanPyApp() is not None:
                 self.getSanPyApp().configDict.removePlugin(pluginObj.getHumanName())
 
-        except KeyError as e:
+        except (KeyError) as e:
             logger.exception(e)
 
-    def _old_slot_selectSpike(self, sDict):
+    def slot_selectSpike(self, sDict):
         """
         On user selection of spike in a plugin
 
         Tell main app to select a spike everywhere
         """
         logger.info(sDict)
         app = self.getSanPyApp()
         if app is not None:
-            spikeNumber = sDict["spikeNumber"]
-            doZoom = sDict["doZoom"]
+            spikeNumber = sDict['spikeNumber']
+            doZoom = sDict['doZoom']
             app.selectSpike(spikeNumber, doZoom=doZoom)
 
-    def _old_slot_selectSpikeList(self, sDict: dict):
+    def slot_selectSpikeList(self, sDict : dict):
         """On user selection of spike(s) in a plugin
 
         Tell main app to select a spike everywhere
 
         Args:
             sDict (dict) with keys
                 spikeList : List[int]
                 doZoom : bool
                 ba : sanpy.bAnalysis_.bAnalysis
         """
         logger.info(sDict)
         app = self.getSanPyApp()
         if app is not None:
-            spikeList = sDict["spikeList"]
-            doZoom = sDict["doZoom"]
+            spikeList = sDict['spikeList']
+            doZoom = sDict['doZoom']
             app.selectSpikeList(spikeList, doZoom=doZoom)
 
-
 def test_print_classes():
     """testing"""
-    print("__name__:", __name__)
+    print('__name__:', __name__)
     for name, obj in inspect.getmembers(sys.modules[__name__]):
         if inspect.isclass(obj):
-            print(name, ":", obj)
+            print(name, ':', obj)
 
-    print("===")
+    print('===')
     for name, obj in inspect.getmembers(sanpy.interface.plugins):
         if inspect.isclass(obj):
-            print(name, ":", obj)
-
+            print(name, ':', obj)
 
-if __name__ == "__main__":
-    # print_classes()
-    # sys.exit(1)
+if __name__ == '__main__':
+    #print_classes()
+    #sys.exit(1)
 
     bp = bPlugins()
 
     pluginList = bp.pluginList()
-    print("pluginList:", pluginList)
+    print('pluginList:', pluginList)
 
-    abfPath = "/Users/cudmore/Sites/SanPy/data/19114001.abf"
+    abfPath = '/Users/cudmore/Sites/SanPy/data/19114001.abf'
     ba = sanpy.bAnalysis(abfPath)
 
-    bp.runPlugin("plotRecording", ba)
-    # bp.runPlugin('plotRecording3', ba)
+    bp.runPlugin('plotRecording', ba)
+    #bp.runPlugin('plotRecording3', ba)
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bScatterPlotWidget2.py` & `sanpy-ephys-0.1.6/sanpy/scatterwidget/bScatterPlotWidget2.py`

 * *Files 7% similar despite different names*

```diff
@@ -19,342 +19,307 @@
     matplotlib
     seaborn
     mplcursors
     openpyxl # to load xlsx
 """
 
 import os, sys, io, csv
-from functools import partial
 from collections import OrderedDict
 import traceback
 import pandas as pd
 import numpy as np
-
 from PyQt5 import QtCore, QtGui, QtWidgets
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
 from matplotlib.figure import Figure
 import matplotlib.gridspec as gridspec
-import matplotlib.pyplot as plt  # abb 202012 added to set theme
+import matplotlib.pyplot as plt # abb 202012 added to set theme
 import seaborn as sns
-import mplcursors  # popup on hover
-
-# originally, I wanted this to not rely on sanpy
-import sanpy
-
-from sanpy.sanpyLogger import get_logger
-
-logger = get_logger(__name__)
+import mplcursors # popup on hover
 
+#sysPath = os.path.dirname(sys.path[0])
+#sysPath = os.path.join(sysPath, 'sanpy')
+#print('bScatterPlotWidget2.py sysPath:', sysPath)
+#sys.path.append(sysPath)
+
+#print('os.getcwd():', os.getcwd())
+#import sanpy
+#import bUtil # from sanpy folder, for pandas model
 
 def old_loadDatabase(path):
     """
     path: full path to .csv file generated with reanalyze.py
     """
-    # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+    #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
     masterDf = None
     if not os.path.isfile(path):
-        logger.error("did not find file:", path)
-    elif path.endswith(".csv"):
-        masterDf = pd.read_csv(path, header=0)  # , dtype={'ABF File': str})
-    elif path.endswith(".xls"):
-        masterDf = pd.read_excel(path, header=0)  # , dtype={'ABF File': str})
-    elif path.endswith(".xlsx"):
-        masterDf = pd.read_excel(
-            path, header=0, engine="openpyxl"
-        )  # , dtype={'ABF File': str})
+        print('eror: bUtil.loadDatabase() did not find file:', path)
+    elif path.endswith('.csv'):
+        masterDf = pd.read_csv(path, header=0) #, dtype={'ABF File': str})
+    elif path.endswith('.xls'):
+        masterDf = pd.read_excel(path, header=0) #, dtype={'ABF File': str})
+    elif path.endswith('.xlsx'):
+        masterDf = pd.read_excel(path, header=0, engine='openpyxl') #, dtype={'ABF File': str})
     else:
-        print("error: file type not supported. Expecting csv/xls/xlsx. Path:", path)
+        print('error: file type not supported. Expecting csv/xls/xlsx. Path:', path)
 
-    # self.masterDfColumns = self.masterDf.columns.to_list()
+    #self.masterDfColumns = self.masterDf.columns.to_list()
 
     # not sure what this was for ???
     # 20210112, put back in if necc
-    # self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
-    # self.masterCatColumns = self.categoricalList
+    #self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
+    #self.masterCatColumns = self.categoricalList
 
-    # print(self.masterDf.head())
-    """
+    #print(self.masterDf.head())
+    '''
     print(masterDf.info())
     print('masterDf.iloc[0,3]:', masterDf.iloc[0,3], type(masterDf.iloc[0,3]))
     print('start seconds:', masterDf['Start Seconds'].dtype.type)
     print('start seconds:', masterDf['Start Seconds'].dtype)
-    """
+    '''
     #
     return masterDf
 
-
 def printDict(d, withType=False):
-    for k, v in d.items():
+    for k,v in d.items():
         if withType:
-            print(f"  {k}: {v} {type(v)}")
+            print(f'  {k}: {v} {type(v)}')
         else:
-            print(f"  {k}: {v}")
-
+            print(f'  {k}: {v}')
 
 class myPandasModel(QtCore.QAbstractTableModel):
+
     def __init__(self, data):
         """
         data: pandas dataframe
         """
         QtCore.QAbstractTableModel.__init__(self)
         self.verbose = False
         self._data = data
         columnList = self._data.columns.values.tolist()
-        if "include" in columnList:
-            self.includeCol = columnList.index("include")
+        if 'include' in columnList:
+            self.includeCol = columnList.index('include')
         else:
             self.includeCol = None
-        # print('pandasModel.__init__() self.includeCol:', self.includeCol)
-        self.columns_boolean = ["include"]
+        #print('pandasModel.__init__() self.includeCol:', self.includeCol)
+        self.columns_boolean = ['include']
 
     def rowCount(self, parent=None):
-        # if self.verbose: print('myPandasModel.rowCount()')
+        #if self.verbose: print('myPandasModel.rowCount()')
         return self._data.shape[0]
 
     def columnCount(self, parnet=None):
-        # if self.verbose: print('myPandasModel.columnCount()')
+        #if self.verbose: print('myPandasModel.columnCount()')
         return self._data.shape[1]
 
     def data(self, index, role=QtCore.Qt.DisplayRole):
-        if self.verbose:
-            print("myPandasModel.data()")
+        if self.verbose: print('myPandasModel.data()')
         if index.isValid():
             if role == QtCore.Qt.DisplayRole:
-                # return QtCore.QVariant()
 
-                # return str(self._data.iloc[index.row(), index.column()])
+                #return QtCore.QVariant()
+
+                #return str(self._data.iloc[index.row(), index.column()])
                 retVal = self._data.iloc[index.row(), index.column()]
                 if isinstance(retVal, np.float64):
                     retVal = float(retVal)
-                    retVal = round(retVal, 4)  # round everything to 4 decimal places
+                    retVal = round(retVal,4) # round everything to 4 decimal places
                     if np.isnan(retVal):
-                        retVal = ""
+                        retVal = ''
                 elif isinstance(retVal, np.int64):
                     retVal = int(retVal)
                 #
                 return retVal
             elif role == QtCore.Qt.BackgroundRole:
-                # return
+                #return
                 return QtCore.QVariant()
 
         return None
 
     def update(self, dataIn):
-        if self.verbose:
-            print("myPandasModel.update()")
+        if self.verbose: print('myPandasModel.update()')
 
     def setData(self, index, value, role=QtCore.Qt.DisplayRole):
         """
         This is curently limited to only handle checkbox
         todo: extend to allow editing
 
         Returns:
             True if value is changed. Calls layoutChanged after update.
             False if value is not different from original value.
         """
-        if self.verbose:
-            print("myPandasModel.setData()")
-        print(
-            "  myPandasModel.setData() row:",
-            index.row(),
-            "column:",
-            index.column(),
-            "value:",
-            value,
-            type(value),
-        )
-        # if index.column() == self.includeCol:
+        if self.verbose: print('myPandasModel.setData()')
+        print('  myPandasModel.setData() row:', index.row(), 'column:', index.column(), 'value:', value, type(value))
+        #if index.column() == self.includeCol:
 
         # dataChanged is inherited from QAbstractItemModel
-        # topLeftIndex = index
-        # bottomRightIndex = index
-        # self.dataChanged.emit(index, index)
+        #topLeftIndex = index
+        #bottomRightIndex = index
+        #self.dataChanged.emit(index, index)
 
         if 1:
-            # print('value:', value, type(value))
+
+            #print('value:', value, type(value))
             v = self._data.iloc[index.row(), index.column()]
-            # print('before v:',v, type(v))
-            # print('isinstance:', isinstance(v, np.float64))
+            #print('before v:',v, type(v))
+            #print('isinstance:', isinstance(v, np.float64))
             if isinstance(v, np.float64):
                 try:
                     value = float(value)
-                except ValueError as e:
-                    print("please enter a number")
+                except (ValueError) as e:
+                    print('please enter a number')
                     return False
 
             # set
             self._data.iloc[index.row(), index.column()] = value
 
             v = self._data.iloc[index.row(), index.column()]
-            print("    after v:", v, type(v))
+            print('    after v:',v, type(v))
             return True
         return True
 
     def flags(self, index):
         if self.verbose:
-            print("myPandasModel.flags()")
-            print("  index.column():", index.column())
+            print('myPandasModel.flags()')
+            print('  index.column():', index.column())
         if 1:
             # turn on editing (limited to checkbox for now)
             if index.column() in self.columns_boolean:
-                # print('  return with columns_boolean')
+                #print('  return with columns_boolean')
                 return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsUserCheckable
-            # print('  return with ...')
-            return (
-                QtCore.Qt.ItemIsEditable
-                | QtCore.Qt.ItemIsEnabled
-                | QtCore.Qt.ItemIsSelectable
-            )
+            #print('  return with ...')
+            return QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable
         else:
             return QtCore.Qt.ItemIsEnabled
 
     def headerData(self, col, orientation, role):
-        # if self.verbose: print('myPandasModel.headerData()')
+        #if self.verbose: print('myPandasModel.headerData()')
         if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
             return self._data.columns[col]
         return None
 
-
 # see: https://stackoverflow.com/questions/17748546/pyqt-column-of-checkboxes-in-a-qtableview
 class myCheckBoxDelegate(QtWidgets.QItemDelegate):
     """
     A delegate that places a fully functioning QCheckBox cell of the column to which it's applied.
     """
-
     def __init__(self, parent):
         QtWidgets.QItemDelegate.__init__(self, parent)
         self.verbose = False
-        if self.verbose:
-            print("myCheckBoxDelegate.__init__()")
+        if self.verbose: print('myCheckBoxDelegate.__init__()')
 
     def createEditor(self, parent, option, index):
         """
         Important, otherwise an editor is created if the user clicks in this cell.
         """
-        if self.verbose:
-            print("myCheckBoxDelegate.createEditor()")
+        if self.verbose: print('myCheckBoxDelegate.createEditor()')
         return None
 
     def paint(self, painter, option, index):
         """
         Paint a checkbox without the label.
 
         option: PyQt5.QtWidgets.QStyleOptionViewItem
         index: PyQt5.QtCore.QModelIndex
         """
-        if self.verbose:
-            print("myCheckBoxDelegate.paint()")
-        # print('  option:', option, 'index:', index)
-        # print('  index.data():', type(index.data()), index.data())
-        # HasCheckIndicator = QtWidget.QStyleOptionViewItem.HasCheckIndicator
+        if self.verbose: print('myCheckBoxDelegate.paint()')
+        #print('  option:', option, 'index:', index)
+        #print('  index.data():', type(index.data()), index.data())
+        #HasCheckIndicator = QtWidget.QStyleOptionViewItem.HasCheckIndicator
         # options.HasCheckIndicator returns hex 4, value of enum
         # how do i query it?
-        # print('  ', option.ViewItemFeatures().HasCheckIndicator) # returns PyQt5.QtWidgets.QStyleOptionViewItem.ViewItemFeature
-        # print('  ', option.features)
-        # print('  ', index.data(QtCore.Qt.CheckStateRole)  )
-        # state = index.data(QtCore.Qt.CheckStateRole)
-        # print('  state:', state, 'option.HasCheckIndicator:', option.HasCheckIndicator)
-        self.drawCheck(
-            painter,
-            option,
-            option.rect,
-            QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked,
-        )
+        #print('  ', option.ViewItemFeatures().HasCheckIndicator) # returns PyQt5.QtWidgets.QStyleOptionViewItem.ViewItemFeature
+        #print('  ', option.features)
+        #print('  ', index.data(QtCore.Qt.CheckStateRole)  )
+        #state = index.data(QtCore.Qt.CheckStateRole)
+        #print('  state:', state, 'option.HasCheckIndicator:', option.HasCheckIndicator)
+        self.drawCheck(painter, option, option.rect, QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked)
 
     def editorEvent(self, event, model, option, index):
-        """
+        '''
         Change the data in the model and the state of the checkbox
         if the user presses the left mousebutton and this cell is editable. Otherwise do nothing.
-        """
-        if self.verbose:
-            print("myCheckBoxDelegate.editorEvent()")
+        '''
+        if self.verbose: print('myCheckBoxDelegate.editorEvent()')
         if not int(index.flags() & QtCore.Qt.ItemIsEditable) > 0:
             return False
 
-        if (
-            event.type() == QtCore.QEvent.MouseButtonRelease
-            and event.button() == QtCore.Qt.LeftButton
-        ):
+        if event.type() == QtCore.QEvent.MouseButtonRelease and event.button() == QtCore.Qt.LeftButton:
             # Change the checkbox-state
             self.setModelData(None, model, index)
             return True
 
         return False
 
+
     def setModelData(self, editor, model, index):
-        """
+        '''
         The user wanted to change the old state in the opposite.
-        """
+        '''
         if self.verbose:
-            print("myCheckBoxDelegate.setModelData()")
-            print("  editor:", editor)
-            print("  model:", model)
-            print("  index:", index)
-            print("  index.data():", type(index.data()), index.data())
-        # data = index.data()
-        # if isinstance(data, str):
+            print('myCheckBoxDelegate.setModelData()')
+            print('  editor:', editor)
+            print('  model:', model)
+            print('  index:', index)
+            print('  index.data():', type(index.data()), index.data())
+        #data = index.data()
+        #if isinstance(data, str):
         #    return
         newValue = 1 if int(index.data()) == 0 else 0
         model.setData(index, newValue, QtCore.Qt.EditRole)
 
-
-# class MainWindow(QtWidgets.QWidget):
-myInterfaceDefaults = OrderedDict(
-    {
-        "X Statistic": None,
-        "Y Statistic": None,
-        "Hue": None,
-        "Group By": None,
-    }
-)
-
+#class MainWindow(QtWidgets.QWidget):
+myInterfaceDefaults = OrderedDict({
+    'X Statistic': None,
+    'Y Statistic': None,
+    'Hue': None,
+    'Group By': None,
+})
 
 class myTableView(QtWidgets.QTableView):
     def __init__(self, dataType, parent=None):
         """
         dataType: in ['All Spikes', 'File Mean']
         """
         super(myTableView, self).__init__(parent)
 
         self.dataType = dataType
 
-        self.doIncludeCheckbox = False  # todo: turn this on
+        self.doIncludeCheckbox = False # todo: turn this on
         self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
 
-        # self.setFont(QtGui.QFont('Arial', 10))
-        self.setSizePolicy(
-            QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        )
+        #self.setFont(QtGui.QFont('Arial', 10))
+        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                  QtWidgets.QSizePolicy.Expanding)
         self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
 
-        p = self.palette()
-        color1 = QtGui.QColor("#dddddd")
-        color2 = QtGui.QColor("#ffffff")
-        p.setColor(QtGui.QPalette.Base, color1)
-        p.setColor(QtGui.QPalette.AlternateBase, color2)
+        p = self.palette();
+        color1 = QtGui.QColor('#dddddd')
+        color2 = QtGui.QColor('#ffffff')
+        p.setColor(QtGui.QPalette.Base, color1);
+        p.setColor(QtGui.QPalette.AlternateBase, color2);
         self.setAlternatingRowColors(True)
-        self.setPalette(p)
+        self.setPalette(p);
 
     def slotSelectRow(self, selectDict):
         """
         only selecct if selectDict['dataType'] matches what we are showing
         """
-        if self.dataType != selectDict["dataType"]:
+        if self.dataType != selectDict['dataType']:
             return
 
-        print("slotSelectRow() selectDict:", selectDict)
-        ind = selectDict["index"]
-        """
+        print('slotSelectRow() selectDict:', selectDict)
+        ind = selectDict['index']
+        '''
         plotDf = selectDict['plotDf']
         index = plotDf.at[ind, 'index']
         index = int(index)
-        """
+        '''
         index = ind
-        index -= 1  # !!! MY VISUAL INDEX IN TABLE IS ONE BASED !!!
+        index -= 1 # !!! MY VISUAL INDEX IN TABLE IS ONE BASED !!!
         column = 0
         modelIndex = self.model().index(index, column)
         self.setCurrentIndex(modelIndex)
 
     def slotSwitchTableDf(self, newDf):
         """
         set model from df
@@ -365,774 +330,548 @@
             model = myPandasModel(newDf)
         self.slotSwitchTableModel(model)
 
     def slotSwitchTableModel(self, newModel):
         """
         switch between full .csv model and getMeanDf model
         """
-        # print('myTableView.slotSwitchTableModel()')
+        #print('myTableView.slotSwitchTableModel()')
         self.setModel(newModel)
 
         if newModel is None:
             return
 
         colList = newModel._data.columns.values.tolist()
-        # print('  todo: slotSwitchTableModel() set all columns to default delegate itemDelegate()')
+        #print('  todo: slotSwitchTableModel() set all columns to default delegate itemDelegate()')
         for idx, col in enumerate(colList):
             # default delegate is self.tableView.itemDelegate()
             self.setItemDelegateForColumn(idx, self.itemDelegate())
 
         # install checkboxes in 'incude' column
-        if self.doIncludeCheckbox and "include" in colList:
-            includeColIndex = colList.index("include")
-            print(
-                f"_switchTableModel() setting include column {includeColIndex} to myCheckBoxDelegate"
-            )
-            # self.tableView.setItemDelegateForColumn(includeColIndex, myCheckBoxDelegate(None))
+        if self.doIncludeCheckbox and 'include' in colList:
+            includeColIndex = colList.index('include')
+            print(f'_switchTableModel() setting include column {includeColIndex} to myCheckBoxDelegate')
+            #self.tableView.setItemDelegateForColumn(includeColIndex, myCheckBoxDelegate(None))
             self.setItemDelegateForColumn(includeColIndex, self.keepCheckBoxDelegate)
 
-
-class myStatListWidget(QtWidgets.QWidget):
-    """
-    Widget to display a table with selectable stats.
-
-    Gets list of stats from: sanpy.bAnalysisUtil.getStatList()
-    """
-
-    def __init__(self, myParent, statList=None, headerStr="Stat", parent=None):
-        """
-        Parameters
-        ----------
-        myParent : sanpy.interface.plugins.sanpyPlugin
-        statList : dict
-            from sanpy.bAnalysisUtil.getStatList()
-        headerStr : str
-            Show as label aove stat list
-        """
-        super().__init__(parent)
-
-        self.myParent = myParent
-        if statList is not None:
-            self.statList = statList
-        else:
-            # from main sanpy
-            # for pooling we have some addition columns like 'file number'
-            self.statList = sanpy.bAnalysisUtil.getStatList()
-
-        self._rowHeight = 9
-
-        self.myQVBoxLayout = QtWidgets.QVBoxLayout(self)
-
-        self.myTableWidget = QtWidgets.QTableWidget()
-        self.myTableWidget.setWordWrap(False)
-        self.myTableWidget.setRowCount(len(self.statList))
-        self.myTableWidget.setColumnCount(1)
-        self.myTableWidget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
-        self.myTableWidget.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
-        self.myTableWidget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
-        self.myTableWidget.cellClicked.connect(self.on_scatter_toolbar_table_click)
-
-        # set font size of table (default seems to be 13 point)
-        fnt = self.font()
-        fnt.setPointSize(self._rowHeight)
-        self.myTableWidget.setFont(fnt)
-
-        headerLabels = [headerStr]
-        self.myTableWidget.setHorizontalHeaderLabels(headerLabels)
-
-        header = self.myTableWidget.horizontalHeader()
-        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
-        # QHeaderView will automatically resize the section to fill the available space. The size cannot be changed by the user or programmatically.
-        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
-
-        for idx, stat in enumerate(self.statList):
-            item = QtWidgets.QTableWidgetItem(stat)
-            self.myTableWidget.setItem(idx, 0, item)
-            self.myTableWidget.setRowHeight(idx, self._rowHeight)
-
-        # assuming dark theme
-        # does not work
-        """
-        p = self.myTableWidget.palette()
-        color1 = QtGui.QColor('#222222')
-        color2 = QtGui.QColor('#555555')
-        p.setColor(QtGui.QPalette.Base, color1)
-        p.setColor(QtGui.QPalette.AlternateBase, color2)
-        self.myTableWidget.setPalette(p)
-        self.myTableWidget.setAlternatingRowColors(True)
-        """
-        self.myQVBoxLayout.addWidget(self.myTableWidget)
-
-        # select a default stat
-        self.myTableWidget.selectRow(0)  # hard coding 'Spike Frequency (Hz)'
-
-    def getCurrentRow(self):
-        return self.myTableWidget.currentRow()
-
-    def getCurrentStat(self):
-        # assuming single selection
-        row = self.getCurrentRow()
-        humanStat = self.myTableWidget.item(row, 0).text()
-
-        # convert from human readbale to backend
-        try:
-            stat = self.statList[humanStat]["name"]
-        except KeyError as e:
-            logger.error(f'Did not find humanStat:"{humanStat}"')
-            humanStat = None
-            stat = None
-
-        return humanStat, stat
-
-    @QtCore.pyqtSlot()
-    def on_scatter_toolbar_table_click(self):
-        """
-        replot the stat based on selected row
-        """
-        # print('*** on table click ***')
-        row = self.myTableWidget.currentRow()
-        if row == -1 or row is None:
-            return
-        yStat = self.myTableWidget.item(row, 0).text()
-        self.myParent.replot()
-
-    """
-    @QtCore.pyqtSlot()
-    def on_button_click(self, name):
-        print('=== myStatPlotToolbarWidget.on_button_click() name:', name)
-    """
-
-
-# class myMplCanvas(FigureCanvas):
+#class myMplCanvas(FigureCanvas):
 class myMplCanvas(QtWidgets.QFrame):
     """
     hold an fig/plot canvas, in scatter plot we can have 1-4 of these
     """
-
     signalSelectFromPlot = QtCore.Signal(object)
     signalSelectSquare = QtCore.Signal(object, object)
 
     def __init__(self, plotNumber=None, parent=None):
-        super().__init__(parent)  # FigureCanvas
 
-        # self.plotType = None
+        super(myMplCanvas, self).__init__(parent) # FigureCanvas
+
+        #self.plotType = None
 
-        # self.setFrameWidth(5)
-        # self.setStyleSheet("background-color: rgb(0, 255, 0)")
-        # self.setContentsMargins(0, 0, 0, 0)
-        # self.setContentsMargins(-20, 0, 5, 0)
+        #self.setFrameWidth(5)
+        #self.setStyleSheet("background-color: rgb(0, 255, 0)")
+        #self.setContentsMargins(0, 0, 0, 0)
+        #self.setContentsMargins(-20, 0, 5, 0)
         self.setFrameShape(QtWidgets.QFrame.Box)
         self.setLineWidth(0)
 
         pal = self.palette()
-        pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor("red"))
+        pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor('red'))
         self.setPalette(pal)
 
         #
         self.plotNumber = plotNumber
         self.stateDict = None
         self.plotDf = None
         self.whatWeArePlotting = None
         self.mplCursorHover = None
 
         # needed to show canvas in widget
-        self.layout = QtWidgets.QVBoxLayout()  # any will do
+        self.layout = QtWidgets.QVBoxLayout() # any will do
 
         self.fig = Figure(constrained_layout=True)
 
         self.canvas = FigureCanvas(self.fig)
 
-        self.canvas.axes = self.fig.add_subplot(111)  # was this
-        # self.canvas.axes = self.fig.add_axes([0.1, 0.1, 0.9, 0.9]) # [x, y, w, h]
-        # gs1 = gridspec.GridSpec(1, 1)
-        # gs1.tight_layout(self.fig, rect=[0.5, 0, 1, 1], h_pad=0.5)
-        # self.canvas.axes = self.fig.add_subplot(gs1[0])
-
-        # user clicks on plot point
-        self.cid2 = self.canvas.mpl_connect("pick_event", self.on_pick_event)
-        # user clicks in the figure
-        self.cid3 = self.canvas.mpl_connect("button_press_event", self.on_pick_event2)
+        self.canvas.axes = self.fig.add_subplot(111) # was this
+        #self.canvas.axes = self.fig.add_axes([0.1, 0.1, 0.9, 0.9]) # [x, y, w, h]
+        #gs1 = gridspec.GridSpec(1, 1)
+        #gs1.tight_layout(self.fig, rect=[0.5, 0, 1, 1], h_pad=0.5)
+        #self.canvas.axes = self.fig.add_subplot(gs1[0])
 
-        self.scatterPlotSelection = None
+        self.cid2 = self.canvas.mpl_connect('pick_event', self.on_pick_event)
 
-        self.mplToolbar = NavigationToolbar2QT(
-            self.canvas, self.canvas
-        )  # params are (canvas, parent)
-        self.mplToolbar.hide()  # initially hidden
+        self.scatterPlotSelection = None
 
-        # 20210829
-        """
-        print('1 creating empty legend')
-        self.myLegend = self.canvas.axes.legend()
-        self.myLegend.set_visible(False)  #hide()
-        """
+        self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
+        self.mplToolbar.hide() # initially hidden
 
-        self.canvas.setSizePolicy(
-            QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        )
+        self.canvas.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                  QtWidgets.QSizePolicy.Expanding)
         self.canvas.updateGeometry()
 
-        # fig.subplots_adjust(wspace=0.3, hspace=0.3)
-        # self.fig.tight_layout(pad = 3.0) # Padding between the figure edge and the edges of subplots, as a fraction of the font size.
-        # self.fig.subplots_adjust(left=0.15,right=0.9,
+        #fig.subplots_adjust(wspace=0.3, hspace=0.3)
+        #self.fig.tight_layout(pad = 3.0) # Padding between the figure edge and the edges of subplots, as a fraction of the font size.
+        #self.fig.subplots_adjust(left=0.15,right=0.9,
         #                            bottom=0.1,top=0.9,
         #                            hspace=0.2,wspace=0.2)
 
         #
         self.layout.addWidget(self.canvas)
         self.setLayout(self.layout)
 
     def buildUI(self):
         pass
 
     def mousePressEvent(self, event):
-        logger.info("===")
-        print(
-            "  todo: set all controls to match the plot just clicked on using self.stateDict!!!"
-        )
-        # print('  stateDict:', self.stateDict)
+        print('myMplCanvas.mousePressEvent()')
+        print('  todo: set all controls to match the plot just clicked on using self.stateDict!!!')
+        #print('  stateDict:', self.stateDict)
         self.signalSelectSquare.emit(self.plotNumber, self.stateDict)
 
     def contextMenuEvent(self, event):
-        print("myMplCanvas.contextMenuEvent()")
+        print('myMplCanvas.contextMenuEvent()')
         contextMenu = QtWidgets.QMenu(self)
         saveAsAction = contextMenu.addAction("Save As...")
         action = contextMenu.exec_(self.mapToGlobal(event.pos()))
         if action == saveAsAction:
-            print("todo: save as")
-            self.fig.savefig("", dpi=600)
+            print('todo: save as')
+            self.fig.savefig('', dpi=600)
 
     def on_pick_event(self, event):
         try:
-            logger.info(f'=== event: "{event.ind}"')
+            print('myMplCanvas.on_pick_event() event:', event)
+            print('  event.ind:', event.ind)
 
             if len(event.ind) < 1:
                 return
             spikeNumber = event.ind[0]
-            # print('  selected:', spikeNumber)
+            print('  selected:', spikeNumber)
 
             # propagate a signal to parent
-            # self.myMainWindow.mySignal('select spike', data=spikeNumber)
-            # self.selectSpike(spikeNumber)
-        except AttributeError as e:
+            #self.myMainWindow.mySignal('select spike', data=spikeNumber)
+            #self.selectSpike(spikeNumber)
+        except (AttributeError) as e:
             pass
 
-    def on_pick_event2(self, event):
-        logger.info("===")
-
-        # print(self.stateDict)
-        for k, v in self.stateDict.items():
-            if k == "masterDf":
-                print(f"  {k}: length is {len(v)}")
-            else:
-                print(f"  {k}: {v}")
-        #
-        self.signalSelectSquare.emit(self.plotNumber, self.stateDict)
-
     def onPick(self, event):
         """
         when user clicks on a point in the graph
 
         todo: this makes perfect sense for scatter but maybe not other plots???
         """
-        print("=== myMplCanvas.onPick()")  #' event:', type(event), event)
+        print('=== myMplCanvas.onPick()') #' event:', type(event), event)
         line = event.artist
 
         # filter out clicks on 'Annotation' used by mplcursors
         try:
             # when Scatter, line is 'PathCollection', a list of (x,y)
             offsets = line.get_offsets()
-        except AttributeError as e:
+        except (AttributeError) as e:
             return
 
-        ind = event.ind  # ind is a list []
-        if len(ind) == 0:
+        ind = event.ind # ind is a list []
+        if len(ind)==0:
             return
         ind = ind[0]
 
         # ind is the ith element in (x,y) list of offsets
         # ind 10 (0 based) is index 11 (1 based) in table list
-        print(f"  selected from plot ind:{ind}, offsets values are {offsets[ind]}")
+        print(f'  selected from plot ind:{ind}, offsets values are {offsets[ind]}')
         selectDict = self.getAnnotation(ind)
 
         # to do, just put copy of state dict ???
-        selectDict["plotType"] = self.stateDict["plotType"]
-        selectDict["dataType"] = self.stateDict["dataType"]
+        selectDict['plotType'] = self.stateDict['plotType']
+        selectDict['dataType'] = self.stateDict['dataType']
         #
         # emit
-        logger.info(f"  myMplCanvas.signalSelectFromPlot.emit() {selectDict}")
+        print('  myMplCanvas.signalSelectFromPlot.emit()', selectDict)
         self.signalSelectFromPlot.emit(selectDict)
 
     def _selectInd(self, ind):
         """
         visually select a point in scatter plot
         """
-        print("myMplCanvas._selectInd() ind:", ind)
-        if ind > len(self.plotDf) - 1:
+        print('myMplCanvas._selectInd() ind:', ind)
+        if ind > len(self.plotDf)-1:
             return
-        xVal = self.plotDf.at[ind, self.stateDict["xStat"]]
-        yVal = self.plotDf.at[ind, self.stateDict["yStat"]]
+        xVal = self.plotDf.at[ind, self.stateDict['xStat']]
+        yVal = self.plotDf.at[ind, self.stateDict['yStat']]
         if self.scatterPlotSelection is not None:
-            print("  scatterPlotSelection x:", xVal, "y:", yVal)
+            print('  scatterPlotSelection x:', xVal, 'y:', yVal)
             self.scatterPlotSelection.set_data(xVal, yVal)
         self.fig.canvas.draw()
 
     def getAnnotation(self, ind):
         if not np.issubdtype(ind, np.integer):
-            print("myMplCanvas.getAnnotation() got bad ind:", ind, type(ind))
+            print('myMplCanvas.getAnnotation() got bad ind:', ind, type(ind))
             return
 
-        xStat = self.stateDict["xStat"]
-        yStat = self.stateDict["yStat"]
-        groupByColumnName = self.stateDict["groupByColumnName"]
+        xStat = self.stateDict['xStat']
+        yStat = self.stateDict['yStat']
+        groupByColumnName = self.stateDict['groupByColumnName']
 
         analysisName = self.plotDf.at[ind, groupByColumnName]
-        index = self.plotDf.at[ind, "index"]
+        index = self.plotDf.at[ind, 'index']
         try:
-            region = self.plotDf.at[ind, "Region"]  # not all will have this
-        except KeyError as e:
-            region = "n/a"
+            region = self.plotDf.at[ind, 'Region'] # not all will have this
+        except (KeyError) as e:
+            region = 'n/a'
         xVal = self.plotDf.at[ind, xStat]
         yVal = self.plotDf.at[ind, yStat]
 
         returnDict = {
-            "ind": ind,
-            "index": index,
-            "analysisName": analysisName,
-            "region": region,
-            "xVal": xVal,
-            "yVal": yVal,
-            #'plotDf': self.plotDf, # potentially very big
-        }
+                    'ind': ind,
+                    'index': index,
+                    'analysisName': analysisName,
+                    'region': region,
+                    'xVal': xVal,
+                    'yVal': yVal,
+                    #'plotDf': self.plotDf, # potentially very big
+            }
         return returnDict
 
     def slotSelectSquare(self, plotNumber, stateDict):
-        # print('myMplCanvas.slotSelectSquare()', plotNumber, 'self.plotNumber:', self.plotNumber)
+        #print('myMplCanvas.slotSelectSquare()', plotNumber, 'self.plotNumber:', self.plotNumber)
         if plotNumber == self.plotNumber:
             self.setLineWidth(1)
         else:
             self.setLineWidth(0)
 
     def slotSelectInd(self, selectDict):
-        if self.stateDict["plotType"] == selectDict["plotType"]:
+        if self.stateDict['plotType'] == selectDict['plotType']:
             # only select if same plot type, o/w selections are out of synch
-            self._selectInd(selectDict["ind"])
+            self._selectInd(selectDict['ind'])
 
     def slotCancelSelection(self):
         if self.scatterPlotSelection is not None:
             self.scatterPlotSelection.set_data([], [])
-        # self.draw()
+        #self.draw()
         # cancel mplCursorHover hover selection
         if self.mplCursorHover is not None:
             selections = self.mplCursorHover.selections
-            if len(selections) == 1:
+            if len(selections) ==1 :
                 self.mplCursorHover.remove_selection(selections[0])
 
         # never cancel red square, we always wan't one
-        # self.slotSelectSquare(None)
+        #self.slotSelectSquare(None)
 
         #
-        # self.draw() # to update hover
+        #self.draw() # to update hover
         self.fig.canvas.draw()
 
     def updateTheme(self):
         """
         redraw using stored self.state
         """
         self.myUpdate(stateDict=None)
 
     def myUpdateGlobal(self, stateDict):
         """
         update globals but do not plot
-
-        globals are things shared across all plots like mpl toolbar and legend (???)
         """
-        self.canvas.axes.legend().set_visible(stateDict["showLegend"])
-        # self.myLegend.set_visible(stateDict['showLegend'])
+        self.canvas.axes.legend().set_visible(stateDict['showLegend'])
 
-        if stateDict["showMplToolbar"]:
+        if stateDict['showMplToolbar']:
             self.mplToolbar.show()
         else:
             self.mplToolbar.hide()
 
-        if stateDict["doHover"] and self.whatWeArePlotting is not None:
+        if stateDict['doHover'] and self.whatWeArePlotting is not None:
             self.mplCursorHover = mplcursors.cursor(self.whatWeArePlotting, hover=True)
-
             @self.mplCursorHover.connect("add")
             def _(sel):
-                # sel.annotation.get_bbox_patch().set(fc="white")
-                sel.annotation.arrow_patch.set(
-                    arrowstyle="simple", fc="white", alpha=0.5
-                )
+                #sel.annotation.get_bbox_patch().set(fc="white")
+                sel.annotation.arrow_patch.set(arrowstyle="simple", fc="white", alpha=.5)
                 # row in df is from sel.target.index
-                # print('sel.target.index:', sel.target.index)
+                #print('sel.target.index:', sel.target.index)
                 ind = sel.target.index
                 annotationDict = self.getAnnotation(ind)
-                myText = ""
-                for k, v in annotationDict.items():
-                    myText += f"{k}: {v}\n"
+                myText = ''
+                for k,v in annotationDict.items():
+                    myText += f'{k}: {v}\n'
                 sel.annotation.set_text(myText)
-
-        elif not stateDict["doHover"]:
+        elif not stateDict['doHover']:
             # cancel mplCursorHover hover selection
             if self.mplCursorHover is not None:
                 selections = self.mplCursorHover.selections
-                if len(selections) == 1:
+                if len(selections) ==1 :
                     self.mplCursorHover.remove_selection(selections[0])
-        # self.mplCursorHover = None
+        #self.mplCursorHover = None
 
         #
-        # self.draw() # to update hover
+        #self.draw() # to update hover
         self.fig.canvas.draw()
 
     def myUpdate(self, stateDict=None):
         """
         update plot based on control interface
         """
 
         # store stateDict so we can replot on changing dark theme
         if stateDict is None and self.stateDict is not None:
             # re-use our stateDict
             stateDict = self.stateDict
         else:
             self.stateDict = stateDict.copy()
 
-        dataType = stateDict["dataType"]
-        hue = stateDict["hue"]
-        groupByColumnName = stateDict["groupByColumnName"]
+        dataType = stateDict['dataType']
+        hue = stateDict['hue']
+        groupByColumnName = stateDict['groupByColumnName']
 
-        plotType = stateDict["plotType"]
-        # self.plotType = plotType
+        plotType = stateDict['plotType']
+        #self.plotType = plotType
 
-        xStatHuman = stateDict["xStatHuman"]
-        yStatHuman = stateDict["yStatHuman"]
+        xStatHuman = stateDict['xStatHuman']
+        yStatHuman = stateDict['yStatHuman']
 
-        xStat = stateDict["xStat"]
-        yStat = stateDict["yStat"]
+        xStat = stateDict['xStat']
+        yStat = stateDict['yStat']
 
-        """
+        '''
         print('=== myMplCanvas.myUpdate()')
         print('  ', plotType)
         print('  ', 'xStatHuman:', xStatHuman, 'yStatHuman:', yStatHuman)
         print('  ', 'xStat:', xStat, 'yStat:', yStat)
-        """
+        '''
 
-        xIsCategorical = stateDict["xIsCategorical"]
-        yIsCategorical = stateDict["yIsCategorical"]
+        xIsCategorical = stateDict['xIsCategorical']
+        yIsCategorical = stateDict['yIsCategorical']
 
-        masterDf = stateDict["masterDf"]
-        meanDf = stateDict["meanDf"]
+        masterDf = stateDict['masterDf']
+        meanDf = stateDict['meanDf']
 
         self.plotDf = meanDf
 
         self.canvas.axes.clear()
 
         picker = 5
-        if plotType in ["Scatter Plot", "Scatter + Raw + Mean"]:
+        if plotType in ['Scatter Plot', 'Scatter + Raw + Mean']:
             # scatter plot user selection
-            (self.scatterPlotSelection,) = self.canvas.axes.plot(
-                [], [], "oy", markersize=12, fillstyle="none"
-            )
+            self.scatterPlotSelection, = self.canvas.axes.plot([], [], 'oy',
+                                    markersize=12, fillstyle='none')
 
             # main scatter
             try:
-                self.whatWeArePlotting = sns.scatterplot(
-                    x=xStat,
-                    y=yStat,
-                    hue=hue,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                    zorder=0,
-                )
-            except ValueError as e:
+                self.whatWeArePlotting = sns.scatterplot(x=xStat, y=yStat, hue=hue,
+                                data=meanDf, ax=self.canvas.axes, picker=picker,
+                                zorder=0)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
                 print('  EXCEPTION: in myUpdate() "Scatter Plot", exception is:')
-                print("  ", e)
-                print("  ", "hue:", hue)
+                print('  ', e)
+                print('  ', 'hue:', hue)
 
             # sem in both x and y, pulling from masterDf
-            if dataType == "File Mean" or plotType == "Scatter + Raw + Mean":
+            if dataType=='File Mean' or plotType=='Scatter + Raw + Mean':
                 # we need to do this for each hue???
                 # if x or y is in categorical (e.g. a string) then do not do this ...
                 if xIsCategorical or yIsCategorical:
                     pass
                 else:
-                    logger.info(
-                        f"  grabbing mean +- sem for self.groupByColumnName: {groupByColumnName}"
-                    )
-                    color = "k"
-                    xd = masterDf.groupby(groupByColumnName).mean(numeric_only=True)[
-                        xStat
-                    ]
-                    xerrd = masterDf.groupby(groupByColumnName).sem(numeric_only=True)[
-                        xStat
-                    ]
-                    yd = masterDf.groupby(groupByColumnName).mean(numeric_only=True)[
-                        yStat
-                    ]
-                    yerrd = masterDf.groupby(groupByColumnName).sem(numeric_only=True)[
-                        yStat
-                    ]
-                    self.canvas.axes.errorbar(
-                        xd,
-                        yd,
-                        xerr=xerrd,
-                        yerr=yerrd,
-                        fmt="none",
-                        capsize=0,
-                        zorder=10,
-                        color=color,
-                        alpha=0.5,
-                    )
-
-        elif plotType == "Histogram":
-            yStatHuman = "Count"
-            doKde = False  # stateDict['doKDE']
+                    print('  grabbing mean +- sem for self.groupByColumnName:', groupByColumnName)
+                    color = 'k'
+                    xd = masterDf.groupby(groupByColumnName).mean()[xStat]
+                    xerrd = masterDf.groupby(groupByColumnName).sem()[xStat]
+                    yd = masterDf.groupby(groupByColumnName).mean()[yStat]
+                    yerrd = masterDf.groupby(groupByColumnName).sem()[yStat]
+                    self.canvas.axes.errorbar(xd, yd, xerr=xerrd, yerr=yerrd,
+                        fmt='none', capsize=0, zorder=10, color=color, alpha=0.5);
+
+        elif plotType == 'Histogram':
+            yStatHuman = 'Count'
+            doKde = False #stateDict['doKDE']
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    kde=doKde,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, kde=doKde,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTIONin Histogram:", e)
+                print('EXCEPTIONin Histogram:', e)
 
-        elif plotType == "Cumulative Histogram":
-            yStatHuman = "Probability"
+        elif plotType == 'Cumulative Histogram':
+            yStatHuman = 'Probability'
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    cumulative=True,
-                    stat="density",
-                    element="step",
-                    fill=False,
-                    common_norm=False,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, cumulative=True, stat='density',
+                                element="step", fill=False, common_norm=False,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTION in Cumulative Histogram:", e)
+                print('EXCEPTION in Cumulative Histogram:', e)
 
-        elif plotType == "Cumulative Histogram":
-            yStatHuman = "Probability"
+        elif plotType == 'Cumulative Histogram':
+            yStatHuman = 'Probability'
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    cumulative=True,
-                    stat="density",
-                    element="step",
-                    fill=False,
-                    common_norm=False,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, cumulative=True, stat='density',
+                                element="step", fill=False, common_norm=False,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTION in Cumulative Histogram:", e)
+                print('EXCEPTION in Cumulative Histogram:', e)
 
-        elif plotType == "Violin Plot":
+        elif plotType == 'Violin Plot':
             if not xIsCategorical:
-                warningStr = "Violin plot requires a categorical x statistic"
+                warningStr = 'Violin plot requires a categorical x statistic'
             else:
-                g = sns.violinplot(
-                    x=xStat, y=yStat, hue=hue, data=meanDf, ax=self.canvas.axes
-                )
+                g = sns.violinplot(x=xStat, y=yStat, hue=hue,
+                        data=meanDf, ax=self.canvas.axes)
 
-        elif plotType == "Box Plot":
+        elif plotType == 'Box Plot':
             if not xIsCategorical:
-                warningStr = "Box plot requires a categorical x statistic"
+                warningStr = 'Box plot requires a categorical x statistic'
             else:
-                g = sns.boxplot(
-                    x=xStat, y=yStat, hue=hue, data=meanDf, ax=self.canvas.axes
-                )
+                g = sns.boxplot(x=xStat, y=yStat, hue=hue,
+                        data=meanDf, ax=self.canvas.axes)
 
-        elif plotType == "Raw + Mean Plot":
+        elif plotType == 'Raw + Mean Plot':
             if not xIsCategorical:
-                warningStr = "Raw + Mean plot requires a categorical x statistic"
+                warningStr = 'Raw + Mean plot requires a categorical x statistic'
             else:
                 try:
                     # does not work here for categorical x
-                    # self.scatterPlotSelection, = self.canvas.axes[0].plot([], [], 'oy',
+                    #self.scatterPlotSelection, = self.canvas.axes[0].plot([], [], 'oy',
                     #                markersize=12, fillstyle='none')
 
-                    """
+                    '''
                     colorList = [('red'), ('green'), 'b', 'c', 'm', 'y']
                     hueList = meanDf[hue].unique()
                     palette = {}
                     for idx, hue in enumerate(hueList):
                         palette[hue] = colorList[idx]
                     print(palette)
-                    """
+                    '''
 
                     palette = sns.color_palette("Paired")
-                    # palette = ['r', 'g', 'b']
+                    #palette = ['r', 'g', 'b']
 
                     # stripplot
-                    # g = sns.swarmplot(x=xStat, y=yStat,
-                    g = sns.stripplot(
-                        x=xStat,
-                        y=yStat,
-                        hue=hue,
-                        palette=palette,
-                        data=meanDf,
-                        ax=self.canvas.axes,
-                        # color = color,
-                        dodge=True,
-                        alpha=0.6,
-                        picker=picker,
-                        zorder=1,
-                    )
+                    #g = sns.swarmplot(x=xStat, y=yStat,
+                    g = sns.stripplot(x=xStat, y=yStat,
+                            hue=hue,
+                            palette=palette,
+                            data=meanDf,
+                            ax=self.canvas.axes,
+                            #color = color,
+                            dodge=True,
+                            alpha=0.6,
+                            picker=picker,
+                            zorder=1)
 
-                    # logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
+
+                    #g.legend().remove()
                     self.canvas.axes.legend().remove()
 
-                    # logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
-                    print("\n\n\nREMAKING LEGEND\n\n\n")
                     handles, labels = self.canvas.axes.get_legend_handles_labels()
-                    l = self.canvas.axes.legend(
-                        handles[0:2],
-                        labels[0:2],
-                        bbox_to_anchor=(1.05, 1),
-                        loc=2,
-                        borderaxespad=0.0,
-                    )
-                    # self.myLegend = self.canvas.axes.Legend(handles[0:2], labels[0:2], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
+                    l = self.canvas.axes.legend(handles[0:2], labels[0:2], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
 
-                    """
+                    '''
                     if self.darkTheme:
                         color = 'w'
                     else:
                         color = 'k'
                     color = [color] * len(hueList)
                     print('color:', color)
-                    """
+                    '''
+
+                    self.whatWeArePlotting = sns.pointplot(x=xStat, y=yStat,
+                            hue=hue,
+                            #palette=palette,
+                            data=meanDf,
+                            estimator=np.nanmean,
+                            ci=68, capsize=0.1,
+                            ax=self.canvas.axes,
+                            color='r',
+                            #legend='full',
+                            zorder=10)
 
-                    self.whatWeArePlotting = sns.pointplot(
-                        x=xStat,
-                        y=yStat,
-                        hue=hue,
-                        # palette=palette,
-                        data=meanDf,
-                        estimator=np.nanmean,
-                        ci=68,
-                        capsize=0.1,
-                        ax=self.canvas.axes,
-                        color="r",
-                        # legend='full',
-                        # zorder=10)
-                    )
-                except ValueError as e:
+                except (ValueError) as e:
                     print('EXCEPTION in "Raw + Mean Plot":', e)
                     traceback.print_exc()
 
-        elif plotType == "Regression Plot":
+        elif plotType == 'Regression Plot':
             # regplot does not have hue
             if xIsCategorical or yIsCategorical:
-                warningStr = "Regression plot requires continuous x and y statistics"
+                warningStr = 'Regression plot requires continuous x and y statistics'
             else:
                 # todo: loop and make a regplot
                 # for each unique() name in
                 # hue (like Region, Sex, Condition)
                 hueList = masterDf[hue].unique()
                 for oneHue in hueList:
-                    if oneHue == "None":
+                    if oneHue == 'None':
                         continue
-                    tmpDf = meanDf[meanDf[hue] == oneHue]
-                    # print('regplot oneHue:', oneHue, 'len(tmpDf)', len(tmpDf))
-                    sns.regplot(x=xStat, y=yStat, data=tmpDf, ax=self.canvas.axes)
+                    tmpDf = meanDf [ meanDf[hue]==oneHue ]
+                    #print('regplot oneHue:', oneHue, 'len(tmpDf)', len(tmpDf))
+                    sns.regplot(x=xStat, y=yStat, data=tmpDf,
+                            ax=self.canvas.axes);
         else:
-            print("  did not understand plot type:", plotType)
+            print('  did not understand plot type:', plotType)
+
 
         #
         # update
         self.canvas.axes.figure.canvas.mpl_connect("pick_event", self.onPick)
 
         self.mplCursorHover = None
-        if stateDict["doHover"] and self.whatWeArePlotting is not None:
+        if stateDict['doHover'] and self.whatWeArePlotting is not None:
             self.mplCursorHover = mplcursors.cursor(self.whatWeArePlotting, hover=True)
-
             @self.mplCursorHover.connect("add")
             def _(sel):
-                # sel.annotation.get_bbox_patch().set(fc="white")
-                sel.annotation.arrow_patch.set(
-                    arrowstyle="simple", fc="white", alpha=0.5
-                )
+                #sel.annotation.get_bbox_patch().set(fc="white")
+                sel.annotation.arrow_patch.set(arrowstyle="simple", fc="white", alpha=.5)
                 # row in df is from sel.target.index
-                # print('sel.target.index:', sel.target.index)
+                #print('sel.target.index:', sel.target.index)
                 ind = sel.target.index
                 annotationDict = self.getAnnotation(ind)
-                myText = ""
-                for k, v in annotationDict.items():
-                    myText += f"{k}: {v}\n"
+                myText = ''
+                for k,v in annotationDict.items():
+                    myText += f'{k}: {v}\n'
                 sel.annotation.set_text(myText)
 
         #
-        # self.mySetStatusBar(warningStr)
+        #self.mySetStatusBar(warningStr)
 
-        self.canvas.axes.spines["right"].set_visible(False)
-        self.canvas.axes.spines["top"].set_visible(False)
+        self.canvas.axes.spines['right'].set_visible(False)
+        self.canvas.axes.spines['top'].set_visible(False)
 
-        if not stateDict["showLegend"]:
-            # print('self.canvas.axes.legend():', self.canvas.axes.legend())
-            # print('self.canvas.axes.legend:', self.canvas.axes.legend)
-            # if self.canvas.axes.legend() is not None:
-            if 1:
-                # logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
-                self.canvas.axes.legend().remove()
+        if not stateDict['showLegend']:
+            self.canvas.axes.legend().remove()
 
-        # print('myUpdate() self.plotSize:', self.plotSize)
+        #print('myUpdate() self.plotSize:', self.plotSize)
         self.canvas.axes.set_xlabel(xStatHuman)
         self.canvas.axes.set_ylabel(yStatHuman)
-        """
+        '''
         if self.plotSize == 'paper':
             fontsize = 10
             self.canvas.axes[0].set_xlabel(xStatHuman, fontsize=fontsize)
             self.canvas.axes[0].set_ylabel(yStatHuman, fontsize=fontsize)
         else:
             self.canvas.axes[0].set_xlabel(xStatHuman)
             self.canvas.axes[0].set_ylabel(yStatHuman)
-        """
+        '''
 
         # subplots_adjust
-        # self.fig.canvas.draw_idle()
+        #self.fig.canvas.draw_idle()
         self.fig.canvas.draw()
 
 
 class bScatterPlotMainWindow(QtWidgets.QMainWindow):
-    # send_fig = QtCore.pyqtSignal(str)
+    #send_fig = QtCore.pyqtSignal(str)
     signalStateChange = QtCore.Signal(object)
     signalSelectFromPlot = QtCore.Signal(object)
     signalCancelSelection = QtCore.Signal()
     signalMeanModelChange = QtCore.Signal(object)
     signal_xModelChange = QtCore.Signal(object)
     signal_yModelChange = QtCore.Signal(object)
 
-    def __init__(
-        self,
-        path,
-        categoricalList,
-        hueTypes,
-        analysisName,
-        sortOrder=None,
-        statListDict=None,
-        interfaceDefaults=None,
-        masterDf=None,
-        limitToCol=None,  # col like 'epoch' to create popup to limit to one value (like 0)
-        parent=None,
-    ):
+    def __init__(self, path,
+                    categoricalList, hueTypes, analysisName, sortOrder=None,
+                    statListDict=None,
+                    interfaceDefaults=None,
+                    masterDf=None,
+                    parent=None):
         """
         path: full path to .csv file generated with reanalyze
         categoricalList: specify columns that are categorical
             would just like to use 'if column is string' but sometimes number like 1/2/3 need to be categorical
         hueTypes:
         analysisName: column used for group by
         sortOrder:
@@ -1143,17 +882,17 @@
                     used by main sanpy interface
         parent: not used, parent sanpy app
 
         todo: make pure text columns categorical
         todo: remove analysisName and add as 'groupby' popup from categorical columns
             depending on 'analysisName' popup, group differently in getMeanDf
         """
-        super().__init__(parent)
+        super(bScatterPlotMainWindow, self).__init__(parent)
 
-        # self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
+        #self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
 
         if interfaceDefaults is None:
             interfaceDefaults = myInterfaceDefaults
         self.shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+w"), self)
         self.shortcut.activated.connect(self.myCloseAction)
 
         self.statusBar = QtWidgets.QStatusBar()
@@ -1163,158 +902,129 @@
 
         self.buildMenus()
 
         # assigns self.masterDf
         # if masterDf is not None will use masterDf rather than loading path
         self.loadPath(path, masterDf=masterDf, categoricalList=categoricalList)
 
-        # dec 2022
-        self._limitToCol = limitToCol
-
         # statListDict is a dict with key=humanstat name and yStat=column name in csv
-        # self.statListDict = sanpy.bAnalysisUtil.getStatList()
+        #self.statListDict = sanpy.bAnalysisUtil.getStatList()
         # 20210305 done in loadPath()
         if statListDict is not None:
             self.statListDict = statListDict
             # append all categorical
             if categoricalList is not None:
                 for categorical in categoricalList:
-                    self.statListDict[categorical] = {"yStat": categorical}
-                    self.statListDict[categorical] = {
-                        "name": categorical
-                    }  # we need both yStat and name !!!
-
-        # statListDict now has categorical like 'File Number'
-        for k, v in self.statListDict.items():
-            print("    ", k, v)
-
-        """
+                    self.statListDict[categorical] = {'yStat':categorical}
+        '''
         if statListDict is None:
             # build statListDict from columns of csv path
             self.statListDict = {}
             for colStr in self.masterDfColumns:
                 self.statListDict[colStr] = {'yStat': colStr}
         else:
             self.statListDict = statListDict
-        """
+        '''
 
-        # categoricalList = ['Condition', 'Sex', 'Region', 'File Number', 'File Name']
+        #categoricalList = ['Condition', 'Sex', 'Region', 'File Number', 'File Name']
         # 20210305 done in load path
-        """
+        '''
         for categorical in categoricalList:
             self.statListDict[categorical] = {'yStat': categorical}
         # this was originally in self.load() ???
         self.masterCatColumns = categoricalList
-        """
+        '''
 
-        """
+        '''
         self.stateDict = {}
         self.stateDict['groupByColumnName'] = analysisName
         self.stateDict['sortOrder'] = sortOrder
         self.stateDict['hue'] = hue
         self.stateDict['darkTheme'] = True
         self.stateDict['doKDE'] = False
         self.stateDict['doHover'] = False
         self.stateDict['plotSize'] = 'paper'
         self.stateDict['showLegend'] = True
         self.stateDict['plotType'] = 'Scatter Plot'
         self.stateDict['dataType'] = 'File Mean'
-        """
+        '''
 
         # unique identifyer to group by
         # for sanpy this is 'analysisName', for bImPy this is xxx
         self.groupByColumnName = analysisName
         self.sortOrder = sortOrder
 
         # 20210112 moved up
-        # self.loadPath(path)
+        #self.loadPath(path)
 
-        self.whatWeArePlotting = None  # return from sns scatter plot (all plots)
+        self.whatWeArePlotting = None # return from sns scatter plot (all plots)
         self.scatterPlotSelection = None
-        self.xDf = None  #
-        self.yDf = None  #
-        self.plotDF = None  # df we are plotting (can be same as mean yDf)
-        # use this to get row on self.onPick
+        self.xDf = None #
+        self.yDf = None #
+        self.plotDF = None # df we are plotting (can be same as mean yDf)
+                            # use this to get row on self.onPick
         self.plotStatx = None
         self.plotStaty = None
 
-        # self.main_widget = QtWidgets.QWidget(self)
+        #self.main_widget = QtWidgets.QWidget(self)
 
         # this is causing tons of problems/crashes
-        if interfaceDefaults["Hue"] is not None:
-            self.hue = interfaceDefaults["Hue"]
+        if interfaceDefaults['Hue'] is not None:
+            self.hue = interfaceDefaults['Hue']
         else:
-            self.hue = "None"  # self.hueTypes[0]
+            self.hue = 'None' #self.hueTypes[0]
 
         self.darkTheme = False
-        self.doKDE = False  # fits on histogram plots
-        self.showMplToolbar = False  # fits on histogram plots
+        self.doKDE = False # fits on histogram plots
+        self.showMplToolbar = False # fits on histogram plots
 
         self.doHover = False
 
-        self.plotSizeList = ["paper", "talk", "poster"]
-        self.plotSize = "paper"
-        self.plotLayoutList = ["1x", "1x2", "2x1", "2x2"]
-        self.plotLayoutType = "2x2"
-        self.updatePlot = None  # which plot to update 1,2,3,4
+        self.plotSizeList = ['paper', 'talk', 'poster']
+        self.plotSize = 'paper'
+        self.plotLayoutList = ['1x', '1x2', '2x1', '2x2']
+        self.plotLayoutType = '2x2'
+        self.updatePlot = None # which plot to update 1,2,3,4
 
         self.showLegend = False
-        self.plotType = "Scatter Plot"
+        self.plotType = 'Scatter Plot'
 
-        self.dataTypes = ["All Spikes", "File Mean"]
-        self.dataType = "File Mean"  # (Raw, File Mean)
+        self.dataTypes = ['All Spikes', 'File Mean']
+        self.dataType = 'File Mean' # (Raw, File Mean)
 
         self.buildUI(interfaceDefaults=interfaceDefaults)
 
-        # bar = self.menuBar()
-        # file = bar.addMenu("Load")
+        #bar = self.menuBar()
+        #file = bar.addMenu("Load")
 
-        # abb removed 20210828
-        # self.show()
+        self.show()
 
         # self.updatePlotSize() # calls update2()
         self.update2()
 
-    def _mySetWindowTitle(self, windowTitle):
-        """Required to interact with sanpyPlugin."""
-        self.setWindowTitle(windowTitle)
-
-    def _buildPlotOptionsLayout(self):
-        hBoxLayout = QtWidgets.QHBoxLayout()
-
-        hueList = ["None"] + self.hueTypes  # prepend 'None'
-        hueDropdown = QtWidgets.QComboBox()
-        hueDropdown.addItems(hueList)
-        # if interfaceDefaults['Hue'] is not None:
-        #     defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults['Hue'])
-        # else:
-        #     defaultIdx = 0
-        defaultIdx = 0
-        hueDropdown.setCurrentIndex(defaultIdx)  # 1 because we pre-pended 'None'
-        hueDropdown.currentIndexChanged.connect(self.updateHue)
-
-        hBoxLayout.addWidget(hueDropdown)
-        return hBoxLayout
-
     def buildUI(self, interfaceDefaults):
+        # if self.darkTheme:
+        #     plt.style.use('dark_background')
         if self.darkTheme:
-            plt.style.use("dark_background")
+            plt.style.use('dark_background')
+        else:
+            plt.rcParams.update(plt.rcParamsDefault)
 
         # HBox for control and plot grid
         self.hBoxLayout = QtWidgets.QHBoxLayout(self)
 
         # this is confusing, beacaue we are a QMainWindow
         # we need to create a central widget, set its layout
         # and then set the central widget of self (QMainWindow)
         centralWidget = QtWidgets.QWidget()
         centralWidget.setLayout(self.hBoxLayout)
         self.setCentralWidget(centralWidget)
 
         # switch to 2x2
-        """
+        '''
         # allow 1-4 plots
         tmpNumRow = 1
         tmpNumCol = 1
         numPlot = tmpNumRow * tmpNumCol
 
         self.fig = Figure()
         self.fig.tight_layout()
@@ -1325,450 +1035,367 @@
         # maybe use
         #self.toolbar = NavigationToolbar(self.canvas, self)
         self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
 
         self.canvas.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                   QtWidgets.QSizePolicy.Expanding)
         self.canvas.updateGeometry()
-        """
+        '''
 
         # to hold popups
         self.layout = QtWidgets.QGridLayout()
         self.hBoxLayout.addLayout(self.layout)
 
         def _defaultDropdownIdx(keyList, name):
             # if name not in keys, return 0
             theRet = 0
             try:
                 theRet = keyList.index(name)
-            except ValueError as e:
-                print(
-                    f'WARNING: _defaultDropdownIdx() did not find "{name}"" in keyList: {keyList}'
-                )
+            except (ValueError) as e:
+                print(f'WARNING: _defaultDropdownIdx() did not find "{name}"" in keyList: {keyList}')
                 theRet = 0
             return theRet
 
-        # removed 20210828
-        """
         keys = list(self.statListDict.keys())
         #keys += self.hueTypes
         self.xDropdown = QtWidgets.QComboBox()
         self.xDropdown.addItems(keys)
         if interfaceDefaults['X Statistic'] is not None:
             defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults['X Statistic'])
         else:
             defaultIdx = 0
         self.xDropdown.setCurrentIndex(defaultIdx)
-        self.xDropdown.currentIndexChanged.connect(self.update2)
 
         self.yDropdown = QtWidgets.QComboBox()
         self.yDropdown.addItems(keys)
         if interfaceDefaults['Y Statistic'] is not None:
             defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults['Y Statistic'])
         else:
             defaultIdx = 0
         self.yDropdown.setCurrentIndex(defaultIdx)
-        self.yDropdown.currentIndexChanged.connect(self.update2)
-        """
 
         #
         # hue, to control colors in plot
-        hueList = ["None"] + self.hueTypes  # prepend 'None'
+        hueList = ['None'] + self.hueTypes # prepend 'None'
         self.hueDropdown = QtWidgets.QComboBox()
         self.hueDropdown.addItems(hueList)
-        if interfaceDefaults["Hue"] is not None:
-            defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults["Hue"])
+        if interfaceDefaults['Hue'] is not None:
+            defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults['Hue'])
         else:
             defaultIdx = 0
-        self.hueDropdown.setCurrentIndex(defaultIdx)  # 1 because we pre-pended 'None'
+        self.hueDropdown.setCurrentIndex(defaultIdx) # 1 because we pre-pended 'None'
         self.hueDropdown.currentIndexChanged.connect(self.updateHue)
 
         #
         # group by, to control grouping in table
         # todo: get 'None' implemented
-        # groupByList = ['None'] + self.hueTypes # prepend 'None'
+        #groupByList = ['None'] + self.hueTypes # prepend 'None'
         groupByList = self.hueTypes
         self.groupByDropdown = QtWidgets.QComboBox()
         self.groupByDropdown.addItems(groupByList)
-        if interfaceDefaults["Group By"] is not None:
-            defaultIdx = _defaultDropdownIdx(groupByList, interfaceDefaults["Group By"])
+        if interfaceDefaults['Group By'] is not None:
+            defaultIdx = _defaultDropdownIdx(groupByList, interfaceDefaults['Group By'])
         else:
             defaultIdx = 0
-        self.groupByDropdown.setCurrentIndex(
-            defaultIdx
-        )  # 1 because we pre-pended 'None'
+        self.groupByDropdown.setCurrentIndex(defaultIdx) # 1 because we pre-pended 'None'
         self.groupByDropdown.currentIndexChanged.connect(self.updateGroupBy)
 
         # color
-        # colorTypes = ['Region', 'Sex', 'Condition', 'File Number'] #, 'File Name'] #, 'None']
-        # self.color = 'Region'
-        """
+        #colorTypes = ['Region', 'Sex', 'Condition', 'File Number'] #, 'File Name'] #, 'None']
+        #self.color = 'Region'
+        '''
         self.color = self.colorTypes[0]
         self.colorDropdown = QtWidgets.QComboBox()
         self.colorDropdown.addItems(self.colorTypes)
         self.colorDropdown.setCurrentIndex(0)
         self.colorDropdown.currentIndexChanged.connect(self.updateColor)
-        """
+        '''
 
         self.typeDropdown = QtWidgets.QComboBox()
-        self.typeDropdown.addItems(
-            [
-                "Scatter Plot",
-                "Scatter + Raw + Mean",
-                "Regression Plot",
-                "Violin Plot",
-                "Box Plot",
-                "Raw + Mean Plot",
-                "Histogram",
-                "Cumulative Histogram",
-            ]
-        )
+        self.typeDropdown.addItems(['Scatter Plot', 'Scatter + Raw + Mean', 'Regression Plot', 'Violin Plot', 'Box Plot', 'Raw + Mean Plot', 'Histogram', 'Cumulative Histogram'])
         self.typeDropdown.setCurrentIndex(0)
-        self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
 
         self.dataTypeDropdown = QtWidgets.QComboBox()
-        self.dataTypeDropdown.setToolTip(
-            "All Spikes is all spikes \n File Mean is the mean within each analysis file"
-        )
+        self.dataTypeDropdown.setToolTip('All Spikes is all spikes \n File Mean is the mean within each analysis file')
         self.dataTypeDropdown.addItems(self.dataTypes)
         self.dataTypeDropdown.setCurrentIndex(1)
-        self.dataTypeDropdown.currentIndexChanged.connect(self.updateDataType)
 
-        # self.xDropdown.currentIndexChanged.connect(self.update2)
-        # self.yDropdown.currentIndexChanged.connect(self.update2)
-        # self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
-        # self.dataTypeDropdown.currentIndexChanged.connect(self.updateDataType)
+        self.xDropdown.currentIndexChanged.connect(self.update2)
+        self.yDropdown.currentIndexChanged.connect(self.update2)
+        self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
+        self.dataTypeDropdown.currentIndexChanged.connect(self.updateDataType)
 
-        showLegendCheckBox = QtWidgets.QCheckBox("Legend")
+        showLegendCheckBox = QtWidgets.QCheckBox('Legend')
         showLegendCheckBox.setChecked(self.showLegend)
         showLegendCheckBox.stateChanged.connect(self.setShowLegend)
 
         # swap the sort order
-        aName = "Swap Sort Order"
-        swapSortButton = QtWidgets.QPushButton(aName)
-        swapSortButton.clicked.connect(partial(self.on_button_click, aName))
+        swapSortButton = QtWidgets.QPushButton('Swap Sort Order')
+        swapSortButton.clicked.connect(self.setSwapSort)
         # works fine
-        """
+        '''
         darkThemeCheckBox = QtWidgets.QCheckBox('Dark Theme')
         darkThemeCheckBox.setChecked(self.darkTheme)
         darkThemeCheckBox.stateChanged.connect(self.setTheme)
         darkThemeCheckBox.setDisabled(True)
         darkThemeCheckBox.setEnabled(False)
-        """
+        '''
 
-        """
+        '''
         kdeCheckBox = QtWidgets.QCheckBox('kde (hist)')
         kdeCheckBox.setChecked(self.doKDE)
         kdeCheckBox.stateChanged.connect(self.setKDE)
-        """
-        mplToolbar = QtWidgets.QCheckBox("Toolbar")
+        '''
+        mplToolbar = QtWidgets.QCheckBox('Toolbar')
         mplToolbar.setChecked(self.showMplToolbar)
         mplToolbar.stateChanged.connect(self.setMplToolbar)
 
-        hoverCheckbox = QtWidgets.QCheckBox("Hover Info")
+        hoverCheckbox = QtWidgets.QCheckBox('Hover Info')
         hoverCheckbox.setChecked(self.doHover)
         hoverCheckbox.stateChanged.connect(self.setHover)
 
         # work fine
-        """
+        '''
         self.plotSizeDropdown = QtWidgets.QComboBox()
         self.plotSizeDropdown.setToolTip('Set size of fonts for paper, talk, or poster')
         self.plotSizeDropdown.addItems(self.plotSizeList)
         self.plotSizeDropdown.setCurrentIndex(0) # paper
         self.plotSizeDropdown.currentIndexChanged.connect(self.updatePlotSize)
         self.plotSizeDropdown.setDisabled(True)
-        """
+        '''
 
         # works fine
-        """
+        '''
         self.plotLayoutDropdown = QtWidgets.QComboBox()
         self.plotLayoutDropdown.setToolTip('1, 2, or 4 plots')
         self.plotLayoutDropdown.addItems(self.plotLayoutList)
         self.plotLayoutDropdown.setCurrentIndex(3) #
         self.plotLayoutDropdown.currentIndexChanged.connect(self.updatePlotLayout)
         self.plotLayoutDropdown.setDisabled(True)
-        """
+        '''
 
         # not needed beccause we now clik plot to show red square
-        """
+        '''
         self.plotUpdateList = ['1', '2', '3', '4']
         self.plotUpdateDropdown = QtWidgets.QComboBox()
         self.plotUpdateDropdown.setToolTip('Which plot to update')
         self.plotUpdateDropdown.addItems(self.plotUpdateList)
         self.plotUpdateDropdown.setCurrentIndex(0) # paper
         self.plotUpdateDropdown.currentIndexChanged.connect(self.updatePlotUpdate)
-        """
+        '''
 
-        # 20210828
-        # table view of x stat
-        row = 4
-        col = 0
-        rowSpan = 1
-        colSpan = 2
-        self.xStatTableView = myStatListWidget(
-            myParent=self, headerStr="X-Stat", statList=self.statListDict
-        )
-        self.layout.addWidget(self.xStatTableView, row, col, rowSpan, colSpan)
-        # table view of y stat
-        row = 4
-        col = 2
-        rowSpan = 1
-        colSpan = 2
-        self.yStatTableView = myStatListWidget(
-            myParent=self, headerStr="Y-Stat", statList=self.statListDict
-        )
-        self.layout.addWidget(self.yStatTableView, row, col, rowSpan, colSpan)
-
-        col = 0
-        # removed 20210828
-        """
-        self.layout.addWidget(QtWidgets.QLabel("X Statistic"), 0, col)
-        self.layout.addWidget(self.xDropdown, 0, col+1)
-        self.layout.addWidget(QtWidgets.QLabel("Y Statistic"), 1, col)
-        self.layout.addWidget(self.yDropdown, 1, col+1)
-        """
-
-        aName = "Replot"
-        aButton = QtWidgets.QPushButton(aName)
-        aButton.clicked.connect(partial(self.on_button_click, aName))
-        self.layout.addWidget(aButton, 1, 0)
-
-        self.layout.addWidget(QtWidgets.QLabel("Hue (Plot)"), 2, col)
-        self.layout.addWidget(self.hueDropdown, 2, col + 1)
-
-        self.layout.addWidget(QtWidgets.QLabel("Group By (Stats)"), 3, col)
-        self.layout.addWidget(self.groupByDropdown, 3, col + 1)
-        # self.layout.addWidget(QtWidgets.QLabel("Color"), 3, 0)
-        # self.layout.addWidget(self.colorDropdown, 3, 1)
-
-        # dec2022
-        # print(self._limitToCol)
-        # self.limitToDropdown = QtWidgets.QComboBox()
-        # if self._limitToCol is not None:
-        #     self.limitToDropdown.addItem('None')
-        #     for _x in self._limitToCol:
-        #         self.limitToDropdown.addItem(_x)
-        # self.limitToDropdown.setCurrentIndex(0)
-        # self.limitToDropdown.currentIndexChanged.connect(self.updateLimitTo)
-        # self.layout.addWidget(self.limitToDropdown, 3, col+1)
-
-        #
-        col += 2
-        self.layout.addWidget(QtWidgets.QLabel("Plot Type"), 0, col)
-        self.layout.addWidget(self.typeDropdown, 0, col + 1)
-        self.layout.addWidget(QtWidgets.QLabel("Data Type"), 1, col)
-        self.layout.addWidget(self.dataTypeDropdown, 1, col + 1)
-        self.layout.addWidget(showLegendCheckBox, 2, col)
+        self.layout.addWidget(QtWidgets.QLabel("X Statistic"), 0, 0)
+        self.layout.addWidget(self.xDropdown, 0, 1)
+        self.layout.addWidget(QtWidgets.QLabel("Y Statistic"), 1, 0)
+        self.layout.addWidget(self.yDropdown, 1, 1)
+        self.layout.addWidget(QtWidgets.QLabel("Hue"), 2, 0)
+        self.layout.addWidget(self.hueDropdown, 2, 1)
+        self.layout.addWidget(QtWidgets.QLabel("Group By"), 3, 0)
+        self.layout.addWidget(self.groupByDropdown, 3, 1)
+        #self.layout.addWidget(QtWidgets.QLabel("Color"), 3, 0)
+        #self.layout.addWidget(self.colorDropdown, 3, 1)
+        #
+        self.layout.addWidget(QtWidgets.QLabel("Plot Type"), 0, 2)
+        self.layout.addWidget(self.typeDropdown, 0, 3)
+        self.layout.addWidget(QtWidgets.QLabel("Data Type"), 1, 2)
+        self.layout.addWidget(self.dataTypeDropdown, 1, 3)
+        self.layout.addWidget(showLegendCheckBox, 2, 2)
         # works fine
-        # self.layout.addWidget(darkThemeCheckBox, 2, 3)
-        self.layout.addWidget(swapSortButton, 2, col + 1)
-        self.layout.addWidget(mplToolbar, 3, col)
-        self.layout.addWidget(hoverCheckbox, 3, col + 1)
-
+        #self.layout.addWidget(darkThemeCheckBox, 2, 3)
+        self.layout.addWidget(swapSortButton, 2, 3)
+        self.layout.addWidget(mplToolbar, 3, 2)
+        self.layout.addWidget(hoverCheckbox, 3, 3)
         # works fine
-        # self.layout.addWidget(QtWidgets.QLabel("Plot Size"), 4, 2)
-        # self.layout.addWidget(self.plotSizeDropdown, 4, 3)
+        #self.layout.addWidget(QtWidgets.QLabel("Plot Size"), 4, 2)
+        #self.layout.addWidget(self.plotSizeDropdown, 4, 3)
         # works fine
-        # self.layout.addWidget(QtWidgets.QLabel("Plot Layout"), 4, 0) # out of order
-        # self.layout.addWidget(self.plotLayoutDropdown, 4, 1)
+        #self.layout.addWidget(QtWidgets.QLabel("Plot Layout"), 4, 0) # out of order
+        #self.layout.addWidget(self.plotLayoutDropdown, 4, 1)
 
-        # self.layout.addWidget(QtWidgets.QLabel("Update Plot"), 5, 0) # out of order
-        # self.layout.addWidget(self.plotUpdateDropdown, 5, 1)
+        #self.layout.addWidget(QtWidgets.QLabel("Update Plot"), 5, 0) # out of order
+        #self.layout.addWidget(self.plotUpdateDropdown, 5, 1)
 
-        nextRow = 5  # for text table
+        nextRow = 5 # for text table
         rowSpan = 1
-        colSpan = 5
-        # self.layout.addWidget(self.canvas, 3, 0, rowSpan, colSpan)
+        colSpan = 4
+        #self.layout.addWidget(self.canvas, 3, 0, rowSpan, colSpan)
 
         #
         # grid of plots (myMplCanvas)
         self.plotLayout = QtWidgets.QGridLayout()
-        self.plotLayout.setContentsMargins(0, 0, 0, 0)
+        self.plotLayout.setContentsMargins(0,0,0,0)
         self.plotLayout.setHorizontalSpacing(0)
         self.plotLayout.setVerticalSpacing(0)
 
         self.myPlotCanvasList = [None] * 4
 
         self.updatePlotLayoutGrid()
 
         # append
         self.hBoxLayout.addLayout(self.plotLayout)
 
-        """
+        '''
         self.myToolbar = QtWidgets.QToolBar()
         self.myToolbar.setFloatable(True)
         self.myToolbar.setMovable(True)
         self.tmpToolbarAction = self.myToolbar.addWidget(self.canvas)
         self.addToolBar(QtCore.Qt.RightToolBarArea, self.myToolbar)
-        """
+        '''
 
-        #
-        # tabs to show (raw, x, y) stat tables
         tabwidget = QtWidgets.QTabWidget()
 
         # hold main df database (imutable except for 'include'
-        # table-view to insert into tab
-        self.rawTableView = myTableView("All Spikes")
+        self.rawTableView = myTableView('All Spikes')
         self.rawTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.rawTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.rawTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.rawTableView.slotSwitchTableDf(self.masterDf)
 
         # self.xDf
-        # table-view to insert into tab
-        self.xTableView = myTableView("File Mean")
+        self.xTableView = myTableView('File Mean')
         self.xTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.xTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.xTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.xTableView.slotSwitchTableDf(self.xDf)
 
         # self.yDf
-        self.yTableView = myTableView("File Mean")
-        # table-view to insert into tab
+        self.yTableView = myTableView('File Mean')
         self.yTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.yTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.yTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.yTableView.slotSwitchTableDf(self.yDf)
 
         # todo: make this mean across yDf with stat test
         # mean table with pandas dataframe
-        """
+        '''
         self.tableView = myTableView('Not Sure')
         self.tableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.tableView.clearSelection)
         self.signalSelectFromPlot.connect(self.tableView.slotSelectRow)
         self.signalMeanModelChange.connect(self.tableView.slotSwitchTableModel)
-        """
+        '''
 
         #
-        # self.layout.addWidget(self.tableView, nextRow, 0, rowSpan, colSpan)
+        #self.layout.addWidget(self.tableView, nextRow, 0, rowSpan, colSpan)
+        tabwidget.addTab(self.rawTableView, "Raw")
+        #tabwidget.addTab(self.tableView, "Mean")
         tabwidget.addTab(self.xTableView, "X-Stats")
         tabwidget.addTab(self.yTableView, "Y-Stats")
-        tabwidget.addTab(self.rawTableView, "Raw")
-        # tabwidget.addTab(self.tableView, "Mean")
-        rowSpan = 1
-        colSpan = 5
-        self.layout.addWidget(
-            tabwidget, nextRow, 0, rowSpan, colSpan
-        )  # add widget takes ownership
-
-        # 20210828
-        # self.setLayout(self.layout)
+        self.layout.addWidget(tabwidget, nextRow, 0, rowSpan, colSpan)
 
     def updatePlotLayoutGrid(self):
         """
         use this to switch between (1x, 1x2, 2x1, 2x2)
         """
 
-        print("updatePlotLayoutGrid()")
-        plotLayoutType = self.plotLayoutType  # 1x, 1x2, 2x1, 2x2
-        if plotLayoutType == "1x":
+        print('updatePlotLayoutGrid()')
+        plotLayoutType = self.plotLayoutType # 1x, 1x2, 2x1, 2x2
+        if plotLayoutType == '1x':
             numPlots = 1
-        elif plotLayoutType == "1x2":
+        elif plotLayoutType == '1x2':
             numPlots = 2
-        elif plotLayoutType == "2x1":
+        elif plotLayoutType == '2x1':
             numPlots = 2
-        elif plotLayoutType == "2x2":
+        elif plotLayoutType == '2x2':
             numPlots = 4
 
         # remove all widgets from self.plotLayout
         n = self.plotLayout.count()
         for i in range(n):
             item = self.plotLayout.itemAt(i)
             if item is None:
-                print("  warning: updatePlotLayoutGrid() got None item at step", i)
+                print('  warning: updatePlotLayoutGrid() got None item at step', i)
                 continue
             widget = item.widget()
-            print("  updatePlotLayoutGrid() removing i:", i, "item:", type(item))
+            print('  updatePlotLayoutGrid() removing i:', i, 'item:', type(item))
             self.plotLayout.removeWidget(widget)
-            # self.plotLayout.removeItem(item)
+            #self.plotLayout.removeItem(item)
 
         state = self.getState()
         for i in range(numPlots):
-            if i == 0:
+            if i==0:
                 row = 0
                 col = 0
-            elif i == 1:
-                if plotLayoutType == "1x2":
+            elif i==1:
+                if plotLayoutType == '1x2':
                     row = 0
                     col = 1
-                elif plotLayoutType == "2x1":
+                elif plotLayoutType == '2x1':
                     row = 1
                     col = 0
-                elif plotLayoutType == "2x2":
+                elif plotLayoutType == '2x2':
                     row = 0
                     col = 1
-            elif i == 2:
+            elif i==2:
                 row = 1
                 col = 0
-            elif i == 3:
+            elif i==3:
                 row = 1
                 col = 1
             #
             oneCanvas = myMplCanvas(plotNumber=i)
-            oneCanvas.myUpdate(state)  # initial plot
+            oneCanvas.myUpdate(state) # initial plot
             self.signalCancelSelection.connect(oneCanvas.slotCancelSelection)
             self.myPlotCanvasList[i] = oneCanvas
 
             #
             self.plotLayout.addWidget(oneCanvas, row, col)
 
         # connect each canvas to all other canvas
         for i in range(numPlots):
             iCanvas = self.myPlotCanvasList[i]
             iCanvas.signalSelectSquare.connect(self.slotSelectSquare)
             iCanvas.signalSelectFromPlot.connect(self.slotSelectFromPlot)
             for j in range(numPlots):
-                # if i==j:
+                #if i==j:
                 #    continue
                 jCanvas = self.myPlotCanvasList[j]
                 iCanvas.signalSelectFromPlot.connect(jCanvas.slotSelectInd)
                 iCanvas.signalSelectSquare.connect(jCanvas.slotSelectSquare)
 
         #
         # select the firsr plot
-        self.myPlotCanvasList[0].signalSelectSquare.emit(0, None)  # slotSelectSquare(0)
+        self.myPlotCanvasList[0].signalSelectSquare.emit(0, None) #slotSelectSquare(0)
 
     def keyPressEvent(self, event):
-        logger.info("keyPressEvent()")
+        print('keyPressEvent()')
         if event.key() == QtCore.Qt.Key_Escape:
             self.cancelSelection()
-        elif event.type() == QtCore.QEvent.KeyPress and event.matches(
-            QtGui.QKeySequence.Copy
-        ):
+        elif (event.type() == QtCore.QEvent.KeyPress and
+                        event.matches(QtGui.QKeySequence.Copy)):
             self.copySelection2()
         #
         event.accept()
 
     def copySelection2(self):
         dfCopy = None
         if self.xDf is not None:
             dfCopy = self.xDf.copy()
-            # self.xDf.to_clipboard(sep='\t', index=False)
-            # print('Copied to clipboard')
-            # print(self.xDf)
+            #self.xDf.to_clipboard(sep='\t', index=False)
+            #print('Copied to clipboard')
+            #print(self.xDf)
         if self.yDf is not None:
             if dfCopy is None:
                 dfCopy = self.yDf.copy()
             else:
                 # append row then yDf
                 dfCopy.append(pd.Series(), ignore_index=True)
                 dfCopy.append(self.yDf, ignore_index=True)
-            # self.yDf.to_clipboard(sep='\t', index=False)
-            # print('Copied to clipboard')
-            # print(self.yDf)
+            #self.yDf.to_clipboard(sep='\t', index=False)
+            #print('Copied to clipboard')
+            #print(self.yDf)
         #
         if dfCopy is not None:
-            dfCopy.to_clipboard(sep="\t", index=False)
+            dfCopy.to_clipboard(sep='\t', index=False)
             print(dfCopy)
 
     """
     def eventFilter(self, source, event):
         if (event.type() == QtCore.QEvent.KeyPress and
                         event.matches(QtGui.QKeySequence.Copy)):
             self.copySelection2()
@@ -1779,103 +1406,95 @@
     def cancelSelection(self):
         self.signalCancelSelection.emit()
 
     def _switchTableModel(self, newModel):
         """
         switch model for mean table (Self.xxx)
         """
-        # print('bScatterPlotMainWindow._switchTableModel()')
+        #print('bScatterPlotMainWindow._switchTableModel()')
         self.signalMeanModelChange.emit(newModel)
 
     def getState(self):
         """
         query all controls and create dict with state
 
         used by myMplCanvas.update()
         """
         stateDict = {}
 
-        stateDict["dataType"] = self.dataType  # ['All spikes', 'File Mean']
-        stateDict["groupByColumnName"] = self.groupByColumnName
+        stateDict['dataType'] = self.dataType # ['All spikes', 'File Mean']
+        stateDict['groupByColumnName'] = self.groupByColumnName
 
         plotType = self.plotType
-        stateDict["plotType"] = plotType
+        stateDict['plotType'] = plotType
 
-        # was this, replacing dropdown with listview
-        # xStatHuman = self.xDropdown.currentText()
-        # yStatHuman = self.yDropdown.currentText()
-        xStatHuman, xStat = self.xStatTableView.getCurrentStat()
-        yStatHuman, yStat = self.yStatTableView.getCurrentStat()
-
-        stateDict["xStatHuman"] = xStatHuman
-        stateDict["yStatHuman"] = yStatHuman
-        # xStat = self.statListDict[xStatHuman]['yStat'] # statListDict always used yStat
-        # yStat = self.statListDict[yStatHuman]['yStat']
-        stateDict["xStat"] = xStat
-        stateDict["yStat"] = yStat
-        stateDict["xIsCategorical"] = pd.api.types.is_string_dtype(
-            self.masterDf[xStat].dtype
-        )
-        stateDict["yIsCategorical"] = pd.api.types.is_string_dtype(
-            self.masterDf[yStat].dtype
-        )
+        xStatHuman = self.xDropdown.currentText()
+        yStatHuman = self.yDropdown.currentText()
+        stateDict['xStatHuman'] = xStatHuman
+        stateDict['yStatHuman'] = yStatHuman
+        xStat = self.statListDict[xStatHuman]['yStat'] # statListDict always used yStat
+        yStat = self.statListDict[yStatHuman]['yStat']
+        stateDict['xStat'] = xStat
+        stateDict['yStat'] = yStat
+        stateDict['xIsCategorical'] = pd.api.types.is_string_dtype(self.masterDf[xStat].dtype)
+        stateDict['yIsCategorical'] = pd.api.types.is_string_dtype(self.masterDf[yStat].dtype)
 
-        if self.hue == "None":
+        if self.hue == 'None':
             # special case, we do not want None in self.statNameMap
             hue = None
         else:
             hue = self.hue
-        stateDict["hue"] = hue
+        stateDict['hue'] = hue
 
-        stateDict["darkTheme"] = self.darkTheme
-        stateDict["showLegend"] = self.showLegend
-        stateDict["doHover"] = self.doHover
-        stateDict["showMplToolbar"] = self.showMplToolbar
+        stateDict['darkTheme'] = self.darkTheme
+        stateDict['showLegend'] = self.showLegend
+        stateDict['doHover'] = self.doHover
+        stateDict['showMplToolbar'] = self.showMplToolbar
 
-        if self.dataType == "All Spikes":
+        if self.dataType == 'All Spikes':
             meanDf = self.masterDf
             if self.sortOrder is not None:
                 # need to sort so onPick works
-                print("  ", "(1) sorting by self.sortOrder:", self.sortOrder)
+                print('  ', '(1) sorting by self.sortOrder:', self.sortOrder)
                 meanDf = meanDf.sort_values(self.sortOrder)
 
             # remove rows that have nan in our x or y stat
             meanDf = meanDf[~meanDf[xStat].isnull()]
             meanDf = meanDf[~meanDf[yStat].isnull()]
             meanDf = meanDf.reset_index()
 
-        elif self.dataType == "File Mean":
+        elif self.dataType == 'File Mean':
             meanDf = self.getMeanDf(xStat, yStat)
         else:
-            print("error in self.dataType:", self.dataType)
+            print('error in self.dataType:', self.dataType)
 
-        stateDict["masterDf"] = self.masterDf
-        stateDict["meanDf"] = meanDf
+        stateDict['masterDf'] = self.masterDf
+        stateDict['meanDf'] = meanDf
         return stateDict
 
     def myCloseAction(self):
-        print("myCloseAction()")
+        print('myCloseAction()')
 
     def mySetStatusBar(self, text):
-        self.statusBar.showMessage(text)  # ,2000)
+        self.statusBar.showMessage(text) #,2000)
 
-    """
+    '''
     def copyTable(self):
         headerList = []
         for i in self.tableView.model().columnCount():
             headers.append(self.tableView.model().headerData(i, QtCore.Qt.Horizontal).toString()
         print('copyTable()')
         print('  headers:', headers)
         m = self.tableView.rowCount()
         n = self.tableView.columnCount()
         table = [[''] * n for x in range(m+1)]
         #for i in m:
-    """
+    '''
 
-    """
+    '''
     def copySelection(self):
         #self.copyTable()
 
         selection = self.tableView.selectedIndexes()
         if selection:
             rows = sorted(index.row() for index in selection)
             columns = sorted(index.column() for index in selection)
@@ -1885,199 +1504,177 @@
             for index in selection:
                 row = index.row() - rows[0]
                 column = index.column() - columns[0]
                 table[row][column] = index.data()
             stream = io.StringIO()
             csv.writer(stream).writerows(table)
             QtWidgets.QApplication.clipboard().setText(stream.getvalue())
-    """
+    '''
 
     def buildMenus(self):
-        loadAction = QtWidgets.QAction("Load database.xlsx", self)
+        loadAction = QtWidgets.QAction('Load database.xlsx', self)
         loadAction.triggered.connect(self.loadPathMenuAction)
 
         menubar = self.menuBar()
-        fileMenu = menubar.addMenu("&File")
+        fileMenu = menubar.addMenu('&File')
         fileMenu.addAction(loadAction)
 
     def loadPathMenuAction(self):
         """
         prompt user for database.xlsx
         run reanalyze.py on that xlsx database
         load resultant _master.csv
         """
-        print("loadPathMenuAction")
+        print('loadPathMenuAction')
 
     def loadPath(self, path, masterDf=None, categoricalList=None):
         """
         path: full path to .csv file generated with reanalyze.py
         """
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
         if masterDf is not None:
             self.masterDf = masterDf
         else:
-            if path.endswith(".csv"):
-                self.masterDf = pd.read_csv(
-                    path, header=0
-                )  # , dtype={'ABF File': str})
-            elif path.endswith(".xls"):
-                self.masterDf = pd.read_excel(
-                    path, header=0
-                )  # , dtype={'ABF File': str})
-            elif path.endswith(".xlsx"):
-                self.masterDf = pd.read_excel(
-                    path, header=0, engine="openpyxl"
-                )  # , dtype={'ABF File': str})
+            if path.endswith('.csv'):
+                self.masterDf = pd.read_csv(path, header=0) #, dtype={'ABF File': str})
+            elif path.endswith('.xls'):
+                self.masterDf = pd.read_excel(path, header=0) #, dtype={'ABF File': str})
+            elif path.endswith('.xlsx'):
+                self.masterDf = pd.read_excel(path, header=0, engine='openpyxl') #, dtype={'ABF File': str})
             else:
-                print(
-                    "error: file type not supported. Expecting csv/xls/xlsx. Path:",
-                    path,
-                )
+                print('error: file type not supported. Expecting csv/xls/xlsx. Path:', path)
 
         # 20210426
         # combine some columns into new encoding
         # like, 'male+superior' as 'ms'
         # moved to reanalyze
         # want to move to reanalyze
         # but my base analysis does not have region/sex/condition etc
-        if "Region" in self.masterDf.columns and "Sex" in self.masterDf.columns:
-            tmpNewCol = "RegSex"
-            self.masterDf[tmpNewCol] = ""
-            for tmpRegion in ["Superior", "Inferior"]:
-                for tmpSex in ["Male", "Female"]:
-                    newEncoding = tmpRegion[0] + tmpSex[0]
-                    regSex = self.masterDf[
-                        (self.masterDf["Region"] == tmpRegion)
-                        & (self.masterDf["Sex"] == tmpSex)
-                    ]
-                    regSex = (self.masterDf["Region"] == tmpRegion) & (
-                        self.masterDf["Sex"] == tmpSex
-                    )
-                    print("newEncoding:", newEncoding, "regSex:", regSex.shape)
-                    self.masterDf.loc[regSex, tmpNewCol] = newEncoding
+        tmpNewCol = 'RegSex'
+        self.masterDf[tmpNewCol] = ''
+        for tmpRegion in ['Superior', 'Inferior']:
+            for tmpSex in ['Male', 'Female']:
+                newEncoding = tmpRegion[0] + tmpSex[0]
+                regSex = self.masterDf[ (self.masterDf['Region']==tmpRegion) & (self.masterDf['Sex']==tmpSex)]
+                regSex = (self.masterDf['Region']==tmpRegion) & (self.masterDf['Sex']==tmpSex)
+                print('newEncoding:', newEncoding, 'regSex:', regSex.shape)
+                self.masterDf.loc[regSex, tmpNewCol] = newEncoding
 
-        # sys.exit()
+        #sys.exit()
 
         self.masterDfColumns = self.masterDf.columns.to_list()
 
         #
         # try and guess categorical columns
         # if int64 and unique()<20 then assume it is category (works for date yyyymmdd)
-        # print('loadPath() dtypes:')
-        # print(self.masterDf.dtypes)
+        #print('loadPath() dtypes:')
+        #print(self.masterDf.dtypes)
         if categoricalList is None:
             categoricalList = []
             for colStr, dtype in self.masterDf.dtypes.items():
-                if dtype == object:
-                    print("colStr:", colStr, "is", dtype)
+                if dtype==object:
+                    print('colStr:', colStr, 'is', dtype)
                     categoricalList.append(colStr)
-                elif dtype == np.int64:
+                elif dtype==np.int64:
                     unique = self.masterDf[colStr].unique()
                     numUnique = len(unique)
-                    print("colStr:", colStr, "is", dtype, "numUnique:", numUnique)
+                    print('colStr:', colStr, 'is', dtype, 'numUnique:', numUnique)
                     categoricalList.append(colStr)
 
         self.masterCatColumns = categoricalList
         self.hueTypes = categoricalList
 
         self.statListDict = {}
         for colStr in self.masterDfColumns:
-            self.statListDict[colStr] = {"yStat": colStr}
+            self.statListDict[colStr] = {'yStat': colStr}
 
         # not sure what this was for ???
         # 20210112, put back in if necc
-        # self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
-        # self.masterCatColumns = self.categoricalList
+        #self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
+        #self.masterCatColumns = self.categoricalList
 
         # todo: put this somewhere better
         self.setWindowTitle(path)
 
-    def on_button_click(self, name):
-        """ """
-        logger.info(f"=== {name}")
-
-        if name == "Replot":
-            self.update2()
-        elif name == "Swap Sort Order":
-            # rotate the sort key to be able to sort by different keys, like 'sex' versus 'region'
-            # print('  sortOrder was:', self.sortOrder)
-            self.sortOrder = self.sortOrder[1:] + self.sortOrder[:1]
-            # print('  sortOrder now:', self.sortOrder)
-            self.mySetStatusBar(f"Sort order is now: {self.sortOrder}")
-        else:
-            logger.warning(f'Did not understand button: "{name}"')
+    def setSwapSort(self):
+        """
+        rotate the sort key to be able to sort by different keys, like 'sex' versus 'region'
+        """
+        #print('=== setSwapSort()')
+        #print('  sortOrder was:', self.sortOrder)
+        self.sortOrder = self.sortOrder[1:] + self.sortOrder[:1]
+        #print('  sortOrder now:', self.sortOrder)
+        self.mySetStatusBar(f'Sort order is now: {self.sortOrder}')
 
     def setShowLegend(self, state):
-        logger.info(f"setShowLegend() state: {state}")
+        print('setShowLegend() state:', state)
         self.showLegend = state
         self.updateGlobal()
 
-    """
+    '''
     def setKDE(self, state):
         # only used in histograms
         self.doKDE = state
         self.updateGlobal()
-    """
+    '''
 
     def setMplToolbar(self, state):
         # only used in histograms
         self.showMplToolbar = state
         self.updateGlobal()
 
     def setHover(self, state):
         # used in scatterplots and point plots
         self.doHover = state
-        # self.signalStateChange.emit(self.getState())
+        #self.signalStateChange.emit(self.getState())
         self.updateGlobal()
 
     def setTheme(self, state):
-        print("setTheme() state:", state)
+        print('setTheme() state:', state)
 
         self.darkTheme = state
         if self.darkTheme:
-            plt.style.use("dark_background")
-            # sns.set_context('talk')
+            plt.style.use('dark_background')
+            #sns.set_context('talk')
 
         else:
-            # print(plt.style.available)
+            #print(plt.style.available)
             plt.rcParams.update(plt.rcParamsDefault)
-            # sns.set_context('paper')
+            #sns.set_context('paper')
 
-        # self.updateGlobal()
+        #self.updateGlobal()
         n = len(self.myPlotCanvasList)
         for i in range(n):
             if self.myPlotCanvasList[i] is not None:
                 self.myPlotCanvasList[i].updateTheme()
 
         ###
         return
         ###
 
         ###
         ###
         # remove
-        # self.plotVBoxLayout.removeWidget(self.toolbar)
+        #self.plotVBoxLayout.removeWidget(self.toolbar)
         # need this !!! removeWidget does not work
-        # self.myToolbar.removeAction(self.tmpToolbarAction)
+        #self.myToolbar.removeAction(self.tmpToolbarAction)
         self.hBoxLayout.removeWidget(self.canvas)
         self.canvas.setParent(None)
 
-        self.fig = None  # ???
+        self.fig = None # ???
         self.mplToolbar = None
         self.canvas = None
 
         self.fig = Figure()
         self.canvas = FigureCanvas(self.fig)
-        tmpAx = self.fig.add_subplot(111)  # self.ax1 not used
+        tmpAx = self.fig.add_subplot(111) # self.ax1 not used
         self.axes = [tmpAx]
-        self.cid = self.canvas.mpl_connect("pick_event", self.on_pick_event)
+        self.cid = self.canvas.mpl_connect('pick_event', self.on_pick_event)
         # matplotlib navigation toolbar
-        self.mplToolbar = NavigationToolbar2QT(
-            self.canvas, self.canvas
-        )  # params are (canvas, parent)
+        self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
         self.hBoxLayout.addWidget(self.canvas)
 
         #
         # add a second plot
         if self.canvas2 is not None:
             self.hBoxLayout.removeWidget(self.canvas2)
             self.canvas2.setParent(None)
@@ -2090,60 +1687,53 @@
         # original plot
         self.update2()
 
     def updatePlotLayout(self):
         """
         set number of plots [1x, 1x2, 2x1, 2x2]
         """
-        self.plotLayoutType = (
-            self.plotLayoutDropdown.currentText()
-        )  # ['paper', 'poster', 'talk']
+        self.plotLayoutType = self.plotLayoutDropdown.currentText() # ['paper', 'poster', 'talk']
 
         self.updatePlotLayoutGrid()
 
         self.update2()
 
     def updatePlotSize(self):
-        self.plotSize = (
-            self.plotSizeDropdown.currentText()
-        )  # ['paper', 'poster', 'talk']
-        sns.set_context(self.plotSize)  # , font_scale=1.4)
+        self.plotSize = self.plotSizeDropdown.currentText() # ['paper', 'poster', 'talk']
+        sns.set_context(self.plotSize) #, font_scale=1.4)
         self.updateGlobal()
 
     def updateHue(self):
         hue = self.hueDropdown.currentText()
         self.hue = hue
-        # self.signalStateChange.emit(self.getState())
+        #self.signalStateChange.emit(self.getState())
         self.update2()
 
     def updateGroupBy(self):
         self.groupByColumnName = self.groupByDropdown.currentText()
-        self.update2()  # todo: don't update plot, update table
-
-    def updateLimitTo(self):
-        logger.info("")
+        self.update2() # todo: don't update plot, update table
 
-    """
+    '''
     def updateColor(self):
         color = self.colorDropdown.currentText()
         self.color = color
         self.update2()
-    """
+    '''
 
     def updatePlotType(self):
         plotType = self.typeDropdown.currentText()
         self.plotType = plotType
         self.update2()
 
     def updateDataType(self):
         dataType = self.dataTypeDropdown.currentText()
         self.dataType = dataType
         self.update2()
 
-    """
+    '''
     def old_on_pick_event(self, event):
         try:
             print('on_pick_event() event:', event)
             print('event.ind:', event.ind)
 
             if len(event.ind) < 1:
                 return
@@ -2151,153 +1741,141 @@
             print('  selected:', spikeNumber)
 
             # propagate a signal to parent
             #self.myMainWindow.mySignal('select spike', data=spikeNumber)
             #self.selectSpike(spikeNumber)
         except (AttributeError) as e:
             pass
-    """
+    '''
 
     def getMeanDf(self, xStat, yStat, verbose=False):
         # need to get all categorical columns from orig df
         # these do not change per file (sex, condition, region)
-        print("=== getMeanDf() xStat:", xStat, "yStat:", yStat)
-        print("  self.groupByColumnName:", self.groupByColumnName)
+        print('=== getMeanDf() xStat:', xStat, 'yStat:', yStat)
+        print('  self.groupByColumnName:', self.groupByColumnName)
 
         xIsCategorical = pd.api.types.is_string_dtype(self.masterDf[xStat].dtype)
         yIsCategorical = pd.api.types.is_string_dtype(self.masterDf[yStat].dtype)
 
-        groupByNone = self.groupByColumnName == "None"
+        groupByNone = self.groupByColumnName == 'None'
 
-        aggList = ["count", "mean", "std", "sem", "median"]
+        aggList = ['count', 'mean', 'std', 'sem', 'median']
         if xIsCategorical or groupByNone:
             self.xDf = None
         else:
-            self.xDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                xStat
-            ].agg(aggList)
+            self.xDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[xStat].agg(aggList)
             self.xDf = self.xDf.reset_index()
-            self.xDf.insert(1, "stat", xStat)  # column 1, in place
+            self.xDf.insert(1, 'stat', xStat) # column 1, in place
 
         if yIsCategorical or groupByNone:
             self.yDf = None
         else:
-            self.yDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                yStat
-            ].agg(aggList)
+            self.yDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[yStat].agg(aggList)
             self.yDf = self.yDf.reset_index()
-            self.yDf.insert(1, "stat", yStat)  # column 1, in place
+            self.yDf.insert(1, 'stat', yStat) # column 1, in place
 
         if xStat == yStat:
             groupList = [xStat]
         else:
             groupList = [xStat, yStat]
         if groupByNone:
             meanDf = None
         else:
-            meanDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                groupList
-            ].mean()
+            meanDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[groupList].mean()
             meanDf = meanDf.reset_index()
 
         #
         # 20210211 get median/std/sem/n
         # try and add median/std/sem/sem/n
         if 0:
-            tmpDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                groupList
-            ].median()
-            # print('tmpDf:', tmpDf)
-            meanDf["median"] = tmpDf[self.groupByColumnName]
+            tmpDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[groupList].median()
+            #print('tmpDf:', tmpDf)
+            meanDf['median'] = tmpDf[self.groupByColumnName]
 
-        """
+        '''
         for catName in self.masterCatColumns:
             #if catName == 'analysisname':
             if catName == self.groupByColumnName:
                 # this is column we grouped by, already in meanDf
                 continue
             meanDf[catName] = ''
-        """
+        '''
 
         # for each row, update all categorical columns using self.masterCatColumns
         fileNameList = meanDf[self.groupByColumnName].unique()
-        # print('  getMeanDf() updating all categorical columns for rows in fileNameList:')#, fileNameList)
-        # print('    categorical columns are self.masterCatColumns:', self.masterCatColumns)
+        #print('  getMeanDf() updating all categorical columns for rows in fileNameList:')#, fileNameList)
+        #print('    categorical columns are self.masterCatColumns:', self.masterCatColumns)
         for i, analysisname in enumerate(fileNameList):
-            tmpDf = self.masterDf[self.masterDf[self.groupByColumnName] == analysisname]
+            tmpDf = self.masterDf[ self.masterDf[self.groupByColumnName]==analysisname ]
             if len(tmpDf) == 0:
-                print("  ERROR: got 0 length for analysisname:", analysisname)
+                print('  ERROR: got 0 length for analysisname:', analysisname)
                 continue
             # need to limit this to pre-defined catecorical columns
             for catName in self.masterCatColumns:
-                # if i==0:
+                #if i==0:
                 #    print('analysisname:', analysisname, 'catName:', catName)
 
-                # if catName == self.groupByColumnName:
+                #if catName == self.groupByColumnName:
                 #    # this is column we grouped by, already in meanDf
                 #    continue
 
                 # find value of catName column from 1st instance in masterDf
                 # if more than one unique value, don't put into table
                 numUnique = len(tmpDf[catName].unique())
                 if numUnique == 1:
-                    # print('    updating categorical colum with catName:', catName)
+                    #print('    updating categorical colum with catName:', catName)
                     catValue = tmpDf[catName].iloc[0]
 
-                    theseRows = (
-                        meanDf[self.groupByColumnName] == analysisname
-                    ).tolist()
-                    # if catName == self.groupByColumnName:
+                    theseRows = (meanDf[self.groupByColumnName]==analysisname).tolist()
+                    #if catName == self.groupByColumnName:
                     meanDf.loc[theseRows, catName] = catValue
                     if self.xDf is not None:
                         self.xDf.loc[theseRows, catName] = catValue
                     if self.yDf is not None:
                         self.yDf.loc[theseRows, catName] = catValue
-                    # print('catName:', catName, 'catValue:', type(catValue), catValue)
+                    #print('catName:', catName, 'catValue:', type(catValue), catValue)
                 else:
-                    print(
-                        "warning catName:", catName, "has", numUnique, "unique values"
-                    )
+                    print('warning catName:', catName, 'has', numUnique, 'unique values')
                     pass
-                    # print(f'not adding {catName} to table, numUnique: {numUnique}')
+                    #print(f'not adding {catName} to table, numUnique: {numUnique}')
         #
         # sort
-        # meanDf = meanDf.sort_values(['Region', 'Sex', 'Condition'])
+        #meanDf = meanDf.sort_values(['Region', 'Sex', 'Condition'])
         if self.sortOrder is not None:
-            print("  ", "sorting by self.sortOrder:", self.sortOrder)
+            print('  ', 'sorting by self.sortOrder:', self.sortOrder)
             try:
                 meanDf = meanDf.sort_values(self.sortOrder)
                 if self.xDf is not None:
                     self.xDf = self.xDf.sort_values(self.sortOrder)
                 if self.yDf is not None:
                     self.yDf = self.yDf.sort_values(self.sortOrder)
-            except KeyError as e:
-                print("    ", "sorting (2) failed with:", e)
+            except (KeyError) as e:
+                print('    ', 'sorting (2) failed with:', e)
         #
-        meanDf["index"] = [x + 1 for x in range(len(meanDf))]
+        meanDf['index'] = [x+1 for x in range(len(meanDf))]
         meanDf = meanDf.reset_index()
         if self.xDf is not None:
-            self.xDf["index"] = [x + 1 for x in range(len(self.xDf))]
+            self.xDf['index'] = [x+1 for x in range(len(self.xDf))]
             self.xDf = self.xDf.reset_index()
         if self.yDf is not None:
-            self.yDf["index"] = [x + 1 for x in range(len(self.yDf))]
+            self.yDf['index'] = [x+1 for x in range(len(self.yDf))]
             self.yDf = self.yDf.reset_index()
 
         # drop extra columns
-        # modelMeanDf = meanDf.drop(['level_0'], axis=1)
-        if self.xDf is not None and "level_0" in self.xDf.columns:
-            self.xDf = self.xDf.drop(["level_0"], axis=1)
-        if self.yDf is not None and "level_0" in self.yDf.columns:
-            self.yDf = self.yDf.drop(["level_0"], axis=1)
+        #modelMeanDf = meanDf.drop(['level_0'], axis=1)
+        if self.xDf is not None and 'level_0' in self.xDf.columns:
+            self.xDf = self.xDf.drop(['level_0'], axis=1)
+        if self.yDf is not None and 'level_0' in self.yDf.columns:
+            self.yDf = self.yDf.drop(['level_0'], axis=1)
         # we need to round for the table, but NOT the plot !!!!!
-        # meanDf = meanDf.round(3)
+        #meanDf = meanDf.round(3)
 
         #
         if verbose:
-            print("getMeanDf():")
+            print('getMeanDf():')
             print(meanDf)
         #
         return meanDf
 
     def updateGlobal(self):
         """
         update all plots
@@ -2305,72 +1883,66 @@
         """
         state = self.getState()
         n = len(self.myPlotCanvasList)
         for i in range(n):
             if self.myPlotCanvasList[i] is not None:
                 self.myPlotCanvasList[i].myUpdateGlobal(state)
 
-    def replot(self):
-        self.update2()
-
     def update2(self):
-        # self.updatePlot is the plot to update 1,2,3,4
-        logger.info("")
+        #self.updatePlot is the plot to update 1,2,3,4
         updateIndex = self.updatePlot
         if updateIndex is None:
-            logger.info(
-                f"Found no plots to update with self.updatePlot: {self.updatePlot}"
-            )
-            self.mySetStatusBar("Please select a plot to update")
+            print('update2() found no plots to update with self.updatePlot:', self.updatePlot)
+            self.mySetStatusBar('Please select a plot to update')
             return
 
         state = self.getState()
 
         # update table model
-        meanDf = state["meanDf"]
-        # modelMeanDf = meanDf.drop(['level_0'], axis=1)
-        # self.myModel = myPandasModel(meanDf) # todo: don't need self.myModel
-        myModel = myPandasModel(meanDf)  # todo: don't need self.myModel
-        # print('calling _switchTableModel from update2() updateIndex:', updateIndex)
+        meanDf = state['meanDf']
+        #modelMeanDf = meanDf.drop(['level_0'], axis=1)
+        #self.myModel = myPandasModel(meanDf) # todo: don't need self.myModel
+        myModel = myPandasModel(meanDf) # todo: don't need self.myModel
+        #print('calling _switchTableModel from update2() updateIndex:', updateIndex)
         self._switchTableModel(myModel)
 
         self.xTableView.slotSwitchTableDf(self.xDf)
         self.yTableView.slotSwitchTableDf(self.yDf)
 
         # update plots
         n = len(self.myPlotCanvasList)
         for i in range(n):
-            if i == updateIndex:
+            if i==updateIndex:
                 if self.myPlotCanvasList[i] is not None:
                     self.myPlotCanvasList[i].myUpdate(state)
 
     def old_getAnnotation(self, ind):
         # todo: replace with _getStatFromPlot
 
         if not np.issubdtype(ind, np.integer):
-            print("getAnnotation() got bad ind:", ind, type(ind))
+            print('getAnnotation() got bad ind:', ind, type(ind))
             return
 
         analysisName = self.plotDf.at[ind, self.groupByColumnName]
-        index = self.plotDf.at[ind, "index"]
+        index = self.plotDf.at[ind, 'index']
         try:
-            region = self.plotDf.at[ind, "Region"]  # not all will have this
-        except KeyError as e:
-            region = "n/a"
+            region = self.plotDf.at[ind, 'Region'] # not all will have this
+        except (KeyError) as e:
+            region = 'n/a'
         xVal = self.plotDf.at[ind, self.plotStatx]
         yVal = self.plotDf.at[ind, self.plotStaty]
 
         returnDict = {
-            "index": index,
-            "analysisName": analysisName,
-            "region": region,
-            "xVal": xVal,
-            "yVal": yVal,
-            #'plotDf': self.plotDf, # potentially very big
-        }
+                    'index': index,
+                    'analysisName': analysisName,
+                    'region': region,
+                    'xVal': xVal,
+                    'yVal': yVal,
+                    #'plotDf': self.plotDf, # potentially very big
+            }
         return returnDict
 
     # see: https://stackoverflow.com/questions/7908636/possible-to-make-labels-appear-when-hovering-over-a-point-in-matplotlib
     """
     def old_onHover(self, event):
         print('onHover:', type(event), 'inaxes:', event.inaxes)
         if event.inaxes == self.axes[0]:
@@ -2403,212 +1975,142 @@
     '''
 
     def slotSelectFromPlot(self, selectDict):
         """
         A point in one of plots was selected
         pass this to parent app
         """
-        print("bScatterPlotMainWindow.slotSelectFromPlot() ", selectDict)
+        print('bScatterPlotMainWindow.slotSelectFromPlot() ', selectDict)
 
     def slotSelectSquare(self, plotNumber, stateDict):
-        logger.info(f"plotNumber:{plotNumber}")
-        # print('  stateDict:', stateDict)
-        print("  todo: fill in all interface using stateDict")
+        print('bScatterPlotMainWindow.slotSelectSquare()', plotNumber)
+        #print('  stateDict:', stateDict)
+        print('  todo: fill in all interface using stateDict')
         self.updatePlot = plotNumber
 
     def slotTableViewClicked(self, clickedIndex):
         """
         Respond to signal self.tableView.clicked
         clickedIndex: PyQt5.QtCore.QModelIndex
         """
-        row = clickedIndex.row()
-        model = clickedIndex.model()
-        logger.info(f"row:{row} clickedIndex:{clickedIndex}")
+        row=clickedIndex.row()
+        model=clickedIndex.model()
+        print('bScatterPlotMainWindow.slotTableViewClicked() row:', row, 'clickedIndex:', clickedIndex)
 
         # select in plot
-        # self._selectInd(row) # !!!! visually, index start at 1
-
+        #self._selectInd(row) # !!!! visually, index start at 1
 
-def test():
+if __name__ == '__main__':
     """
     20210112, extending this to work with any csv. Starting with nodes/edges from bimpy
     """
 
     # todo: using 'analysisname' for group by, I think I can also use 'File Number'
-    statListDict = None  # list of dict mapping human readbale to column names
+    statListDict = None # list of dict mapping human readbale to column names
     masterDf = None
     interfaceDefaults = None
 
     # machine learning db
     if 0:
         # this is from mac laptop
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
-        path = "/Users/cudmore/data/laura-ephys/SANdatabaseForMachineLearning.xlsx"
-        analysisName = "File Number"
-        # statListDict = None #sanpy.bAnalysisUtil.getStatList()
-        categoricalList = ["LOCATION", "SEX", "File Number"]  # , 'File Name']
-        hueTypes = ["LOCATION", "SEX", "File Number"]  # , 'File Name'] #, 'None']
-        sortOrder = ["LOCATION", "SEX", "File Number"]
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/SANdatabaseForMachineLearning.xlsx'
+        analysisName = 'File Number'
+        #statListDict = None #sanpy.bAnalysisUtil.getStatList()
+        categoricalList = ['LOCATION', 'SEX', 'File Number']#, 'File Name']
+        hueTypes = ['LOCATION', 'SEX', 'File Number'] #, 'File Name'] #, 'None']
+        sortOrder = ['LOCATION', 'SEX', 'File Number']
 
     # sanpy database
-    if 0:
-        # import sanpy
-        # sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
-        # import bAnalysisUtil
-        # statListDict = bAnalysisUtil.statList
+    if 1:
+        #import sanpy
+        #sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
+        #import bAnalysisUtil
+        #statListDict = bAnalysisUtil.statList
         import statlist
-
         statListDict = statlist.statList
 
         # this is from mac laptop
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
-        path = "../examples/Superior vs Inferior database_master.csv"
-        path = "/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv"
-        path = (
-            "/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv"
-        )
-        path = "/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master_20210402.csv"
-
-        # path = 'data/Superior vs Inferior database_master_20210402.csv'
-        path = "data/Superior vs Inferior database_master_20210402.csv"
-        # path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
-        path = "data/Superior vs Inferior database_13_Feb_master.csv"
-        analysisName = "analysisname"
-        # statListDict = None #sanpy.bAnalysisUtil.getStatList()
-        categoricalList = [
-            "include",
-            "condition",
-            "region",
-            "Sex",
-            "RegSex",
-            "File Number",
-            "analysisname",
-        ]  # , 'File Name']
-        hueTypes = [
-            "region",
-            "sex",
-            "RegSex",
-            "condition",
-            "File Number",
-            "analysisname",
-        ]  # , 'File Name'] #, 'None']
-        sortOrder = ["region", "sex", "condition"]
-
-        interfaceDefaults = {
-            "Y Statistic": "Spike Frequency (Hz)",
-            "X Statistic": "region",
-            "Hue": "region",
-            "Group By": "File Number",
-        }
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '../examples/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master_20210402.csv'
+
+        #path = 'data/Superior vs Inferior database_master_20210402.csv'
+        path = 'data/Superior vs Inferior database_master_20210402.csv'
+        #path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
+        path = 'data/Superior vs Inferior database_13_Feb_master.csv'
+        analysisName = 'analysisname'
+        #statListDict = None #sanpy.bAnalysisUtil.getStatList()
+        categoricalList = ['include', 'Condition', 'Region', 'Sex', 'RegSex', 'File Number', 'analysisname']#, 'File Name']
+        hueTypes = ['Region', 'Sex', 'RegSex', 'Condition', 'File Number', 'analysisname'] #, 'File Name'] #, 'None']
+        sortOrder = ['Region', 'Sex', 'Condition']
+
+        interfaceDefaults = {'Y Statistic': 'Spike Frequency (Hz)',
+                            'X Statistic': 'Region',
+                            'Hue': 'Region',
+                            'Group By': 'File Number'}
     # bimpy database
     if 0:
-        path = "../examples/edges_db.csv"
-        analysisName = "fileNumber"
-        categoricalList = ["san", "region", "path", "file", "fileNumber", "nCon"]
+        path = '../examples/edges_db.csv'
+        analysisName = 'fileNumber'
+        categoricalList = ['san', 'region', 'path', 'file', 'fileNumber', 'nCon']
         hueTypes = categoricalList
-        sortOrder = ["san", "region"]
+        sortOrder = ['san', 'region']
 
     # dualAnalysis database
     if 0:
         # grab our list of dict mapping human readable to .csv column names
-        sys.path.append(os.path.join(os.path.dirname(sys.path[0]), "sanpy"))
+        sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
         import bAnalysisUtil
-
         statListDict = bAnalysisUtil.statList
 
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/dualAnalysis_final_db.csv"
-        analysisName = "fileNumber"  # # rows in .xlsx database, one recording per row
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/dualAnalysis_final_db.csv'
+        analysisName = 'fileNumber' # # rows in .xlsx database, one recording per row
         # trial is 1a/1b/1c... trial withing cellNumber
-        categoricalList = [
-            "include",
-            "region",
-            "fileNumber",
-            "cellNumber",
-            "trial",
-            "quality",
-        ]
+        categoricalList = ['include', 'region', 'fileNumber', 'cellNumber', 'trial', 'quality']
         hueTypes = categoricalList
-        sortOrder = ["region"]
+        sortOrder = ['region']
 
     # sparkmaster lcr database
     if 0:
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcr-database.csv"
-        analysisName = "fileNumber"  # # rows in .xlsx database, one recording per row
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcr-database.csv'
+        analysisName = 'fileNumber' # # rows in .xlsx database, one recording per row
         # trial is 1a/1b/1c... trial withing cellNumber
-        categoricalList = ["quality", "region", "fileNumber", "dateFolder", "tifFile"]
+        categoricalList = ['quality', 'region', 'fileNumber', 'dateFolder', 'tifFile']
         hueTypes = categoricalList
-        sortOrder = ["region"]
+        sortOrder = ['region']
 
     # lcr/vm analysis using lcrPicker.py
     if 0:
-        # basePath = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/'
-        # path = basePath + 'dual-data/20210115/20210115__0002_lcrPicker.csv'
-        # path = basePath + 'dual-data/20210115/20210115__0001_lcrPicker.csv'
+        #basePath = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/'
+        #path = basePath + 'dual-data/20210115/20210115__0002_lcrPicker.csv'
+        #path = basePath + 'dual-data/20210115/20210115__0001_lcrPicker.csv'
 
         # output of lcrPicker.py ... mergeDatabase()
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcrPicker-db.csv"
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcrPicker-db.csv'
         categoricalList = None
         hueTypes = None
-        analysisName = "tifFile"
+        analysisName= 'tifFile'
         sortOrder = None
 
     # merged sanpy+lcr pre spike slope
     # generated by dualAnalysis.py xxx()
     # usnig to compare lcr slope to edddr for fig 9
     if 0:
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/combined-sanpy-lcr-db.csv"
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/combined-sanpy-lcr-db.csv'
         statListDict = None
         categoricalList = None
         hueTypes = None
-        analysisName = "filename"
+        analysisName= 'filename'
         sortOrder = None
 
-    if 1:
-        path = "data"
-        ad = sanpy.analysisDir(path, autoLoad=True)
-        for row in range(len(ad)):
-            ad.getAnalysis(row)
-        masterDf = ad.pool_build()
-        categoricalList = ["file", "File Number"]
-        hueTypes = ["file", "File Number"]
-        analysisName = "file"
-        from sanpy.bAnalysisUtil import statList as statListDict
-
-        sortOrder = ["file", "File Number"]
-        interfaceDefaults = {
-            "Y Statistic": "Spike Frequency (Hz)",
-            "X Statistic": "Spike Number",
-            "Hue": "file",
-            "Group By": "file",
-        }
-
     #
     app = QtWidgets.QApplication(sys.argv)
 
-    ex = bScatterPlotMainWindow(
-        path,
-        categoricalList,
-        hueTypes,
-        analysisName,
-        sortOrder,
-        statListDict=statListDict,
-        masterDf=masterDf,
-        interfaceDefaults=interfaceDefaults,
-    )
-    ex.show()
+    ex = bScatterPlotMainWindow(path, categoricalList, hueTypes,
+                    analysisName, sortOrder, statListDict=statListDict,
+                    masterDf = masterDf,
+                    interfaceDefaults = interfaceDefaults)
 
     sys.exit(app.exec_())
-
-
-def testDec2022():
-    import sanpy.interface
-
-    app = QtWidgets.QApplication(sys.argv)
-    df = pd.read_csv("/Users/cudmore/Desktop/tmpDf-20221231.csv")
-    ptp = sanpy.interface.plugins.plotToolPool(tmpMasterDf=df)
-    ptp.show()
-    sys.exit(app.exec_())
-
-
-if __name__ == "__main__":
-    # test()
-    testDec2022()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/bTableView.py` & `sanpy-ephys-0.1.6/sanpy/interface/bTableView.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,114 +3,106 @@
 import numpy as np
 import pandas as pd
 
 from PyQt5 import QtCore, QtGui, QtWidgets
 
 import sanpy
 import sanpy.interface
-
-# import sanpy.analysisDir
+#import sanpy.analysisDir
 import sanpy.bDetection
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class bTableView(QtWidgets.QTableView):
-    """Table view to display list of files."""
-
+    """Table view to display list of files.
     """
+    
+    '''
     signalUnloadRow = QtCore.pyqtSignal(object)  # row index
     signalRemoveFromDatabase = QtCore.pyqtSignal(object)  # row index
     signalDuplicateRow = QtCore.pyqtSignal(object)  # row index
     signalDeleteRow = QtCore.pyqtSignal(object)  # row index
     #signalRefreshTabe = QtCore.pyqtSignal(object) # row index
     signalCopyTable = QtCore.pyqtSignal()
     signalFindNewFiles = QtCore.pyqtSignal()
 
     signalSaveFileTable = QtCore.pyqtSignal()
     # Save entire database as pandas hsf.
-    """
+    '''
 
-    signalSelectRow = QtCore.pyqtSignal(
-        object, object, object
-    )  # (row, rowDict, selectingAgain)
+    signalSelectRow = QtCore.pyqtSignal(object, object, object)  # (row, rowDict, selectingAgain)
 
     signalUpdateStatus = QtCore.pyqtSignal(object)
     """Update status in main SanPy app."""
 
-    signalSetDefaultDetection = QtCore.pyqtSignal(
-        object, object
-    )  # selected row, detection type
+    signalSetDefaultDetection = QtCore.pyqtSignal(object, object)  # selected row, detection type
 
     def __init__(self, model, parent=None):
         """
         Args:
             model: sanpy.interface.bFileTable.pandasModel
         """
         super().__init__(parent=parent)
 
-        # self.setAcceptDrops(True)
-        # self.setDragDropMode(QtWidgets.QAbstractItemView.DropOnly)
-        # self.setDropIndicatorShown(True)
+        #self.setAcceptDrops(True)
+        #self.setDragDropMode(QtWidgets.QAbstractItemView.DropOnly)
+        #self.setDropIndicatorShown(True)
 
         self.lastSeletedRow = None
         self.clicked.connect(self.onLeftClick)
 
         self.mySetModel(model)
 
         # frozen table was my attempt to keep a few columns always on the left
         # this led to huge problems and is not worth it
 
         # (L, A, S, N, I(include), File)
-        """
+        '''
         self.numFrozenColumns = 6 # depends on columns in analysisDir
 
         self.frozenTableView = QtWidgets.QTableView(self)
         self.frozenTableView.clicked.connect(self.onLeftClick)
         self.frozenTableView.setSortingEnabled(True)
         self.frozenTableView.setSelectionBehavior(QtWidgets.QTableView.SelectRows)  # abb
         # only allow one row to be selected
         self.frozenTableView.setSelectionMode(QtWidgets.QTableView.SingleSelection)
         self.initFrozenColumn()
-        """
+        '''
 
         # dec 2022, not needed
         # self.horizontalHeader().sectionResized.connect(self.updateSectionWidth)
         # self.verticalHeader().sectionResized.connect(self.updateSectionHeight)
-
+    
         _hHeader = self.horizontalHeader()
         _hHeader.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
         # _hHeader.setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
 
-        """
+        '''
         self.frozenTableView.verticalScrollBar().valueChanged.connect(self.verticalScrollBar().setValue)
         self.verticalScrollBar().valueChanged.connect(self.frozenTableView.verticalScrollBar().setValue)
-        """
+        '''
 
         # rewire contextMenuEvent to self (WIERD BUT SEEMS TO WORK)
-        """
+        '''
         self.frozenTableView.contextMenuEvent = self.contextMenuEvent
-        """
+        '''
 
         #
         # original
-        # self.doIncludeCheckbox = False  # todo: turn this on
+        #self.doIncludeCheckbox = False  # todo: turn this on
         # need a local reference to delegate else 'segmentation fault'
-        # self.keepCheckBoxDelegate = myCheckBoxDelegate(self)
-        # self.setItemDelegateForColumn(1, self.keepCheckBoxDelegate)
+        #self.keepCheckBoxDelegate = myCheckBoxDelegate(self)
+        #self.setItemDelegateForColumn(1, self.keepCheckBoxDelegate)
 
         self.setSortingEnabled(True)
 
         self.setAlternatingRowColors(True)
-
-        self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
-
-        # TODO: add font size to options
+        
+        #TODO: add font size to options
         """
         _fonSize = 10
         self.setFont(QtGui.QFont('Arial', _fonSize))
         self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                             QtWidgets.QSizePolicy.Expanding)
         self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
         
@@ -126,25 +118,25 @@
         rowHeight = _fonSize + 1
         fnt = self.font()
         fnt.setPointSize(rowHeight)
 
         self.setFont(fnt)
         self.verticalHeader().setDefaultSectionSize(rowHeight)
         """
-
+        
         # todo: minimize all column widths
-        # for col in range(showNumCol):
+        #for col in range(showNumCol):
         #    self.frozenTableView.setColumnWidth(col, self.columnWidth(col))
 
         # frozen column
-        # self.frozenTableView.setFont(QtGui.QFont('Arial', 10))
-        """
+        #self.frozenTableView.setFont(QtGui.QFont('Arial', 10))
+        '''
         self.frozenTableView.setFont(fnt)
         self.frozenTableView.verticalHeader().setDefaultSectionSize(rowHeight)
-        """
+        '''
 
         # original was this
         # active background-color: #346792;
         # !active background-color: #37414F;
         # removed for manuscript 2023
         # qss = """
         #     QTableView::item:selected:active {
@@ -153,136 +145,132 @@
 
         #     QTableView::item:selected:!active {
         #         color: #E0E1E3;
         #         background-color: #346792;
         #     }
         #     """
         # this almost works but header becomes white???
-        # self.setStyleSheet(qss)
+        #self.setStyleSheet(qss)
 
     # def dragEnterEvent(self, event):
     #     logger.info('')
-
+    
     # def dropEvent(self, event):
     #     logger.info('')
 
     #
     # frozen
-    def _old_initFrozenColumn(self):
+    def old_initFrozenColumn(self):
         self.frozenTableView.setModel(self.model())
 
         # this is causing selection to be in muted blue
-        # self.frozenTableView.setFocusPolicy(QtCore.Qt.NoFocus)
+        #self.frozenTableView.setFocusPolicy(QtCore.Qt.NoFocus)
 
         self.frozenTableView.verticalHeader().hide()
-        # self.frozenTableView.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
+        #self.frozenTableView.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
         self.viewport().stackUnder(self.frozenTableView)
 
-        # self.frozenTableView.setStyleSheet('''
+        #self.frozenTableView.setStyleSheet('''
         #    QtWidgets.QTableView { border: none;
         #                 background-color: #8EDE21;
         #                 selection-background-color: #999;
         #    }''') # for demo purposes
 
         self.frozenTableView.setSelectionModel(self.selectionModel())
 
         # hide trailing column
         for col in range(self.numFrozenColumns, self.model().columnCount()):
             self.frozenTableView.setColumnHidden(col, True)
 
         # set width of remaining columns, does not have an effect ???
         for col in range(self.numFrozenColumns):
-            # print('  col:', col, 'widht:', self.columnWidth(col))
+            #print('  col:', col, 'widht:', self.columnWidth(col))
             columnWidth = self.columnWidth(col)
             columnWidth = 28
             self.frozenTableView.setColumnWidth(col, columnWidth)
-            # self.setColumnWidth(col, columnWidth)
-        # columnWidth = 150
-        # self.frozenTableView.setColumnWidth(self.numFrozenColumns-1, columnWidth)
-        # self.setColumnWidth(self.numFrozenColumns-1, columnWidth)
+            #self.setColumnWidth(col, columnWidth)
+        #columnWidth = 150
+        #self.frozenTableView.setColumnWidth(self.numFrozenColumns-1, columnWidth)
+        #self.setColumnWidth(self.numFrozenColumns-1, columnWidth)
 
-        # self.frozenTableView.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+        #self.frozenTableView.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
         #                    QtWidgets.QSizePolicy.Expanding)
 
         self.frozenTableView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
         self.frozenTableView.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
         self.frozenTableView.show()
         self.updateFrozenTableGeometry()
         self.setHorizontalScrollMode(self.ScrollPerPixel)
         self.setVerticalScrollMode(self.ScrollPerPixel)
         self.frozenTableView.setVerticalScrollMode(self.ScrollPerPixel)
 
         # set Loaded and Analyzed columns
-        self.frozenTableView.horizontalHeader().setSectionResizeMode(
-            0, QtWidgets.QHeaderView.ResizeToContents
-        )
-        self.frozenTableView.horizontalHeader().setSectionResizeMode(
-            1, QtWidgets.QHeaderView.ResizeToContents
-        )
+        self.frozenTableView.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
+        self.frozenTableView.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
         self.frozenTableView.horizontalHeader().setStretchLastSection(True)
 
     def getSelectedRowDict(self):
         selectedRows = self.selectionModel().selectedRows()
         if len(selectedRows) == 0:
             return None
         else:
             selectedItem = selectedRows[0]
             selectedRow = selectedItem.row()
         rowDict = self.model().myGetRowDict(selectedRow)
         return rowDict
 
     def onLeftClick(self, item):
         """Hanlde user left-click on a row.
-
+        
         Keep track of lastSelected row to differentiate between
         switch-file and click again.
         """
         row = item.row()
-        realRow = self.model()._data.index[row]  # sort order
-        # logger.info(f'User clicked row:{row} realRow:{realRow}')
+        realRow = self.model()._data.index[row] # sort order
+        #logger.info(f'User clicked row:{row} realRow:{realRow}')
         self._onLeftClick(realRow)
 
     def _onLeftClick(self, realRow):
         rowDict = self.model().myGetRowDict(realRow)
 
         logger.info(f"=== User click row:{realRow} relPath:{rowDict['relPath']}")
 
         # always emit on clip, keep track if row was already selected
-        # if self.lastSeletedRow is None or self.lastSeletedRow != realRow:
+        #if self.lastSeletedRow is None or self.lastSeletedRow != realRow:
         if 1:
             selectedAgain = self.lastSeletedRow == realRow
             # new row selection
-            # print('  new row selection')
-            # logger.info(f'realRow:{realRow} rowDict:{rowDict}')
+            #print('  new row selection')
+            #logger.info(f'realRow:{realRow} rowDict:{rowDict}')
             self.signalSelectRow.emit(realRow, rowDict, selectedAgain)
         else:
-            # print('  handle another click on already selected row')
+            #print('  handle another click on already selected row')
             pass
 
-        # print('!!!!! TODO: _onLeftClick needs to always emit on click but pass along if row was already selected')
+        #print('!!!!! TODO: _onLeftClick needs to always emit on click but pass along if row was already selected')
         self.lastSeletedRow = realRow
 
-    def _old_selectionChanged(self, selected, deselected):
-        logger.info("")
+    def old_selectionChanged(self, selected, deselected):
+        logger.info('')
         modelIndexList = selected.indexes()
         if len(modelIndexList) == 0:
             return
 
         super(bTableView, self).selectionChanged(selected, deselected)
-        # self.frozenTableView.selectionChanged(selected, deselected)
+        #self.frozenTableView.selectionChanged(selected, deselected)
         modelIndex = modelIndexList[0]
-        # row = modelIndex.row()
+        #row = modelIndex.row()
         column = modelIndex.column()
 
         realRow = self.model()._data.index[modelIndex.row()]
 
         # assuming model is my pandas model
         rowDict = self.model().myGetRowDict(realRow)
 
-        logger.info(f"realRow:{realRow} col:{column} {rowDict}")
+        logger.info(f'realRow:{realRow} col:{column} {rowDict}')
 
         self.signalSelectRow.emit(realRow, rowDict)
 
     def mySetModel(self, model):
         """
         Set the model. Needed so we can show/hide columns
 
@@ -294,60 +282,54 @@
 
         # when we are created, we are given an empty dataframe
         if isinstance(model._data, pd.core.frame.DataFrame):
             if model._data.empty:
                 return
 
         # hide some columns, needed each time we set the model
-        hiddenColumns = [
-            "kLeft",
-            "kTop",
-            "kRight",
-            "kBottom",
-            "Channels",
-            "Cell Type",
-            "Sex",
-            "Condition",
-            "Notes",
-            "relPath",
-            "uuid",
-            "badColumn",
-        ]
+        hiddenColumns = ['kLeft', 'kTop', 'kRight', 'kBottom', 
+                            'Channels',
+                            'Cell Type', 'Sex', 'Condition',
+                            'Notes',
+                            'relPath',
+                            'uuid',
+                            'badColumn']
         for hiddenColumn in hiddenColumns:
             try:
                 columnIdx = model._data.columns.index(hiddenColumn)
-                # print('xxx hiding column', hiddenColumn, columnIdx)
+                #print('xxx hiding column', hiddenColumn, columnIdx)
                 self.setColumnHidden(columnIdx, True)
-            except ValueError as e:
-                logger.error(f"Did not find column {hiddenColumn}")
+            except (ValueError) as e:
+                logger.error(f'Did not find column {hiddenColumn}')
 
-        """
+        '''
         self.frozenTableView.setModel(self.model())
         # this is required otherwise selections become disconnected
         self.frozenTableView.setSelectionModel(self.selectionModel())
-        """
+        '''
 
     def mySelectRow(self, rowIdx):
         """Needed to connect main and frozen table."""
-        # logger.info('')
+        #logger.info('')
 
         self.selectRow(rowIdx)
-        """
+        '''
         self.frozenTableView.selectRow(rowIdx)
-        """
+        '''
 
-    """
+    '''
     # trying to use this to remove tooltip when it comes up as empty ''
     def viewportEvent(self, event):
         logger.info('')
         return True
-    """
+    '''
 
     def contextMenuEvent(self, event):
-        """hHandle right mouse click"""
+        """hHandle right mouse click
+        """
         contextMenu = QtWidgets.QMenu(self)
 
         #
         unloadData = contextMenu.addAction("Unload Data")
 
         # contextMenu.addSeparator()
         # removeFromDatabase = contextMenu.addAction("Remove From Database")
@@ -367,50 +349,50 @@
         # saNodeParams = contextMenu.addAction('SA Node Params')
         # ventricularParams = contextMenu.addAction('Ventricular Params')
         # neuronParams = contextMenu.addAction('Neuron Params')
         # subthresholdParams = contextMenu.addAction('Subthreshold Params')
 
         #
         action = contextMenu.exec_(self.mapToGlobal(event.pos()))
-
+        
         if action is None:
             # no user selection
             return
-
+            
         logger.info(f'  action: "{action.text()}"')
-
+        
         selectedRow = None
         tmp = self.selectedIndexes()
-        if len(tmp) > 0:
-            selectedRow = tmp[0].row()  # not in sort order
+        if len(tmp)>0:
+            selectedRow = tmp[0].row() # not in sort order
 
         if action == unloadData:
-            # self.signalUnloadRow.emit(selectedRow) # not in sort order
-            self.model().myUnloadRow(selectedRow)
+            #self.signalUnloadRow.emit(selectedRow) # not in sort order
+                self.model().myUnloadRow(selectedRow)
         # elif action == removeFromDatabase:
         #     #self.signalRemoveFromDatabase.emit(selectedRow) # not in sort order
         #     self.model().myRemoveFromDatabase(selectedRow)
 
         # depreciated, we no longer duplicate rows
         # elif action == duplicateRow:
         #     #self.signalDuplicateRow.emit(selectedRow) # not in sort order
         #     self.model().myDuplicateRow(selectedRow)
 
         # elif action == deleteRow:
         #     #self.signalDeleteRow.emit(selectedRow)
         #     self.model().myDeleteRow(selectedRow)
 
         elif action == copyTable:
-            # self.signalCopyTable.emit()
+            #self.signalCopyTable.emit()
             self.model().myCopyTable()
         elif action == findNewFiles:
-            # self.signalFindNewFiles.emit()
+            #self.signalFindNewFiles.emit()
             self.model().mySyncDfWithPath()
         elif action == saveAllAnalysis:
-            # self.signalSaveFileTable.emit()
+            #self.signalSaveFileTable.emit()
             self.model().mySave()
 
         # not sure what this was supposed to do
         # elif action in [saNodeParams, ventricularParams, neuronParams, subthresholdParams]:
         #     #print(action, action.text())
         #     if selectedRow is not None:
         #         self.signalSetDefaultDetection.emit(selectedRow, action.text())
@@ -420,77 +402,74 @@
 
         else:
             # user did not select action
             pass
 
     #
     # frozen
-    def _old_updateSectionWidth(self, logicalIndex, oldSize, newSize):
-        # if self.logicalIndex == 0:
+    def updateSectionWidth(self, logicalIndex, oldSize, newSize):
+        #if self.logicalIndex == 0:
         if logicalIndex == 0:
-            # logger.info(f'XXX {newSize}')
-            """
+            #logger.info(f'XXX {newSize}')
+            '''
             self.frozenTableView.setColumnWidth(0, newSize)
-            """
+            '''
             self.updateFrozenTableGeometry()
 
-    def _old_updateSectionHeight(self, logicalIndex, oldSize, newSize):
+    def old_updateSectionHeight(self, logicalIndex, oldSize, newSize):
         self.frozenTableView.setRowHeight(logicalIndex, newSize)
 
-    def _old_resizeEvent(self, event):
+    def old_resizeEvent(self, event):
         super(bTableView, self).resizeEvent(event)
         self.updateFrozenTableGeometry()
 
-    def _old_moveCursor(self, cursorAction, modifiers):
-        # logger.info('')
+    def old_moveCursor(self, cursorAction, modifiers):
+        #logger.info('')
         current = super(bTableView, self).moveCursor(cursorAction, modifiers)
-        if (
-            cursorAction == self.MoveLeft
-            and self.current.column() > 0
-            and self.visualRect(current).topLeft().x()
-            < self.frozenTableView.columnWidth(0)
-        ):
-            newValue = (
-                self.horizontalScrollBar().value()
-                + self.visualRect(current).topLeft().x()
-                - self.frozenTableView.columnWidth(0)
-            )
+        if (cursorAction == self.MoveLeft and
+                self.current.column() > 0 and
+                self.visualRect(current).topLeft().x() <
+                    self.frozenTableView.columnWidth(0)):
+            newValue = (self.horizontalScrollBar().value() +
+                        self.visualRect(current).topLeft().x() -
+                        self.frozenTableView.columnWidth(0))
             self.horizontalScrollBar().setValue(newValue)
         return current
 
     def scrollTo(self, index, hint):
-        """Not sure what this is for?"""
-        # logger.info(f'index:{index} hint:{hint}')
+        """Not sure what this is for?
+        """
+        #logger.info(f'index:{index} hint:{hint}')
         if index.column() > 0:
             super(bTableView, self).scrollTo(index, hint)
 
-    def _old_updateFrozenTableGeometry(self):
-        """ """
+    def old_updateFrozenTableGeometry(self):
+        """
+        """
         myWidth = 400
         theGeometryRect = self.geometry()
-        # theGeometryRect.setWidth(myWidth)
-        # self.frozenTableView.setGeometry(theGeometryRect)
+        #theGeometryRect.setWidth(myWidth)
+        #self.frozenTableView.setGeometry(theGeometryRect)
 
-        """
+        '''
         print('=== self.verticalHeader().width():', self.verticalHeader().width())
         print('  self.frameWidth():', self.frameWidth())
         print('  self.viewport().height():', self.viewport().height())
         print('  self.horizontalHeader().height():', self.horizontalHeader().height())
-        """
-
+        '''
+        
         self.frozenTableView.setGeometry(
             self.verticalHeader().width() - self.frameWidth(),
             self.frameWidth(),
             myWidth,
-            self.viewport().height() + self.horizontalHeader().height(),
-        )
+            self.viewport().height() + self.horizontalHeader().height())
 
         return
 
-        """
+        '''
         #myWidth = self.columnWidth(0) + self.columnWidth(1) + self.columnWidth(2)
         myWidth = 0
         for i in range(self.numFrozenColumns):
             #logger.info(f'{i} {self.frozenTableView.columnWidth(i)}')
             myWidth += self.columnWidth(i)
             print('  col', i, self.columnWidth(i))
         logger.info(f'myWidth:{myWidth}')
@@ -498,33 +477,32 @@
         # (x, y, w, h)
         self.frozenTableView.setGeometry(
             self.verticalHeader().width() + self.frameWidth(),
             self.frameWidth(),
             #self.columnWidth(0),
             myWidth,
             self.viewport().height() + self.horizontalHeader().height())
-        """
+        '''
 
     def slot_detect(self, ba):
-        """Find row of _ba and update model"""
+        """Find row of _ba and update model
+        """
         tmp = self.selectedIndexes()
-        if len(tmp) > 0:
-            selectedRow = tmp[0].row()  # not in sort order
+        if len(tmp)>0:
+            selectedRow = tmp[0].row() # not in sort order
             self.model().myUpdateLoadedAnalyzed(ba, selectedRow)
 
-
 def test():
     import sys
-
     app = QtWidgets.QApplication([])
-
+    
     # import qdarkstyle
     # app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
 
-    path = "data"  # assuming we are run from SanPy repo
+    path = 'data'  # assuming we are run from SanPy repo
     ad = sanpy.analysisDir(path)
 
     df = ad.getDataFrame()
     model = sanpy.interface.bFileTable.pandasModel(ad)
 
     # why was I doing this?
     # # make an empty dataframe with just headers !!!
@@ -532,16 +510,15 @@
     # #dfEmpty = dfEmpty.append(pd.Series(), ignore_index=True)
     # #dfEmpty['_ba'] = ''
     # print('dfEmpty:')
     # print(dfEmpty)
     # emptyModel = sanpy.interface.bFileTable.pandasModel(dfEmpty)
 
     btv = bTableView(model)
-    # btv.mySetModel(model)
+    #btv.mySetModel(model)
 
     btv.show()
 
     sys.exit(app.exec_())
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     test()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/fileListWidget.py` & `sanpy-ephys-0.1.6/sanpy/interface/fileListWidget.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,45 +7,43 @@
 
 import sanpy
 import sanpy.interface
 import sanpy.bDetection
 from sanpy.interface.bFileTable import pandasModel
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class fileListWidget(QtWidgets.QWidget):
     """A widget showing
-    - file list controls
-    - file list widget, see: sanpy.interface.bTableView
+        - file list controls
+        - file list widget, see: sanpy.interface.bTableView
     """
 
     signalLoadFolder = QtCore.pyqtSignal(object, object)  # path, depth
 
-    # signalSelectRow = QtCore.pyqtSignal(object, object, object)  # (row, rowDict, selectingAgain)
-    # signalUpdateStatus = QtCore.pyqtSignal(object)
+    #signalSelectRow = QtCore.pyqtSignal(object, object, object)  # (row, rowDict, selectingAgain)
+    #signalUpdateStatus = QtCore.pyqtSignal(object)
     """Update status in main SanPy app."""
-    # signalSetDefaultDetection = QtCore.pyqtSignal(object, object)  # selected row, detection type
+    #signalSetDefaultDetection = QtCore.pyqtSignal(object, object)  # selected row, detection type
 
-    def __init__(self, myModel: pandasModel, parent=None):
+    def __init__(self, myModel : pandasModel, parent=None):
         """
         Args:
             myModel: sanpy.interface.bFileTable.pandasModel
         """
         super().__init__(parent)
-        self._myModel: pandasModel = myModel
+        self._myModel : pandasModel = myModel
         # self.setAcceptDrops(True)
         self._folderDepth = 1
         self._buildUI()
 
     # def dragEnterEvent(self, event):
     #     logger.info('')
-
+    
     # def dropEvent(self, event):
     #     logger.info('')
 
     def mySetModel(self, theModel):
         """
         Args:
             theModel: sanpy.interface.bFileTable.pandasModel
@@ -57,21 +55,21 @@
         return self._tableView
 
     def _buildUI(self):
         self._vLayout = QtWidgets.QVBoxLayout()
 
         self._hToolbarLayout = QtWidgets.QHBoxLayout()
 
-        buttonName = "Load Folder"
+        buttonName = 'Load Folder'
         button = QtWidgets.QPushButton(buttonName)
-        # button.setToolTip('Save Detected Spikes to Excel file')
-        button.clicked.connect(partial(self.on_button_click, buttonName))
+        #button.setToolTip('Save Detected Spikes to Excel file')
+        button.clicked.connect(partial(self.on_button_click,buttonName))
         self._hToolbarLayout.addWidget(button, alignment=QtCore.Qt.AlignLeft)
 
-        labelName = "Depth"
+        labelName = 'Depth'
         aLabel = QtWidgets.QLabel(labelName)
         self._hToolbarLayout.addWidget(aLabel)
 
         aSpinBox = QtWidgets.QSpinBox()
         aSpinBox.setMinimum(1)
         aSpinBox.setMaximum(5)
         aSpinBox.setValue(1)
@@ -89,14 +87,19 @@
 
         self.setLayout(self._vLayout)
 
     def on_depth_spin_box(self, value):
         self._folderDepth = value
 
     def on_button_click(self, name):
-        logger.info(f"{name}")
-        if name == "Load Folder":
+        logger.info(f'{name}')
+        if name == 'Load Folder':
             self.signalLoadFolder.emit(None, self._folderDepth)
 
     def getDepth(self):
-        """Get the folder depth."""
+        """Get the folder depth.
+        """
         return self._folderDepth
+
+
+
+
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/kymographPlugin2.py` & `sanpy-ephys-0.1.6/sanpy/interface/kymographPlugin2.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,167 +9,164 @@
 from turtle import back
 import numpy as np
 
 from qtpy import QtGui, QtSql, QtCore, QtWidgets
 
 import pyqtgraph as pg
 
-# import qdarkstyle
+#import qdarkstyle
 
 # turn off qdarkstyle logging
-# import logging
-# logging.getLogger('qdarkstyle').setLevel(logging.WARNING)
+#import logging
+#logging.getLogger('qdarkstyle').setLevel(logging.WARNING)
 
-# from shapeanalysisplugin._my_logger import logger
-# from shapeanalysisplugin import kymographAnalysis
+#from shapeanalysisplugin._my_logger import logger
+#from shapeanalysisplugin import kymographAnalysis
 
 import sanpy
 import sanpy.interface
-
-# from sanpy import kymographAnalysis
+#from sanpy import kymographAnalysis
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 class kymographPlugin2(QtWidgets.QWidget):
-    def __init__(self, ba: sanpy.bAnalysis, parent=None):
-        logger.info("")
 
+    def __init__(self, ba : sanpy.bAnalysis, parent = None):
+        logger.info('')
+        
         super().__init__(parent)
-
+        
         # switching to hold actual bAnalysis
-        # self._ba = sanpy.bAnalysis(path)
+        #self._ba = sanpy.bAnalysis(path)
         self._ba = None
         if ba is not None and ba.fileLoader.isKymograph():
             self._ba = ba
 
         # self._kymographAnalysis = sanpy.kymographAnalysis(path)
         # dec 2022
         self._kymographAnalysis = None  # will be created in slotSwitchFile()
         if self._ba is not None:
             self._kymographAnalysis = sanpy.kymAnalysis(ba.getFilePath())
+        
 
         self._imageMedianKernel = 0
         self._lineMedianKernel = 5
 
         self._currentLineNumber = 0
 
         self._fitIsVivible = True
         # keep track of left/right fit on top of kym image
 
-        self._kymWidgetMain = None  # sanpy.interface.kymographWidget(self._ba)
+        self._kymWidgetMain = None  #sanpy.interface.kymographWidget(self._ba)
         self._initGui()
 
         self._on_slider_changed(0)
 
         self.refreshSumLinePlot()
         self.refreshDiameterPlot()
 
-    def _checkboxCallback(self, state: bool, name: str):
-        logger.info(f"state:{state} name:{name}")
-        if name == "Line Profile":
+    def _checkboxCallback(self, state : bool, name : str):
+        logger.info(f'state:{state} name:{name}')
+        if name == 'Line Profile':
             self.showLineProfile(state)
-        elif name == "Diameter":
+        elif name == 'Diameter':
             self.diameterPlotItem.setVisible(state)
-        elif name == "Sum Line":
+        elif name == 'Sum Line':
             self.sumIntensityPlotItem.setVisible(state)
-        elif name == "Fit On Image":
+        elif name == 'Fit On Image':
             self._fitIsVivible = state
             self.refreshDiameterPlot()
 
-    def showLineProfile(self, state: bool):
-        """Toggle interface for "Line Profile" """
-        # self.profileSlider.setVisible(state)
-
+    def showLineProfile(self, state : bool):
+        """Toggle interface for "Line Profile"
+        """
+        #self.profileSlider.setVisible(state)
+        
         self.lineIntensityPlotItem.setVisible(state)
 
         for line in self._sliceLinesList:
             line.setVisible(state)
 
     def _buttonCallback(self, name):
-        logger.info(f"name:{name}")
+        logger.info(f'name:{name}')
         # pos = self._rectRoi.pos()  # (left, bottom)
         # size = self._rectRoi.size()  # (widht, height)
-        # print(f'    pos:{pos} size:{size}')
-
-        if name == "Reset ROI":
+        #print(f'    pos:{pos} size:{size}')
+    
+        if name == 'Reset ROI':
             pos, size = self._kymographAnalysis.getFullRectRoi()  # (w,h)
             self._rectRoi.setPos(pos)
             self._rectRoi.setSize(size)
             # set the x-axis of the image plot
-            # self.kymographWindow.setXRange(0, shape[0])
+            #self.kymographWindow.setXRange(0, shape[0])
 
-        elif name == "Analyze":
+        elif name == 'Analyze':
             self._analyzeButton.setStyleSheet("background-color : #AA2222")
             self._analyzeButton.repaint()
             self._analyzeButton.update()
             QtCore.QCoreApplication.processEvents()
 
-            # left_idx, right_idx = self._kymographAnalysis.getLineProfileWidth()
+            #left_idx, right_idx = self._kymographAnalysis.getLineProfileWidth()
             imageMedianKernel = self._imageMedianKernel
             lineMedianKernel = self._lineMedianKernel
-            self._kymographAnalysis.analyze(
-                imageMedianKernel=imageMedianKernel, lineMedianKernel=lineMedianKernel
-            )
-
-            # self.refreshSumLinePlot()
+            self._kymographAnalysis.analyze(imageMedianKernel=imageMedianKernel, lineMedianKernel=lineMedianKernel)
+            
+            #self.refreshSumLinePlot()
             self.refreshDiameterPlot()
-
+            
             self._analyzeButton.setStyleSheet("background-color : #22AA22")
             self._analyzeButton.repaint()
             self._analyzeButton.update()
             QtCore.QCoreApplication.processEvents()
 
-        elif name == "Save":
+        elif name == 'Save':
             saveFilePath = self._kymographAnalysis.getAnalysisFile()
             # get file name to save
-            # name = QtGui.QFileDialog.getSaveFileName(self, 'Save File')
-            savefile, tmp = QtWidgets.QFileDialog.getSaveFileName(
-                self, "Save File", saveFilePath
-            )
+            #name = QtGui.QFileDialog.getSaveFileName(self, 'Save File')
+            savefile, tmp = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', saveFilePath)
             self._kymographAnalysis.save(savefile)
 
-        elif name == "Rot -90":
+        elif name == 'Rot -90':
             newImage = self._kymographAnalysis.rotateImage()
             self.kymographImage.setImage(newImage)
 
         else:
             logger.warning(f'did not understand "{name}"')
 
-    def setLineWidth(self, value: int):
+    def setLineWidth(self, value : int):
         logger.info(value)
         if self._kymographAnalysis is not None:
             self._kymographAnalysis.setLineWidth(value)
 
-    def setPercentMax(self, value: float):
-        logger.info(f"value:{value}")
+    def setPercentMax(self, value : float):
+        logger.info(f'value:{value}')
         if self._kymographAnalysis is not None:
             self._kymographAnalysis.setPercentOfMax(value)
 
-    def slotSwitchFile(self, ba: sanpy.bAnalysis):
+    def slotSwitchFile(self, ba :sanpy.bAnalysis):
         if ba is not None and not ba.fileLoader.isKymograph():
             return
 
         self._ba = ba
-
+        
         self._kymWidgetMain.slot_switchFile(ba=self._ba)
 
         path = self._ba.getFilePath()
         self._kymographAnalysis = sanpy.kymAnalysis(path)
 
         self.refreshSumLinePlot()
         self.refreshDiameterPlot()
 
     def _slot_roi_changed2(self, newRect):
         """User modified ROI.
-
+        
         Sent from bKymographWidget. Rewrite of '_slot_roi_changed'
             To use new improved bKymographWidget
-
+        
         Args:
             newRect: [l,t,r,b]
         """
         lNew = newRect[0]
         tNew = newRect[1]
         rNew = newRect[2]
         bNew = newRect[3]
@@ -179,180 +176,169 @@
 
         _pos = (lNew, bNew)
         _size = (widthNew, heightNew)
 
         # pos = self._rectRoi.pos()
         # size = self._rectRoi.size()
 
-        logger.info(f"pos:{_pos} size:{_size}")
+        logger.info(f'pos:{_pos} size:{_size}')
 
         self._kymographAnalysis.setPosRoi(_pos)
         self._kymographAnalysis.setSizeRoi(_size)
 
         # update line profile plot
-        # _lineScanValue = self.profileSlider.value()
-        # self._on_slider_changed(_lineScanValue)
+        #_lineScanValue = self.profileSlider.value()
+        #self._on_slider_changed(_lineScanValue)
 
         # replot sum
         self.refreshSumLinePlot()
 
     def old_slot_roi_changed(self):
         pos = self._rectRoi.pos()
         size = self._rectRoi.size()
 
-        logger.info(f"pos:{pos} size:{size}")
+        logger.info(f'pos:{pos} size:{size}')
 
         self._kymographAnalysis.setPosRoi(pos)
         self._kymographAnalysis.setSizeRoi(size)
 
         # update line profile plot
         _lineScanValue = self.profileSlider.value()
         self._on_slider_changed(_lineScanValue)
 
     def setImageMedianKernel(self, value):
         self._imageMedianKernel = value
-
+        
     def setLineMedianKernel(self, value):
         self._lineMedianKernel = value
-
+        
         # refresh the line profile plot
         self._on_slider_changed(value=None)
 
-    def _on_slider_changed(self, value: int = None):
+    def _on_slider_changed(self, value : int = None):
         """Respond to user changing the "Line Scan" slider.
-
+        
         Args:
             value: The line profile number
         """
         if self._ba is None:
             return
-
+        
         if value is None:
             value = self._currentLineNumber
         else:
             self._currentLineNumber = value
 
-        logger.info(f"value:{value}")
+        logger.info(f'value:{value}')
 
-        xScale = self._ba._abf.tifHeader["secondsPerLine"]
+        xScale = self._ba._abf.tifHeader['secondsPerLine']
 
-        # secondsValue = value * self._kymographAnalysis._secondsPerLine
+        #secondsValue = value * self._kymographAnalysis._secondsPerLine
         secondsValue = value * xScale
 
         # update verical lines on top of plots
         for line in self._sliceLinesList:
             line.setValue(secondsValue)
 
         # update one line profile plot
-        lineProfile, left_pnt, right_pnt = self._kymographAnalysis._getFitLineProfile(
-            value, self._lineMedianKernel
-        )
-        # print('    left:', left, 'right:', right)
+        lineProfile, left_pnt, right_pnt = \
+            self._kymographAnalysis._getFitLineProfile(value, self._lineMedianKernel)
+        #print('    left:', left, 'right:', right)
 
         # logger.info(f'  len(lineProfile):{len(lineProfile)} \
         #             left_pnt:{left_pnt} \
         #             right_pnt:{right_pnt}')
 
         # +1 because np.arange() does NOT include the last point
-        # xData = np.arange(0, self._kymographAnalysis.pointsPerLineScan()+1)
+        #xData = np.arange(0, self._kymographAnalysis.pointsPerLineScan()+1)
         pointsPerLineScan = self._kymographAnalysis.pointsPerLineScan()
         umPerPixel = self._kymographAnalysis._umPerPixel
-        logger.info(f"pointsPerLineScan:{pointsPerLineScan} umPerPixel:{umPerPixel}")
+        logger.info(f'pointsPerLineScan:{pointsPerLineScan} umPerPixel:{umPerPixel}')
 
         xData = np.arange(0, pointsPerLineScan)
         xData = np.multiply(xData, umPerPixel)
         if len(xData) != len(lineProfile):
-            logger.error(f"xData: {len(xData)}")
-            logger.error(f"lineProfile: {len(lineProfile)}")
+            logger.error(f'xData: {len(xData)}')
+            logger.error(f'lineProfile: {len(lineProfile)}')
         self.lineIntensityPlot.setData(xData, lineProfile)
 
         # if the fit fails we get left/right as nan
         if np.isnan(left_pnt) or np.isnan(right_pnt):
             xLeftRightData = [np.nan, np.nan]
             yLeftRightData = [np.nan, np.nan]
         else:
             left_um = self._kymographAnalysis.pnt2um(left_pnt)
             right_um = self._kymographAnalysis.pnt2um(right_pnt)
-            xLeftRightData = [left_um, right_um]
-            # print(xLeftRightData)
-            yLeftRightData = [lineProfile[left_pnt], lineProfile[right_pnt]]
+            xLeftRightData = [left_um, right_um] 
+            #print(xLeftRightData)
+            yLeftRightData = [lineProfile[left_pnt], lineProfile[right_pnt]] 
         self.leftRightPlot.setData(xLeftRightData, yLeftRightData)
 
     def _initGui(self):
-        self.setWindowTitle("Kymograph Analysis")
-
+        self.setWindowTitle('Kymograph Analysis')
+        
         self._sliceLinesList = []
-
+        
         vBoxLayout = QtWidgets.QVBoxLayout()
 
         # new oct 5 rosie
         #
         # kymograph widget from main interface
-        self._kymWidgetMain = sanpy.interface.kymographWidget(
-            self._ba
-        )  # will handle na is None
+        self._kymWidgetMain = sanpy.interface.kymographWidget(self._ba) # will handle na is None
         self._kymWidgetMain.signalKymographRoiChanged.connect(self._slot_roi_changed2)
         self._kymWidgetMain.signalLineSliderChanged.connect(self._on_slider_changed)
         vBoxLayout.addWidget(self._kymWidgetMain)
 
         #
         # control bar
         hBoxLayoutControls = QtWidgets.QHBoxLayout()
 
-        lineWidthLabel = QtWidgets.QLabel("Line Width (pixels)")
+        lineWidthLabel = QtWidgets.QLabel('Line Width (pixels)')
         hBoxLayoutControls.addWidget(lineWidthLabel)
 
         lineWidthSpinbox = QtWidgets.QSpinBox()
         lineWidthSpinbox.setMinimum(1)
         if self._kymographAnalysis is not None:
             lineWidthSpinbox.setValue(self._kymographAnalysis.getLineWidth())
         else:
             lineWidthSpinbox.setValue(1)
-        lineWidthSpinbox.valueChanged.connect(
-            self.setLineWidth
-        )  # triggers as user types e.g. (22)
+        lineWidthSpinbox.valueChanged.connect(self.setLineWidth)  # triggers as user types e.g. (22)
         hBoxLayoutControls.addWidget(lineWidthSpinbox)
 
         # percent of max in line profile (for analysis)
-        percentMaxLabel = QtWidgets.QLabel("Percent Of Max")
+        percentMaxLabel = QtWidgets.QLabel('Percent Of Max')
         hBoxLayoutControls.addWidget(percentMaxLabel)
 
         percentMaxSpinbox = QtWidgets.QDoubleSpinBox()
         percentMaxSpinbox.setSingleStep(0.1)
         percentMaxSpinbox.setMinimum(0.001)
         if self._kymographAnalysis is not None:
             percentMaxSpinbox.setValue(self._kymographAnalysis.getPercentOfMax())
         else:
             percentMaxSpinbox.setValue(10)
-        percentMaxSpinbox.valueChanged.connect(
-            self.setPercentMax
-        )  # triggers as user types e.g. (22)
+        percentMaxSpinbox.valueChanged.connect(self.setPercentMax)  # triggers as user types e.g. (22)
         hBoxLayoutControls.addWidget(percentMaxSpinbox)
 
         # median kernels for image and line profile
-        medianLabel = QtWidgets.QLabel("Median Image")
+        medianLabel = QtWidgets.QLabel('Median Image')
         hBoxLayoutControls.addWidget(medianLabel)
 
         imageMedianKernelSpinbox = QtWidgets.QSpinBox()
         imageMedianKernelSpinbox.setMinimum(0)
         imageMedianKernelSpinbox.setValue(self._imageMedianKernel)
-        imageMedianKernelSpinbox.valueChanged.connect(
-            self.setImageMedianKernel
-        )  # triggers as user types e.g. (22)
+        imageMedianKernelSpinbox.valueChanged.connect(self.setImageMedianKernel)  # triggers as user types e.g. (22)
         hBoxLayoutControls.addWidget(imageMedianKernelSpinbox)
 
-        medianLabel2 = QtWidgets.QLabel("Line")
+        medianLabel2 = QtWidgets.QLabel('Line')
         hBoxLayoutControls.addWidget(medianLabel2)
 
         aSpinbox = QtWidgets.QSpinBox()
         aSpinbox.setMinimum(0)
         aSpinbox.setValue(self._lineMedianKernel)
-        aSpinbox.valueChanged.connect(
-            self.setLineMedianKernel
-        )  # triggers as user types e.g. (22)
+        aSpinbox.valueChanged.connect(self.setLineMedianKernel)  # triggers as user types e.g. (22)
         hBoxLayoutControls.addWidget(aSpinbox)
 
         # buttons
         # buttonName = 'Reset ROI'
         # aButton = QtWidgets.QPushButton(buttonName)
         # aButton.clicked.connect(lambda state, name=buttonName: self._buttonCallback(name))
         # hBoxLayoutControls.addWidget(aButton)
@@ -360,62 +346,50 @@
         # buttonName = 'Rot -90'
         # aButton = QtWidgets.QPushButton(buttonName)
         # aButton.setEnabled(False)
         # aButton.clicked.connect(lambda state, name=buttonName: self._buttonCallback(name))
         # hBoxLayoutControls.addWidget(aButton)
 
         # keep reference to button so we can change color during analysis
-        buttonName = "Analyze"
+        buttonName = 'Analyze'
         self._analyzeButton = QtWidgets.QPushButton(buttonName)
         self._analyzeButton.setStyleSheet("background-color : #22AA22")
-        self._analyzeButton.clicked.connect(
-            lambda state, name=buttonName: self._buttonCallback(name)
-        )
+        self._analyzeButton.clicked.connect(lambda state, name=buttonName: self._buttonCallback(name))
         hBoxLayoutControls.addWidget(self._analyzeButton)
 
-        buttonName = "Save"
+        buttonName = 'Save'
         aButton = QtWidgets.QPushButton(buttonName)
-        aButton.clicked.connect(
-            lambda state, name=buttonName: self._buttonCallback(name)
-        )
+        aButton.clicked.connect(lambda state, name=buttonName: self._buttonCallback(name))
         hBoxLayoutControls.addWidget(aButton)
 
         # 2nd row of controls
         hBoxLayoutControls2 = QtWidgets.QHBoxLayout()
 
-        checkboxName = "Line Profile"
+        checkboxName = 'Line Profile'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(True)
-        aCheckBox.stateChanged.connect(
-            lambda state, name=checkboxName: self._checkboxCallback(state, name)
-        )
+        aCheckBox.stateChanged.connect(lambda state, name=checkboxName: self._checkboxCallback(state,name))
         hBoxLayoutControls2.addWidget(aCheckBox)
 
-        checkboxName = "Diameter"
+        checkboxName = 'Diameter'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(True)
-        aCheckBox.stateChanged.connect(
-            lambda state, name=checkboxName: self._checkboxCallback(state, name)
-        )
+        aCheckBox.stateChanged.connect(lambda state, name=checkboxName: self._checkboxCallback(state,name))
         hBoxLayoutControls2.addWidget(aCheckBox)
 
-        checkboxName = "Sum Line"
+        checkboxName = 'Sum Line'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(True)
-        aCheckBox.stateChanged.connect(
-            lambda state, name=checkboxName: self._checkboxCallback(state, name)
-        )
+        aCheckBox.stateChanged.connect(lambda state, name=checkboxName: self._checkboxCallback(state,name))
         hBoxLayoutControls2.addWidget(aCheckBox)
 
-        checkboxName = "Fit On Image"
+        checkboxName = 'Fit On Image'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(self._fitIsVivible)
-        aCheckBox.stateChanged.connect(
-            lambda state, name=checkboxName: self._checkboxCallback(state, name)
-        )
+        aCheckBox.stateChanged.connect(lambda state, name=checkboxName: self._checkboxCallback(state,name))
         hBoxLayoutControls2.addWidget(aCheckBox)
 
         # 3rd row of controls
         # hBoxLayoutControls3 = QtWidgets.QHBoxLayout()
 
         # percentMaxLabel = QtWidgets.QLabel('y: um/pixel')
         # hBoxLayoutControls3.addWidget(percentMaxLabel)
@@ -427,52 +401,47 @@
         vBoxLayout.addLayout(hBoxLayoutControls)
         vBoxLayout.addLayout(hBoxLayoutControls2)
         # vBoxLayout.addLayout(hBoxLayoutControls3)
 
         # 1) kymograph image
         if 0:
             self.kymographWindow = pg.PlotWidget()
-            self.kymographWindow.setLabel("left", "Line Scan", units="")
-            # self.kymographWindow.setLabel('bottom', 'Time', units='')
+            self.kymographWindow.setLabel('left', 'Line Scan', units='')
+            #self.kymographWindow.setLabel('bottom', 'Time', units='')
 
             self.kymographImage = pg.ImageItem(self._kymographAnalysis.getImage())
             # setRect(x, y, w, h)
             imageRect = self._kymographAnalysis.getImageRect()  # (x,y,w,h)
-            # pos, size = self._kymographAnalysis.getFullRectRoi()  # (x,y,w,h)
-            self.kymographImage.setRect(
-                imageRect[0], imageRect[1], imageRect[2], imageRect[3]
-            )
-            # self.kymographImage.setRect(pos[0], pos[1], size[0], size[1])
+            #pos, size = self._kymographAnalysis.getFullRectRoi()  # (x,y,w,h)
+            self.kymographImage.setRect(imageRect[0], imageRect[1], imageRect[2], imageRect[3])
+            #self.kymographImage.setRect(pos[0], pos[1], size[0], size[1])
             self.kymographWindow.addItem(self.kymographImage)
 
             # vertical line to show "Line Profile"
             sliceLine = pg.InfiniteLine(pos=0, angle=90)
-            self._sliceLinesList.append(
-                sliceLine
-            )  # keep a list of vertical slice lines so we can update all at once
+            self._sliceLinesList.append(sliceLine) # keep a list of vertical slice lines so we can update all at once
             self.kymographWindow.addItem(sliceLine)
 
             # rectangulaar roi over image
-            # _penWidth = self._kymographAnalysis.getLineWidth()
+            #_penWidth = self._kymographAnalysis.getLineWidth()
             _penWidth = 1
-            rectPen = pg.mkPen("r", width=_penWidth)
+            rectPen = pg.mkPen('r', width=_penWidth)
             pos = self._kymographAnalysis.getPosRoi()
             size = self._kymographAnalysis.getSizeRoi()
-            _imageRect = self._kymographAnalysis.getImageRect()  # (x,y,w,h)
-            maxBounds = QtCore.QRectF(
-                _imageRect[0], _imageRect[1], _imageRect[2], _imageRect[3]
-            )
-            # print('  init roi pos:', pos)
-            # print('  init roi size:', size)
-            # print('  init roi pos:', maxBounds)
-            self._rectRoi = pg.ROI(pos=pos, size=size, maxBounds=maxBounds, pen=rectPen)
-            self._rectRoi.addScaleHandle(pos=(1, 0), center=(0, 1))
-            self._rectRoi.sigRegionChangeFinished.connect(
-                self._slot_roi_changed
-            )  # remove
+            _imageRect = self._kymographAnalysis.getImageRect()   # (x,y,w,h)
+            maxBounds = QtCore.QRectF(_imageRect[0], _imageRect[1],
+                                _imageRect[2], _imageRect[3])
+            #print('  init roi pos:', pos)
+            #print('  init roi size:', size)
+            #print('  init roi pos:', maxBounds)
+            self._rectRoi = pg.ROI(pos=pos,
+                                size=size, maxBounds=maxBounds,
+                                pen=rectPen)
+            self._rectRoi.addScaleHandle(pos=(1,0), center=(0,1))
+            self._rectRoi.sigRegionChangeFinished.connect(self._slot_roi_changed)  # remove
             self.kymographWindow.addItem(self._rectRoi)
 
             vBoxLayout.addWidget(self.kymographWindow)
 
         #
         # 1.5) slider to step through "Line Profile"
         if 0:
@@ -481,171 +450,161 @@
             self.profileSlider.setMaximum(self._kymographAnalysis.numLineScans())
             self.profileSlider.valueChanged.connect(self._on_slider_changed)
             vBoxLayout.addWidget(self.profileSlider)
 
         #
         # plot of just one line intensity
         self.lineIntensityPlotItem = pg.PlotWidget()
-        self.lineIntensityPlotItem.setLabel("left", "Intensity", units="")
-        self.lineIntensityPlotItem.setLabel("bottom", "Points", units="")
-        self.lineIntensityPlot = self.lineIntensityPlotItem.plot(
-            name="lineIntensityPlot"
-        )
+        self.lineIntensityPlotItem.setLabel('left', 'Intensity', units='')
+        self.lineIntensityPlotItem.setLabel('bottom', 'Points', units='')
+        self.lineIntensityPlot = self.lineIntensityPlotItem.plot(name='lineIntensityPlot')
         if self._kymographAnalysis is not None:
             xPlot = np.arange(0, self._kymographAnalysis.pointsPerLineScan())
         else:
-            xPlot = np.arange(0, 0)
+            xPlot = np.arange(0,0)
         yPlot = xPlot * np.nan
-        self.lineIntensityPlot.setData(xPlot, yPlot, connect="finite")  # fill with nan
+        self.lineIntensityPlot.setData(xPlot, yPlot, connect='finite')  # fill with nan
         # single point of left/right
-        self.leftRightPlot = self.lineIntensityPlotItem.plot(name="leftRightPlot")
+        self.leftRightPlot = self.lineIntensityPlotItem.plot(name='leftRightPlot')
 
         vBoxLayout.addWidget(self.lineIntensityPlotItem)
 
         #
         # 3) dimaeter of each line scan
         self.diameterPlotItem = pg.PlotWidget()
-        self.diameterPlotItem.setLabel("left", "Diameter", units="")
-        self.diameterPlot = self.diameterPlotItem.plot(name="diameterPlot")
+        self.diameterPlotItem.setLabel('left', 'Diameter', units='')
+        self.diameterPlot = self.diameterPlotItem.plot(name='diameterPlot')
         if self._kymographAnalysis is not None:
             xPlot = np.arange(0, self._kymographAnalysis.numLineScans())
         else:
-            xPlot = np.arange(0, 0)
+            xPlot = np.arange(0,0)
         yPlot = xPlot * np.nan
-        self.diameterPlot.setData(xPlot, yPlot, connect="finite")  # fill with nan
+        self.diameterPlot.setData(xPlot, yPlot, connect='finite')  # fill with nan
         # link x-axis with kymograph PlotWidget
-        # self.diameterPlotItem.setXLink(self.kymographWindow)
+        #self.diameterPlotItem.setXLink(self.kymographWindow)
         # link to kymographWidget plot of the image
         self.diameterPlotItem.setXLink(self._kymWidgetMain.kymographPlot)
 
         # vertical line to show "Line Profile"
         sliceLine = pg.InfiniteLine(pos=0, angle=90)
-        self._sliceLinesList.append(
-            sliceLine
-        )  # keep a list of vertical slice lines so we can update all at once
+        self._sliceLinesList.append(sliceLine) # keep a list of vertical slice lines so we can update all at once
         self.diameterPlotItem.addItem(sliceLine)
 
         vBoxLayout.addWidget(self.diameterPlotItem)
 
         # 4) sum intensity of each line scan
         self.sumIntensityPlotItem = pg.PlotWidget()
-        self.sumIntensityPlotItem.setLabel("left", "Sum Intensity", units="")
-        self.sumIntensityPlot = self.sumIntensityPlotItem.plot(name="sumIntensityPlot")
+        self.sumIntensityPlotItem.setLabel('left', 'Sum Intensity', units='')
+        self.sumIntensityPlot = self.sumIntensityPlotItem.plot(name='sumIntensityPlot')
         # TODO: fix
         if self._ba is not None:
             _recordingDur = self._ba.recordingDur
         else:
             _recordingDur = 0
-        # xPlot = np.arange(0, self._kymographAnalysis.numLineScans())
+        #xPlot = np.arange(0, self._kymographAnalysis.numLineScans())
         xPlot = np.arange(0, _recordingDur)
         yPlot = xPlot * np.nan
-        self.sumIntensityPlot.setData(xPlot, yPlot, connect="finite")  # fill with nan
+        self.sumIntensityPlot.setData(xPlot, yPlot, connect='finite')  # fill with nan
         # link x-axis with kymograph PlotWidget
-        # self.sumIntensityPlotItem.setXLink(self.kymographWindow)
+        #self.sumIntensityPlotItem.setXLink(self.kymographWindow)
         # link to kymographWidget plot of the image
         self.sumIntensityPlotItem.setXLink(self._kymWidgetMain.kymographPlot)
 
         # vertical line to show "Line Profile"
         sliceLine = pg.InfiniteLine(pos=0, angle=90)
-        self._sliceLinesList.append(
-            sliceLine
-        )  # keep a list of vertical slice lines so we can update all at once
+        self._sliceLinesList.append(sliceLine) # keep a list of vertical slice lines so we can update all at once
         self.sumIntensityPlotItem.addItem(sliceLine)
 
         vBoxLayout.addWidget(self.sumIntensityPlotItem)
 
         # finalize
         self.setLayout(vBoxLayout)
 
-    def old_replot(self, path):
-        logger.info("")
+    def old_replot(self,path):
 
+        logger.info('')
+        
         self._kymographAnalysis = sanpy.kymAnalysis(path)
-
+        
         if 0:
             # clear the image from the panel
-            # self.kymographWindow.clear()
-
+            #self.kymographWindow.clear()
+            
             self.kymographImage = pg.ImageItem(self._kymographAnalysis.getImage())
             # setRect(x, y, w, h)
             imageRect = self._kymographAnalysis.getImageRect()  # (x,y,w,h)
-            self.kymographImage.setRect(
-                imageRect[0], imageRect[1], imageRect[2], imageRect[3]
-            )
+            self.kymographImage.setRect(imageRect[0], imageRect[1], imageRect[2], imageRect[3])
             self.kymographWindow.addItem(self.kymographImage)
 
             # update roi
-            _imageRect = self._kymographAnalysis.getImageRect()  # (x,y,w,h)
-            maxBounds = QtCore.QRectF(
-                _imageRect[0], _imageRect[1], _imageRect[2], _imageRect[3]
-            )
+            _imageRect = self._kymographAnalysis.getImageRect()   # (x,y,w,h)
+            maxBounds = QtCore.QRectF(_imageRect[0], _imageRect[1],
+                                _imageRect[2], _imageRect[3])
             self._rectRoi.maxBounds = maxBounds
             pos = self._kymographAnalysis.getPosRoi()
             size = self._kymographAnalysis.getSizeRoi()
-            print(f"  pos:{pos}, size:{size}")
+            print(f'  pos:{pos}, size:{size}')
             self._rectRoi.setPos(pos)
             self._rectRoi.setSize(size)
             self._rectRoi.stateChanged()
 
         # update slider
-        # self.profileSlider.setMaximum(self._kymographAnalysis.numLineScans())
+        #self.profileSlider.setMaximum(self._kymographAnalysis.numLineScans())
 
         #
-        # self._on_slider_changed(0)
+        #self._on_slider_changed(0)
 
         self.refreshSumLinePlot()
         self.refreshDiameterPlot()
 
     def refreshSumLinePlot(self):
-        logger.info("")
+        logger.info('')
         if self._ba is None:
             return
         numLineScans = self._kymographAnalysis.numLineScans()
-        # xPlot = self._kymographAnalysis.getResults('time_ms')
-
+        #xPlot = self._kymographAnalysis.getResults('time_ms')
+        
         # xPlot = self._kymographAnalysis.getTimeArray()  # always the same
         # yPlot = self._kymographAnalysis.getResults('sumintensity')
 
         xPlot = self._ba.fileLoader.sweepX
         yPlot = self._ba.fileLoader.sweepY
 
-        self.sumIntensityPlot.setData(xPlot, yPlot, connect="finite")
+        self.sumIntensityPlot.setData(xPlot, yPlot, connect='finite')
 
     def refreshDiameterPlot(self):
-        logger.info("")
+        logger.info('')
         if self._ba is None:
             return
-        # numLineScans = self._kymographAnalysis.numLineScans()
-        # xPlot = self._kymographAnalysis.getResults('time_ms')
-        # xPlot = self._kymographAnalysis.getTimeArray()  # always the same
+        #numLineScans = self._kymographAnalysis.numLineScans()
+        #xPlot = self._kymographAnalysis.getResults('time_ms')
+        #xPlot = self._kymographAnalysis.getTimeArray()  # always the same
         xPlot = self._ba.fileLoader.sweepX
-        yDiam_um = self._kymographAnalysis.getResults("diameter_um")
+        yDiam_um = self._kymographAnalysis.getResults('diameter_um')
 
-        self.diameterPlot.setData(xPlot, yDiam_um, connect="finite")
+        self.diameterPlot.setData(xPlot, yDiam_um, connect='finite')
 
         # show start/stop of fit in main kymograph
-        left_pnt = self._kymographAnalysis.getResults("left_pnt")
-        right_pnt = self._kymographAnalysis.getResults("right_pnt")
-        self._kymWidgetMain.updateLeftRightFit(
-            left_pnt, right_pnt, visible=self._fitIsVivible
-        )
+        left_pnt = self._kymographAnalysis.getResults('left_pnt')
+        right_pnt = self._kymographAnalysis.getResults('right_pnt')
+        self._kymWidgetMain.updateLeftRightFit(left_pnt, right_pnt,
+                                            visible=self._fitIsVivible)
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     app = QtWidgets.QApplication(sys.argv)
 
-    # app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api=os.environ['PYQTGRAPH_QT_LIB']))
-    # app.setStyleSheet(qdarkstyle.load_stylesheet())
-
-    path = "/Users/cudmore/data/kym-example/control 2.5_0012.tif.frames/control 2.5_0012.tif"
-    # path = '/Users/cudmore/data/sa-node-ca-video/HighK-aligned-8bit_ch1.tif'
-
-    path = "/Users/cudmore/data/rosie/Raw data for contraction analysis/Female Old/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif"
+    #app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api=os.environ['PYQTGRAPH_QT_LIB']))
+    #app.setStyleSheet(qdarkstyle.load_stylesheet())
 
+    path = '/Users/cudmore/data/kym-example/control 2.5_0012.tif.frames/control 2.5_0012.tif'
+    #path = '/Users/cudmore/data/sa-node-ca-video/HighK-aligned-8bit_ch1.tif'
+    
+    path = '/Users/cudmore/data/rosie/Raw data for contraction analysis/Female Old/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif'
+    
     ba = sanpy.bAnalysis(path)
 
     kw = kymographPlugin2(ba)
     kw.show()
 
-    # print(kw._kymographAnalysis._getHeader())
+    #print(kw._kymographAnalysis._getHeader())
 
-    sys.exit(app.exec_())
+    sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/__init__.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,45 +1,37 @@
-# from . import *
+#from . import *
 
 from .sanpyPlugin import *
 
 # TODO: Fix this so I do not need to add each
 from .plotRecording import plotRecording
 from .sanpyLog import sanpyLog
 
 from .basePlotTool import basePlotTool
 from .plotTool import plotTool
 from .plotToolPool import plotToolPool
 
 from .plotScatter import plotScatter
-# from .detectionErrors import detectionErrors
+from .detectionErrors import detectionErrors
 from .spikeClips import spikeClips
-
-#from .sanpyPlugin import sanpyPlugin
-
-# from .resultsTable import resultsTable
-# from .resultsTable2 import resultsTable2
-# from .analysisSummary import analysisSummary
-from .summarizeResults import SummarizeResults
-
+from .resultsTable import resultsTable
+from .resultsTable2 import resultsTable2
+from .analysisSummary import analysisSummary
 from .exportTrace import exportTrace
 
 from .fftPlugin import fftPlugin
 from .stimGen import stimGen
 
 from .detectionParams import detectionParams
 
-# remove for publication
-# from .kymographPlugin import kymographPlugin
-
-# from .kymographPlugin2 import kymographPlugin2
+from .kymographPlugin import kymographPlugin
+#from .kymographPlugin2 import kymographPlugin2
 
 from .setSpikeStat import SetSpikeStat
 
 # eventually move this out of plotScatter
 from .plotScatter import myStatListWidget
-from .plotScatter import getPlotMarkersAndColors
 
 from .plotFi import plotFi
 
 # TODO: make this just one line, so user can drop a bplugin inn and restart
 from . import *
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/basePlotTool.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/basePlotTool.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,116 +2,95 @@
 import scipy.signal
 
 from PyQt5 import QtCore, QtGui, QtWidgets
 
 import matplotlib.pyplot as plt
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
 from sanpy.bAnalysisUtil import statList
 
-
 class basePlotTool(sanpyPlugin):
-    """ """
-
-    myHumanName = "Base Plot Tool"
+    """
+    """
+    myHumanName = 'Base Plot Tool'
 
     def __init__(self, **kwargs):
         super(basePlotTool, self).__init__(**kwargs)
 
         self.masterDf = None
         # one
-        # self.masterDf = self.ba.dfReportForScatter
+        #self.masterDf = self.ba.dfReportForScatter
         # pool of bAnalysis
-        # self.masterDf = self._bPlugins._sanpyApp.myAnalysisDir.pool_build()
+        #self.masterDf = self._bPlugins._sanpyApp.myAnalysisDir.pool_build()
 
         self.mainWidget2 = None
 
         # turn off all signal/slot
         switchFile = self.responseTypes.switchFile
         self.toggleResponseOptions(switchFile, newValue=False)
         analysisChange = self.responseTypes.analysisChange
         self.toggleResponseOptions(analysisChange, newValue=False)
         selectSpike = self.responseTypes.selectSpike
         self.toggleResponseOptions(selectSpike, newValue=False)
         setAxis = self.responseTypes.setAxis
         self.toggleResponseOptions(setAxis, newValue=False)
 
-        # self.plot()
+        #self.plot()
 
     def plot(self):
-        logger.info("")
+        logger.info('')
 
         # this plugin does not rely on underlying self.ba
-        # if self.ba is None:
+        #if self.ba is None:
         #    return
 
         # analysisName = 'analysisname'
-        analysisName = "file"
-        statListDict = statList  # maps human readable to comments
-        categoricalList = [
-            "include",
-            "condition",
-            "cellType",
-            "sex",
-            "file",
-            "File Number",
-        ]  # , 'File Name']
-        hueTypes = [
-            "cellType",
-            "sex",
-            "condition",
-            "file",
-            "File Number",
-        ]  # , 'File Name'] #, 'None']
-        sortOrder = ["cellType", "sex", "condition", "File Number"]
-
-        limitToCol = ["epoch"]
-
-        interfaceDefaults = {
-            "Y Statistic": "Spike Frequency (Hz)",
-            "X Statistic": "Spike Frequency (Hz)",
-            "Hue": "cellType",
-            "Group By": "file",
-        }
+        analysisName = 'file'
+        statListDict = statList # maps human readable to comments
+        categoricalList = ['include', 'condition', 'cellType', 'sex', 'file', 'File Number']#, 'File Name']
+        hueTypes = ['cellType', 'sex', 'condition', 'file', 'File Number'] #, 'File Name'] #, 'None']
+        sortOrder = ['cellType', 'sex', 'condition', 'File Number']
+        
+        limitToCol = ['epoch']
+        
+        interfaceDefaults = {'Y Statistic': 'Spike Frequency (Hz)',
+                            'X Statistic': 'Spike Frequency (Hz)',
+                            'Hue': 'cellType',
+                            'Group By': 'file'}
 
-        # analysisName, masterDf = analysisName, df0 = ba.getReportDf(theMin, theMax, savefile)
+        #analysisName, masterDf = analysisName, df0 = ba.getReportDf(theMin, theMax, savefile)
 
-        # print('!!!! FIX THIS in plugin plotTool.plot()')
-        # masterDf = self._bPlugins._sanpyApp.myAnalysisDir.pool_build()
+        #print('!!!! FIX THIS in plugin plotTool.plot()')
+        #masterDf = self._bPlugins._sanpyApp.myAnalysisDir.pool_build()
         # was this
-        # masterDf = self.ba.dfReportForScatter
+        #masterDf = self.ba.dfReportForScatter
 
         if self.masterDf is None:
-            logger.error("Did not get analysis df, be sure to run detectioon")
+            logger.error('Did not get analysis df, be sure to run detectioon')
             return
-        # bScatterPlotMainWindow
-        # self.scatterWindow = sanpy.scatterwidget.bScatterPlotMainWindow(
-        path = ""
+        #bScatterPlotMainWindow
+        #self.scatterWindow = sanpy.scatterwidget.bScatterPlotMainWindow(
+        path = ''
         self.mainWidget2 = sanpy.interface.bScatterPlotMainWindow(
-            path,
-            categoricalList,
-            hueTypes,
-            analysisName,
-            sortOrder,
-            statListDict=statListDict,
-            masterDf=self.masterDf,
-            limitToCol=limitToCol,
-            interfaceDefaults=interfaceDefaults,
-        )
+                        path, categoricalList, hueTypes,
+                        analysisName, sortOrder, statListDict=statListDict,
+                        masterDf = self.masterDf,
+                        limitToCol = limitToCol,
+                        interfaceDefaults = interfaceDefaults)
         # rewire existing widget into plugin architecture
-        # self.mainWidget.closeEvent = self.onClose
+        #self.mainWidget.closeEvent = self.onClose
         self._mySetWindowTitle()
 
-        # self.mainWidget2.show()
+        #self.mainWidget2.show()
 
         tmpLayout = QtWidgets.QVBoxLayout()
         tmpLayout.addWidget(self.mainWidget2)
 
         #
-        # self.setLayout(tmpLayout)
+        #self.setLayout(tmpLayout)
         self.getVBoxLayout().addLayout(tmpLayout)
+
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/detectionParams.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/detectionParams.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,41 +6,38 @@
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class detectionParams(sanpyPlugin):
     """
     Plugin to display overview of detection parameters for analysis.
 
     Uses:
         QTableView: sanpy.interface.bErrorTable.errorTableView()
         QAbstractTableModel: sanpy.interface.bFileTable.pandasModel
     """
-
-    myHumanName = "Detection Parameters"
+    myHumanName = 'Detection Parameters'
 
     def __init__(self, **kwargs):
         super().__init__(**kwargs)
 
-        logger.info("")
-
+        logger.info('')
+        
         # this is a class that holds all premade and loaded presets
         # it exists when runnin the sanpy app
         # if not running sanpy app then build it here (for debuggin)
-        self._detectionObject: sanpy.bDetection = None
-
-        _detectionDict: dict = None
-        _currentDetectionName: str = None
+        self._detectionObject : sanpy.bDetection = None
+        
+        _detectionDict : dict = None
+        _currentDetectionName : str = None
 
         _sanPyApp = self.getSanPyApp()
         if _sanPyApp is not None:
             self._detectionObject = _sanPyApp.getDetectionClass()
         else:
             self._detectionObject = sanpy.bDetection()
 
@@ -53,75 +50,74 @@
         # or, get from app
         if _detectionDict is None:
             # ba is either None or does not have detection yet
             # get the list
             presetList = self._detectionObject.getDetectionPresetList()
             # select first in list
             _currentDetectionName = presetList[0]
-            _detectionDict = self._detectionObject.getDetectionDict(
-                _currentDetectionName
-            )
+            _detectionDict = self._detectionObject.getDetectionDict(_currentDetectionName)        
 
         # deep copy because we are modifying this
         # do not want to change ba (for example) until we detect
         self._detectionDict = _detectionDict  # dict
 
         # the name of the detection dict in ba OR the first detection type in detection class
-        _currentDetectionName = _detectionDict["detectionName"]
+        _currentDetectionName = _detectionDict['detectionName']
         self._currentDetectionName = _currentDetectionName
 
-        self._qLabelRed = "QLabel { background-color : #888822;}"
-        self._qLabelBackground = "QLabel { background-color : #222222;}"
+        self._qLabelRed = 'QLabel { background-color : #888822;}'
+        self._qLabelBackground = 'QLabel { background-color : #222222;}'
 
         self.buildUI()
 
-        # self.insertIntoScrollArea()
+        #self.insertIntoScrollArea()
 
     def buildUI(self):
+
         self.vLayout = QtWidgets.QVBoxLayout()
 
         # top controls
         hControlLayout = QtWidgets.QHBoxLayout()
 
-        fileName = "None"
+        fileName = 'None'
         if self.ba is not None:
             fileName = self.ba.fileLoader.filename
-        self.fileNameLabel = QtWidgets.QLabel(f"File: {fileName}")
+        self.fileNameLabel = QtWidgets.QLabel(f'File: {fileName}')
         hControlLayout.addWidget(self.fileNameLabel, alignment=QtCore.Qt.AlignLeft)
 
-        aName = "Detect"
+        aName = 'Detect'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton, alignment=QtCore.Qt.AlignLeft)
 
-        aName = "Set Defaults"
+        aName = 'Set Defaults'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton, alignment=QtCore.Qt.AlignLeft)
 
         # get list of names of detection presets (like SANode)
-        # detectionPresetList = self.getSanPyApp().getDetectionClass().getDetectionPresetList()
+        #detectionPresetList = self.getSanPyApp().getDetectionClass().getDetectionPresetList()
         detectionPresetList = self._detectionObject.getDetectionPresetList()
 
         aComboBox = QtWidgets.QComboBox()
-        # detectionPresets = sanpy.bDetection.getDetectionPresetList()
+        #detectionPresets = sanpy.bDetection.getDetectionPresetList()
         for detectionPreset in detectionPresetList:
             aComboBox.addItem(detectionPreset)
         aComboBox.setCurrentText(detectionPresetList[0])
         aComboBox.currentTextChanged.connect(self.on_select_detection_preset)
         hControlLayout.addWidget(aComboBox, alignment=QtCore.Qt.AlignLeft)
 
-        aName = "Save Params"
+        aName = 'Save Params'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton, alignment=QtCore.Qt.AlignLeft)
 
         hControlLayout.addStretch()
 
-        """
+        '''
         aName = 'Set Defaults'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton)
 
         aName = 'SA Node'
         aButton = QtWidgets.QPushButton(aName)
@@ -148,192 +144,171 @@
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton)
 
         aName = 'Ca++ Spikes'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click, aName))
         hControlLayout.addWidget(aButton)
-        """
+        '''
 
         #
         self.vLayout.addLayout(hControlLayout)
 
         self.vLayoutParams = self.buildUI2()
         self.vLayout.addLayout(self.vLayoutParams)
 
         #
         # scroll area again
         self._tmpWidget = QtWidgets.QWidget()
         self._tmpWidget.setLayout(self.vLayout)
 
         self.scrollArea = QtWidgets.QScrollArea()
-        self.scrollArea.setWidgetResizable(True)
+        self.scrollArea.setWidgetResizable(True);
         self.scrollArea.setWidget(self._tmpWidget)
 
         self.finalLayout = QtWidgets.QVBoxLayout()
         self.finalLayout.addWidget(self.scrollArea)
 
         # finalize
-        # self.setLayout(self.finalLayout)
+        #self.setLayout(self.finalLayout)
         _vBoxLayout = self.getVBoxLayout()
         _vBoxLayout.addLayout(self.finalLayout)
 
     def buildUI2(self):
-        """Build a control for each detection parameter."""
+        """Build a control for each detection parameter.
+        """
         # list of keys/columns in main analysis dir file list
         analysisDirDict = sanpy.analysisDir.sanpyColumns
 
         dDict = self._detectionObject.getMasterDict(self._currentDetectionName)
-
+        
         vLayoutParams = QtWidgets.QGridLayout()
 
         self.widgetDict = {}  # list of widgets we are displaying
 
         row = 0
         col = 0
         rowSpan = 1
         colSpan = 1
-        for k, v in dDict.items():
+        for k,v in dDict.items():
             col = 0
 
             currentValue = self._detectionDict[k]
 
             # k is the name in spike dictionary
             paramName = k
-            defaultValue = v["defaultValue"]
-            valueType = v[
-                "type"
-            ]  # from ('int', 'float', 'boolean', 'string', detectionTypes_)
-            units = v["units"]
-            humanName = v["humanName"]
-            description = v["description"]
-            allowNone = v["allowNone"]  # set special value for spin box
+            defaultValue = v['defaultValue']
+            valueType = v['type']  # from ('int', 'float', 'boolean', 'string', detectionTypes_)
+            units = v['units']
+            humanName = v['humanName']
+            description = v['description']
+            allowNone = v['allowNone']  # set special value for spin box
 
             # flag with red
             flagWithRed = currentValue != defaultValue
 
             inAnalysisDir = paramName in analysisDirDict.keys()
 
             # add an '*' for params in main file table keys/columns
-            aName = " "
+            aName = ' '
             if inAnalysisDir:
-                aName = "*"
-            nameLabel = QtWidgets.QLabel(
-                aName
-            )  # added to list so we can later set color
+                aName = '*'
+            nameLabel = QtWidgets.QLabel(aName)  # added to list so we can later set color
             col += 1
 
             # for debugging
-            """
+            '''
             aLabel = QtWidgets.QLabel(paramName)
             vLayoutParams.addWidget(aLabel, row, col, rowSpan, colSpan)
             col += 1
-            """
+            '''
 
             humanNameLabel = QtWidgets.QLabel(humanName)
             vLayoutParams.addWidget(nameLabel, row, col, rowSpan, colSpan)
             if flagWithRed:
                 humanNameLabel.setStyleSheet(self._qLabelRed)
             vLayoutParams.addWidget(humanNameLabel, row, col, rowSpan, colSpan)
             col += 1
 
             # for debugging
-            """
+            '''
             aLabel = QtWidgets.QLabel(valueType)
             vLayoutParams.addWidget(aLabel, row, col, rowSpan, colSpan)
             col += 1
-            """
+            '''
 
             aLabel = QtWidgets.QLabel(units)
             vLayoutParams.addWidget(aLabel, row, col, rowSpan, colSpan)
             col += 1
 
             aWidget = None
-            if valueType == "int":
+            if valueType == 'int':
                 aWidget = QtWidgets.QSpinBox()
-                aWidget.setRange(
-                    0, 2**16
-                )  # minimum is used for setSpecialValueText()
-                aWidget.setSpecialValueText(
-                    "None"
-                )  # displayed when widget is set to minimum
+                aWidget.setRange(0, 2**16)  # minimum is used for setSpecialValueText()
+                aWidget.setSpecialValueText("None")  # displayed when widget is set to minimum
                 if currentValue is None or math.isnan(currentValue):
                     aWidget.setValue(0)
                 else:
                     aWidget.setValue(currentValue)
-                aWidget.setKeyboardTracking(False)  # don't trigger signal as user edits
+                aWidget.setKeyboardTracking(False) # don't trigger signal as user edits
                 aWidget.valueChanged.connect(partial(self.on_spin_box, paramName))
-            elif valueType == "float":
+            elif valueType == 'float':
                 aWidget = QtWidgets.QDoubleSpinBox()
-                aWidget.setRange(
-                    -1e9, +1e9
-                )  # minimum is used for setSpecialValueText()
-                aWidget.setSpecialValueText(
-                    "None"
-                )  # displayed when widget is set to minimum
+                aWidget.setRange(-1e9, +1e9)  # minimum is used for setSpecialValueText()
+                aWidget.setSpecialValueText("None")  # displayed when widget is set to minimum
 
                 if currentValue is None or math.isnan(currentValue):
                     aWidget.setValue(-1e9)
                 else:
                     aWidget.setValue(currentValue)
-                aWidget.setKeyboardTracking(False)  # don't trigger signal as user edits
+                aWidget.setKeyboardTracking(False) # don't trigger signal as user edits
                 aWidget.valueChanged.connect(partial(self.on_spin_box, paramName))
-            elif valueType == "list":
+            elif valueType == 'list':
                 # text edit a list
                 pass
-            elif valueType in ["bool", "boolean"]:
+            elif valueType in ['bool', 'boolean']:
                 # popup of True/False
                 aWidget = QtWidgets.QComboBox()
-                aWidget.addItem("True")
-                aWidget.addItem("False")
+                aWidget.addItem('True')
+                aWidget.addItem('False')
                 aWidget.setCurrentText(str(currentValue))
-                aWidget.currentTextChanged.connect(
-                    partial(self.on_bool_combo_box, paramName)
-                )
-            elif valueType == "string":
+                aWidget.currentTextChanged.connect(partial(self.on_bool_combo_box, paramName))
+            elif valueType == 'string':
                 # text edit
                 aWidget = QtWidgets.QLineEdit(currentValue)
                 aWidget.setReadOnly(True)  # for now our 1 edit widget is not editable
-                # aWidget.setKeyboardTracking(False) # don't trigger signal as user edits
-                # aWidget.setValidator(QIntValidator())
-                # aWidget.setMaxLength(4)
+                #aWidget.setKeyboardTracking(False) # don't trigger signal as user edits
+                #aWidget.setValidator(QIntValidator())
+                #aWidget.setMaxLength(4)
                 aWidget.setAlignment(QtCore.Qt.AlignLeft)
-                aWidget.editingFinished.connect(
-                    partial(self.on_text_edit, aWidget, paramName)
-                )
-            elif valueType == "sanpy.bDetection.detectionTypes":
+                aWidget.editingFinished.connect(partial(self.on_text_edit, aWidget, paramName))
+            elif valueType == 'sanpy.bDetection.detectionTypes':
                 aWidget = QtWidgets.QComboBox()
                 detectionTypes = sanpy.bDetection.detectionTypes
                 for theType in detectionTypes:
                     aWidget.addItem(theType.name)
                 aWidget.setCurrentText(str(currentValue))
-                aWidget.currentTextChanged.connect(
-                    partial(self.on_detection_type_combo_box, paramName)
-                )
+                aWidget.currentTextChanged.connect(partial(self.on_detection_type_combo_box, paramName))
             else:
-                logger.error(
-                    f'Did not understand valueType:"{valueType}" for parameter:"{paramName}"'
-                )
+                logger.error(f'Did not understand valueType:"{valueType}" for parameter:"{paramName}"')
 
             if aWidget is not None:
+                
                 # keep track of what we are displaying
                 # used to we can get default value (form 'key' and set label to red
-                self.widgetDict[paramName] = {
-                    "widget": aWidget,
-                    "nameLabelWidget": humanNameLabel,
-                }
-
+                self.widgetDict[paramName] = {'widget': aWidget, 'nameLabelWidget':humanNameLabel}
+                
                 vLayoutParams.addWidget(aWidget, row, col, rowSpan, colSpan)
             #
             col += 1
 
             # add a 'None' button for detection parameters that allow it
             if allowNone:
-                aName = f"{paramName}_none"
-                aButton = QtWidgets.QPushButton("Set None")
+                aName = f'{paramName}_none'
+                aButton = QtWidgets.QPushButton('Set None')
                 aButton.clicked.connect(partial(self.on_button_click, aName))
                 vLayoutParams.addWidget(aButton, row, col, rowSpan, colSpan)
             #
             col += 1
 
             aLabel = QtWidgets.QLabel(description)
             vLayoutParams.addWidget(aLabel, row, col, rowSpan, colSpan)
@@ -341,105 +316,101 @@
             #
             row += 1
         #
         return vLayoutParams
 
     def _setDict(self, detectionParam, value):
         """Respond to user chhanging a detection parameter.
-
+        
         This is getting triggered when we update values in Widgets in replot()
         Not intended but just be aware
         """
-        logger.info(
-            f'Setting dDict key:"{detectionParam}" to value "{value}" type:{type(value)}'
-        )
+        logger.info(f'Setting dDict key:"{detectionParam}" to value "{value}" type:{type(value)}')
         if value == -1e9:
-            # print(f'TWEAK paramName:{paramName} --->>> value:', value)
+            #print(f'TWEAK paramName:{paramName} --->>> value:', value)
             value = None
-        # ok = self.detectionClass.setValue(paramName, value)
+        #ok = self.detectionClass.setValue(paramName, value)
         # if not ok:
         #     logger.error('')
         self._detectionDict[detectionParam] = value
 
         _masterDict = self._detectionObject.getMasterDict(self._currentDetectionName)
-        defaultValue = _masterDict[detectionParam]["defaultValue"]
+        defaultValue = _masterDict[detectionParam]['defaultValue']
         flagWithRed = value != defaultValue
-        aLabel = self.widgetDict[detectionParam]["nameLabelWidget"]
+        aLabel = self.widgetDict[detectionParam]['nameLabelWidget']
         if flagWithRed:
             aLabel.setStyleSheet(self._qLabelRed)
         else:
             aLabel.setStyleSheet(self._qLabelBackground)
 
     def on_bool_combo_box(self, paramName, text):
-        # logger.info(f'paramName:{paramName} text:"{text}" {type(text)}')
-        value = text == "True"
+        #logger.info(f'paramName:{paramName} text:"{text}" {type(text)}')
+        value = text == 'True'
         self._setDict(paramName, value)
 
     def on_detection_type_combo_box(self, paramName, text):
-        # logger.info(f'paramName:"{paramName}" text:"{text}"')
+        #logger.info(f'paramName:"{paramName}" text:"{text}"')
         self._setDict(paramName, text)
 
     def on_text_edit(self, aWidget, paramName):
         text = aWidget.text()
-        # logger.info(f'paramName:{paramName} text:"{text}"')
+        #logger.info(f'paramName:{paramName} text:"{text}"')
         self._setDict(paramName, text)
 
     def on_spin_box(self, paramName, value):
         """
         When QDoubldeSpinBox accepts None, value is -1e9
         """
-        # logger.info(f'paramName:{paramName} value:"{value}" {type(value)}')
+        #logger.info(f'paramName:{paramName} value:"{value}" {type(value)}')
         self._setDict(paramName, value)
 
     def detect(self):
-        logger.info("detecting spikes")
-
+        logger.info('detecting spikes')
+        
         if self.ba is None:
             return
 
         # spike detect
         self.ba.spikeDetect(self._detectionDict)
 
-        logger.info(f"detected {self.ba.numSpikes} spikes")
+        logger.info(f'detected {self.ba.numSpikes} spikes')
 
         # update interface
         self.signalDetect.emit(self.ba)
 
-    def on_select_detection_preset(self, detectionPresetName: str):
-        """User selected a detection preset from combobox."""
+    def on_select_detection_preset(self, detectionPresetName : str):
+        """User selected a detection preset from combobox.
+        """
         logger.info(f'detectionPresetName:"{detectionPresetName}"')
-        # detectionPreset = sanpy.bDetection.detectionPresets[detectionPreset]
-        # detectionPreset = sanpy.bDetection.detectionPresets(detectionPreset)
-        # self.detectionClass.setToType(detectionPreset)
-
+        #detectionPreset = sanpy.bDetection.detectionPresets[detectionPreset]
+        #detectionPreset = sanpy.bDetection.detectionPresets(detectionPreset)
+        #self.detectionClass.setToType(detectionPreset)
+        
         # grab the detection from sanpy app
-        self._detectionDict = self._detectionObject.getDetectionDict(
-            detectionPresetName
-        )
-        self._currentDetectionName = self._detectionDict["detectionName"]
+        self._detectionDict = self._detectionObject.getDetectionDict(detectionPresetName)
+        self._currentDetectionName = self._detectionDict['detectionName']
 
         self.replot()
 
     def on_button_click(self, buttonName):
-        if buttonName == "Detect":
+
+        if buttonName == 'Detect':
             # take our current dDict and ba.detectSpikes
             # need to signal main interface we did this
             self.detect()
 
-        elif buttonName == "Set Defaults":
+        elif buttonName == 'Set Defaults':
             # set current dict to defaults from sanpy.bDetection
-            self._detectionDict = self._detectionObject.getDetectionDict(
-                self._currentDetectionName
-            )
-            self._currentDetectionName = self._detectionDict["detectionName"]
+            self._detectionDict = self._detectionObject.getDetectionDict(self._currentDetectionName)
+            self._currentDetectionName = self._detectionDict['detectionName']
 
             # refresh interface
             self.replot()
-
-        elif buttonName == "Save Params":
+        
+        elif buttonName == 'Save Params':
             self.save()
 
         # elif buttonName == 'SA Node':
         #     detectionPreset = sanpy.bDetection.detectionPresets.sanode
         #     self.detectionClass.setToType(detectionPreset)
         #     # refresh interface
         #     self.replot()
@@ -465,152 +436,143 @@
         #     self.replot()
         # elif buttonName == 'Ca++ Kymograph':
         #     detectionPreset = sanpy.bDetection.detectionPresets.cakymograph
         #     self.detectionClass.setToType(detectionPreset)
         #     # refresh interface
         #     self.replot()
 
-        elif buttonName.endswith("_none"):
+        elif buttonName.endswith('_none'):
             # set a parameter to None, will only work if 'allowNone'
-            paramName = buttonName.replace("_none", "")
+            paramName = buttonName.replace('_none', '')
             self._setDict(paramName, None)
             self.replot()
 
         else:
             logger.warning(f'Button "{buttonName}" not understood.')
 
     def replot(self):
-        # if self.ba is None:
+        #if self.ba is None:
         #    return
 
-        logger.info("")
+        logger.info('')
 
         # was this
-        # detectionClass = self.detectionClass
+        #detectionClass = self.detectionClass
         detectionDict = self._detectionDict
 
         _masterDict = self._detectionObject.getMasterDict(self._currentDetectionName)
 
-        # for detectionParam in detectionClass.keys():
+        #for detectionParam in detectionClass.keys():
         for detectionParam in detectionDict.keys():
             if detectionParam not in self.widgetDict.keys():
-                logger.warning(
-                    f'detectionParam missing "{detectionParam}" -->> not adding to display'
-                )
+                logger.warning(f'detectionParam missing "{detectionParam}" -->> not adding to display')
                 continue
 
-            # currentValue = v['currentValue']
-            # currentValue = detectionClass.getValue(detectionParam)
+            #currentValue = v['currentValue']
+            #currentValue = detectionClass.getValue(detectionParam)
             currentValue = detectionDict[detectionParam]
 
-            defaultValue = _masterDict[detectionParam]["defaultValue"]
+            defaultValue = _masterDict[detectionParam]['defaultValue']
             flagWithRed = defaultValue != currentValue
 
             if currentValue == -1e9:
-                logger.error(
-                    f"XXXXX detectionParam:{detectionParam} currentValue:{currentValue} {type(currentValue)}"
-                )
+                logger.error(f'XXXXX detectionParam:{detectionParam} currentValue:{currentValue} {type(currentValue)}')
                 currentValue = None
 
-            aLabel = self.widgetDict[detectionParam]["nameLabelWidget"]
+            aLabel = self.widgetDict[detectionParam]['nameLabelWidget']
             if flagWithRed:
                 aLabel.setStyleSheet(self._qLabelRed)
                 aLabel.update()
             else:
                 aLabel.setStyleSheet(self._qLabelBackground)
                 aLabel.update()
 
-            aWidget = self.widgetDict[detectionParam]["widget"]
+            aWidget = self.widgetDict[detectionParam]['widget']
             if isinstance(aWidget, QtWidgets.QSpinBox):
                 try:
                     if currentValue is None or math.isnan(currentValue):
                         aWidget.setValue(0)
                     else:
                         aWidget.setValue(currentValue)
-                except TypeError as e:
-                    logger.error(f"QSpinBox detectionParam:{detectionParam} ... {e}")
+                except (TypeError) as e:
+                    logger.error(f'QSpinBox detectionParam:{detectionParam} ... {e}')
             elif isinstance(aWidget, QtWidgets.QDoubleSpinBox):
                 try:
                     if currentValue is None or math.isnan(currentValue):
                         aWidget.setValue(-1e9)
                     else:
                         aWidget.setValue(currentValue)
-                except TypeError as e:
-                    logger.error(
-                        f"QDoubleSpinBox detectionParam:{detectionParam} ... {e}"
-                    )
+                except (TypeError) as e:
+                    logger.error(f'QDoubleSpinBox detectionParam:{detectionParam} ... {e}')
             elif isinstance(aWidget, QtWidgets.QComboBox):
                 aWidget.setCurrentText(str(currentValue))
             elif isinstance(aWidget, QtWidgets.QLineEdit):
                 aWidget.setText(str(currentValue))
             else:
-                logger.warning(
-                    f'key "{detectionParam}" has value "{currentValue}" but widget type "{type(aWidget)}" not understood.'
-                )
-
-    def slot_switchFile(
-        self, ba: sanpy.bAnalysis, rowDict: Optional[dict] = None, replot: bool = True
-    ):
+                logger.warning(f'key "{detectionParam}" has value "{currentValue}" but widget type "{type(aWidget)}" not understood.')
+
+    def slot_switchFile(self,
+                        ba : sanpy.bAnalysis,
+                        rowDict : Optional[dict] = None,
+                        replot : bool = True):
         # don't replot until we set our detectionClass
         replot = False
         super().slot_switchFile(ba, rowDict, replot=replot)
-
+        
         # before we detect a ba, its detection dict is None
         _detectionDict = self.ba.getDetectionDict(asCopy=True)  # can be None
         if _detectionDict is not None:
-            self._detectionDict = _detectionDict  #
-            self._currentDetectionName = _detectionDict["detectionName"]
+            self._detectionDict = _detectionDict  # 
+            self._currentDetectionName = _detectionDict['detectionName']
 
         self.replot()
 
     def save(self):
-        """Save our current detection dict to a user file."""
+        """Save our current detection dict to a user file.
+        """
         userDetectionFolder = sanpy._util._getUserDetectionFolder()
 
         # key 'detectionName'
-        filename = self._detectionDict["userSaveName"]
+        filename = self._detectionDict['userSaveName']
         if not filename:
-            filename = self._detectionDict["detectionName"] + " User"
-
-        savePath = os.path.join(userDetectionFolder, filename + ".json")
+            filename = self._detectionDict['detectionName'] + ' User'
+            
+        savePath = os.path.join(userDetectionFolder, filename+'.json')
 
-        userSaveFile, _tmp = QtWidgets.QFileDialog.getSaveFileName(
-            self, "Save Detection Params", savePath
-        )
+        userSaveFile, _tmp = QtWidgets.QFileDialog.getSaveFileName(self, 'Save Detection Params', savePath)
         logger.info(userSaveFile)
 
-        with open(userSaveFile, "w") as f:
-            self._detectionDict["userSaveName"] = filename
+        with open(userSaveFile, 'w') as f:
+            self._detectionDict['userSaveName'] = filename
             json.dump(self._detectionDict, f, indent=4)
 
+if __name__ == '__main__':
 
-if __name__ == "__main__":
-    path = "data/19114001.abf"
+    path = 'data/19114001.abf'
     ba = sanpy.bAnalysis(path)
 
     bd = sanpy.bDetection()  # gets default
-    dDict = bd.getDetectionDict("SA Node")  # an actual dict
+    dDict = bd.getDetectionDict('SA Node')  # an actual dict
 
     # from pprint import pprint
     # pprint(dDict)
-
-    # dDict['dvdtThreshold'] = 12
+    
+    #dDict['dvdtThreshold'] = 12
 
     ba.spikeDetect(dDict)
-    logger.info(f"detected numSpike:{ba.numSpikes}")
+    logger.info(f'detected numSpike:{ba.numSpikes}')
 
     import sys
-
     app = QtWidgets.QApplication([])
 
     dp = detectionParams(ba=ba)  # dec 2022, do not pass bd
     dp.show()
 
-    """
+    '''
     scrollArea = dp.insertIntoScrollArea()
     if scrollArea is not None:
         scrollArea.show()
     else:
         dp.show()
-    """
+    '''
 
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/exportTrace.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/exportTrace.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,125 +2,114 @@
 import scipy.signal
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 import matplotlib.pyplot as plt
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
 from sanpy.bAnalysisUtil import statList
 
-
 class exportTrace(sanpyPlugin):
-    """ """
-
-    myHumanName = "Export Trace"
+    """
+    """
+    myHumanName = 'Export Trace'
 
     def __init__(self, **kwargs):
         super(exportTrace, self).__init__(**kwargs)
 
         # this plugin will not respond to any interface changes
-        # self.turnOffAllSignalSlot()
+        #self.turnOffAllSignalSlot()
 
         self.mainWidget = None
 
         self.plot()
 
     def replot(self):
-        logger.info(f"sweepNumber: {self.sweepNumber}")
+        logger.info(f'sweepNumber: {self.sweepNumber}')
 
         if self.mainWidget is None:
             self.plot()
 
-        x = self.getSweep("x")  # get for current sweep
-        y = self.getSweep("y")
+        x = self.getSweep('x')  # get for current sweep
+        y = self.getSweep('y')
         self.mainWidget.switchFile(self.ba, x, y)
-
+        
     def plot(self):
         if self.ba is None:
             return
 
-        self.myType = "vmFiltered"
+        self.myType = 'vmFiltered'
 
-        if self.myType == "vmFiltered":
-            xyUnits = ("Time (sec)", "Vm (mV)")  # todo: pass xMin,xMax to constructor
-            x = self.getSweep("x")  # corresponds to sweepX
-            y = self.getSweep("y")  # corresponds to sweepY
-        elif self.myType == "dvdtFiltered":
-            xyUnits = (
-                "Time (sec)",
-                "dV/dt (mV/ms)",
-            )  # todo: pass xMin,xMax to constructor
-        elif self.myType == "meanclip":
-            xyUnits = ("Time (ms)", "Vm (mV)")  # todo: pass xMin,xMax to constructor
+        if self.myType == 'vmFiltered':
+            xyUnits = ('Time (sec)', 'Vm (mV)')# todo: pass xMin,xMax to constructor
+            x = self.getSweep('x')  # corresponds to sweepX
+            y = self.getSweep('y')  # corresponds to sweepY
+        elif self.myType == 'dvdtFiltered':
+            xyUnits = ('Time (sec)', 'dV/dt (mV/ms)')# todo: pass xMin,xMax to constructor
+        elif self.myType == 'meanclip':
+            xyUnits = ('Time (ms)', 'Vm (mV)')# todo: pass xMin,xMax to constructor
         else:
             logger.error(f'Unknown myType: "{self.myType}"')
-            xyUnits = ("error time", "error y")
+            xyUnits = ('error time', 'error y')
 
         path = self.ba.fileLoader.filepath
 
         xMin, xMax = self.getStartStop()
-        """
+        '''
         xMin = None
         xMax = None
         if self.myType in ['clip', 'meanclip']:
             xMin, xMax = self.detectionWidget.clipPlot.getAxis('bottom').range
         else:
             xMin, xMax = self.detectionWidget.getXRange()
-        """
+        '''
 
-        if self.myType in ["vm", "dvdt"]:
-            xMargin = 2  # seconds
+        if self.myType in ['vm', 'dvdt']:
+            xMargin = 2 # seconds
         else:
             xMargin = 2
 
         # a large x margin was causing matplotlib erors when a swep was short, like 0.2 sec
         xMargin = 0
-
+        
         tmpLayout = QtWidgets.QVBoxLayout()
 
-        self.mainWidget = sanpy.interface.bExportWidget(
-            x,
-            y,
-            xyUnits=xyUnits,
-            path=path,
-            xMin=xMin,
-            xMax=xMax,
-            xMargin=xMargin,
-            type=self.myType,
-            darkTheme=True,
-        )
-        # darkTheme=self.detectionWidget.useDarkStyle)
+        self.mainWidget = sanpy.interface.bExportWidget(x, y,
+                        xyUnits=xyUnits,
+                        path=path,
+                        xMin=xMin, xMax=xMax,
+                        xMargin = xMargin,
+                        type = self.myType,
+                        darkTheme = True)
+                        #darkTheme=self.detectionWidget.useDarkStyle)
 
         tmpLayout.addWidget(self.mainWidget)
 
         # rewire existing widget into plugin architecture
-        # self.mainWidget.closeEvent = self.onClose
-        # self._mySetWindowTitle()
+        #self.mainWidget.closeEvent = self.onClose
+        #self._mySetWindowTitle()
 
-        # self.setCentralWidget(self.mainWidget)
-        # self.setLayout(tmpLayout)
+        #self.setCentralWidget(self.mainWidget)
+        #self.setLayout(tmpLayout)
         self.getVBoxLayout().addLayout(tmpLayout)
-
-
-if __name__ == "__main__":
-    path = "/Users/cudmore/Sites/SanPy/data/19114001.abf"
+        
+if __name__ == '__main__':
+    path = '/Users/cudmore/Sites/SanPy/data/19114001.abf'
     ba = sanpy.bAnalysis(path)
     ba.spikeDetect()
     print(ba.numSpikes)
 
     import sys
-
     app = QtWidgets.QApplication([])
     et = exportTrace(ba=ba)
     et.show()
 
-    path2 = "/Users/cudmore/Sites/SanPy/data/19114000.abf"
+    path2 = '/Users/cudmore/Sites/SanPy/data/19114000.abf'
     ba2 = sanpy.bAnalysis(path2)
     et.mainWidget.switchFile(ba2)
 
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/fftPlugin.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/fftPlugin.py`

 * *Files 8% similar despite different names*

```diff
@@ -21,95 +21,86 @@
 import matplotlib as mpl
 import matplotlib.pyplot as plt
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-def butter_sos(cutOff, fs, order=50, passType="lowpass"):
+def butter_sos(cutOff, fs, order=50, passType='lowpass'):
     """
     passType (str): ('lowpass', 'highpass')
     """
 
-    """
+    '''
     nyq = fs * 0.5
     normal_cutoff = cutOff / nyq
-    """
+    '''
 
-    logger.info(
-        f"Making butter file with order:{order} cutOff:{cutOff} passType:{passType} fs:{fs}"
-    )
-
-    # sos = butter(order, normal_cutoff, btype='low', analog=False, output='sos')
-    # sos = scipy.signal.butter(N=order, Wn=normal_cutoff, btype=passType, analog=False, fs=fs, output='sos')
-    sos = scipy.signal.butter(
-        N=order, Wn=cutOff, btype=passType, analog=False, fs=fs, output="sos"
-    )
-    return sos
+    logger.info(f'Making butter file with order:{order} cutOff:{cutOff} passType:{passType} fs:{fs}')
 
+    #sos = butter(order, normal_cutoff, btype='low', analog=False, output='sos')
+    #sos = scipy.signal.butter(N=order, Wn=normal_cutoff, btype=passType, analog=False, fs=fs, output='sos')
+    sos = scipy.signal.butter(N=order, Wn=cutOff, btype=passType, analog=False, fs=fs, output='sos')
+    return sos
 
 def spikeDetect(t, dataFiltered, dataThreshold2, startPoint=None, stopPoint=None):
     verbose = False
-    # dataThreshold2 = -59.81
+    #dataThreshold2 = -59.81
 
     g_backupFraction = 0.3  # 0.5 or 0.3
 
-    logger.info(
-        f"dataThreshold2:{dataThreshold2} startPoint:{startPoint} stopPoint:{stopPoint}"
-    )
+    logger.info(f'dataThreshold2:{dataThreshold2} startPoint:{startPoint} stopPoint:{stopPoint}')
 
     #
     # detect spikes, dataThreshold2 changes as we zoom
-    Is = np.where(dataFiltered > dataThreshold2)[0]
-    Is = np.concatenate(([0], Is))
-    Ds = Is[:-1] - Is[1:] + 1
-    spikePoints = Is[np.where(Ds)[0] + 1]
+    Is = np.where(dataFiltered>dataThreshold2)[0]
+    Is=np.concatenate(([0],Is))
+    Ds=Is[:-1]-Is[1:]+1
+    spikePoints = Is[np.where(Ds)[0]+1]
     spikeSeconds = t[spikePoints]
 
     #
     # Throw out spikes that are within refractory (ms) of previous
     spikePoints = _throwOutRefractory(spikePoints, refractory_ms=100)
     spikeSeconds = t[spikePoints]
 
     #
     # remove spikes outside of start/stop
     goodSpikes = []
     if startPoint is not None and stopPoint is not None:
         if verbose:
-            print(f"  Removing spikes outside point range {startPoint} ... {stopPoint}")
-        # print(f'    {t[startPoint]} ... {t[stopPoint]} (s)')
+            print(f'  Removing spikes outside point range {startPoint} ... {stopPoint}')
+        #print(f'    {t[startPoint]} ... {t[stopPoint]} (s)')
         for idx, spikePoint in enumerate(spikePoints):
-            if spikePoint < startPoint or spikePoint > stopPoint:
+            if spikePoint<startPoint or spikePoint>stopPoint:
                 pass
             else:
                 goodSpikes.append(spikePoint)
                 if verbose:
-                    print(f"    appending spike {idx} {t[spikePoint]}(s)")
+                    print(f'    appending spike {idx} {t[spikePoint]}(s)')
     #
     spikePoints = goodSpikes
     spikeSeconds = t[spikePoints]
 
     #
     # only accept rising phase
-    windowPoints = 40  # assuming 10 kHz -->> 4 ms
+    windowPoints = 40 # assuming 10 kHz -->> 4 ms
     goodSpikes = []
     for idx, spikePoint in enumerate(spikePoints):
-        preClip = dataFiltered[spikePoint - windowPoints : spikePoint - 1]
-        postClip = dataFiltered[spikePoint + 1 : spikePoint + windowPoints]
+        preClip = dataFiltered[spikePoint-windowPoints:spikePoint-1]
+        postClip = dataFiltered[spikePoint+1:spikePoint+windowPoints]
         preMean = np.nanmean(preClip)
         postMean = np.nanmean(postClip)
         if preMean < postMean:
             goodSpikes.append(spikePoint)
         else:
             pass
-            # print(f'  rejected spike {idx}, at point {spikePoint}')
+            #print(f'  rejected spike {idx}, at point {spikePoint}')
     #
     spikePoints = goodSpikes
     spikeSeconds = t[spikePoints]
 
     #
     # throw out above take-off-potential of APs (-30 mV)
     apTakeOff = -30
@@ -124,89 +115,80 @@
     #
     # find peak for eack spike
     # at 500 pnts, assuming spikes are slower than 20 Hz
     peakWindow_pnts = 500
     peakPoints = []
     peakVals = []
     for idx, spikePoint in enumerate(spikePoints):
-        peakPnt = np.argmax(dataFiltered[spikePoint : spikePoint + peakWindow_pnts])
+        peakPnt = np.argmax(dataFiltered[spikePoint:spikePoint+peakWindow_pnts])
         peakPnt += spikePoint
-        peakVal = np.max(dataFiltered[spikePoint : spikePoint + peakWindow_pnts])
+        peakVal = np.max(dataFiltered[spikePoint:spikePoint+peakWindow_pnts])
         #
         peakPoints.append(peakPnt)
         peakVals.append(peakVal)
 
     #
     # backup each spike until pre/post is not changing
     # uses g_backupFraction to get percent of dv/dt at spike veruus each backup window
     backupWindow_pnts = 30
     maxSteps = 30  # 30 steps at 20 pnts (2ms) per step gives 60 ms
     backupSpikes = []
     for idx, spikePoint in enumerate(spikePoints):
-        # print(f'=== backup spike:{idx} at {t[spikePoint]}(s)')
+        #print(f'=== backup spike:{idx} at {t[spikePoint]}(s)')
         foundBackupPoint = None
         for step in range(maxSteps):
-            tmpPnt = spikePoint - (step * backupWindow_pnts)
+            tmpPnt = spikePoint - (step*backupWindow_pnts)
             tmpSeconds = t[tmpPnt]
-            preClip = dataFiltered[
-                tmpPnt - 1 - backupWindow_pnts : tmpPnt - 1
-            ]  # reversed
-            postClip = dataFiltered[tmpPnt + 1 : tmpPnt + 1 + backupWindow_pnts]
+            preClip = dataFiltered[tmpPnt-1-backupWindow_pnts:tmpPnt-1]  # reversed
+            postClip = dataFiltered[tmpPnt+1:tmpPnt+1+backupWindow_pnts]
             preMean = np.nanmean(preClip)
             postMean = np.nanmean(postClip)
             diffMean = postMean - preMean
             if step == 0:
                 initialDiff = diffMean
-            # print(f'  spike {idx} step:{step} tmpSeconds:{round(tmpSeconds,4)} initialDiff:{round(initialDiff,4)} diff:{round(diffMean,3)}')
+            #print(f'  spike {idx} step:{step} tmpSeconds:{round(tmpSeconds,4)} initialDiff:{round(initialDiff,4)} diff:{round(diffMean,3)}')
             # if diffMean is 1/2 initial AP slope then accept
             if diffMean < (initialDiff * g_backupFraction):
                 # stop
                 if foundBackupPoint is None:
                     foundBackupPoint = tmpPnt
-                # break
+                #break
         #
         if foundBackupPoint is not None:
             backupSpikes.append(foundBackupPoint)
         else:
             # needed to keep spike parity
-            logger.warning(
-                f"Did not find backupSpike for spike {idx} at {t[spikePoint]}(s)"
-            )
+            logger.warning(f'Did not find backupSpike for spike {idx} at {t[spikePoint]}(s)')
             backupSpikes.append(spikePoint)
 
     #
     # use backupSpikes (points) to get each spike amplitude
     spikeAmps = []
     for idx, backupSpike in enumerate(backupSpikes):
-        if backupSpikes == np.nan or math.isnan(backupSpike):
+        if backupSpikes==np.nan or math.isnan(backupSpike):
             continue
-        # print('backupSpike:', backupSpike)
+        #print('backupSpike:', backupSpike)
         footVal = dataFiltered[backupSpike]
         peakVal = peakVals[idx]
         spikeAmp = peakVal - footVal
         spikeAmps.append(spikeAmp)
 
     # TODO: use foot and peak to get real half/width
-    theseWidths = [10, 20, 50, 80, 90]
-    window_ms = 100
-    spikeDictList = _getHalfWidths(
-        t,
-        dataFiltered,
-        backupSpikes,
-        peakPoints,
-        theseWidths=theseWidths,
-        window_ms=window_ms,
-    )
-    # for idx, spikeDict in enumerate(spikeDictList):
+    theseWidths=[10,20,50,80,90]
+    window_ms=100
+    spikeDictList = _getHalfWidths(t, dataFiltered,
+                        backupSpikes, peakPoints,
+                        theseWidths=theseWidths, window_ms=window_ms)
+    #for idx, spikeDict in enumerate(spikeDictList):
     #    print(idx, spikeDict)
 
     #
     # get estimate of duration
     # for each spike, find next downward crossing (starting at peak)
-    """
+    '''
     minDurationPoints = 10
     windowPoints = 1000  # 100 ms
     fallingPoints = []
     for idx, spikePoint in enumerate(spikePoints):
         peakPoint = peakPoints[idx]
         backupPoint = backupSpikes[idx]
         if backupPoint == np.nan or math.isnan(backupPoint):
@@ -228,232 +210,211 @@
             else:
                 print(f'  reject spike {idx} at {spikeSecond} (s), duration is {duration} points, minDurationPoints:{minDurationPoints}')
                 #fallingPoints.append(fallingPoint)
         else:
             print(f'    did not find falling pnt for spike {idx} at {spikeSecond}(s) point {spikePoint}, assume it is longer than windowPoints')
             pass
             #fallingPoints.append(np.nan)
-    """
+    '''
 
     # TODO: Package all results into a dictionary
     spikeDictList = [{}] * len(spikePoints)
     for idx, spikePoint in enumerate(spikePoints):
-        """
+        '''
         spikeSecond = spikeSeconds[idx]
         peakPoint = peakPoints[idx]
         peakVal = peakVals[idx]
         fallingPoint = fallingPoints[idx]  # get rid of this
         backupSpike = backupSpikes[idx]  # get rid of this
         spikeAmp = spikeAmps[idx]  # get rid of this
-        """
-        spikeDictList[idx]["spikePoint"] = spikePoint
-        spikeDictList[idx]["spikeSecond"] = spikeSeconds[idx]
-        spikeDictList[idx]["peakPoint"] = peakPoints[idx]
-        spikeDictList[idx]["peakVal"] = peakVals[idx]
-        # spikeDictList[idx]['fallingPoint'] = fallingPoints[idx]
-        spikeDictList[idx]["backupSpike"] = backupSpikes[idx]
-        spikeDictList[idx]["spikeAmp"] = spikeAmps[idx]
+        '''
+        spikeDictList[idx]['spikePoint'] = spikePoint
+        spikeDictList[idx]['spikeSecond'] = spikeSeconds[idx]
+        spikeDictList[idx]['peakPoint'] = peakPoints[idx]
+        spikeDictList[idx]['peakVal'] = peakVals[idx]
+        #spikeDictList[idx]['fallingPoint'] = fallingPoints[idx]
+        spikeDictList[idx]['backupSpike'] = backupSpikes[idx]
+        spikeDictList[idx]['spikeAmp'] = spikeAmps[idx]
     #
     spikeSeconds = t[spikePoints]
-    # return spikeSeconds, spikePoints, peakPoints, peakVals, fallingPoints, backupSpikes, spikeAmps
+    #return spikeSeconds, spikePoints, peakPoints, peakVals, fallingPoints, backupSpikes, spikeAmps
     # removved fallingPoints
-    return (
-        spikeDictList,
-        spikeSeconds,
-        spikePoints,
-        peakPoints,
-        peakVals,
-        backupSpikes,
-        spikeAmps,
-    )
+    return spikeDictList, spikeSeconds, spikePoints, peakPoints, peakVals, backupSpikes, spikeAmps
 
-
-def _getHalfWidths(
-    t, v, spikePoints, peakPoints, theseWidths=[10, 20, 50, 80, 90], window_ms=50
-):
+def _getHalfWidths(t, v, spikePoints, peakPoints, theseWidths=[10,20,50,80,90], window_ms=50):
     """Get half widths.
 
     Args:
         t (ndarray): Time
         v (ndaray): Recording (usually curent clamp Vm)
         spikePoints (list of int): List of spike threshold crossings.
                             Usually the back-up version
         peakPoints (list of int):
         theseWidths (list of int): Specifies full-width-half maximal to calculate
         window_ms (int): Number of ms to look after the peak for downward 1/2 height crossing
 
     Returns:
         List of dict, one elemennt per spike
     """
-    logger.info(
-        f"theseWidths:{theseWidths} window_ms:{window_ms} spikePoints:{len(spikePoints)} peakPoints:{len(peakPoints)}"
-    )
+    logger.info(f'theseWidths:{theseWidths} window_ms:{window_ms} spikePoints:{len(spikePoints)} peakPoints:{len(peakPoints)}')
 
     pointsPerMs = 10  # ToDo: generalize this
     window_pnts = window_ms * pointsPerMs
 
-    spikeDictList = [{}] * len(spikePoints)  # an empy list of dict with proper size
+    spikeDictList = [{}] * len(spikePoints) # an empy list of dict with proper size
     for idx, spikePoint in enumerate(spikePoints):
-        # print(f'Spike {idx} pnt:{spikePoint}')
+        #print(f'Spike {idx} pnt:{spikePoint}')
 
         # each spike has a list of dict for each width result
-        spikeDictList[idx]["widths"] = []
+        spikeDictList[idx]['widths'] = []
 
         # check each pre/post pnt is before next spike
         nextSpikePnt = None
-        if idx < len(spikePoints) - 1:
-            nextSpikePnt = spikePoints[idx + 1]
+        if idx < len(spikePoints)-1:
+            nextSpikePnt = spikePoints[idx+1]
 
         peakPoint = peakPoints[idx]
         try:
             vSpike = v[spikePoint]
-        except IndexError as e:
-            logger.error(f"spikePoint:{spikePoint} {type(spikePoint)}")
+        except (IndexError) as e:
+            logger.error(f'spikePoint:{spikePoint} {type(spikePoint)}')
         vPeak = v[peakPoint]
-        height = vPeak - vSpike
-        preStartPnt = spikePoint + 1
-        preClip = v[preStartPnt : peakPoint - 1]
-        postStartPnt = peakPoint + 1
-        postClip = v[postStartPnt : peakPoint + window_pnts]
+        height = vPeak-vSpike
+        preStartPnt = spikePoint+1
+        preClip = v[preStartPnt:peakPoint-1]
+        postStartPnt = peakPoint+1
+        postClip = v[postStartPnt:peakPoint+window_pnts]
         for width in theseWidths:
             thisHeight = vSpike + (height / width)  # search for a percent of height
-            prePnt = np.where(preClip >= thisHeight)[0]
+            prePnt = np.where(preClip>=thisHeight)[0]
             if len(prePnt) > 0:
                 prePnt = preStartPnt + prePnt[0]
             else:
-                # print(f'  Error: Spike {idx} "prePnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
+                #print(f'  Error: Spike {idx} "prePnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
                 prePnt = None
-            postPnt = np.where(postClip < thisHeight)[0]
+            postPnt = np.where(postClip<thisHeight)[0]
             if len(postPnt) > 0:
                 postPnt = postStartPnt + postPnt[0]
             else:
-                # print(f'  Error: Spike {idx} "postPnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
+                #print(f'  Error: Spike {idx} "postPnt" width:{width} vSpike:{vSpike} height:{height} thisHeight:{thisHeight}')
                 postPnt = None
             widthMs = None
             if prePnt is not None and postPnt is not None:
                 widthPnts = postPnt - prePnt
                 widthMs = widthPnts / pointsPerMs
-                # print(f'  width:{width} tPre:{t[prePnt]} tPost:{t[postPnt]} widthMs:{widthMs}')
+                #print(f'  width:{width} tPre:{t[prePnt]} tPost:{t[postPnt]} widthMs:{widthMs}')
                 if nextSpikePnt is not None and prePnt >= nextSpikePnt:
-                    print(
-                        f"  Error: Spike {idx} widthMs:{widthMs} prePnt:{prePnt} is after nextSpikePnt:{nextSpikePnt}"
-                    )
+                    print(f'  Error: Spike {idx} widthMs:{widthMs} prePnt:{prePnt} is after nextSpikePnt:{nextSpikePnt}')
                 if nextSpikePnt is not None and postPnt >= nextSpikePnt:
-                    print(
-                        f"  Error: Spike {idx} widthMs:{widthMs} postPnt:{postPnt} is after nextSpikePnt:{nextSpikePnt}"
-                    )
+                    print(f'  Error: Spike {idx} widthMs:{widthMs} postPnt:{postPnt} is after nextSpikePnt:{nextSpikePnt}')
 
             # put into dict
             widthDict = {
-                "halfHeight": width,
-                "risingPnt": prePnt,
+                'halfHeight': width,
+                'risingPnt': prePnt,
                 #'risingVal': defaultVal,
-                "fallingPnt": postPnt,
+                'fallingPnt': postPnt,
                 #'fallingVal': defaultVal,
                 #'widthPnts': None,
-                "widthMs": widthMs,
+                'widthMs': widthMs
             }
-            spikeDictList[idx]["widths_" + str(width)] = widthMs
-            spikeDictList[idx]["widths"].append(widthDict)
+            spikeDictList[idx]['widths_' + str(width)] = widthMs
+            spikeDictList[idx]['widths'].append(widthDict)
     #
     return spikeDictList
 
-
 def _throwOutRefractory(spikePoints, refractory_ms=100):
     """
     spikePoints: spike times to consider
     refractory_ms:
     """
     dataPointsPerMs = 10
 
     before = len(spikePoints)
 
     # if there are doubles, throw-out the second one
-    # refractory_ms = 20 #10 # remove spike [i] if it occurs within refractory_ms of spike [i-1]
-    lastGood = 0  # first spike [0] will always be good, there is no spike [i-1]
+    #refractory_ms = 20 #10 # remove spike [i] if it occurs within refractory_ms of spike [i-1]
+    lastGood = 0 # first spike [0] will always be good, there is no spike [i-1]
     for i in range(len(spikePoints)):
-        if i == 0:
+        if i==0:
             # first spike is always good
             continue
         dPoints = spikePoints[i] - spikePoints[lastGood]
-        if dPoints < dataPointsPerMs * refractory_ms:
+        if dPoints < dataPointsPerMs*refractory_ms:
             # remove spike time [i]
             spikePoints[i] = 0
         else:
             # spike time [i] was good
             lastGood = i
     # regenerate spikeTimes0 by throwing out any spike time that does not pass 'if spikeTime'
     # spikeTimes[i] that were set to 0 above (they were too close to the previous spike)
     # will not pass 'if spikeTime', as 'if 0' evaluates to False
-    # if goodSpikeErrors is not None:
+    #if goodSpikeErrors is not None:
     #    goodSpikeErrors = [goodSpikeErrors[idx] for idx, spikeTime in enumerate(spikeTimes0) if spikeTime]
     spikePoints = [spikePoint for spikePoint in spikePoints if spikePoint]
 
     # TODO: put back in and log if detection ['verbose']
     after = len(spikePoints)
-    logger.info(f"From {before} to {after} spikes with refractory_ms:{refractory_ms}")
+    logger.info(f'From {before} to {after} spikes with refractory_ms:{refractory_ms}')
 
     return spikePoints
 
-
-def getKernel(type="sumExp", amp=5, tau1=30, tau2=70):
+def getKernel(type='sumExp', amp=5, tau1=30, tau2=70):
     """Get a kernel for convolution with a spike train."""
     N = 500  # pnts
     t = [x for x in range(N)]
     y = t
 
-    if type == "sumExp":
+    if type == 'sumExp':
         for i in t:
-            y[i] = -amp * (exp(-t[i] / tau1) - (exp(-t[i] / tau2)))
+            y[i] = -amp * ( exp(-t[i]/tau1) - (exp(-t[i]/tau2)) )
     #
     return y
 
-
 def getSpikeTrain(numSeconds=1, fs=10000, spikeFreq=3, amp=10, noiseAmp=10):
     """Get a spike train at given frequency.
 
     Arguments:
         numSeconds (int): Total number of seconds
         fs (int): Sampling frequency, 10000 for 10 kH
         spikeFreq (int): Frequency of events in spike train, e.g. simulated EPSPs
         amp (float): Amplitude of sum exponential kernel (getKernel)
     """
-    n = int(numSeconds * fs)  # total number of samples
+    n = int(numSeconds * fs) # total number of samples
     numSpikes = int(numSeconds * spikeFreq)
     spikeTrain = np.zeros(n)
     start = fs / spikeFreq
     spikeTimes = np.linspace(start, n, numSpikes, endpoint=False)
     for idx, spike in enumerate(spikeTimes):
-        # print(idx, spike)
+        #print(idx, spike)
         spike = int(spike)
         spikeTrain[spike] = 1
 
     expKernel = getKernel(amp=amp)
-    epspTrain = scipy.signal.convolve(spikeTrain, expKernel, mode="same")
+    epspTrain = scipy.signal.convolve(spikeTrain, expKernel, mode='same')
     # shift to -60 mV
     epspTrain -= 60
 
     # add noise
     if noiseAmp == 0:
         pass
     else:
-        # noise_power = 0.001 * fs / noiseAmp
-        # epspTrain += np.random.normal(scale=np.sqrt(noise_power), size=epspTrain.shape)
+        #noise_power = 0.001 * fs / noiseAmp
+        #epspTrain += np.random.normal(scale=np.sqrt(noise_power), size=epspTrain.shape)
         epspTrain += np.random.normal(scale=noiseAmp, size=epspTrain.shape)
 
     #
     t = np.linspace(0, numSeconds, n, endpoint=True)
     #
     return t, spikeTrain, epspTrain
 
-
 class fftPlugin(sanpyPlugin):
-    myHumanName = "FFT"
+    myHumanName = 'FFT'
 
-    # def __init__(self, myAnalysisDir=None, **kwargs):
+    #def __init__(self, myAnalysisDir=None, **kwargs):
     def __init__(self, plotRawAxis=False, ba=None, **kwargs):
         """
         Args:
             ba (bAnalysis): Not required
         """
         super(fftPlugin, self).__init__(ba=ba, **kwargs)
 
@@ -462,685 +423,635 @@
         self.plotRawAxis = plotRawAxis
 
         self.doButterFilter = True
         self.butterOrder = 70
         self.butterCutoff = [0.7, 10]  # [low freq, high freq] for bandpass
 
         self._resultsDictList = []
-        self._resultStr = ""
+        self._resultStr = ''
 
         self.isModel = False
 
         # only defined when running without SanPy app
-        # self._analysisDir = myAnalysisDir
+        #self._analysisDir = myAnalysisDir
 
         self._store_ba = None  # allow switching between model and self.ba
 
         if self.ba is not None:
             self.fs = self.ba.fileLoader.recordingFrequency * 1000
         else:
             self.fs = None
-        self.psdWindowStr = "Hanning"  # mpl.mlab.window_hanning
+        self.psdWindowStr = 'Hanning'  # mpl.mlab.window_hanning
 
         # fft Freq (Hz) resolution is fs/nfft --> resolution 0.2 Hz = 10000/50000
-        self.nfft = 50000  # 512 * 100
+        self.nfft = 50000 #512 * 100
 
         self.signalHz = None  # assign when using fake data
         self.maxPlotHz = 10  # limit x-axis frequenccy
 
-        # self.sos = None
+        #self.sos = None
 
         self.medianFilterPnts = 0
 
         # points
         self.lastLeft = None  # 0
         self.lastRight = None  # len(self.ba.sweepX())
 
-        # if self._analysisDir is not None:
+        #if self._analysisDir is not None:
         #    # running lpugin without sanpy
         #    self.loadData(2)  # load the 3rd file in analysis dir
 
         self._buildInterface()
 
-        # self._getPsd()
+        #self._getPsd()
 
         self.dataLine = None
         self.dataFilteredLine = None
         self.spikesLine = None
         self.peaksLine = None
         self.dataMeanLine = None
         self.thresholdLine2 = None
         self.thresholdLine3 = None
 
-        # self.getMean()
+
+        #self.getMean()
         self.plot()  # first plot of data
         self.replot2(switchFile=True)
-        # self.replotPsd()
-        # self.replot_fft()
+        #self.replotPsd()
+        #self.replot_fft()
 
         self._isInited = True
 
     @property
     def ba(self):
         return self._ba
 
     def _buildInterface(self):
-        # self.pyqtWindow()
+        #self.pyqtWindow()
 
         # main layout
         vLayout = QtWidgets.QVBoxLayout()
 
         self.controlLayout = QtWidgets.QHBoxLayout()
         #
-        # aLabel = QtWidgets.QLabel('fft')
-        # self.controlLayout.addWidget(aLabel)
+        #aLabel = QtWidgets.QLabel('fft')
+        #self.controlLayout.addWidget(aLabel)
 
-        """
+        '''
         buttonName = 'Detect'
         aButton = QtWidgets.QPushButton(buttonName)
         aButton.clicked.connect(partial(self.on_button_click,buttonName))
         self.controlLayout.addWidget(aButton)
-        """
+        '''
 
-        """
+        '''
         aLabel = QtWidgets.QLabel('mV Threshold')
         self.controlLayout.addWidget(aLabel)
 
         self.mvThresholdSpinBox = QtWidgets.QDoubleSpinBox()
         self.mvThresholdSpinBox.setRange(-1e9, 1e9)
         self.controlLayout.addWidget(self.mvThresholdSpinBox)
-        """
+        '''
 
-        """
+        '''
         checkboxName = 'PSD'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(True)
         aCheckBox.stateChanged.connect(partial(self.on_checkbox_clicked, checkboxName))
         self.controlLayout.addWidget(aCheckBox)
-        """
+        '''
 
-        """
+        '''
         checkboxName = 'Auto-Correlation'
         aCheckBox = QtWidgets.QCheckBox(checkboxName)
         aCheckBox.setChecked(True)
         aCheckBox.stateChanged.connect(partial(self.on_checkbox_clicked, checkboxName))
         self.controlLayout.addWidget(aCheckBox)
-        """
+        '''
 
-        buttonName = "Replot"
+        buttonName = 'Replot'
         aButton = QtWidgets.QPushButton(buttonName)
-        aButton.clicked.connect(partial(self.on_button_click, buttonName))
+        aButton.clicked.connect(partial(self.on_button_click,buttonName))
         self.controlLayout.addWidget(aButton)
 
-        self.resultsLabel = QtWidgets.QLabel("Results: Peak Hz=??? Ampplitude=???")
+        self.resultsLabel = QtWidgets.QLabel('Results: Peak Hz=??? Ampplitude=???')
         self.controlLayout.addWidget(self.resultsLabel)
 
-        checkboxName = "Butter Filter"
+        checkboxName = 'Butter Filter'
         butterCheckBox = QtWidgets.QCheckBox(checkboxName)
         butterCheckBox.setChecked(self.doButterFilter)
-        butterCheckBox.stateChanged.connect(
-            partial(self.on_checkbox_clicked, checkboxName)
-        )
+        butterCheckBox.stateChanged.connect(partial(self.on_checkbox_clicked, checkboxName))
         self.controlLayout.addWidget(butterCheckBox)
 
-        aLabel = QtWidgets.QLabel("Order")
+        aLabel = QtWidgets.QLabel('Order')
         self.controlLayout.addWidget(aLabel)
         self.butterOrderSpinBox = QtWidgets.QSpinBox()
         self.butterOrderSpinBox.setRange(0, 2**16)
         self.butterOrderSpinBox.setValue(self.butterOrder)
-        self.butterOrderSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.butterOrderSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout.addWidget(self.butterOrderSpinBox)
 
-        aLabel = QtWidgets.QLabel("Low (Hz)")
+        aLabel = QtWidgets.QLabel('Low (Hz)')
         self.controlLayout.addWidget(aLabel)
         self.lowCutoffSpinBox = QtWidgets.QDoubleSpinBox()
         self.lowCutoffSpinBox.setRange(0, 2**16)
         self.lowCutoffSpinBox.setValue(self.butterCutoff[0])
-        self.lowCutoffSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.lowCutoffSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout.addWidget(self.lowCutoffSpinBox)
 
-        aLabel = QtWidgets.QLabel("High")
+        aLabel = QtWidgets.QLabel('High')
         self.controlLayout.addWidget(aLabel)
         self.highCutoffSpinBox = QtWidgets.QDoubleSpinBox()
         self.highCutoffSpinBox.setRange(0, 2**16)
         self.highCutoffSpinBox.setValue(self.butterCutoff[1])
-        self.highCutoffSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.highCutoffSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout.addWidget(self.highCutoffSpinBox)
 
         psdWindowComboBox = QtWidgets.QComboBox()
-        psdWindowComboBox.addItem("Hanning")
-        psdWindowComboBox.addItem("Blackman")
+        psdWindowComboBox.addItem('Hanning')
+        psdWindowComboBox.addItem('Blackman')
         psdWindowComboBox.currentTextChanged.connect(self.on_psd_window_changed)
         self.controlLayout.addWidget(psdWindowComboBox)
 
         #
-        vLayout.addLayout(self.controlLayout)  # add mpl canvas
+        vLayout.addLayout(self.controlLayout) # add mpl canvas
 
         self.controlLayout1_5 = QtWidgets.QHBoxLayout()
 
-        self.fsLabel = QtWidgets.QLabel(f"fs={self.fs}")
+        self.fsLabel = QtWidgets.QLabel(f'fs={self.fs}')
         self.controlLayout1_5.addWidget(self.fsLabel)
 
-        aLabel = QtWidgets.QLabel("NFFT")
+        aLabel = QtWidgets.QLabel('NFFT')
         self.controlLayout1_5.addWidget(aLabel)
         self.nfftSpinBox = QtWidgets.QSpinBox()
         self.nfftSpinBox.setRange(0, 2**16)
         self.nfftSpinBox.setValue(self.nfft)
-        self.nfftSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.nfftSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout1_5.addWidget(self.nfftSpinBox)
 
-        # self.freqResLabel = QtWidgets.QLabel(f'Freq Resolution (Hz) {round(self.fs/self.nfft,3)}')
-        self.freqResLabel = QtWidgets.QLabel(f"Freq Resolution (Hz) Unknown")
+        #self.freqResLabel = QtWidgets.QLabel(f'Freq Resolution (Hz) {round(self.fs/self.nfft,3)}')
+        self.freqResLabel = QtWidgets.QLabel(f'Freq Resolution (Hz) Unknown')
         self.controlLayout1_5.addWidget(self.freqResLabel)
 
-        aLabel = QtWidgets.QLabel("Median Filter (Pnts)")
+        aLabel = QtWidgets.QLabel('Median Filter (Pnts)')
         self.controlLayout1_5.addWidget(aLabel)
         self.medianFilterPntsSpinBox = QtWidgets.QSpinBox()
         self.medianFilterPntsSpinBox.setRange(0, 2**16)
         self.medianFilterPntsSpinBox.setValue(self.medianFilterPnts)
-        self.medianFilterPntsSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.medianFilterPntsSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout1_5.addWidget(self.medianFilterPntsSpinBox)
 
-        aLabel = QtWidgets.QLabel("Max Plot (Hz)")
+        aLabel = QtWidgets.QLabel('Max Plot (Hz)')
         self.controlLayout1_5.addWidget(aLabel)
         self.maxPlotHzSpinBox = QtWidgets.QDoubleSpinBox()
         self.maxPlotHzSpinBox.setRange(0, 2**16)
         self.maxPlotHzSpinBox.setValue(self.maxPlotHz)
-        self.maxPlotHzSpinBox.editingFinished.connect(
-            partial(self.on_cutoff_spinbox, aLabel)
-        )
+        self.maxPlotHzSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout1_5.addWidget(self.maxPlotHzSpinBox)
 
-        """
+        '''
         aLabel = QtWidgets.QLabel('Order')
         self.controlLayout1_5.addWidget(aLabel)
         self.orderSpinBox = QtWidgets.QDoubleSpinBox()
         self.orderSpinBox.setRange(-1e9, 1e9)
         self.orderSpinBox.setValue(self.order)
         self.orderSpinBox.editingFinished.connect(partial(self.on_cutoff_spinbox, aLabel))
         self.controlLayout1_5.addWidget(self.orderSpinBox)
-        """
+        '''
 
-        buttonName = "Filter Response"
+        buttonName = 'Filter Response'
         aButton = QtWidgets.QPushButton(buttonName)
-        aButton.clicked.connect(partial(self.on_button_click, buttonName))
+        aButton.clicked.connect(partial(self.on_button_click,buttonName))
         self.controlLayout1_5.addWidget(aButton)
 
-        """
+        '''
         buttonName = 'Rebuild Auto-Corr'
         aButton = QtWidgets.QPushButton(buttonName)
         aButton.clicked.connect(partial(self.on_button_click,buttonName))
         self.controlLayout1_5.addWidget(aButton)
-        """
+        '''
 
         #
-        vLayout.addLayout(self.controlLayout1_5)  # add mpl canvas
+        vLayout.addLayout(self.controlLayout1_5) # add mpl canvas
 
         #
         # second row of controls (for model)
         self.controlLayout_row2 = QtWidgets.QHBoxLayout()
 
-        checkboxName = "Model Data"
+        checkboxName = 'Model Data'
         self.modelDataCheckBox = QtWidgets.QCheckBox(checkboxName)
         self.modelDataCheckBox.setChecked(False)
-        self.modelDataCheckBox.stateChanged.connect(
-            partial(self.on_checkbox_clicked, checkboxName)
-        )
+        self.modelDataCheckBox.stateChanged.connect(partial(self.on_checkbox_clicked, checkboxName))
         self.controlLayout_row2.addWidget(self.modelDataCheckBox)
 
-        """
+        '''
         buttonName = 'Detect'
         aButton = QtWidgets.QPushButton(buttonName)
         aButton.clicked.connect(partial(self.on_button_click,buttonName))
         self.controlLayout_row2.addWidget(aButton)
-        """
+        '''
 
-        """
+        '''
         aLabel = QtWidgets.QLabel('mvThreshold')
         self.controlLayout_row2.addWidget(aLabel)
 
         self.mvThresholdSpinBox = QtWidgets.QDoubleSpinBox()
         self.mvThresholdSpinBox.setValue(-52)
         self.mvThresholdSpinBox.setRange(-1000, 1000)
         self.controlLayout_row2.addWidget(self.mvThresholdSpinBox)
-        """
+        '''
 
         # numSeconds, spikeFreq, amp, noise
-        aLabel = QtWidgets.QLabel("Seconds")
+        aLabel = QtWidgets.QLabel('Seconds')
         self.controlLayout_row2.addWidget(aLabel)
 
         self.modelSecondsSpinBox = QtWidgets.QDoubleSpinBox()
         self.modelSecondsSpinBox.setValue(20)
         self.modelSecondsSpinBox.setRange(0, 1000)
         self.controlLayout_row2.addWidget(self.modelSecondsSpinBox)
 
         # finalize row 2
-        vLayout.addLayout(self.controlLayout_row2)  # add mpl canvas
+        vLayout.addLayout(self.controlLayout_row2) # add mpl canvas
 
         # 3rd row
         # second row of controls (for model)
-        # self.controlLayout_row3 = QtWidgets.QHBoxLayout()
+        #self.controlLayout_row3 = QtWidgets.QHBoxLayout()
 
-        aLabel = QtWidgets.QLabel("Spike Frequency")
+        aLabel = QtWidgets.QLabel('Spike Frequency')
         self.controlLayout_row2.addWidget(aLabel)
 
         self.modelFrequencySpinBox = QtWidgets.QDoubleSpinBox()
         self.modelFrequencySpinBox.setValue(1)
         self.modelFrequencySpinBox.setRange(0, 100)
         self.controlLayout_row2.addWidget(self.modelFrequencySpinBox)
 
-        aLabel = QtWidgets.QLabel("Amplitude")
+        aLabel = QtWidgets.QLabel('Amplitude')
         self.controlLayout_row2.addWidget(aLabel)
 
         self.modelAmpSpinBox = QtWidgets.QDoubleSpinBox()
         self.modelAmpSpinBox.setValue(100)
         self.modelAmpSpinBox.setRange(-100, 100)
         self.controlLayout_row2.addWidget(self.modelAmpSpinBox)
 
-        aLabel = QtWidgets.QLabel("Noise Amp")
+        aLabel = QtWidgets.QLabel('Noise Amp')
         self.controlLayout_row2.addWidget(aLabel)
 
         self.modelNoiseAmpSpinBox = QtWidgets.QDoubleSpinBox()
         self.modelNoiseAmpSpinBox.setValue(50)
         self.modelNoiseAmpSpinBox.setRange(0, 1000)
         self.controlLayout_row2.addWidget(self.modelNoiseAmpSpinBox)
 
         # finalize row 3
-        # vLayout.addLayout(self.controlLayout_row3) # add mpl canvas
+        #vLayout.addLayout(self.controlLayout_row3) # add mpl canvas
 
         vSplitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
         vLayout.addWidget(vSplitter)
 
         # don't use inherited, want 3x3 with rows: 1, 1, 3 subplits
-        """
+        '''
         self.mplWindow2(numRow=3)  # makes self.axs[] and self.static_canvas
         #self.vmAxes = self.axs[0]
         self.rawAxes = self.axs[0]
         self.rawZoomAxes = self.axs[1]
         self.fftAxes = self.axs[2]
         #self.autoCorrAxes = self.axs[3]  # uses spike detection
-        """
+        '''
 
         #  mirror self.mplWindow2()
         from matplotlib.backends import backend_qt5agg
-
         self.fig = mpl.figure.Figure(constrained_layout=True)
         self.static_canvas = backend_qt5agg.FigureCanvas(self.fig)
         # this is really tricky and annoying
-        self.static_canvas.setFocusPolicy(QtCore.Qt.ClickFocus)
+        self.static_canvas.setFocusPolicy( QtCore.Qt.ClickFocus )
         self.static_canvas.setFocus()
-        # self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
+        #self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
 
-        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(
-            self.static_canvas, self.static_canvas
-        )
+        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(self.static_canvas, self.static_canvas)
 
         if self.plotRawAxis:
             numRow = 3
         else:
             numRow = 2
 
         gs = self.fig.add_gridspec(numRow, 3)
-        # self.rawAxes = self.fig.addsubplot(gs[0,:])
+        #self.rawAxes = self.fig.addsubplot(gs[0,:])
         if self.plotRawAxis:
-            self.rawAxes = self.static_canvas.figure.add_subplot(gs[0, :])
-            self.rawZoomAxes = self.static_canvas.figure.add_subplot(gs[1, :])
+            self.rawAxes = self.static_canvas.figure.add_subplot(gs[0,:])
+            self.rawZoomAxes = self.static_canvas.figure.add_subplot(gs[1,:])
             # 3rd row has 3 subplots
-            self.psdAxes = self.static_canvas.figure.add_subplot(gs[2, 0])
-            self.spectrogramAxes = self.static_canvas.figure.add_subplot(gs[2, -2])
+            self.psdAxes = self.static_canvas.figure.add_subplot(gs[2,0])
+            self.spectrogramAxes = self.static_canvas.figure.add_subplot(gs[2,-2])
         else:
             self.rawAxes = None
-            self.rawZoomAxes = self.static_canvas.figure.add_subplot(gs[0, :])
+            self.rawZoomAxes = self.static_canvas.figure.add_subplot(gs[0,:])
             # 3rd row has 3 subplots
-            self.psdAxes = self.static_canvas.figure.add_subplot(gs[1, 0])
-            self.spectrogramAxes = self.static_canvas.figure.add_subplot(gs[1, -2])
+            self.psdAxes = self.static_canvas.figure.add_subplot(gs[1,0])
+            self.spectrogramAxes = self.static_canvas.figure.add_subplot(gs[1,-2])
 
-        vSplitter.addWidget(self.static_canvas)  # add mpl canvas
-        vSplitter.addWidget(self.mplToolbar)  # add mpl canvas
+        vSplitter.addWidget(self.static_canvas) # add mpl canvas
+        vSplitter.addWidget(self.mplToolbar) # add mpl canvas
 
         # this works
-        # self.mplToolbar.hide()
+        #self.mplToolbar.hide()
 
         # set the layout of the main window
-        # self.setLayout(vLayout)
+        #self.setLayout(vLayout)
         self.getVBoxLayout().addLayout(vLayout)
-
+        
     def on_psd_window_changed(self, item):
         """User selected window dropdown
 
         Args:
             item (str):
         """
         logger.info(f'item:"{item}" {type(item)}')
         self.psdWindowStr = item
-        """
+        '''
         if item == 'Hanning':
             self.psdWindow = mpl.mlab.window_hanning
         if item == 'Blackman':
             self.psdWindow = np.blackman(51)
         else:
             logger.warning(f'Item not understood {item}')
-        """
+        '''
         #
         self.replot2(switchFile=False)
 
     def setAxis(self):
         self.replot()
 
     def replot(self):
-        logger.info("")
+        logger.info('')
 
-        # self.getMean()
+        #self.getMean()
         self.replot2(switchFile=True)
 
     def replot2(self, switchFile=False):
-        logger.info(f"switchFile:{switchFile}")
+        logger.info(f'switchFile:{switchFile}')
 
-        # self.replotData(switchFile=switchFile)
-        # self.replotPsd()
-        # self.replot_fft()
-        # self.replotAutoCorr()
+        #self.replotData(switchFile=switchFile)
+        #self.replotPsd()
+        #self.replot_fft()
+        #self.replotAutoCorr()
         self.replot_fft2()
 
         if switchFile:
             self._mySetWindowTitle()
 
         self.static_canvas.draw()
-        # plt.draw()
+        #plt.draw()
 
     def replot_fft2(self):
+
         def myDetrend(x):
-            # print('myDetrend() x:', x.shape)
+            #print('myDetrend() x:', x.shape)
             y = plt.mlab.detrend_linear(x)
-            # y = plt.mlab.detrend_mean(y)
+            #y = plt.mlab.detrend_mean(y)
             return y
 
         start = time.time()
 
         if self.ba is None:
             return
 
-        if self.sweepNumber == "All":
-            logger.warning(
-                f"fft plugin can only show one sweep, received sweepNumber:{self.sweepNumber}"
-            )
+        if self.sweepNumber == 'All':
+            logger.warning(f'fft plugin can only show one sweep, received sweepNumber:{self.sweepNumber}')
             return
 
-        # logger.info(f'using ba: {self.ba}')
+        #logger.info(f'using ba: {self.ba}')
         startSec, stopSec = self.getStartStop()
-        if (
-            startSec is None
-            or stopSec is None
-            or math.isnan(startSec)
-            or math.isnan(stopSec)
-        ):
-            logger.info(f"Resetting start/stop seconds to max")
+        if startSec is None or stopSec is None or math.isnan(startSec) or math.isnan(stopSec):
+            logger.info(f'Resetting start/stop seconds to max')
             startSec = 0
-            stopSec = self.ba.fileLoader.recordingDur  # self.ba.sweepX()[-1]
-        logger.info(f"Using start(s):{startSec} stop(s):{stopSec}")
-        self.lastLeft = round(startSec * 1000 * self.ba.fileLoader.dataPointsPerMs)
-        self.lastRight = round(stopSec * 1000 * self.ba.fileLoader.dataPointsPerMs)
+            stopSec = self.ba.fileLoader.recordingDur  #self.ba.sweepX()[-1]
+        logger.info(f'Using start(s):{startSec} stop(s):{stopSec}')
+        self.lastLeft = round(startSec*1000*self.ba.fileLoader.dataPointsPerMs)
+        self.lastRight = round(stopSec*1000*self.ba.fileLoader.dataPointsPerMs)
 
         leftPoint = self.lastLeft
         rightPoint = self.lastRight
 
-        sweepY = self.getSweep("y")
-        if leftPoint < 0:
+        sweepY = self.getSweep('y')
+        if leftPoint<0:
             leftPoint = 0
         if rightPoint > sweepY.shape[0]:
             rightPoint = sweepY.shape[0]
 
+
         y = sweepY[leftPoint:rightPoint]
 
         medianPnts = self.medianFilterPnts  # 50
         if medianPnts > 0:
-            logger.info(f"  Median filter with pnts={medianPnts}")
+            logger.info(f'  Median filter with pnts={medianPnts}')
             yFiltered = scipy.ndimage.median_filter(y, medianPnts)
         else:
-            logger.info("  No median filter")
+            logger.info('  No median filter')
             yFiltered = y
 
-        # logger.info(f'Fetching sweepX with sweepNumber: {self.sweepNumber}')
+        #logger.info(f'Fetching sweepX with sweepNumber: {self.sweepNumber}')
 
-        sweepX = self.getSweep("x")
+        sweepX = self.getSweep('x')
 
-        # logger.info(f'  sweepX: {sweepX.shape}')
-        # logger.info(f'  leftSec:{sweepX[leftPoint]} rightSec:{sweepX[rightPoint-1]}')
+        #logger.info(f'  sweepX: {sweepX.shape}')
+        #logger.info(f'  leftSec:{sweepX[leftPoint]} rightSec:{sweepX[rightPoint-1]}')
         t = sweepX[leftPoint:rightPoint]
 
-        dt = t[1] - t[0]  # 0.0001
-        fs = round(1 / dt)  # samples per second
+        dt = t[1] - t[0] #0.0001
+        fs = round(1/dt)  # samples per second
         nfft = self.nfft  # The number of data points used in each block for the FFT
-        # print(f'  fs:{fs} nfft:{nfft}')
+        #print(f'  fs:{fs} nfft:{nfft}')
 
         if self.plotRawAxis:
             self.rawAxes.clear()
-            self.rawAxes.plot(sweepX, sweepY, "-", linewidth=1)
+            self.rawAxes.plot(sweepX, sweepY, '-', linewidth=1)
             # draw a rectangle to show left/right time selecction
             yMin = np.nanmin(sweepY)
             yMax = np.nanmax(sweepY)
             xRect = startSec
             yRect = yMin
-            wRect = stopSec - startSec
-            hRect = yMax - yMin
-            rect1 = mpl.patches.Rectangle((xRect, yRect), wRect, hRect, color="gray")
+            wRect = stopSec-startSec
+            hRect = yMax-yMin
+            rect1 = mpl.patches.Rectangle((xRect,yRect), wRect, hRect, color='gray')
             self.rawAxes.add_patch(rect1)
             self.rawAxes.set_xlim([sweepX[0], sweepX[-1]])
 
         #
         # replot the clip +/- std we analyzed, after detrend
         yDetrend = myDetrend(yFiltered)
 
         #
         if self.doButterFilter:
-            # self.butterCutoff = 10  # Hz
-            # self.butterOrder = 70
-            # self.sos = butter_sos(self.butterCutoff, self.fs, order=self.butterOrder, passType='lowpass')
-            # self.butterCutoff = [0.7, 10]
-            # logger.info(f'  butterOrder:{self.butterOrder} butterCutoff:{self.butterCutoff}')
-            self.sos = butter_sos(
-                self.butterCutoff, self.fs, order=self.butterOrder, passType="bandpass"
-            )
+            #self.butterCutoff = 10  # Hz
+            #self.butterOrder = 70
+            #self.sos = butter_sos(self.butterCutoff, self.fs, order=self.butterOrder, passType='lowpass')
+            #self.butterCutoff = [0.7, 10]
+            #logger.info(f'  butterOrder:{self.butterOrder} butterCutoff:{self.butterCutoff}')
+            self.sos = butter_sos(self.butterCutoff, self.fs, order=self.butterOrder, passType='bandpass')
             # filtfilt should remove phase delay in time. A forward-backward digital filter using cascaded second-order sections.
             yFiltered_Butter = scipy.signal.sosfiltfilt(self.sos, yDetrend, axis=0)
-            # print('yDetrend:', yDetrend.shape, np.nanmin(yDetrend), np.nanmax(yDetrend))
-            # print('yFiltered_Butter:', yFiltered_Butter.shape, np.nanmin(yFiltered_Butter), np.nanmax(yFiltered_Butter))
+            #print('yDetrend:', yDetrend.shape, np.nanmin(yDetrend), np.nanmax(yDetrend))
+            #print('yFiltered_Butter:', yFiltered_Butter.shape, np.nanmin(yFiltered_Butter), np.nanmax(yFiltered_Butter))
 
             # we use this for remaining
             yFiltered = yFiltered_Butter
 
         dataMean = np.nanmean(yDetrend)
         dataStd = np.nanstd(yDetrend)
         dataThreshold2 = dataMean + (2 * dataStd)
         dataThreshold3 = dataMean + (3 * dataStd)
 
         self.rawZoomAxes.clear()
-        self.rawZoomAxes.plot(t, yDetrend, "-", linewidth=1)
-        self.rawZoomAxes.axhline(
-            dataMean, marker="", color="r", linestyle="--", linewidth=0.5
-        )
-        self.rawZoomAxes.axhline(
-            dataThreshold2, marker="", color="r", linestyle="--", linewidth=0.5
-        )
-        self.rawZoomAxes.axhline(
-            dataThreshold3, marker="", color="r", linestyle="--", linewidth=0.5
-        )
+        self.rawZoomAxes.plot(t, yDetrend, '-', linewidth=1)
+        self.rawZoomAxes.axhline(dataMean, marker='', color='r', linestyle='--', linewidth=0.5)
+        self.rawZoomAxes.axhline(dataThreshold2, marker='', color='r', linestyle='--', linewidth=0.5)
+        self.rawZoomAxes.axhline(dataThreshold3, marker='', color='r', linestyle='--', linewidth=0.5)
         self.rawZoomAxes.set_xlim([t[0], t[-1]])
         #
         if self.doButterFilter:
-            self.rawZoomAxes.plot(t, yFiltered, "-r", linewidth=1)
+            self.rawZoomAxes.plot(t, yFiltered, '-r', linewidth=1)
 
         # save yDetrend, yFiltered as csv
-        """
+        '''
         print('=== FOR FERNANDO')
         import pandas as pd
         print('  t:', t.shape)
         print('  yDetrend:', yDetrend.shape)
         print('  yFiltered:', yFiltered.shape)
         tmpDf = pd.DataFrame(columns=['s', 'yDetrend', 'yFiltered'])
         tmpDf['s'] = t
         tmpDf['yDetrend'] = yDetrend
         tmpDf['yFiltered'] = yFiltered
         print(tmpDf.head())
         dfFile = 'fft-20200707-0000-16sec-31sec.csv'
         print('saving dfFile:', dfFile)
         tmpDf.to_csv(dfFile, index=False)
         print('=== END')
-        """
+        '''
 
         # we will still scale a freq plots to [0, self.maxPlotHz]
         if self.doButterFilter:
             minPlotFreq = self.butterCutoff[0]
             maxPlotFreq = self.butterCutoff[1]
         else:
             minPlotFreq = 0
-            maxPlotFreq = self.maxPlotHz  # 15
+            maxPlotFreq = self.maxPlotHz #15
 
         #
         # spectrogram
-        # self.fftAxes.clear()
+        #self.fftAxes.clear()
         nfft2 = int(nfft / 4)
-        specSpectrum, specFreqs, spec_t, specIm = self.spectrogramAxes.specgram(
-            yFiltered, NFFT=nfft2, Fs=fs, detrend=myDetrend
-        )
-        """
+        specSpectrum, specFreqs, spec_t, specIm = self.spectrogramAxes.specgram(yFiltered, NFFT=nfft2, Fs=fs, detrend=myDetrend)
+        '''
         print('=== specgram')
         print('  yFiltered:', yFiltered.shape)
         print('  specSpectrum (freq, t):', specSpectrum.shape)  # (25601, 20) is (freq, t)
         print('    ', np.nanmin(specSpectrum), np.nanmax(specSpectrum))
         print('  specFreqs:', specFreqs.shape)
         print('  spec_t:', spec_t.shape)
         print('  specIm:', type(specIm))
-        """
+        '''
         mask = (specFreqs >= minPlotFreq) & (specFreqs <= maxPlotFreq)
-        specSpectrum = specSpectrum[mask, :]  # TRANSPOSE
-        """
+        specSpectrum = specSpectrum[mask,:]  # TRANSPOSE
+        '''
         print('  2 Transpose specSpectrum (freq, t):', specSpectrum.shape)  # (25601, 20) is (freq, t)
         print('    ', np.nanmin(specSpectrum), np.nanmax(specSpectrum))
-        """
+        '''
 
         # careful: I want to eventually scale y-axis to [0, self.maxPlotHz]
         # for now use [minPlotFreq, maxPlotFreq]
         x_min = startSec
         x_max = stopSec
         y_min = maxPlotFreq  # minPlotFreq
         y_max = minPlotFreq  # maxPlotFreq
-        extent = [x_min, x_max, y_min, y_max]
+        extent = [x_min , x_max, y_min , y_max]
 
         self.spectrogramAxes.clear()
-        self.spectrogramAxes.imshow(
-            specSpectrum, extent=extent, aspect="auto", cmap="viridis"
-        )
+        self.spectrogramAxes.imshow(specSpectrum, extent=extent, aspect='auto', cmap='viridis')
         self.spectrogramAxes.invert_yaxis()
-        self.spectrogramAxes.set_xlabel("Time (s)")
-        self.spectrogramAxes.set_ylabel("Freq (Hz)")
+        self.spectrogramAxes.set_xlabel('Time (s)')
+        self.spectrogramAxes.set_ylabel('Freq (Hz)')
 
         #
         # matplotlib psd
-        if self.psdWindowStr == "Hanning":
+        if self.psdWindowStr == 'Hanning':
             psdWindow = mpl.mlab.window_hanning
-        elif self.psdWindowStr == "Blackman":
+        elif self.psdWindowStr == 'Blackman':
             psdWindow = np.blackman(nfft)
         else:
-            logger.warning(f"psdWindowStr not understood {self.psdWindowStr}")
-        """
+            logger.warning(f'psdWindowStr not understood {self.psdWindowStr}')
+        '''
         print('=== calling mpl psd()')
         print('  nfft:', nfft)
         print('  fs:', fs)
         print('  myDetrend:', myDetrend)
         print('  psdWindowStr:', self.psdWindowStr)
         print('  psdWindow:', psdWindow)
-        """
+        '''
         # default scale_by_freq=True
         scale_by_freq = True
-        Pxx, freqs = self.psdAxes.psd(
-            yFiltered,
-            marker="",
-            linestyle="-",
-            NFFT=nfft,
-            Fs=fs,
-            scale_by_freq=scale_by_freq,
-            detrend=myDetrend,
-            window=psdWindow,
-        )
+        Pxx, freqs = self.psdAxes.psd(yFiltered, marker='', linestyle='-', NFFT=nfft, Fs=fs,
+                                    scale_by_freq=scale_by_freq, detrend=myDetrend, window=psdWindow)
 
         #
         # replot matplotlib psd
         pxxLog10 = 10 * np.log10(Pxx)
         mask = (freqs >= minPlotFreq) & (freqs <= maxPlotFreq)
-        pxxLog10 = pxxLog10[mask]  # order matters
-        freqsLog10 = freqs[mask]  # order matters
+        pxxLog10 = pxxLog10[mask] # order matters
+        freqsLog10 = freqs[mask] # order matters
         self.psdAxes.clear()
-        self.psdAxes.plot(freqsLog10, pxxLog10, "-", linewidth=1)
+        self.psdAxes.plot(freqsLog10, pxxLog10, '-', linewidth=1)
         self.psdAxes.set_xlim([0, self.maxPlotHz])  # x-axes is frequency
         self.psdAxes.grid(True)
-        # self.psdAxes.set_ylabel('10*log10(Pxx)')
-        self.psdAxes.set_ylabel("PSD (dB)")
-        self.psdAxes.set_xlabel("Freq (Hz)")
+        #self.psdAxes.set_ylabel('10*log10(Pxx)')
+        self.psdAxes.set_ylabel('PSD (dB)')
+        self.psdAxes.set_xlabel('Freq (Hz)')
 
         #
         # get peak frequency from psd, finding max peak with width
         inflection = np.diff(np.sign(np.diff(pxxLog10)))
         peaks = (inflection < 0).nonzero()[0] + 1
         # excception ValueError
         try:
             peak = peaks[pxxLog10[peaks].argmax()]
-            maxFreq = round(freqsLog10[peak], 3)  # Gives 0.05
-            maxPsd = round(pxxLog10[peak], 3)  # Gives 0.05
-        except ValueError as e:
-            logger.error("BAD PEAK in pxx")
+            maxFreq = round(freqsLog10[peak],3) # Gives 0.05
+            maxPsd = round(pxxLog10[peak],3) # Gives 0.05
+        except(ValueError) as e:
+            logger.error('BAD PEAK in pxx')
             maxFreq = []
-            maxPsd = []
+            maxPsd =[]
 
         # add to plot
-        self.psdAxes.plot(maxFreq, maxPsd, ".r")
+        self.psdAxes.plot(maxFreq, maxPsd, '.r')
 
         maxPsd = np.nanmax(pxxLog10)
         maxPnt = np.argmax(pxxLog10)
         maxFreq = freqsLog10[maxPnt]
-        self.resultsLabel.setText(
-            f"Results: Peak Hz={round(maxFreq,3)} Amplitude={round(maxPsd,3)}"
-        )
+        self.resultsLabel.setText(f'Results: Peak Hz={round(maxFreq,3)} Amplitude={round(maxPsd,3)}')
 
         #
         # print results
         # (file, startSec, stopSec, max psd amp, max psd freq)
-        pStart = round(startSec, 3)
-        pStop = round(stopSec, 3)
-        pMaxFreq = round(maxFreq, 3)
-        pMaxPsd = round(maxPsd, 3)
-
-        printStr = f"Type\tFile\tstartSec\tstopSec\tmaxFreqPsd\tmaxPsd"  # \tmaxFreqFft\tmaxFft'
-        # self.appendResultsStr(printStr)
-
-        # print("=== FFT results are:")
-        # print(printStr)
-
-        printStr = f"fftPlugin\t{self.ba.fileLoader.filename}\t{pStart}\t{pStop}\t{pMaxFreq}\t{pMaxPsd}"
-
-        self.appendResultsStr(
-            printStr, maxFreq=pMaxFreq, maxPsd=pMaxPsd, freqs=freqsLog10, psd=pxxLog10
-        )
-        # print(printStr)
+        pStart = round(startSec,3)
+        pStop = round(stopSec,3)
+        pMaxFreq = round(maxFreq,3)
+        pMaxPsd = round(maxPsd,3)
+
+        printStr = f'Type\tFile\tstartSec\tstopSec\tmaxFreqPsd\tmaxPsd'  #\tmaxFreqFft\tmaxFft'
+        #self.appendResultsStr(printStr)
+        print('=== FFT results are:')
+        print(printStr)
+        printStr = f'fftPlugin\t{self.ba.fileLoader.filename}\t{pStart}\t{pStop}\t{pMaxFreq}\t{pMaxPsd}'
+        self.appendResultsStr(printStr, maxFreq=pMaxFreq, maxPsd=pMaxPsd, freqs=freqsLog10, psd=pxxLog10)
+        print(printStr)
 
         #
         # plot np fft
         # see: https://www.gw-openscience.org/tutorial05/
         # blackman is supposed to correct for low freq signal ???
-        """
+        '''
         doBlackman = False
         if doBlackman:
             window = np.blackman(yFiltered.size)
             windowed_yFiltered = yFiltered*window
         else:
             windowed_yFiltered = yFiltered
 
@@ -1174,36 +1085,36 @@
         self.fftAxes.clear()
         self.fftAxes.semilogy(fftFreqs, fftMags, '-', linewidth=1)
         self.fftAxes.set_xlim([minPlotFreq, maxPlotFreq])  # x-axes is frequency
         self.fftAxes.set_xlabel('Freq (Hz)')
         self.fftAxes.set_ylabel('FFT Mag')
         self.fftAxes.grid(True)
         self.fftAxes.semilogy(signal_freq, signal_mag, '.r')
-        """
+        '''
 
         stop = time.time()
-        # logger.info(f'Took {stop-start} seconds.')
+        #logger.info(f'Took {stop-start} seconds.')
 
         #
         self.static_canvas.draw()
 
-    def appendResultsStr(self, str, maxFreq="", maxPsd="", freqs="", psd=""):
-        self._resultStr += str + "\n"
+    def appendResultsStr(self, str, maxFreq='', maxPsd='', freqs='', psd=''):
+        self._resultStr += str + '\n'
         resultDict = {
-            "file": self.ba.fileLoader.filename,
-            "startSec": self.getStartStop()[0],
-            "stopSec": self.getStartStop()[1],
-            "butterFilter": self.doButterFilter,
-            "butterOrder": self.butterOrder,
-            "lowFreqCutoff": self.butterCutoff[0],
-            "highFreqCutoff": self.butterCutoff[1],
-            "maxFreq": maxFreq,
-            "maxPSD": maxPsd,
-            "freqs": freqs,
-            "psd": psd,
+            'file': self.ba.fileLoader.filename,
+            'startSec': self.getStartStop()[0],
+            'stopSec': self.getStartStop()[1],
+            'butterFilter': self.doButterFilter,
+            'butterOrder': self.butterOrder,
+            'lowFreqCutoff': self.butterCutoff[0],
+            'highFreqCutoff': self.butterCutoff[1],
+            'maxFreq': maxFreq,
+            'maxPSD': maxPsd,
+            'freqs': freqs,
+            'psd': psd,
         }
         self._resultsDictList.append(resultDict)
 
     def getResultsDictList(self):
         return self._resultsDictList
 
     def getResultStr(self):
@@ -1212,103 +1123,104 @@
     def old_replot_fft(self):
         self.replot_fft2()
         return
 
     def replotFilter(self):
         """Plot frequency response of butter sos filter."""
 
-        logger.info("")
+        logger.info('')
 
-        # self.sos = butter_sos(self.butterCutoff, self.fs, self.butterOrder, passType='lowpass')
+        #self.sos = butter_sos(self.butterCutoff, self.fs, self.butterOrder, passType='lowpass')
 
         fs = self.fs
 
         if self.sos is None:
             # filter has not been created
-            self.sos = butter_sos(
-                self.butterCutoff, self.fs, order=self.butterOrder, passType="bandpass"
-            )
+            self.sos = butter_sos(self.butterCutoff, self.fs, order=self.butterOrder, passType='bandpass')
 
-        w, h = scipy.signal.sosfreqz(self.sos, worN=fs * 5, fs=fs)
+        w,h = scipy.signal.sosfreqz(self.sos, worN=fs*5, fs=fs)
 
-        print("w:", w)
-        print("h:", np.abs(h))
+        print('w:', w)
+        print('h:', np.abs(h))
 
         fig = plt.figure(figsize=(3, 3))
-        ax1 = fig.add_subplot(1, 1, 1)  #
+        ax1 = fig.add_subplot(1,1,1) #
 
-        # plt.plot(0.5*fs*w/np.pi, np.abs(H), 'b')
-        db = 20 * np.log10(np.maximum(np.abs(h), 1e-5))
-        # y = np.abs(H)  # 10*np.log10(np.maximum(1e-10, np.abs(H)))
-        ax1.plot(w, db, "-")
-        ax1.axvline(self.butterCutoff[0], color="r", linestyle="--", linewidth=0.5)
-        ax1.axvline(self.butterCutoff[1], color="r", linestyle="--", linewidth=0.5)
-        # y_sos = signal.sosfilt(sos, x)
+        #plt.plot(0.5*fs*w/np.pi, np.abs(H), 'b')
+        db = 20*np.log10(np.maximum(np.abs(h), 1e-5))
+        #y = np.abs(H)  # 10*np.log10(np.maximum(1e-10, np.abs(H)))
+        ax1.plot(w, db, '-')
+        ax1.axvline(self.butterCutoff[0], color='r', linestyle='--', linewidth=0.5)
+        ax1.axvline(self.butterCutoff[1], color='r', linestyle='--', linewidth=0.5)
+        #y_sos = signal.sosfilt(sos, x)
         ax1.set_xlim(0, self.maxPlotHz * 2)
 
-        ax1.set_xlabel("Frequency (Hz)")
-        ax1.set_ylabel("Decibles (dB)")
+        ax1.set_xlabel('Frequency (Hz)')
+        ax1.set_ylabel('Decibles (dB)')
 
         plt.show()
 
     def old_getPsd(self):
-        """Get psd from selected x-axes range."""
-        # logger.info(f'self.lastLeft:{self.lastLeft} self.lastRight:{self.lastRight}')
-        dataFiltered = self.getSweep("filteredVm")
+        """Get psd from selected x-axes range.
+        """
+        #logger.info(f'self.lastLeft:{self.lastLeft} self.lastRight:{self.lastRight}')
+        dataFiltered = self.getSweep('filteredVm')
         leftPoint = self.lastLeft
         rightPoint = self.lastRight
         y_sos = scipy.signal.sosfilt(self.sos, dataFiltered[leftPoint:rightPoint])
         self.f, self.Pxx_den = scipy.signal.periodogram(y_sos, self.fs)
 
     def rebuildModel(self):
         numSeconds = self.modelSecondsSpinBox.value()
         spikeFreq = self.modelFrequencySpinBox.value()
         amp = self.modelAmpSpinBox.value()
         noiseAmp = self.modelNoiseAmpSpinBox.value()
         fs = 10000  # 10 kHz
-        t, spikeTrain, data = getSpikeTrain(
-            numSeconds=numSeconds,
-            spikeFreq=spikeFreq,
-            fs=fs,
-            amp=amp,
-            noiseAmp=noiseAmp,
-        )
+        t, spikeTrain, data = getSpikeTrain(numSeconds=numSeconds,
+                                spikeFreq=spikeFreq,
+                                fs=fs,
+                                amp=amp,
+                                noiseAmp=noiseAmp)
         # (t, data) need to be one column (for bAnalysis)
-        t = t.reshape(t.shape[0], -1)
-        data = data.reshape(data.shape[0], -1)
+        t = t.reshape(t.shape[0],-1)
+        data = data.reshape(data.shape[0],-1)
 
         self._startSec = 0
         self._stopSec = numSeconds
 
-        # t = t[:,0]
-        # data = data[:,0]
+        #t = t[:,0]
+        #data = data[:,0]
 
-        print("  model t:", t.shape)
-        print("  model data:", data.shape)
+        print('  model t:', t.shape)
+        print('  model data:', data.shape)
 
-        modelDict = {"sweepX": t, "sweepY": data, "mode": "I-Clamp"}
+        modelDict = {
+            'sweepX': t,
+            'sweepY': data,
+            'mode': 'I-Clamp'
+        }
         self._ba = sanpy.bAnalysis(fromDict=modelDict)
 
-        # self.modelDetect()
+        #self.modelDetect()
 
     def loadData(self, fileIdx=0, modelData=False):
         """Load from an analysis directory. Only used when no SanPyApp."""
         if modelData:
             self.isModel = True
 
             # store bAnalysis so we can bring it back
             self._store_ba = self._ba
             self._store_startSec = self._startSec
             self._store_stopSec = self._stopSec
 
             #
             # load from a model
-            # numSeconds = 50
-            # spikeFreq = 1
-            # amp = 20
+            #numSeconds = 50
+            #spikeFreq = 1
+            #amp = 20
             #  TODO: ensure we separate interface from backend !!!
             self.rebuildModel()
         else:
             self.isModel = False
             if self._analysisDir is not None:
                 self._ba = self._analysisDir.getAnalysis(fileIdx)
 
@@ -1323,356 +1235,351 @@
         self.fs = self.ba.fileLoader.recordingFrequency * 1000
 
         self.replot2(switchFile=True)
 
         return
 
     def not_used_modelDetect(self):
-        # mvThreshold = self.mvThresholdSpinBox.value() # for detection
+        #mvThreshold = self.mvThresholdSpinBox.value() # for detection
         mvThreshold = -20
 
-        dDict = sanpy.bDetection().getDetectionDict("SA Node")
-        dDict["dvdtThreshold"] = np.nan
-        dDict["mvThreshold"] = mvThreshold
-        dDict["onlyPeaksAbove_mV"] = None
-        dDict["doBackupSpikeVm"] = False
+        dDict = sanpy.bDetection().getDetectionDict('SA Node')
+        dDict['dvdtThreshold'] = np.nan
+        dDict['mvThreshold'] = mvThreshold
+        dDict['onlyPeaksAbove_mV'] = None
+        dDict['doBackupSpikeVm'] = False
         self._ba.spikeDetect(dDict)
 
     def on_cutoff_spinbox(self, name):
-        """When user sets values, rebuild low-pass filter."""
+        """When user sets values, rebuild low-pass filter.
+        """
         self.nfft = self.nfftSpinBox.value()
         self.maxPlotHz = self.maxPlotHzSpinBox.value()
         self.medianFilterPnts = self.medianFilterPntsSpinBox.value()  # int
 
         self.butterOrder = self.butterOrderSpinBox.value()
 
         lowCutoff = self.lowCutoffSpinBox.value()  # int
         highCutoff = self.highCutoffSpinBox.value()  # int
         self.butterCutoff = [lowCutoff, highCutoff]
 
-        self.freqResLabel.setText(f"Freq Resolution (Hz) {round(self.fs/self.nfft, 3)}")
+        self.freqResLabel.setText(f'Freq Resolution (Hz) {round(self.fs/self.nfft, 3)}')
 
-        # self.order = self.orderSpinBox.value()
-        # self.sos = butter_lowpass_sos(self.cutOff, self.fs, self.order)
+        #self.order = self.orderSpinBox.value()
+        #self.sos = butter_lowpass_sos(self.cutOff, self.fs, self.order)
 
     def on_checkbox_clicked(self, name, value):
-        # print('on_crosshair_clicked() value:', value)
+        #print('on_crosshair_clicked() value:', value)
         logger.info(f'name:"{name}" value:{value}')
-        isOn = value == 2
-        if name == "PSD":
+        isOn = value==2
+        if name == 'PSD':
             self.psdAxes.set_visible(isOn)
             if isOn:
-                self.vmAxes.change_.geometry(2, 1, 1)
+                self.vmAxes.change_.geometry(2,1,1)
                 self.replotPsd()
             else:
-                self.vmAxes.change_geometry(1, 1, 1)
+                self.vmAxes.change_geometry(1,1,1)
             self.static_canvas.draw()
-        elif name == "Auto-Correlation":
+        elif name == 'Auto-Correlation':
             pass
-        elif name == "Model Data":
+        elif name == 'Model Data':
             self.loadData(fileIdx=0, modelData=isOn)
-        elif name == "Butter Filter":
-            self.doButterFilter = value == 2
+        elif name == 'Butter Filter':
+            self.doButterFilter = value==2
             self.replot2(switchFile=False)
         else:
             logger.warning(f'name:"{name}" not understood')
 
     def on_button_click(self, name):
-        if name == "Replot":
+        if name == 'Replot':
             if self.isModel:
                 self.rebuildModel()
-                # self.replot2(switchFile=False)
+                #self.replot2(switchFile=False)
             #
             self.replot2(switchFile=False)
-        elif name == "Filter Response":
+        elif name == 'Filter Response':
             # popup new window
             self.replotFilter()
         else:
             logger.warning(f'name:"{name}" not understood')
-        """
+        '''
         elif name == 'Detect':
             #mvThreshold = self.mvThresholdSpinBox.value()
             #logger.info(f'{name} mvThreshold:{mvThreshold}')
             self.modelDetect()
             self.replot2()
         elif name == 'Rebuild Auto-Corr':
             self.replotAutoCorr()
-        """
+        '''
 
     def on_xlims_change(self, event_ax):
         return
 
         if not self._isInited:
             return
 
-        # slogger.info(f'event_ax:{event_ax}')
+        #slogger.info(f'event_ax:{event_ax}')
         left, right = event_ax.get_xlim()  # seconds
-        logger.info(f"left:{left} right:{right}")
+        logger.info(f'left:{left} right:{right}')
 
         # find start/stop point from seconds in 't'
-        t = self.getSweep("x")
+        t = self.getSweep('x')
         leftPoint = np.where(t >= left)[0]
         leftPoint = leftPoint[0]
         rightPoint = np.where(t >= right)[0]
         if len(rightPoint) == 0:
             rightPoint = len(t)  # assuming we use [left:right]
         else:
             rightPoint = rightPoint[0]
-        # print('leftPoint:', leftPoint, 'rightPoint:', rightPoint, 'len(t):', len(self.t))
+        #print('leftPoint:', leftPoint, 'rightPoint:', rightPoint, 'len(t):', len(self.t))
 
         # keep track of last setting, if it does not change then do nothing
-        if self.lastLeft == leftPoint and self.lastRight == rightPoint:
-            logger.info("left/right point same doing nothng -- RETURNING")
+        if self.lastLeft==leftPoint and self.lastRight==rightPoint:
+            logger.info('left/right point same doing nothng -- RETURNING')
             return
         else:
             self.lastLeft = leftPoint
             self.lastRight = rightPoint
 
         #
         # get threshold fromm selection
         self.getMean()
 
         self.replotPsd()
         self.replot_fft()
-        # self.replotAutoCorr()  # slow, requires button push
+        #self.replotAutoCorr()  # slow, requires button push
 
     def keyPressEvent(self, event):
         logger.info(event)
         text = super().keyPressEvent(event)
 
-        # isMpl = isinstance(event, mpl.backend_bases.KeyEvent)
-        # text = event.key
-        # logger.info(f'xxx mpl key: "{text}"')
+        #isMpl = isinstance(event, mpl.backend_bases.KeyEvent)
+        #text = event.key
+        #logger.info(f'xxx mpl key: "{text}"')
 
-        if text == "h":
+        if text == 'h':
             # hide controls (leave plots)
             self.controlLayout.hide()
 
-        if text in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]:
-            # self.loadData yyy
+        if text in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:
+            #self.loadData yyy
             fileIdx = int(text)
             self.loadData(fileIdx)
             self.replot2(switchFile=True)
 
-        elif text == "f":
+        elif text == 'f':
             self.replotFilter()
 
-    def slot_switchFile(
-        self, ba: sanpy.bAnalysis, rowDict: Optional[dict] = None, replot: bool = True
-    ):
+    def slot_switchFile(self,
+                        ba : sanpy.bAnalysis,
+                        rowDict : Optional[dict] = None,
+                        replot : bool = True):
         super().slot_switchFile(ba, rowDict, replot=False)
 
         self.fs = self.ba.fileLoader.recordingFrequency * 1000
 
-        self.freqResLabel.setText(f"Freq Resolution (Hz) {round(self.fs/self.nfft, 3)}")
+        self.freqResLabel.setText(f'Freq Resolution (Hz) {round(self.fs/self.nfft, 3)}')
 
         self.replot()
 
-
 def testPlugin():
     from PyQt5 import QtWidgets
-
     app = QtWidgets.QApplication([])
 
-    path = "/Users/cudmore/Sites/Sanpy/data/fft"
+    path = '/Users/cudmore/Sites/Sanpy/data/fft'
     ad = sanpy.analysisDir(path, autoLoad=True)
 
     fft = fftPlugin(ad)
-    # plt.show()
+    #plt.show()
 
     sys.exit(app.exec_())
 
-
 def test_fft():
     if 0:
         # abf data
-        path = "/Users/cudmore/Sites/SanPy/data/fft/2020_07_07_0000.abf"
+        path = '/Users/cudmore/Sites/SanPy/data/fft/2020_07_07_0000.abf'
         ba = sanpy.bAnalysis(path)
 
         x = ba.fileLoader.sweepX
         y = ba.fileLoader.sweepY
 
         # 20-30 sec
-        startSec = 16.968  # good signal
+        startSec = 16.968 # good signal
         stopSec = 31.313
 
         # reduce to get fft with N=1024 in excel
         dataPointsPerMs = ba.fileLoader.dataPointsPerMs  # 10 for 10 kHz
         startPnt = round(startSec * 1000 * dataPointsPerMs)
         stopPnt = round(stopSec * 1000 * dataPointsPerMs)
 
-        numPnts = stopPnt - startPnt
-        print(f"N={numPnts}")
+        numPnts = stopPnt-startPnt
+        print(f'N={numPnts}')
 
         t = x[startPnt:stopPnt]
         y = y[startPnt:stopPnt]
 
-        # y -= np.nanmean(y)
+        #y -= np.nanmean(y)
 
         dt = 0.0001
-        fs = 1 / dt
-        NFFT = 512  # 2**16 #512 * 100  # The number of data points used in each block for the FFT
+        fs = 1/dt
+        NFFT = 512 # 2**16 #512 * 100  # The number of data points used in each block for the FFT
         medianPnts = 50  # 5 ms
 
         fileName = ba.fileLoader.filename
 
     if 1:
         # sin wave data
         # Fixing random state for reproducibility
         np.random.seed(19680801)
 
         durSec = 10.24  # to get 1024 points at dt=0.01 (power of two)
         dt = 0.01
-        fs = 1 / dt
+        fs = 1/dt
         nfft = 512  # The number of data points used in each block for the FFT
         medianPnts = 5  #
 
         t = np.arange(0, durSec, dt)
         nse = np.random.randn(len(t))
         r = np.exp(-t / 0.05)
 
         cnse = np.convolve(nse, r) * dt
-        cnse = cnse[: len(t)]
+        cnse = cnse[:len(t)]
 
         secondFre = 7
         y = 0.1 * np.sin(2 * np.pi * t) + cnse
         y += 0.1 * np.sin(secondFre * 2 * np.pi * t) + cnse
 
-        fileName = "fakeSin"
+        fileName = 'fakeSin'
 
-    # def replot_fft():
+    #def replot_fft():
 
     #
     # filter
     yFiltered = scipy.ndimage.median_filter(y, medianPnts)
 
     # subsample down to 1024
-    """
+    '''
     from scipy.interpolate import interp1d
     t2 = interp1d(np.arange(1024), t, 'linear')
     yFiltered2 = interp1d(t, yFiltered, 'linear')
     print(f'N2={len(t2)}')
     plt.plot(t2, yFiltered2)
-    """
+    '''
 
     # save [t,y] to csv
-    """
+    '''
     import pandas as pd
     tmpDf = pd.DataFrame(columns=['t', 'y'])
     tmpDf['t'] = t
     tmpDf['y'] = y
     csvPath = fileName + '.csv'
     print('saving csv:', csvPath)
     tmpDf.to_csv(csvPath, index=False)
-    """
+    '''
 
-    """
+    '''
     cutOff = 10 #20  # 20, cutOff of filter (Hz)
     order = 50 # 40  # order of filter
     sos = butter_lowpass_sos(cutOff, fs, order)
-    """
+    '''
 
-    # yFiltered = scipy.signal.sosfilt(sos, yFiltered)
+    #yFiltered = scipy.signal.sosfilt(sos, yFiltered)
 
     #
-    # Fs = 1/dt  # The sampling frequency (samples per time unit)
-    # NFFT = 512  # The number of data points used in each block for the FFT
+    #Fs = 1/dt  # The sampling frequency (samples per time unit)
+    #NFFT = 512  # The number of data points used in each block for the FFT
 
     # plot
     fig, (ax0, ax1, ax2) = plt.subplots(3, 1)
 
-    ax0.plot(t, y, "k")
-    ax0.plot(t, yFiltered, "r")
+    ax0.plot(t, y, 'k')
+    ax0.plot(t, yFiltered, 'r')
 
     def myDetrend(x):
         y = plt.mlab.detrend_linear(x)
         y = plt.mlab.detrend_mean(y)
         return y
 
     # The power spectral density 𝑃𝑥𝑥 by Welch's average periodogram method
-    print("  fs:", fs, "nfft:", nfft)
+    print('  fs:', fs, 'nfft:', nfft)
     ax1.clear()
     Pxx, freqs = ax1.psd(yFiltered, NFFT=nfft, Fs=fs, detrend=myDetrend)
     ax1.set_xlim([0, 20])
-    ax1.set_ylabel("PSD (dB/Hz)")
-    # ax1.callbacks.connect('xlim_changed', self.on_xlims_change)
+    ax1.set_ylabel('PSD (dB/Hz)')
+    #ax1.callbacks.connect('xlim_changed', self.on_xlims_change)
 
-    """
+    '''
     ax1.clear()
     ax1.plot(freqs, Pxx)
     ax1.set_xlim([0, 20])
-    """
+    '''
 
-    """
+    '''
     # recompute the ax.dataLim
     ax1.relim()
     # update ax.viewLim using the new dataLim
     ax1.autoscale_view()
     plt.draw()
-    """
+    '''
 
-    """
+    '''
     ax2.plot(freqs, Pxx)
     ax2.set_xlim([0, 20])
-    """
+    '''
 
     maxPsd = np.nanmax(Pxx)
     maxPnt = np.argmax(Pxx)
-    print(f"Max PSD freq is {freqs[maxPnt]} with power {maxPsd}")
+    print(f'Max PSD freq is {freqs[maxPnt]} with power {maxPsd}')
 
     scipy_f, scipy_Pxx = scipy.signal.periodogram(yFiltered, fs)
     ax2.plot(scipy_f[1:-1], scipy_Pxx[1:-1])  # drop freq 0
     ax2.set_xlim([0, 20])
 
-    ax2.set_xlabel("Frequency (Hz)")
-    ax2.set_ylabel("scipy_Pxx")
+    ax2.set_xlabel('Frequency (Hz)')
+    ax2.set_ylabel('scipy_Pxx')
 
     #
     plt.show()
 
-
 def testFilter():
     butterOrder = 50
     butterCutoff = [0.7, 10]
     fs = 10000
-    # nyq = fs * 0.5
-    # normal_cutoff = butterCutoff / nyq
-    # normal_cutoff = butterCutoff
-    passType = "bandpass"
+    #nyq = fs * 0.5
+    #normal_cutoff = butterCutoff / nyq
+    #normal_cutoff = butterCutoff
+    passType = 'bandpass'
 
-    # sos = scipy.signal.butter(N=butterOrder, Wn=butterCutoff, btype=passType, analog=False, fs=fs, output='sos')
-    sos = butter_sos(butterCutoff, fs, order=butterOrder, passType="bandpass")
+    #sos = scipy.signal.butter(N=butterOrder, Wn=butterCutoff, btype=passType, analog=False, fs=fs, output='sos')
+    sos = butter_sos(butterCutoff, fs, order=butterOrder, passType='bandpass')
 
-    w, h = scipy.signal.sosfreqz(sos, worN=fs * 5, fs=fs)
+    w,h = scipy.signal.sosfreqz(sos, worN=fs*5, fs=fs)
 
-    db = 20 * np.log10(np.maximum(np.abs(h), 1e-5))
+    db = 20*np.log10(np.maximum(np.abs(h), 1e-5))
 
-    print("w:", w)
-    print("db:", db)
+    print('w:', w)
+    print('db:', db)
 
     fig = plt.figure(figsize=(3, 3))
-    ax1 = fig.add_subplot(1, 1, 1)  #
+    ax1 = fig.add_subplot(1,1,1) #
 
-    ax1.plot(w, db, "-")
+    ax1.plot(w, db, '-')
     ax1.set_xlim([0, 15])
 
     plt.show()
 
-
 def main():
-    path = "/home/cudmore/Sites/SanPy/data/19114001.abf"
+    path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
     ba = sanpy.bAnalysis(path)
     ba.spikeDetect()
     print(ba.numSpikes)
 
     import sys
-
     app = QtWidgets.QApplication([])
     fft = fftPlugin(ba=ba)
     fft.show()
     sys.exit(app.exec_())
 
-
-if __name__ == "__main__":
-    # test_fft()
-    # testFilter()
+if __name__ == '__main__':
+    #test_fft()
+    #testFilter()
     main()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/plotFi.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/plotFi.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,44 +1,40 @@
+
 import time
 from typing import Union, Dict, List, Tuple, Optional, Optional
 from functools import partial
 
 import numpy as np
 import pandas as pd
 
 import matplotlib.pyplot as plt
 import seaborn as sns
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy import bDetection
 from sanpy import bAnalysis
 from sanpy.interface import myTableView_tmp  # name conflict with interface.myTableView
 from sanpy.interface.plugins import sanpyPlugin
-from sanpy.interface.plugins import (
-    ResponseType,
-)  # to toggle response to set sweeps, etc
+from sanpy.interface.plugins import ResponseType  # to toggle response to set sweeps, etc
 from sanpy.interface.plugins import myStatListWidget
 
-
-def getStatFi(
-    dfMaster: pd.DataFrame,
-    stat: str,
-    epochNumber: int = 2,
-    intervalStat: bool = False,
-    filename: str = "",
-) -> pd.DataFrame:
+def getStatFi(dfMaster : pd.DataFrame,
+              stat : str,
+              epochNumber : int = 2,
+              intervalStat : bool = False,
+              filename : str = ''
+              ) -> pd.DataFrame:
     """Given a bAnalysis stat, derive a number of stats
     for each sweep
-
+    
     Sweeps correspond to different current injection amplitudes.
 
     Parameters
     ----------
     dfMaster : DataFrame
     stat : str
     epochNumber : int
@@ -47,637 +43,589 @@
         Used for stat like spike frequency (Hz) or ISI (ms)
     filename : str
         Append filename column
 
     Notes
     -----
     Rows in the table are sweeps, if there are no spikes in a sweep it will not be included
-    """
-
+    """    
+    
     _startSec = time.time()
 
     # reduce to only spikes for given epochNumber
-    dfEpoch = dfMaster[dfMaster["epoch"] == epochNumber]
-
+    dfEpoch = dfMaster[dfMaster['epoch']==epochNumber]
+    
     # epochLevels is a list of current injection amplitudes
-    epochLevels = dfEpoch["epochLevel"].unique()
-    epochLevels = np.round(epochLevels, 3)
-
+    epochLevels = dfEpoch['epochLevel'].unique()
+    epochLevels = np.round(epochLevels,3)
+    
     # we also want 1st, 2nd, 3rd and nth values
     # don't use agg variable `first` or `last`` (they skip nan)
     #   `second`` is not available
-    agg_func_math = {stat: ["count", "mean", "median", "min", "max", "std", "sem"]}
+    agg_func_math = {
+        stat:
+        ['count', 'mean', 'median', 'min', 'max', 'std', 'sem']
+    }
     as_index = True  # if True then 'sweep' number becomes the row index
-    dfSweepsSummary = (
-        dfEpoch.groupby(["sweep"], as_index=as_index).agg(agg_func_math).round(2)
-    )
+    dfSweepsSummary = dfEpoch.groupby(['sweep'],
+                                      as_index=as_index).agg(agg_func_math).round(2)
 
-    # flatten
+    #flatten
     dfSweepsSummary.columns = [
-        "_".join(col).rstrip("_") for col in dfSweepsSummary.columns.values
+        '_'.join(col).rstrip('_') for col in dfSweepsSummary.columns.values
     ]
 
     # insert as first column, after 'sweeps'
-    dfSweepsSummary.insert(0, "epochLevel", epochLevels)
+    dfSweepsSummary.insert(0, 'epochLevel', epochLevels)
     # dfSweepsSummary['epochLevel'] = epochLevels
 
     # get the first, second and last values
     # if we are doing interval statistics like 'inter spike interval'
     # then always ignore the `first` event in the epoch (e.g. no interval for first spike)
 
     if intervalStat:
         firstSpike = 1
     else:
         firstSpike = 0
-
-    _first = dfEpoch.groupby(["sweep"], as_index=True)[stat].nth(firstSpike)
-    dfSweepsSummary.at[_first.index, stat + "_first"] = _first.values
+    
+    _first = dfEpoch.groupby(['sweep'], as_index=True)[stat].nth(firstSpike)
+    dfSweepsSummary.at[_first.index, stat + '_first'] = _first.values
     # print('_first.index', _first.index)
 
-    _second = dfEpoch.groupby(["sweep"], as_index=True)[stat].nth(firstSpike + 1)
-    dfSweepsSummary.at[_second.index, stat + "_second"] = _second.values
+    _second = dfEpoch.groupby(['sweep'], as_index=True)[stat].nth(firstSpike+1)
+    dfSweepsSummary.at[_second.index, stat + '_second'] = _second.values
     # print('_second.index', _second.index)
 
     # _third = dfEpoch.groupby(['sweep'], as_index=True)[stat].nth(2)
     # dfSweepsSummary.at[_second.index, stat + '_third'] = _third.values
 
-    _last = dfEpoch.groupby(["sweep"], as_index=True)[stat].nth(-1)
-    dfSweepsSummary.at[_last.index, stat + "_last"] = _last.values
+    _last = dfEpoch.groupby(['sweep'], as_index=True)[stat].nth(-1)
+    dfSweepsSummary.at[_last.index, stat + '_last'] = _last.values
     # print('_last.index', _last.index)
 
     # 1st / 2nd and 1s / last
-    dfSweepsSummary[stat + "_1_2"] = (
-        dfSweepsSummary[stat + "_first"] / dfSweepsSummary[stat + "_second"]
-    )
-    dfSweepsSummary[stat + "_1_n"] = (
-        dfSweepsSummary[stat + "_first"] / dfSweepsSummary[stat + "_last"]
-    )
+    dfSweepsSummary[stat + '_1_2'] = dfSweepsSummary[stat + '_first'] / dfSweepsSummary[stat + '_second']
+    dfSweepsSummary[stat + '_1_n'] = dfSweepsSummary[stat + '_first'] / dfSweepsSummary[stat + '_last']
 
     # coefficient of variation.
     # Always calculate but only meaningful for interval stats?
-    dfSweepsSummary[stat + "_cv"] = (
-        dfSweepsSummary[stat + "_std"] / dfSweepsSummary[stat + "_mean"]
-    )
+    dfSweepsSummary[stat + '_cv'] = dfSweepsSummary[stat + '_std'] / dfSweepsSummary[stat + '_mean']
 
-    dfSweepsSummary["filename"] = filename
+    dfSweepsSummary['filename'] = filename
 
     # move index column 'sweep' into a column
     dfSweepsSummary = dfSweepsSummary.reset_index()
 
     _stopSec = time.time()
-    # print(f'Took {round(_stopSec-_startSec,3)} seconds')
+    #print(f'Took {round(_stopSec-_startSec,3)} seconds')
 
     return dfSweepsSummary
 
-
 class plotFi(sanpyPlugin):
-    myHumanName = "Plot FI"
+    myHumanName = 'Plot FI'
 
     def __init__(self, **kwargs):
         super().__init__(**kwargs)
-
+    
         self.toggleResponseOptions(ResponseType.setSweep, False)  # we plot all sweeps
         self.toggleResponseOptions(ResponseType.setAxis, False)
 
         # inherited property
         self._epochNumber = 2
 
         self.setDefaultPlot()
-
+        
         self.df_fi = None
         self._buildUI()
 
         self._refreshPlotOptionsLayout()
 
-        self._selectInTable("Spike Frequency (Hz)")
+        self._selectInTable('Spike Frequency (Hz)')
 
         self.replot()
 
     def setDefaultPlot(self):
-        """Default plot dict"""
-
+        """Default plot dict
+        """
+        
         self._plotDict = {
-            "Raw": True,
-            "Error": "sem",  # in [None, 'std', 'sem']
-            "Legend": False,
+            'Raw': True,
+            'Error': 'sem',  # in [None, 'std', 'sem']
+            'Legend': False,
             # keys correspond to columns returned by getStatFI()
-            "overlays": {
-                "Mean": True,
-                "First": False,
-                "Last": False,
-                "CV": False,
-                "Count": False,
-                "1_2": False,  # first spike / second spike
-                "1_n": False,  # first spike / last spike
+            'overlays': {
+                'Mean': True,
+                'First': False,
+                'Last': False,            
+                'CV': False,            
+                'Count': False,
+                '1_2': False,  # first spike / second spike
+                '1_n': False, # first spike / last spike
             },
         }
-
-    def on_error_combo_box(self, item: str):
-        if item == "None":
+    
+    def on_error_combo_box(self, item : str):
+        if item == 'None':
             item = None
-        self._plotDict["Error"] = item
+        self._plotDict['Error'] = item
         self.replot()
 
-    def _selectInTable(self, findStatKey: str):
+    def _selectInTable(self, findStatKey : str):
         # this is a CLUDGE !!! FIX IT
         # select in table
         _statList = self._yStatListWidget.statList
         # find 'Spike Frequency (Hz)'
         foundKeyIdx = None
         for keyIdx, k in enumerate(_statList.keys()):
             if k == findStatKey:
                 foundKeyIdx = keyIdx
         if foundKeyIdx is not None:
             self._yStatListWidget.myTableWidget.selectRow(foundKeyIdx)
 
-    def on_button_click(self, name: str):
+    def on_button_click(self, name : str):
         """
         Parameters
         ----------
         name : str
             Name of the buton clicked
         """
         logger.info(name)
-        if name == "Inst Freq":
-            self.setDefaultPlot()  # reset _plotDict to defaults
+        if name == 'Inst Freq':
+            self.setDefaultPlot()  #reset _plotDict to defaults
             # set based on button
-            self._plotDict["Raw"] = True
-            self._plotDict["Error"] = "sem"
-            self._plotDict["overlays"]["Mean"] = True
+            self._plotDict['Raw'] = True
+            self._plotDict['Error'] = 'sem'
+            self._plotDict['overlays']['Mean'] = True
 
-            self._selectInTable("Spike Frequency (Hz)")
+            self._selectInTable('Spike Frequency (Hz)')
 
-        elif name == "Spike Count":
-            self.setDefaultPlot()  # reset _plotDict to defaults
+        elif name == 'Spike Count':
+            self.setDefaultPlot()  #reset _plotDict to defaults
             # set based on button
-            self._plotDict["Raw"] = False
-            self._plotDict["Error"] = None
-            self._plotDict["Legend"] = True
-            self._plotDict["overlays"]["Count"] = True
+            self._plotDict['Raw'] = False
+            self._plotDict['Error'] = None
+            self._plotDict['Legend'] = True
+            self._plotDict['overlays']['Count'] = True
         else:
             logger.warning(f'Did not understand "{name}')
             return
 
         # refresh interface
         self._refreshPlotOptionsLayout()
 
         # replot
         self.replot()
 
-    def on_check_click(self, state: int, name: str):
+    def on_check_click(self, state: int, name : str):
+    
         isChecked = state > 0
 
-        logger.info(f"{name} is checked {isChecked}")
+        logger.info(f'{name} is checked {isChecked}')
 
         _doReplot = False
-
-        if name == "Results Table":
+        
+        if name == 'Results Table':
             self._fiTableView.setVisible(isChecked)
-        elif name == "Plot Toolbar":
+        elif name == 'Plot Toolbar':
             self._mplToolbar.setVisible(isChecked)
         elif name in self._plotDict.keys():
             # top level like [Raw, Legend, Error]
             self._plotDict[name] = isChecked
             _doReplot = True
-        elif name in self._plotDict["overlays"].keys():
-            self._plotDict["overlays"][name] = isChecked
+        elif name in self._plotDict['overlays'].keys():
+            self._plotDict['overlays'][name] = isChecked
             _doReplot = True
         else:
             logger.warning(f'Did not understand checkbox "{name}"')
             return
-
+        
         if _doReplot:
             self.replot()
 
     def _buildTopToolbar(self):
         _topToolbar = QtWidgets.QHBoxLayout()
 
-        _defualtButtons = ["Inst Freq", "Spike Count"]
-
+        _defualtButtons = ['Inst Freq', 'Spike Count']
+        
         for buttonName in _defualtButtons:
             _aButton = QtWidgets.QPushButton(buttonName)
-            _aButton.clicked.connect(partial(self.on_button_click, buttonName))
+            _aButton.clicked.connect(partial(self.on_button_click,buttonName))
             _topToolbar.addWidget(_aButton, alignment=QtCore.Qt.AlignLeft)
 
-        # toggle the fi stat table
-        name = "Results Table"
+        #toggle the fi stat table
+        name = 'Results Table'
         _aCheckbox = QtWidgets.QCheckBox(name)
         _aCheckbox.setChecked(False)
-        _aCheckbox.stateChanged.connect(
-            lambda state, name=name: self.on_check_click(state, name)
-        )
+        _aCheckbox.stateChanged.connect(lambda state, name=name: self.on_check_click(state,name))
         _topToolbar.addWidget(_aCheckbox, alignment=QtCore.Qt.AlignLeft)
 
         # toggle self._mplToolbar
-        name = "Plot Toolbar"
+        name = 'Plot Toolbar'
         _aCheckbox = QtWidgets.QCheckBox(name)
         _aCheckbox.setChecked(False)
-        _aCheckbox.stateChanged.connect(
-            lambda state, name=name: self.on_check_click(state, name)
-        )
+        _aCheckbox.stateChanged.connect(lambda state, name=name: self.on_check_click(state,name))
         _topToolbar.addWidget(_aCheckbox, alignment=QtCore.Qt.AlignLeft)
 
         _topToolbar.addStretch()
 
         return _topToolbar
-
+    
     def _refreshPlotOptionsLayout(self):
-        """Refresh all buttons in _overlayCheckboxes with self._plotDict['overlays']"""
+        """Refresh all buttons in _overlayCheckboxes with self._plotDict['overlays']
+        """
 
         # raw
-        _plotRaw = self._plotDict["Raw"]
+        _plotRaw = self._plotDict['Raw']
         self._rawCheckbox.setChecked(_plotRaw)
 
         # error
-        _errorType = self._plotDict["Error"]
+        _errorType = self._plotDict['Error']
         if _errorType is None:
-            _errorType = "None"
+            _errorType = 'None'
         self._errorComboBox.setCurrentText(_errorType)
 
-        for name, value in self._plotDict["overlays"].items():
+        for name, value in self._plotDict['overlays'].items():
             self._overlayCheckBoxes[name].setChecked(value)
 
     def _buildPlotOptionsLayout(self):
         _vLayout = QtWidgets.QVBoxLayout()
 
         # to toggle columns in fi analysis df
 
-        name = "Legend"
+        name = 'Legend'
         value = self._plotDict[name]
         _aCheckbox = QtWidgets.QCheckBox(name)
         _aCheckbox.setChecked(value)
-        _aCheckbox.stateChanged.connect(
-            lambda state, name=name: self.on_check_click(state, name)
-        )
+        _aCheckbox.stateChanged.connect(lambda state, name=name: self.on_check_click(state,name))
         _vLayout.addWidget(_aCheckbox, alignment=QtCore.Qt.AlignTop)
 
-        name = "Raw"
+        name = 'Raw'
         value = self._plotDict[name]
         self._rawCheckbox = QtWidgets.QCheckBox(name)
         self._rawCheckbox.setChecked(value)
-        self._rawCheckbox.stateChanged.connect(
-            lambda state, name=name: self.on_check_click(state, name)
-        )
+        self._rawCheckbox.stateChanged.connect(lambda state, name=name: self.on_check_click(state,name))
         _vLayout.addWidget(self._rawCheckbox, alignment=QtCore.Qt.AlignTop)
 
-        name = "Error"
+        name = 'Error'
         _errorLayout = QtWidgets.QHBoxLayout()
         _aLabel = QtWidgets.QLabel(name)
         _errorLayout.addWidget(_aLabel)
         self._errorComboBox = QtWidgets.QComboBox()
-        self._errorComboBox.addItems(["None", "std", "sem"])
+        self._errorComboBox.addItems(['None', 'std', 'sem'])
         self._errorComboBox.currentTextChanged.connect(self.on_error_combo_box)
         _errorLayout.addWidget(self._errorComboBox, alignment=QtCore.Qt.AlignTop)
         _vLayout.addLayout(_errorLayout)
 
         self._overlayCheckBoxes = {}
-        for name, value in self._plotDict["overlays"].items():
+        for name,value in self._plotDict['overlays'].items():
             _aCheckbox = QtWidgets.QCheckBox(name)
             _aCheckbox.setChecked(value)
-            _aCheckbox.stateChanged.connect(
-                lambda state, name=name: self.on_check_click(state, name)
-            )
+            _aCheckbox.stateChanged.connect(lambda state, name=name: self.on_check_click(state,name))
             _vLayout.addWidget(_aCheckbox, alignment=QtCore.Qt.AlignTop)
-
+            
             self._overlayCheckBoxes[name] = _aCheckbox
 
         _vLayout.addStretch()
 
         return _vLayout
-
+    
     def replot(self):
-        """Replot when file or analysis changes."""
-
-        logger.info("")
+        """Replot when file or analysis changes.
+        """
 
+        logger.info('')
+        
         if self.ba is None:
             return
-
+        
         # get from stat lists
         yHumanStat, yStat = self._yStatListWidget.getCurrentStat()
 
         # always clear the axis
         self.axs.clear()
 
-        self.axs.autoscale(enable=True, axis="y", tight=None)
+        self.axs.autoscale(enable=True, axis='y', tight=None)
 
         # get masterDf
         dfMaster = self.ba.spikeDict.asDataFrame()
         if dfMaster is None or dfMaster.empty:
             # no spikes
-            logger.info("no spikes to plot -> return")
+            logger.info('no spikes to plot -> return')
             return
-
+        
         # user has to specify which epoch
-        plotRaw = self._plotDict["Raw"]
+        plotRaw = self._plotDict['Raw']
         if plotRaw:
             # reduce to only spikes for given epochNumber
-            dfEpoch = dfMaster[dfMaster["epoch"] == self.epochNumber]
-            # sns.scatterplot(x='epochLevel', y=stat, data=dfEpoch, ax=_ax)
-            self.axs.scatter(
-                "epochLevel",
-                yStat,
-                data=dfEpoch,
-                marker="o",
-                c="#aaaaaa",
-                label=yHumanStat,
-            )
+            dfEpoch = dfMaster[dfMaster['epoch']==self.epochNumber]
+            #sns.scatterplot(x='epochLevel', y=stat, data=dfEpoch, ax=_ax)
+            self.axs.scatter('epochLevel', yStat, data=dfEpoch,
+                            marker='o', c='#aaaaaa',
+                            label=yHumanStat)
 
         #
         # get a df with summary fi data
         intervalStat = False
-        if yStat in ["spikeFreq_hz", "isi_ms"]:
+        if yStat in ['spikeFreq_hz', 'isi_ms']:
             intervalStat = True
         _filename = self.ba.getFileName()
-        logger.info(
-            f"calling getStatFi() with epoch:{self.epochNumber} intervalStat:{intervalStat} filename:{_filename}"
-        )
-        self.df_fi = getStatFi(
-            dfMaster,
-            yStat,
-            epochNumber=self.epochNumber,
-            intervalStat=intervalStat,
-            filename=_filename,
-        )
+        logger.info(f'calling getStatFi() with epoch:{self.epochNumber} intervalStat:{intervalStat} filename:{_filename}')
+        self.df_fi = getStatFi(dfMaster, yStat,
+                            epochNumber=self.epochNumber,
+                            intervalStat=intervalStat,
+                            filename=_filename)
 
-        logger.info("generated new fi table self.df_fi:")
+        logger.info('generated new fi table self.df_fi:')
         print(self.df_fi)
 
         if self.df_fi.empty:
-            logger.warning("  got empty dataframe -> return")
+            logger.warning('  got empty dataframe -> return')
             return
-
+        
         self._fiTableView.slotSwitchTableDf(self.df_fi)
 
         # cycle color
-        _fiStatColor = ["c", "m", "r", "b"] * 5
+        _fiStatColor = ['c', 'm', 'r', 'b'] * 5
 
         # for plotIdx, _fiStat in enumerate(fiStatList):
         plotIdx = -1
-        for _fiStat, value in self._plotDict["overlays"].items():
+        for _fiStat, value in self._plotDict['overlays'].items():
             plotIdx += 1
             if not value:
                 # plot is turned off
                 continue
-            _stat = yStat + "_" + _fiStat.lower()
-            # _ax = sns.scatterplot(x='epochLevel', y=_stat, data=df_fi, ax=_ax)
+            _stat = yStat + '_' + _fiStat.lower()
+            #_ax = sns.scatterplot(x='epochLevel', y=_stat, data=df_fi, ax=_ax)
             # _ax.plot('epochLevel', _stat, data=df_fi, linestyle='-', marker='o', color='k')
             currentColor = _fiStatColor[plotIdx]
             logger.info(f'plotting _stat:"{_stat}"')
-            _errorType = self._plotDict["Error"]
-            if _fiStat == "Mean" and _errorType is not None:
-                _yerr = yStat + "_" + _errorType
+            _errorType = self._plotDict['Error']
+            if _fiStat == 'Mean' and _errorType is not None:
+                _yerr = yStat + '_' + _errorType
             else:
                 _yerr = None
-            self.axs.errorbar(
-                "epochLevel",
-                _stat,
-                yerr=_yerr,
-                data=self.df_fi,
-                linestyle="-",
-                marker="o",
-                color=currentColor,
-                label=_fiStat,
-            )
+            self.axs.errorbar('epochLevel', _stat, yerr=_yerr, data=self.df_fi,
+                              linestyle='-', marker='o', color=currentColor,
+                              label=_fiStat)
 
-        if self._plotDict["Legend"]:
+        if self._plotDict['Legend']:
             self.axs.legend(loc="upper left")
 
         #
         # set x-axis to full range of all injected currents (e.g. epochLevel)
         # pad by 10%
-        epochLevels = dfMaster["epochLevel"].unique()
+        epochLevels = dfMaster['epochLevel'].unique()
         _minEpochLevel = np.min(epochLevels)
         _maxEpochLevel = np.max(epochLevels)
         _xRange = _maxEpochLevel - _minEpochLevel
         _xPad = _xRange * 0.1
         _xMin = _minEpochLevel - _xPad
         _xMax = _maxEpochLevel + _xPad
-        logger.info(f"_xMin:{_xMin} _xMax:{_xMax}")
+        logger.info(f'_xMin:{_xMin} _xMax:{_xMax}')
         if np.isnan(_xMin) or np.isnan(_xMax):
             pass
         else:
             self.axs.set_xlim([_xMin, _xMax])
 
         # set axis labels
-        self.axs.set_xlabel("Current Step (pA)")
+        self.axs.set_xlabel('Current Step (pA)')
         self.axs.set_ylabel(yHumanStat)
 
-        self.axs.spines["right"].set_visible(False)
-        self.axs.spines["top"].set_visible(False)
-
+        self.axs.spines['right'].set_visible(False)
+        self.axs.spines['top'].set_visible(False)
+        
         # redraw
         self.static_canvas.draw()
 
-    def copyToClipboard(self, df: pd.DataFrame = None):
-        logger.info("")
+    def copyToClipboard(self, df : pd.DataFrame = None):
+        logger.info('')
         if self.df_fi is None:
             return
-        self.df_fi.to_clipboard(sep="\t", index=False)
-
+        self.df_fi.to_clipboard(sep='\t', index=False)
+        
         # want to provide some feedback
         # #if self.getSanPyApp() is not None:
 
     def _buildUI(self):
+
         # top toolbar
         _topToolbar = self._buildTopToolbar()
         self.getVBoxLayout().addLayout(_topToolbar)
 
         main_hLayout = QtWidgets.QHBoxLayout()
-
+        
         # add list of y stats
         # has statList, a copy of sanpy.bAnalysisUtil.getStatList()
         # looks like
         #   statList['Spike Time (s)'] = {
         #       'name': 'thresholdSec',
-
+        
         # trim down stat list
         _statList = sanpy.bAnalysisUtil.getStatList()
         # for k in _statList.keys():
         #     print(k)
-        _hideTheseKeys = [
-            "Spike Number",
-            "Sweep Spike Number",
-            "Sweep Number",
-            "Epoch",
-            "Epoch DAC",
-            "Epoch Spike Number",
-        ]
+        _hideTheseKeys = ['Spike Number',
+                          'Sweep Spike Number',
+                          'Sweep Number',
+                          'Epoch',
+                          'Epoch DAC',
+                          'Epoch Spike Number']
         _statListShort = {}
-        for k, v in _statList.items():
+        for k,v in _statList.items():
             if k not in _hideTheseKeys:
                 _statListShort[k] = v
-        # _statListShort = None
-        self._yStatListWidget = myStatListWidget(
-            self, statList=_statListShort, headerStr="Y-Stat"
-        )
+        #_statListShort = None
+        self._yStatListWidget = myStatListWidget(self, statList=_statListShort, headerStr='Y-Stat')
         self._yStatListWidget.myTableWidget.selectRow(3)
         main_hLayout.addWidget(self._yStatListWidget)
 
         # add vertical list of button for fi stats like (first, last, mean, cv, etc)
         _plotOptionsLayout = self._buildPlotOptionsLayout()
         main_hLayout.addLayout(_plotOptionsLayout)
 
+        
         _vPlotLayout = QtWidgets.QVBoxLayout()
         _canvas, self._mplToolbar = self.mplWindow2(addToLayout=False)
         self._mplToolbar.setVisible(False)
-        # self.axs.scatter('epochLevel', stat, data=dfEpoch, marker='o', c='#777777')
+        #self.axs.scatter('epochLevel', stat, data=dfEpoch, marker='o', c='#777777')
         self.axs.scatter([], [])
         sns.despine()
 
         _vPlotLayout.addWidget(_canvas)
         _vPlotLayout.addWidget(self._mplToolbar)
-
+        
         main_hLayout.addLayout(_vPlotLayout)
 
         self.getVBoxLayout().addLayout(main_hLayout)
 
         #
         # table view of current fi stats
-        self._fiTableView = myTableView_tmp("FI Results")
+        self._fiTableView = myTableView_tmp('FI Results')
         self._fiTableView.setVisible(False)
-        # self._fiTableView.slotSwitchTableDf(self.masterDf)
+        #self._fiTableView.slotSwitchTableDf(self.masterDf)
         self.getVBoxLayout().addWidget(self._fiTableView)
 
 
 def testPlugin():
     # load raw data
-    path = "data/2021_07_20_0010.abf"
+    path = 'data/2021_07_20_0010.abf'
     ba = bAnalysis(path)
 
     # spike detect
-    _dDict = bDetection().getDetectionDict("Fast Neuron")
+    _dDict = bDetection().getDetectionDict('Fast Neuron')
     ba.spikeDetect(_dDict)
 
     # run the plugin
     import sys
-
     app = QtWidgets.QApplication([])
     pfi = plotFi(ba=ba)
     pfi.show()
     sys.exit(app.exec_())
 
-
 def test():
     # load raw data
-    path = "data/2021_07_20_0010.abf"
+    path = 'data/2021_07_20_0010.abf'
     ba = bAnalysis(path)
 
     # spike detect
-    _dDict = bDetection().getDetectionDict("Fast Neuron")
+    _dDict = bDetection().getDetectionDict('Fast Neuron')
     ba.spikeDetect(_dDict)
 
     # get masterDf
     dfMaster = ba.asDataFrame()
     if dfMaster is None:
         # no spikes
         return
-
+    
     # user has to specify which epoch
     epochNumber = 2
 
     # the plot we will append to
     fig, _ax = plt.subplots(1, 1, sharex=True)
 
     # decide on what we want to plot
     # this is done in gui
 
     #
     # fiStat could be [first, second, mean, count, etc)
-
+    
     # fiStat is a column in df_fi (See below)
 
     # 1) plot num spikes, no raw data
     if 0:
-        fiStat = "count"  # the number of spikes
-        stat = "thresholdSec"  # thresholdSec, spikeFreq_hz
+        fiStat = 'count'  # the number of spikes
+        stat = 'thresholdSec'  # thresholdSec, spikeFreq_hz
         plotRaw = False
 
     # 1.1) plot fiStat: first, last, mean, ... spike time
     if 0:
-        fiStat = "first"
-        fiStat = "last"
-        fiStat = "mean"
-        stat = "thresholdSec"  # thresholdSec, spikeFreq_hz
+        fiStat = 'first'
+        fiStat = 'last'
+        fiStat = 'mean'
+        stat = 'thresholdSec'  # thresholdSec, spikeFreq_hz
         plotRaw = True
 
     if 0:
         # 2) plot inst freq
-        fiStat = (
-            "second"  # spike freq is an interval statistic (first spike does not count)
-        )
-        fiStat = "mean"
-        stat = "spikeFreq_hz"  # thresholdSec, spikeFreq_hz
+        fiStat = 'second'  # spike freq is an interval statistic (first spike does not count)
+        fiStat = 'mean'
+        stat = 'spikeFreq_hz'  # thresholdSec, spikeFreq_hz
         plotRaw = True
 
     if 0:
         # 3) plot isi_ms
-        fiStat = (
-            "second"  # spike freq is an interval statistic (first spike does not count)
-        )
-        stat = "isi_ms"  # thresholdSec, spikeFreq_hz
+        fiStat = 'second'  # spike freq is an interval statistic (first spike does not count)
+        stat = 'isi_ms'  # thresholdSec, spikeFreq_hz
         plotRaw = True
 
-    fiStatList = ["first", "last", "mean"]
-    fiStatList = ["mean"]
-    stat = "spikeFreq_hz"  # thresholdSec, spikeFreq_hz
+    fiStatList = ['first', 'last', 'mean']
+    fiStatList = ['mean']
+    stat = 'spikeFreq_hz'  # thresholdSec, spikeFreq_hz
     intervalStat = True
     plotRaw = True
 
     #
     # get a df with summary fi data
-    df_fi = getStatFi(
-        dfMaster, stat, epochNumber=epochNumber, intervalStat=intervalStat
-    )
-
-    print("=== summary df_fi:")
+    df_fi = getStatFi(dfMaster, stat, epochNumber=epochNumber, intervalStat=intervalStat)
+          
+    print('=== summary df_fi:')
     print(df_fi)
-
+    
     # plot raw data
     # lines is of type 'matplotlib.axes._subplots.AxesSubplot'
     if plotRaw:
         # reduce to only spikes for given epochNumber
-        dfEpoch = dfMaster[dfMaster["epoch"] == epochNumber]
-        # sns.scatterplot(x='epochLevel', y=stat, data=dfEpoch, ax=_ax)
-        _ax.scatter("epochLevel", stat, data=dfEpoch, marker="o", c="#777777")
+        dfEpoch = dfMaster[dfMaster['epoch']==epochNumber]
+        #sns.scatterplot(x='epochLevel', y=stat, data=dfEpoch, ax=_ax)
+        _ax.scatter('epochLevel', stat, data=dfEpoch, marker='o', c='#777777')
 
     #
     # overlay with one stat like _mean
     # order matters! This is on top of previous plots
-    _yerr = stat + "_std"
-    # _yerr = stat + '_sem'
-
+    _yerr = stat + '_std'
+    #_yerr = stat + '_sem'
+    
     for _fiStat in fiStatList:
-        _stat = stat + "_" + _fiStat
-        # _ax = sns.scatterplot(x='epochLevel', y=_stat, data=df_fi, ax=_ax)
+        _stat = stat + '_' + _fiStat
+        #_ax = sns.scatterplot(x='epochLevel', y=_stat, data=df_fi, ax=_ax)
         # _ax.plot('epochLevel', _stat, data=df_fi, linestyle='-', marker='o', color='k')
-        _ax.errorbar(
-            "epochLevel",
-            _stat,
-            yerr=_yerr,
-            data=df_fi,
-            linestyle="-",
-            marker="o",
-            color="k",
-        )
+        _ax.errorbar('epochLevel', _stat, yerr=_yerr, data=df_fi, linestyle='-', marker='o', color='k')
 
     #
     # set x-axis to full range of all injected currents (e.g. epochLevel)
     # TODO: expand a bit so we can see everything
-    epochLevels = dfMaster["epochLevel"].unique()
-    # epochLevels = np.round(epochLevels,3)
+    epochLevels = dfMaster['epochLevel'].unique()
+    #epochLevels = np.round(epochLevels,3)
     _minEpochLevel = np.min(epochLevels)
     _maxEpochLevel = np.max(epochLevels)
     # pad by 10%
     _xRange = _maxEpochLevel - _minEpochLevel
     _xPad = _xRange * 0.1
     # set x-axis
-    _ax.set_xlim([_minEpochLevel - _xPad, _maxEpochLevel + _xPad])
+    _ax.set_xlim([_minEpochLevel-_xPad, _maxEpochLevel+_xPad])
 
     sns.despine()
 
     plt.show()
-
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     # test()
-    testPlugin()
+    testPlugin()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/plotRecording.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/plotRecording.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,45 +3,40 @@
 import scipy.signal
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 import matplotlib.pyplot as plt
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy import bAnalysis
 from sanpy.interface.plugins import sanpyPlugin
 from sanpy.bAnalysisUtil import statList
-from sanpy.interface.plugins import (
-    ResponseType,
-)  # to toggle response to set sweeps, etc
-
+from sanpy.interface.plugins import ResponseType  # to toggle response to set sweeps, etc
 
 class plotRecording(sanpyPlugin):
     """
     Example of matplotlib plugin.
     """
-
-    myHumanName = "Plot Recording"
+    myHumanName = 'Plot Recording'
 
     def __init__(self, **kwargs):
         super(plotRecording, self).__init__(**kwargs)
 
         # this is a very simple plugin, do not respond to changes in interface
         # switchFile = self.responseTypes.switchFile
         # self.toggleResponseOptions(switchFile, newValue=False)
 
         # analysisChange = self.responseTypes.analysisChange
         # self.toggleResponseOptions(analysisChange, newValue=False)
 
-        # selectSpike = self.responseTypes.selectSpike
-        # self.toggleResponseOptions(selectSpike, newValue=False)
+        #selectSpike = self.responseTypes.selectSpike
+        #self.toggleResponseOptions(selectSpike, newValue=False)
 
         # we are plotting all sweeps and all axis, turn these off
         self.toggleResponseOptions(ResponseType.setSweep, False)  # we plot all sweeps
         self.toggleResponseOptions(ResponseType.setAxis, False)
 
         setAxis = self.responseTypes.setAxis
         self.toggleResponseOptions(setAxis, newValue=False)
@@ -52,286 +47,265 @@
         self.plot()
         self.replot()
 
     def plot(self):
         # if self.ba is None:
         #     return
 
-        self.mplWindow2()  # assigns (self.fig, self.axs)
+        self.mplWindow2() # assigns (self.fig, self.axs)
 
         return
 
     def replot(self):
-        """bAnalysis has been updated, replot"""
-        logger.info(f"{self.ba}")
+        """bAnalysis has been updated, replot
+        """
+        logger.info(f'{self.ba}')
 
         if self.ba is None:
             return
-
+            
         self.xOffset = 0.01
         self.yOffset = 50
-
+        
         xCurrentOffset = 0
         yCurrentOffset = 0
 
         currentSweep = self.ba.fileLoader.currentSweep
         numSweeps = self.ba.fileLoader.numSweeps
 
         self.fig.clear(True)
-        self.axs = self.fig.add_subplot(1, 1, 1)
+        self.axs = self.fig.add_subplot(1,1,1)
 
-        """
+        '''
         if self.rawLine is not None:
             for line in self.rawLine:
                 line.clear()
         self.rawLine = [None] * numSweeps
         
         if self.thresholdLine is not None:
             for line in self.thresholdLine:
                 line.clear()
         self.thresholdLine = [None] * numSweeps
-        """
+        '''
         self.rawLine = [None] * numSweeps
         self.thresholdLine = [None] * numSweeps
 
         _penColor = self.getPenColor()
 
         for sweepIdx in range(numSweeps):
             self.ba.fileLoader.setSweep(sweepIdx)
+            
+            #self.axs[_idx].self.fig.add_subplot(numSweeps, 1, _idx)
 
-            # self.axs[_idx].self.fig.add_subplot(numSweeps, 1, _idx)
-
-            sweepX = self.getSweep("x")
-            sweepY = self.getSweep("y")
+            sweepX = self.getSweep('x')
+            sweepY = self.getSweep('y')
 
             self.sweepX = sweepX
             self.sweepY = sweepY
 
-            (self.rawLine[sweepIdx],) = self.axs.plot(
-                sweepX + xCurrentOffset,
-                sweepY + yCurrentOffset,
-                "-",
-                color=_penColor,
-                linewidth=0.5,
-            )
-
-            thresholdSec = self.ba.getStat("thresholdSec", sweepNumber=sweepIdx)
-            thresholdSec = [x + xCurrentOffset for x in thresholdSec]
-            thresholdVal = self.ba.getStat("thresholdVal", sweepNumber=sweepIdx)
-            thresholdVal = [x + yCurrentOffset for x in thresholdVal]
+            self.rawLine[sweepIdx], = self.axs.plot(sweepX+xCurrentOffset, sweepY+yCurrentOffset,
+                                                    '-', color=_penColor, linewidth=0.5)
+
+            thresholdSec = self.ba.getStat('thresholdSec', sweepNumber=sweepIdx)
+            thresholdSec = [x+xCurrentOffset for x in thresholdSec]
+            thresholdVal = self.ba.getStat('thresholdVal', sweepNumber=sweepIdx)
+            thresholdVal = [x+yCurrentOffset for x in thresholdVal]
             markersize = 4
-            self.thresholdLine[sweepIdx] = self.axs.plot(
-                thresholdSec, thresholdVal, "r.", markersize=markersize
-            )
-            """
+            self.thresholdLine[sweepIdx] = self.axs.plot(thresholdSec, thresholdVal, 'r.', markersize=markersize)
+            '''
             if thresholdSec is None or thresholdVal is None:
                 self.thresholdLine[sweepIdx].set_data([], [])
             else:
                 self.thresholdLine[sweepIdx] = self.axs.plot(thresholdSec, thresholdSec, 'o')
-            """
+            '''
 
-            """
+            '''
             xHW, yHW = self.getHalfWidths()
             self.lineHW, = self.axs.plot(xHW, yHW, '-')
-            """
+            '''
 
             xCurrentOffset += self.xOffset
             yCurrentOffset += self.yOffset
 
         self.axs.relim()
-        self.axs.autoscale_view(True, True, True)
+        self.axs.autoscale_view(True,True,True)
 
         self.ba.fileLoader.setSweep(currentSweep)
         self.static_canvas.draw_idle()
         plt.draw()
 
     def old_getEddLines(self):
-        preLinearFitPnt0 = self.ba.getStat("preLinearFitPnt0")
+        preLinearFitPnt0 = self.ba.getStat('preLinearFitPnt0')
         preLinearFitSec0 = [self.ba.fileLoader.pnt2Sec_(x) for x in preLinearFitPnt0]
-        preLinearFitVal0 = self.ba.fileLoader.getStat("preLinearFitVal0")
+        preLinearFitVal0 = self.ba.fileLoader.getStat('preLinearFitVal0')
 
-        preLinearFitPnt1 = self.ba.getStat("preLinearFitPnt1")
+        preLinearFitPnt1 = self.ba.getStat('preLinearFitPnt1')
         preLinearFitSec1 = [self.ba.fileLoader.pnt2Sec_(x) for x in preLinearFitPnt1]
-        preLinearFitVal1 = self.ba.getStat("preLinearFitVal1")
+        preLinearFitVal1 = self.ba.getStat('preLinearFitVal1')
 
         x = []
         y = []
         for idx in range(self.ba.numSpikes):
             try:
                 dx = preLinearFitSec1[idx] - preLinearFitSec0[idx]
                 dy = preLinearFitVal1[idx] - preLinearFitVal0[idx]
-            except IndexError as e:
-                logger.error(
-                    f"spike {idx} preLinearFitSec1:{len(preLinearFitSec1)} preLinearFitSec0:{len(preLinearFitSec0)}"
-                )
-                logger.error(
-                    f"spike {idx} preLinearFitPnt1:{len(preLinearFitPnt1)} preLinearFitPnt0:{len(preLinearFitPnt0)}"
-                )
+            except (IndexError) as e:
+                logger.error(f'spike {idx} preLinearFitSec1:{len(preLinearFitSec1)} preLinearFitSec0:{len(preLinearFitSec0)}')
+                logger.error(f'spike {idx} preLinearFitPnt1:{len(preLinearFitPnt1)} preLinearFitPnt0:{len(preLinearFitPnt0)}')
 
             lineLength = 4  # TODO: make this a function of spike frequency?
 
             try:
                 x.append(preLinearFitSec0[idx])
-                x.append(preLinearFitSec1[idx] + lineLength * dx)
+                x.append(preLinearFitSec1[idx] + lineLength*dx)
                 x.append(np.nan)
 
                 y.append(preLinearFitVal0[idx])
-                y.append(preLinearFitVal1[idx] + lineLength * dy)
+                y.append(preLinearFitVal1[idx] + lineLength*dy)
                 y.append(np.nan)
-            except IndexError as e:
-                logger.error(
-                    f"preLinearFitSec0:{len(preLinearFitSec0)} preLinearFitSec1:{len(preLinearFitSec1)}"
-                )
+            except (IndexError) as e:
+                logger.error(f'preLinearFitSec0:{len(preLinearFitSec0)} preLinearFitSec1:{len(preLinearFitSec1)}')
                 logger.error(e)
 
         return x, y
 
     def getHalfWidths(self):
         """Get x/y pair for plotting all half widths.
-
+        
         DOes not work with new version because of sweeps.
         """
         # defer until we know how many half-widths 20/50/80
         x = []
         y = []
         numPerSpike = 3  # rise/fall/nan
         numSpikes = self.ba.numSpikes
         xyIdx = 0
         for idx, spike in enumerate(self.ba.spikeDict):
-            if idx == 0:
+            if idx ==0:
                 # make x/y from first spike using halfHeights = [20,50,80]
-                halfHeights = spike[
-                    "halfHeights"
-                ]  # will be same for all spike, like [20, 50, 80]
+                halfHeights = spike['halfHeights'] # will be same for all spike, like [20, 50, 80]
                 numHalfHeights = len(halfHeights)
                 # *numHalfHeights to account for rise/fall + padding nan
                 x = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
                 y = [np.nan] * (numSpikes * numHalfHeights * numPerSpike)
-                # print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
+                #print('  len(x):', len(x), 'numHalfHeights:', numHalfHeights, 'numSpikes:', numSpikes, 'halfHeights:', halfHeights)
 
-            for idx2, width in enumerate(spike["widths"]):
-                halfHeight = width["halfHeight"]  # [20,50,80]
-                risingPnt = width["risingPnt"]
-                # risingVal = width['risingVal']
+            for idx2, width in enumerate(spike['widths']):
+                halfHeight = width['halfHeight'] # [20,50,80]
+                risingPnt = width['risingPnt']
+                #risingVal = width['risingVal']
                 risingVal = self.sweepY[risingPnt]
-                fallingPnt = width["fallingPnt"]
-                # fallingVal = width['fallingVal']
+                fallingPnt = width['fallingPnt']
+                #fallingVal = width['fallingVal']
                 fallingVal = self.sweepY[fallingPnt]
 
                 if risingPnt is None or fallingPnt is None:
                     # half-height was not detected
                     continue
 
                 risingSec = self.ba.fileLoader.pnt2Sec_(risingPnt)
                 fallingSec = self.ba.fileLoader.pnt2Sec_(fallingPnt)
 
                 x[xyIdx] = risingSec
-                x[xyIdx + 1] = fallingSec
-                x[xyIdx + 2] = np.nan
+                x[xyIdx+1] = fallingSec
+                x[xyIdx+2] = np.nan
                 # y
-                y[xyIdx] = fallingVal  # risingVal, to make line horizontal
-                y[xyIdx + 1] = fallingVal
-                y[xyIdx + 2] = np.nan
+                y[xyIdx] = fallingVal  #risingVal, to make line horizontal
+                y[xyIdx+1] = fallingVal
+                y[xyIdx+2] = np.nan
 
                 # each spike has 3x pnts: rise/fall/nan
                 xyIdx += numPerSpike  # accounts for rising/falling/nan
             # end for width
         # end for spike
         return x, y
 
     def selectSpikeList(self):
-        """Only respond to single spike selection."""
-        logger.info("")
+        """Only respond to single spike selection.
+        """
+        logger.info('')
         spikeList = self.getSelectedSpikes()
 
-        if spikeList == [] or len(spikeList) > 1:
+        if spikeList==[] or len(spikeList)>1:
             return
 
         if self.ba is None:
             return
 
         spikeNumber = spikeList[0]
 
-        thresholdSec = self.ba.getStat("thresholdSec")
+        thresholdSec = self.ba.getStat('thresholdSec')
         spikeTime = thresholdSec[spikeNumber]
         xMin = spikeTime - 0.5
         xMax = spikeTime + 0.5
 
         self.axs.set_xlim(xMin, xMax)
 
         self.fig.canvas.draw()
         self.fig.canvas.flush_events()
 
     def old_slot_selectSpike(self, eDict):
         logger.info(eDict)
-        spikeNumber = eDict["spikeNumber"]
-        # doZoom = eDict['doZoom']
+        spikeNumber = eDict['spikeNumber']
+        #doZoom = eDict['doZoom']
 
         if spikeNumber is None:
             return
 
         if self.ba is None:
             return
 
-        thresholdSec = self.ba.getStat("thresholdSec")
+        thresholdSec = self.ba.getStat('thresholdSec')
         spikeTime = thresholdSec[spikeNumber]
         xMin = spikeTime - 0.5
         xMax = spikeTime + 0.5
 
         self.axs.set_xlim(xMin, xMax)
 
         self.fig.canvas.draw()
         self.fig.canvas.flush_events()
 
-
 def testPlot():
     import os
-
     file_path = os.path.realpath(__file__)  # full path to this file
     file_path = os.path.split(file_path)[0]  # folder for this file
-    path = os.path.join(file_path, "../../../data/19114001.abf")
+    path = os.path.join(file_path, '../../../data/19114001.abf')
 
     ba = bAnalysis(path)
     if ba.loadError:
-        print("error loading file")
+        print('error loading file')
         return
     ba.spikeDetect()
 
     # create plugin
     ap = plotRecording(ba=ba)
 
-    # ap.plot()
-
-    # ap.slotUpdateAnalysis()
+    #ap.plot()
 
+    #ap.slotUpdateAnalysis()
 
 def main():
-    path = "/Users/cudmore/Sites/SanPy/data/2021_07_20_0010.abf"
+    path = '/Users/cudmore/Sites/SanPy/data/2021_07_20_0010.abf'
     ba = sanpy.bAnalysis(path)
     ba.spikeDetect()
     print(ba.numSpikes)
 
     import sys
-
     app = QtWidgets.QApplication([])
     pr = plotRecording(ba=ba)
     pr.show()
     sys.exit(app.exec_())
 
-
 def testLoad():
     import os, glob
-
-    pluginFolder = "/Users/cudmore/sanpy_plugins"
-    files = glob.glob(os.path.join(pluginFolder, "*.py"))
+    pluginFolder = '/Users/cudmore/sanpy_plugins'
+    files = glob.glob(os.path.join(pluginFolder, '*.py'))
     for file in files:
-        # if file.startswith('.'):
+        #if file.startswith('.'):
         #    continue
-        if file.endswith("__init__.py"):
+        if file.endswith('__init__.py'):
             continue
         print(file)
-
-
-if __name__ == "__main__":
-    # testPlot()
-    # testLoad()
+if __name__ == '__main__':
+    #testPlot()
+    #testLoad()
     main()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/plotTool.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/plotTool.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,22 +1,19 @@
 import sanpy
 from sanpy.interface.plugins import basePlotTool
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class plotTool(basePlotTool):
     """
     Plot tool for one bAnalysis
     """
-
-    myHumanName = "Plot Tool"
+    myHumanName = 'Plot Tool'
 
     def __init__(self, **kwargs):
         super().__init__(**kwargs)
         self.masterDf = None
         if self.ba is not None and self.ba.isAnalyzed():
             self.masterDf = self.ba.asDataFrame()
-            self.masterDf["File Number"] = 0
+            self.masterDf['File Number'] = 0
         self.plot()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/plotToolPool.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/plotToolPool.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,54 @@
+
 import sanpy
 from sanpy.interface.plugins import basePlotTool
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class plotToolPool(basePlotTool):
-    """Plot tool pooled across all open analysis"""
-
-    myHumanName = "Plot Tool (pool)"
+    """Plot tool pooled across all open analysis
+    """
+    myHumanName = 'Plot Tool (pool)'
 
     def __init__(self, tmpMasterDf=None, **kwargs):
         """
         tmpMasterDf (pd df): only for debuggin
         """
         super().__init__(**kwargs)
 
         self.masterDf = None
         if self.getSanPyApp() is not None:
             self.masterDf = self.getSanPyApp().myAnalysisDir.pool_build()
             logger.info(self.masterDf)
-            self.masterDf.to_csv("/Users/cudmore/Desktop/tmpDf-20221231.csv")
+            self.masterDf.to_csv('/Users/cudmore/Desktop/tmpDf-20221231.csv')
         elif tmpMasterDf is not None:
-            logger.info("Using tmpMasterDf")
+            logger.info('Using tmpMasterDf')
             self.masterDf = tmpMasterDf
 
         self.plot()
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     import sys
     from PyQt5 import QtCore, QtWidgets, QtGui
 
     app = QtWidgets.QApplication([])
 
     # load an analysis dir
-    path = "/home/cudmore/Sites/SanPy/data"
+    path = '/home/cudmore/Sites/SanPy/data'
     ad = sanpy.analysisDir(path, autoLoad=True)
     print(ad._df)
     # load all analysis
-    print("\n=== loading all analysis")
+    print('\n=== loading all analysis')
     for fileIdx in range(ad.numFiles):
         ad.getAnalysis(fileIdx)
     # build the pool
-    print("\n=== building pool")
+    print('\n=== building pool')
     tmpMasterDf = ad.pool_build()
 
     # open window
-    print("\n=== opening plotToolPool with tmpMasterDf:", len(tmpMasterDf))
-    # print('tmpMasterDf.columns:', tmpMasterDf.columns)
+    print('\n=== opening plotToolPool with tmpMasterDf:', len(tmpMasterDf))
+    #print('tmpMasterDf.columns:', tmpMasterDf.columns)
     ptp = plotToolPool(tmpMasterDf=tmpMasterDf)
     ptp.show()
 
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/sanpyLog.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/sanpyLog.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,59 +1,55 @@
+
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
-
 class sanpyLog(sanpyPlugin):
     """
     Plugin to display sanpy.log
 
     Good example of PyQt plugin
     """
-
-    myHumanName = "SanPy Log"
+    myHumanName = 'SanPy Log'
 
     def __init__(self, **kwargs):
         """
         Args:
             ba (bAnalysis): Not required
         """
         super(sanpyLog, self).__init__(**kwargs)
 
-        # self.pyqtWindow() # makes self.mainWidget
+        #self.pyqtWindow() # makes self.mainWidget
 
         layout = QtWidgets.QVBoxLayout()
         widget = QtWidgets.QPlainTextEdit()
         widget.setReadOnly(True)
         layout.addWidget(widget)
 
         # load sanpy.log
         logFilePath = sanpy.sanpyLogger.getLoggerFile()
-        with open(logFilePath, "r") as f:
+        with open(logFilePath, 'r') as f:
             lines = f.readlines()
-        text = ""
+        text = ''
         for line in lines:
-            text += line  # line already has CR
+            text += line # line already has CR
 
         # add text to widget
-        widget.document().setPlainText(text)
+        widget.document().setPlainText(text);
 
-        logger.info(f"logFilePath: {logFilePath}")
+        logger.info(f'logFilePath: {logFilePath}')
 
         self._mySetWindowTitle()
 
-        # self.setLayout(layout)
+        #self.setLayout(layout)
         self.getVBoxLayout().addLayout(layout)
-
-
-if __name__ == "__main__":
+    
+if __name__ == '__main__':
     import sys
-
     app = QtWidgets.QApplication([])
     spl = sanpyLog()
     spl.show()
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/sanpyPlugin.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/sanpyPlugin.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,51 +16,47 @@
 
 # import qdarkstyle
 
 import sanpy
 import sanpy.interface
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 class ResponseType(enum.Enum):
-    """Enum representing the types of events a Plugin will respond to."""
-
-    switchFile = "Switch File"
-    setSweep = "Set Sweep"
-    analysisChange = "Analysis Change"
-    selectSpike = "Select Spike"
-    setAxis = "Set Axis"
-
-
-class SpikeSelectEvent:
-    """Class that encapsulates a spike(s) selection event."""
+    """Enum representing the types of events a Plugin will respond to.
+    """
+    switchFile = 'Switch File'
+    setSweep = 'Set Sweep'
+    analysisChange = 'Analysis Change'
+    selectSpike = 'Select Spike'
+    setAxis = 'Set Axis'
 
-    def __init__(
-        self, spikeList: List[int] = [], ba: sanpy.bAnalysis = None, isAlt: bool = False
-    ):
+class SpikeSelectEvent():
+    """Class that encapsulates a spike(s) selection event.
+    """
+    def __init__(self, spikeList : List[int] = [],
+                 ba : sanpy.bAnalysis = None,
+                 isAlt : bool = False):
         self._spikeList = spikeList
         self._ba = ba
         self._isAlt = isAlt
 
     def getSpikeList(self):
         return self._spikeList
-
+    
     def getAnalysis(self):
         return self._ba
-
+    
     def getDoZoom(self):
         return self._isAlt
-
-
+    
 class sanpyPlugin(QtWidgets.QWidget):
     """Base class for all SanPy plugins.
-
+    
     Provides general purpose API to build plugings including:
 
     - Open PyQt and Matplotlib plots
     - Set up signal/slots to communicate with the main SanPy app:
 
         - file is changed
         - detection is run
@@ -106,44 +102,38 @@
         Signal emitted when spikes are selected in the plugin.
     ba
     """
 
     signalCloseWindow = QtCore.pyqtSignal(object)
     """Emit signal on window close."""
 
-    # signalSelectSpike = QtCore.pyqtSignal(object)
+    #signalSelectSpike = QtCore.pyqtSignal(object)
     """Emit signal on spike selection."""
 
     signalSelectSpikeList = QtCore.pyqtSignal(object)
     """Emit signal on spike selection."""
 
     signalDetect = QtCore.pyqtSignal(object)
     """Emit signal on spike selection."""
 
-    myHumanName = "UNDEFINED-PLUGIN-NAME"
+    myHumanName = 'UNDEFINED-PLUGIN-NAME'
     """Each derived class needs to define this."""
 
-    #signalSetSpikeStat = QtCore.Signal(dict)
-    signalUpdateAnalysis = QtCore.Signal(dict)
-    """Set stats (columns) for a list of spikes."""
-
     # mar 11, if True then show in menus
     showInMenu = True
 
     responseTypes = ResponseType
     """Defines how a plugin will response to interface changes. Includes (switchFile, analysisChange, selectSpike, setAxis)."""
 
-    def __init__(
-        self,
-        ba: Optional[sanpy.bAnalysis] = None,
-        bPlugin: Optional["sanpy.interface.bPlugin"] = None,
-        startStop: Optional[List[float]] = None,
-        options=None,
-        parent=None,
-    ):
+    def __init__(self,
+                 ba : Optional[sanpy.bAnalysis] = None,
+                 bPlugin : Optional["sanpy.interface.bPlugin"] = None,
+                 startStop : Optional[List[float]] = None,
+                 options=None,
+                 parent=None):
         """
         Parameters
         ----------
         ba : sanpy.bAnalysis
             Object representing one file.
         bPlugin : "sanpy.interface.bPlugin"
             Used in PyQt to get SanPy App and to setup signal/slot.
@@ -158,67 +148,65 @@
 
         self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
 
         # does not work, key press gets called first?
         # self._closeAction = QtWidgets.QAction("Exit Application", self)
         # self._closeAction.setShortcut('Ctrl+W')
         # self._closeAction.triggered.connect(self.close)
-
+        
         # derived classes will set this in init (see kymographPlugin)
-        self._initError: bool = False
+        self._initError : bool = False
 
         # underlying bAnalaysis
-        self._ba: sanpy.bAnalysis = ba
+        self._ba : sanpy.bAnalysis = ba
 
         # the sweep number of the sanpy.bAnalaysis
-        self._sweepNumber: Union[int, str] = "All"
-        self._epochNumber: Union[int, str] = "All"
+        self._sweepNumber : Union[int,str] = 0
+        self._epochNumber : Union[int,str] = 'All'
 
-        self._bPlugins: "sanpy.interface.bPlugin" = bPlugin
+        self._bPlugins : "sanpy.interface.bPlugin" = bPlugin
         # pointer to object, send signal back on close
 
         self.darkTheme = True
         if self.getSanPyApp() is not None:
             _useDarkStyle = self.getSanPyApp().useDarkStyle
             self.darkTheme = _useDarkStyle
 
         # to show as a widget
-        self._showSelf: bool = True
-
-        self._blockSlots = False
+        self._showSelf : bool = True
 
         # the start and stop secinds to display
-        self._startSec: Optional[float] = None
-        self._stopSec: Optional[float] = None
+        self._startSec : Optional[float] = None
+        self._stopSec : Optional[float] = None
         if startStop is not None:
             self._startSec = startStop[0]
             self._stopSec = startStop[1]
 
         # keep track of spike selection
-        self._selectedSpikeList: List[int] = []
+        self._selectedSpikeList : List[int] = []
 
         # build a dict of boolean from ResponseType enum class
         # Things to respond to like switch file, set sweep, etc
-        self._responseOptions: dict = {}
-        for option in self.responseTypes:
-            # print(type(option))
+        self._responseOptions : dict = {}
+        for option in (self.responseTypes):
+            #print(type(option))
             self._responseOptions[option.name] = True
 
         # mar 26 2023 was this
         # doDark = self.getSanPyApp().useDarkStyle
         # if doDark and qdarkstyle is not None:
         #     self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
         # else:
         #     self.setStyleSheet("")
 
         # created in mplWindow2()
         # these are causing really freaking annoying failures on GitHub !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         # self.fig : "matplotlib.figure.Figure" = None
         # self.axs : "matplotlib.axes._axes.Axes" = None
-        # self.mplToolbar : "matplotlib.backends.backend_qt.NavigationToolbar2QT" = None
+        #self.mplToolbar : "matplotlib.backends.backend_qt.NavigationToolbar2QT" = None
         self.fig = None
         self.axs = None
         self.mplToolbar = None
 
         self.keyIsDown = None
 
         self.winWidth_inches = 4  # used by mpl
@@ -228,156 +216,150 @@
         self._installSignalSlot()
 
         self._mySetWindowTitle()
 
         # all plugin widgets always have a single QtWidgetQVBoxLayout
         # both widget and layouts can be added to this
         self._vBoxLayout = self.makeVLayout()
-
+        
         # the top toolbar is always present
-        self._blockComboBox: bool = False
+        self._blockComboBox : bool = False
         self._topToolbarWidget = self._buildTopToolbarWidget()
-        
-        # if ba has > 1 sweep or > 2 epochs then show top toolbar
-        _showTop = False
-        if self.ba is not None:
-            _numEpochs = self.ba.fileLoader.numEpochs  # can be None
-            _showTop = self.ba.fileLoader.numSweeps>1
-            _showTop = _showTop | _numEpochs is not None and _numEpochs>2
-        self.toggleTopToobar(_showTop)  # initially hidden
-        
+        self.toggleTopToobar(False)  # initially hidden
         self._updateTopToolbar()
         self._vBoxLayout.addWidget(self._topToolbarWidget)
 
     def _myClassName(self):
         return self.__class__.__name__
 
     def getPenColor(self) -> str:
-        """Get pen color for pyqtgraph traces based on dark theme."""
+        """Get pen color for pyqtgraph traces based on dark theme.
+        """
         if self.darkTheme:
-            return "w"
+            return 'w'
         else:
-            return "k"
-
-    def getStat(self, stat: str, getFullList : bool = False) -> list:
+            return 'k'
+        
+    def getStat(self, stat : str) -> list:
         """Convenianece function to get a stat from underling sanpy.bAnalysis.
-
+        
         Parameters
         ----------
         stat : str
             Stat to get, corresponds to a column in sanpy.bAnalysis
         """
-        return self.ba.getStat(
-            stat, sweepNumber=self.sweepNumber,
-            epochNumber=self.epochNumber,
-            getFullList=getFullList
-        )
-
+        return self.ba.getStat(stat,
+                               sweepNumber=self.sweepNumber,
+                               epochNumber=self.epochNumber)
+                              
     @property
     def responseOptions(self):
         return self._responseOptions
-
-    def toggleTopToobar(self, visible: bool = None):
+    
+    def toggleTopToobar(self, visible : bool = None):
         """Toggle or set the top toolbar.
-
+        
         Parameters
         ----------
         visible : bool or None
             If None then toggle, otherwise set to `visible`.
         """
         if visible is None:
             visible = not self._topToolbarWidget.isVisible()
         self._topToolbarWidget.setVisible(visible)
 
     def getVBoxLayout(self):
         """Get the main PyQt.QWidgets.QVBoxLayout
-
+        
         Derived plugins can add to this with addWidget() and addLayout()
         """
         return self._vBoxLayout
-
+    
     def getSelectedSpikes(self) -> List[int]:
-        """Get the currently selected spikes."""
+        """Get the currently selected spikes.
+        """
         return self._selectedSpikeList
-
-    def setSelectedSpikes(self, spikes: List[int]):
+    
+    def setSelectedSpikes(self, spikes : List[int]):
         """Set the currently selected spikes.
 
         Parameters
         ----------
         spikes : list of int
         """
         self._selectedSpikeList = spikes
 
     def getHumanName(self):
         """Get the human readable name for the plugin.
-
+        
         Each plugin needs a unique name specified in the static property `myHumanName`.
-
+        
         This is used to display the plugin in the menus.
         """
         return self.myHumanName
-
+    
     def getInitError(self):
         return self._initError
 
     def getWidget(self):
         """Over-ride if plugin makes its own PyQt widget.
-
+        
         By default, all plugins inherit from PyQt.QWidgets.QWidget
         """
         return self
-
+    
     def getShowSelf(self):
         return self._showSelf
 
-    def setShowSelf(self, show: bool):
+    def setShowSelf(self, show : bool):
         self._showSelf = show
 
     @property
     def sweepNumber(self):
-        """Get the current sweep number, can be 'All'."""
+        """Get the current sweep number, can be 'All'.
+        """
         return self._sweepNumber
 
     @property
     def epochNumber(self):
-        """Get the current epoch number, can be 'All'."""
+        """Get the current epoch number, can be 'All'.
+        """
         return self._epochNumber
 
-    def getSweep(self, type: str):
+    def getSweep(self, type : str):
         """Get the raw data from a sweep.
-
+        
         Parameters
         ----------
         type : str
             The sweep type from ('X', 'Y', 'C', 'filteredDeriv', 'filteredVm')
         """
         theRet = None
         type = type.upper()
         if self.ba is None:
             return theRet
-        if type == "X":
+        if type == 'X':
             theRet = self.ba.fileLoader.sweepX
-        elif type == "Y":
+        elif type == 'Y':
             theRet = self.ba.fileLoader.sweepY
-        elif type == "C":
+        elif type == 'C':
             theRet = self.ba.fileLoader.sweepC
-        elif type == "filteredDeriv":
+        elif type == 'filteredDeriv':
             theRet = self.ba.fileLoader.filteredDeriv
-        elif type == "filteredVm":
+        elif type == 'filteredVm':
             theRet = self.ba.fileLoader.sweepY_filtered
         else:
             logger.error(f'Did not understand type: "{type}"')
-
+        
         return theRet
 
     @property
     def ba(self):
         """Get the current sanpy.bAnalysis object.
-
+        
         Returns
         -------
         sanpy.bAnalysis
             The underlying bAnalysis object
         """
         return self._ba
 
@@ -388,95 +370,89 @@
         -------
         sanpy.interface.bPlugins
         """
         return self._bPlugins
 
     def getSanPyApp(self) -> "sanpy.interface.sanpy_app":
         """Return underlying SanPy app.
-
+        
         Only exists if running in SanPy Qt Gui
 
         Returns
         -------
         sanpy.interface.sanpy_app
         """
         if self._bPlugins is not None:
             return self._bPlugins.getSanPyApp()
 
     def _installSignalSlot(self):
         """Set up PyQt signals/slots.
-
+        
         Be sure to call _disconnectSignalSlot() on plugin destruction.
         """
         app = self.getSanPyApp()
         if app is not None:
             # receive spike selection
+            # app.signalSelectSpike.connect(self.slot_selectSpike)
             app.signalSelectSpikeList.connect(self.slot_selectSpikeList)
-            
             # receive update analysis (both file change and detect)
-            app.signalUpdateAnalysis.connect(self.slot_updateAnalysis)
-            self.signalUpdateAnalysis.connect(app.slot_updateAnalysis)
-
             app.signalSwitchFile.connect(self.slot_switchFile)
-
+            app.signalUpdateAnalysis.connect(self.slot_updateAnalysis)
             # recieve set sweep
             app.signalSelectSweep.connect(self.slot_setSweep)
-            
             # recieve set x axis
             app.signalSetXAxis.connect(self.slot_set_x_axis)
 
             # emit when we spike detect (used in detectionParams plugin)
             self.signalDetect.connect(app.slot_detect)
 
-            self.signalSelectSpikeList.connect(app.slot_selectSpikeList)
-            
         bPlugins = self.get_bPlugins()
         if bPlugins is not None:
             # emit spike selection
             # self.signalSelectSpike.connect(bPlugins.slot_selectSpike)
-            
-            # removed april 29
-            #self.signalSelectSpikeList.connect(bPlugins.slot_selectSpikeList)
-            
+            self.signalSelectSpikeList.connect(bPlugins.slot_selectSpikeList)
             # emit on close window
             self.signalCloseWindow.connect(bPlugins.slot_closeWindow)
 
         # connect to self
         # self.signalSelectSpike.connect(self.slot_selectSpike)
-        # self.signalSelectSpikeList.connect(self.slot_selectSpikeList)
+        self.signalSelectSpikeList.connect(self.slot_selectSpikeList)
 
     def _disconnectSignalSlot(self):
-        """Disconnect PyQt signal/slot on destruction."""
+        """Disconnect PyQt signal/slot on destruction.
+        """
         app = self.getSanPyApp()
         if app is not None:
             # receive spike selection
             # app.signalSelectSpike.disconnect(self.slot_selectSpike)
             # receive update analysis (both file change and detect)
             app.signalSwitchFile.disconnect(self.slot_switchFile)
             app.signalUpdateAnalysis.disconnect(self.slot_updateAnalysis)
             # recieve set sweep
             app.signalSelectSweep.disconnect(self.slot_setSweep)
             # recieve set x axis
             app.signalSetXAxis.disconnect(self.slot_set_x_axis)
 
-    def toggleResponseOptions(self, thisOption: ResponseType, newValue: bool = None):
+    def toggleResponseOptions(self,
+                              thisOption : ResponseType,
+                              newValue : bool = None):
         """Set underlying responseOptions based on name of thisOption.
 
         Parameters
         ----------
         thisOption : ResponseType
         newValue : Optional[bool]
             If boolean then set, if None then toggle.
         """
-        # logger.info(f'{thisOption} {newValue}')
+        #logger.info(f'{thisOption} {newValue}')
         if newValue is None:
             newValue = not self.responseOptions[thisOption.name]
         self.responseOptions[thisOption.name] = newValue
 
-    def _getResponseOption(self, thisOption: ResponseType) -> str:
+    def _getResponseOption(self, thisOption : ResponseType) -> str:
         """Get the state of a plot option from responseOptions.
 
         Parameters
         ----------
         thisOption : ResponseType
         """
         return self.responseOptions[thisOption.name]
@@ -491,15 +467,15 @@
 
     def old_selectSpike(self, sDict=None):
         """Derived class adds code to select spike from sDict."""
         pass
 
     def selectSpikeList(self):
         """Derived class adds code to select spike from sDict.
-
+        
         Get selected spike list with getSelectedSpikes()
         """
         pass
 
     def getStartStop(self):
         """Get current start stop of interface.
 
@@ -534,422 +510,408 @@
             key = event.key()
             text = event.text()
             doCopy = event.matches(QtGui.QKeySequence.Copy)
             doClose = event.matches(QtGui.QKeySequence.Close)
         elif isMpl:
             # q will quit !!!!
             text = event.key
-            doCopy = text in ["ctrl+c", "cmd+c"]
-            doClose = text in ["ctrl+w", "cmd+w"]
+            doCopy = text in ['ctrl+c', 'cmd+c']
+            doClose = text in ['ctrl+w', 'cmd+w']
             logger.info(f'mpl key: "{text}"')
         else:
-            logger.warning(f"Unknown event type: {type(event)}")
+            logger.warning(f'Unknown event type: {type(event)}')
             return
 
         self.keyIsDown = text
 
         if doCopy:
             self.copyToClipboard()
         elif doClose:
             self.close()
-        elif key == QtCore.Qt.Key_Escape or text == "esc" or text == "escape":
+        elif key==QtCore.Qt.Key_Escape or text=='esc' or text=='escape':
             # single spike
             # sDict = {
             #     'spikeNumber': None,
             #     'doZoom': False,
             #     'ba': self.ba,
 
             # }
             # self.signalSelectSpike.emit(sDict)
             # spike list
             sDict = {
-                "spikeList": [],
-                "doZoom": False,
-                "ba": self.ba,
+                'spikeList': [],
+                'doZoom': False,
+                'ba': self.ba,
             }
             self.signalSelectSpikeList.emit(sDict)
-        elif key == QtCore.Qt.Key_T or text == "t":
+        elif key==QtCore.Qt.Key_T or text=='t':
             self.toggleTopToobar()
-        elif text == "":
+        elif text == '':
             pass
 
         # critical difference between mpl and qt
         if isMpl:
             return text
         else:
-            # return event
+            #return event
             return
 
-    def copyToClipboard(self, df=None):
-        """Derived classes add code to copy plugin to clipboard."""
+    def copyToClipboard(self, df = None):
+        """Derived classes add code to copy plugin to clipboard.
+        """
         if df is None:
             return
-
-        logger.info("")
+    
+        logger.info('')
         if self.ba is None:
             return
-
+        
         fileName = self.ba.fileLoader.filename
-        fileName += ".csv"
+        fileName += '.csv'
         savePath = fileName
         options = QtWidgets.QFileDialog.Options()
-        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(
-            self, "Save .csv file", savePath, "CSV Files (*.csv)", options=options
-        )
+        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Save .csv file",
+                            savePath,"CSV Files (*.csv)", options=options)
         if not fileName:
             return
 
         logger.info(f'Saving: "{fileName}"')
         df.to_csv(fileName, index=False)
 
-    def saveResultsFigure(self, pgPlot=None):
+    def saveResultsFigure(self, pgPlot = None):
         """In derived, add code to save main figure to file.
-
+        
         In derived, pass in a pg plot from a view and we will save it.
         """
         if pgPlot is None:
             return
-
+        
         exporter = pg.exporters.ImageExporter(pgPlot)
-        # print(f'exporter: {type(exporter)}')
-        # print('getSupportedImageFormats:', exporter.getSupportedImageFormats())
+        #print(f'exporter: {type(exporter)}')
+        #print('getSupportedImageFormats:', exporter.getSupportedImageFormats())
         # set export parameters if needed
-
+        
         # (width, height, antialias, background, invertvalue)
-        exporter.parameters()[
-            "width"
-        ] = 1000  # (note this also affects height parameter)
-
+        exporter.parameters()['width'] = 1000   # (note this also affects height parameter)
+        
         # ask user for file
         fileName = self.ba.fileLoader.filename
-        fileName += ".png"
+        fileName += '.png'
         savePath = fileName
         options = QtWidgets.QFileDialog.Options()
-        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(
-            self, "Save .png file", savePath, "CSV Files (*.png)", options=options
-        )
+        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Save .png file",
+                            savePath,"CSV Files (*.png)", options=options)
         if not fileName:
             return
-
+        
         # save to file
-        logger.info(f"Saving to: {fileName}")
+        logger.info(f'Saving to: {fileName}')
         exporter.export(fileName)
 
     def bringToFront(self):
-        """Bring the widget to the front."""
+        """Bring the widget to the front.
+        """
         if not self._showSelf:
             return
-
+        
         # Qt
         self.getWidget().show()
         self.getWidget().activateWindow()
 
         # Matplotlib
         if self.fig is not None:
             FigureManagerQT = self.fig.canvas.manager
             FigureManagerQT.window.activateWindow()
             FigureManagerQT.window.raise_()
 
     def makeVLayout(self):
-        """Make a PyQt QVBoxLayout."""
+        """Make a PyQt QVBoxLayout.
+        """
         vBoxLayout = QtWidgets.QVBoxLayout()
         self.setLayout(vBoxLayout)
         return vBoxLayout
-
-    def mplWindow2(self, numRow=1, numCol=1, addToLayout: bool = True):
+    
+    def mplWindow2(self, numRow=1, numCol=1, addToLayout : bool = True):
         """Make a matplotlib figure, canvas, and axis.
-
+        
         Parameters
         ----------
         numRow : int
         numCol : int
         addToLayout : bool
             If true then add widget to main `getVBoxLayou()`.
 
         Returns
         -------
         self.static_canvas, self.mplToolbar
-
+        
         """
-        # plt.style.use('dark_background')
+        #plt.style.use('dark_background')
         if self.darkTheme:
-            plt.style.use("dark_background")
+            plt.style.use('dark_background')
         else:
             plt.rcParams.update(plt.rcParamsDefault)
-
+        
         # this is dangerous, collides with self.mplWindow()
         # these are causing really freaking annoying failures on GitHub !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         # self.fig : "matplotlib.figure.Figure" = mpl.figure.Figure()
         self.fig = mpl.figure.Figure()
 
         # not working
-        # self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
+        #self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
 
         self.static_canvas = backend_qt5agg.FigureCanvas(self.fig)
-        self.static_canvas.setFocusPolicy(
-            QtCore.Qt.ClickFocus
-        )  # this is really triccky and annoying
+        self.static_canvas.setFocusPolicy( QtCore.Qt.ClickFocus ) # this is really triccky and annoying
         self.static_canvas.setFocus()
-        self.fig.canvas.mpl_connect("key_press_event", self.keyPressEvent)
+        self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)
 
         self.axs = [None] * numRow  # empty list
-        if numRow == 1 and numCol == 1:
+        if numRow==1 and numCol==1:
             _static_ax = self.static_canvas.figure.subplots()
             self.axs = _static_ax
-            # print('self.axs:', type(self.axs))
+            #print('self.axs:', type(self.axs))
         else:
             for idx in range(numRow):
                 plotNum = idx + 1
-                # print('mplWindow2()', idx)
-                self.axs[idx] = self.static_canvas.figure.add_subplot(
-                    numRow, 1, plotNum
-                )
+                #print('mplWindow2()', idx)
+                self.axs[idx] = self.static_canvas.figure.add_subplot(numRow,1,plotNum)
 
         # does not work
-        # self.static_canvas.mpl_connect('key_press_event', self.keyPressEvent)
+        #self.static_canvas.mpl_connect('key_press_event', self.keyPressEvent)
 
         # pick_event assumes 'picker=5' in any .plot()
         # does this need to be a member? I think so?
-        self._cid = self.static_canvas.mpl_connect("pick_event", self.spike_pick_event)
+        self._cid = self.static_canvas.mpl_connect('pick_event', self.spike_pick_event)
 
         # matplotlib plot tools toolbar (zoom, pan, save, etc)
-        # from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
-        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(
-            self.static_canvas, self.static_canvas
-        )
-
-        # layout = QtWidgets.QVBoxLayout()
+        #from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
+        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(self.static_canvas, self.static_canvas)
+              
+        #layout = QtWidgets.QVBoxLayout()
         if addToLayout:
             layout = self.getVBoxLayout()
             layout.addWidget(self.static_canvas)
             layout.addWidget(self.mplToolbar)
         else:
             return self.static_canvas, self.mplToolbar
-
+        
     def _mySetWindowTitle(self):
-        """Set the window title based on ba."""
+        """Set the window title based on ba.
+        """
         if self.ba is not None:
             fileName = self.ba.fileLoader.filename
         else:
-            fileName = ""
-        _windowTitle = self.myHumanName + ":" + fileName
+            fileName = ''
+        _windowTitle = self.myHumanName + ':' + fileName
 
         # mpl
         if self.fig is not None:
             if self.fig.canvas.manager is not None:
                 self.fig.canvas.manager.set_window_title(_windowTitle)
 
         # pyqt
-        # self.mainWidget._mySetWindowTitle(self.windowTitle)
+        #self.mainWidget._mySetWindowTitle(self.windowTitle)
         self.getWidget().setWindowTitle(_windowTitle)
 
     def spike_pick_event(self, event):
         """Respond to user clicks in mpl plot
-
+        
         Assumes plot(..., picker=5)
-
+        
         Parameters
         ----------
         event : matplotlib.backend_bases.PickEvent
             PickEvent with plot indices in ind[]
         """
         if len(event.ind) < 1:
             return
 
-        # logger.info(f'{event.ind}')
+        #logger.info(f'{event.ind}')
 
         spikeNumber = event.ind[0]
 
         doZoom = False
         modifiers = QtWidgets.QApplication.keyboardModifiers()
         if modifiers == QtCore.Qt.ShiftModifier:
             doZoom = True
 
-        logger.info(
-            f"got {len(event.ind)} candidates, first is spike:{spikeNumber} doZoom:{doZoom}"
-        )
+        logger.info(f'got {len(event.ind)} candidates, first is spike:{spikeNumber} doZoom:{doZoom}')
 
         # propagate a signal to parent
         # TODO: use class SpikeSelectEvent()
         sDict = {
-            "spikeList": [spikeNumber],
-            "doZoom": doZoom,
-            "ba": self.ba,
+            'spikeList': [spikeNumber],
+            'doZoom': doZoom,
+            'ba': self.ba,
         }
         self.signalSelectSpikeList.emit(sDict)
 
     def closeEvent(self, event):
         """Called when window is closed.
-
+        
         Signal close event back to parent bPlugin object.
 
         Parameters
         ----------
         event Union[matplotlib.backend_bases.CloseEvent, PyQt5.QtGui.QCloseEvent]
             The close event from either PyQt or matplotlib
         """
-        logger.info(f"  -->> emit signalCloseWindow(self)")
+        logger.info(f'  -->> emit signalCloseWindow(self)')
         self.signalCloseWindow.emit(self)
 
-    def slot_switchFile(
-        self, ba: sanpy.bAnalysis, rowDict: Optional[dict] = None, replot: bool = True
-    ):
+    def slot_switchFile(self,
+                        ba : sanpy.bAnalysis,
+                        rowDict : Optional[dict] = None,
+                        replot : bool = True):
         """Respond to switch file.
-
+        
         Parameters
         ----------
         rowDict : dict
             Optional, assumes rowDict has keys ['Start(s)', 'Stop(s)']
         ba : sanpy.bAnalysis
             The new bAnalysis file to switch to
         replot : bool
             If true then call replot()
         """
         if not self._getResponseOption(self.responseTypes.switchFile):
             return
 
         if ba is None:
             return
-
+        
         # don't respond if we are already using ba
         if self._ba == ba:
             return
-
+        
         self._ba = ba
-        # self.fileRowDict = rowDict  # for detectionParams plugin
+        #self.fileRowDict = rowDict  # for detectionParams plugin
 
-        # rest sweep and epoch
+        # rest sweep
         self._sweepNumber = 0
-        self._epochNumber = 'All'
 
         # reset start/stop
         startSec = None
         stopSec = None
         if rowDict is not None:
-            startSec = rowDict["Start(s)"]
-            stopSec = rowDict["Stop(s)"]
+            startSec = rowDict['Start(s)']
+            stopSec = rowDict['Stop(s)']
             if math.isnan(startSec):
                 startSec = None
             if math.isnan(stopSec):
                 stopSec = None
         self._startSec = startSec
         self._stopSec = stopSec
 
         # reset spike and spike list selection
         self._selectedSpikeList = []
         self.selectedSpike = None
-
+        
         # inform derived classes of change
-        # self.old_selectSpike()
+        #self.old_selectSpike()
         self.selectSpikeList()
 
         # set pyqt window title
         self._mySetWindowTitle()
 
         self._updateTopToolbar()
 
         if replot:
             self.replot()
 
-    def slot_updateAnalysis(self, sDict : dict):
+    def slot_updateAnalysis(self, ba):
         """Respond to new spike detection.
 
         Parameters
         ----------
-        sDict : dict
+        ba : sanpy.bAnalysis
         """
-        logger.info("")
+        logger.info('')
         if not self._getResponseOption(self.responseTypes.analysisChange):
             return
-
-        ba = sDict['ba']
         
         if ba is None:
             return
-
+        
         # don't update analysis if we are showing different ba
         if self._ba != ba:
             return
 
         self.replot()
 
-    def slot_setSweep(self, ba: sanpy.bAnalysis, sweepNumber: int):
-        """Respond to user selecting a sweep."""
-
+    def slot_setSweep(self, ba : sanpy.bAnalysis, sweepNumber : int):
+        """Respond to user selecting a sweep.
+        """
+        
         if not self._getResponseOption(self.responseTypes.setSweep):
             return
 
-        logger.info(f"{self._myClassName()}")
+        logger.info(f'{self._myClassName()}')
 
         if ba is None:
             return
-
+        
         # don't respond if we are showing different ba
         if self._ba != ba:
             return
-
+            
         self._sweepNumber = sweepNumber
 
         # reset selection
         self._selectedSpikeList = []
         self.selectedSpike = None
 
-        # update toolbar
-        self._updateTopToolbar()
-
         self.replot()
 
-    def slot_selectSpikeList(self, eDict: dict):
+    def slot_selectSpikeList(self, eDict : dict):
         """Respond to spike selection.
 
         TODO: convert dict to class spikeSelection
         """
 
-        if self._blockSlots:
-            return
-    
-        logger.info(f"{self._myClassName()} num spikes:{len(eDict['spikeList'])}")
-
+        logger.info(f'{self._myClassName()} eDict:{eDict}')
+        
         # don't respond if we are showing a different ba (bAnalysis)
-        ba = eDict["ba"]
+        ba = eDict['ba']
         if self.ba != ba:
             return
 
-        spikeList = eDict["spikeList"]
+        spikeList = eDict['spikeList']
         self._selectedSpikeList = spikeList  # [] on no selection
 
         self.selectSpikeList()
 
     def old_slot_selectSpike(self, eDict):
-        """Respond to spike selection."""
+        """Respond to spike selection.
+        """
 
         # don't respond if user/code has turned this off
         if not self._getResponseOption(self.responseTypes.selectSpike):
             return
 
         # don't respond if we are showing a different ba (bAnalysis)
-        ba = eDict["ba"]
+        ba = eDict['ba']
         if self.ba != ba:
             return
 
-        self.selectedSpike = eDict["spikeNumber"]
+        self.selectedSpike = eDict['spikeNumber']
 
         self.old_selectSpike(eDict)
 
-    def slot_set_x_axis(self, startStopList: List[float]):
+    def slot_set_x_axis(self, startStopList : List[float]):
         """Respond to changes in x-axis.
 
         Parameters
         ----------
         startStopList : list(float)
             Two element list with [start, stop] in seconds
         """
         if not self._getResponseOption(self.responseTypes.setAxis):
             return
-
+        
         # don't set axis if we are showing different ba
         app = self.getSanPyApp()
         if app is not None:
             ba = app.get_bAnalysis()
             if self._ba != ba:
                 return
 
@@ -968,15 +930,16 @@
         """Respond to set axis.
 
         Some plugins want to replot() when x-axis changes.
         """
         pass
 
     def _turnOffAllSignalSlot(self):
-        """Make plugin not respond to any changes in interface."""
+        """Make plugin not respond to any changes in interface.
+        """
         # turn off all signal/slot
         switchFile = self.responseTypes.switchFile
         self.toggleResponseOptions(switchFile, newValue=False)
 
         setSweep = self.responseTypes.setSweep
         self.toggleResponseOptions(setSweep, newValue=False)
 
@@ -1000,54 +963,54 @@
         Parameters
         ----------
         event : QtGui.QContextMenuEvent
             Used to position popup
         """
         if self.mplToolbar is not None:
             state = self.mplToolbar.mode
-            if state in ["zoom rect", "pan/zoom"]:
+            if state in ['zoom rect', 'pan/zoom']:
                 # don't process right-click when toolbar is active
                 return
 
-        logger.info("")
+        logger.info('')
 
         contextMenu = QtWidgets.QMenu(self)
-
+        
         # prepend any menu from derived classes
         self.prependMenus(contextMenu)
 
         switchFile = contextMenu.addAction("Switch File")
         switchFile.setCheckable(True)
-        switchFile.setChecked(self.responseOptions["switchFile"])
+        switchFile.setChecked(self.responseOptions['switchFile'])
 
         setSweep = contextMenu.addAction("Set Sweep")
         setSweep.setCheckable(True)
-        setSweep.setChecked(self.responseOptions["setSweep"])
+        setSweep.setChecked(self.responseOptions['setSweep'])
 
         analysisChange = contextMenu.addAction("Analysis Change")
         analysisChange.setCheckable(True)
-        analysisChange.setChecked(self.responseOptions["analysisChange"])
+        analysisChange.setChecked(self.responseOptions['analysisChange'])
 
         selectSpike = contextMenu.addAction("Select Spike")
         selectSpike.setCheckable(True)
-        selectSpike.setChecked(self.responseOptions["selectSpike"])
+        selectSpike.setChecked(self.responseOptions['selectSpike'])
 
-        axisChange = contextMenu.addAction("Axis Change")
+        axisChange = contextMenu.addAction('Axis Change')
         axisChange.setCheckable(True)
-        axisChange.setChecked(self.responseOptions["setAxis"])
+        axisChange.setChecked(self.responseOptions['setAxis'])
 
         contextMenu.addSeparator()
-        copyTable = contextMenu.addAction("Copy Results")
-        saveFigure = contextMenu.addAction("Save Figure")
+        copyTable = contextMenu.addAction('Copy Results')
+        saveFigure = contextMenu.addAction('Save Figure')
 
         contextMenu.addSeparator()
-        showTopToolbar = contextMenu.addAction("Toggle Top Toolbar")
+        showTopToolbar = contextMenu.addAction('Toggle Top Toolbar')
 
-        # contextMenu.addSeparator()
-        # saveTable = contextMenu.addAction("Save Table")
+        #contextMenu.addSeparator()
+        #saveTable = contextMenu.addAction("Save Table")
 
         #
         # open the menu
         action = contextMenu.exec_(self.mapToGlobal(event.pos()))
 
         if action is None:
             # no menu selected
@@ -1072,216 +1035,211 @@
             self.toggleResponseOptions(self.responseTypes.setAxis)
         elif action == copyTable:
             self.copyToClipboard()
         elif action == saveFigure:
             self.saveResultsFigure()
         elif action == showTopToolbar:
             self.toggleTopToobar()
-        # elif action == saveTable:
+        #elif action == saveTable:
         #    #self.saveToFile()
         #    logger.info('NOT IMPLEMENTED')
 
         elif action is not None:
-            logger.warning(f'Menu action not taken "{action.text}"')
+                logger.warning(f'Menu action not taken "{action.text}"')
 
-    def prependMenus(self, contextMenu: "QtWidgets.QMenu"):
+    def prependMenus(self, contextMenu : "QtWidgets.QMenu"):
         """Prepend menus to mouse right-click contect menu.
-
+        
         Parameters
         ----------
         contextMenu : QtWidgets.QMenu
         """
         pass
 
-    def handleContextMenu(self, action: "QtGui.QAction"):
+    def handleContextMenu(self, action : "QtGui.QAction"):
         """Derived plugins need to define this to handle right-click contect menu actions.
-
+        
         Only needed if `prependMenus` is used.
 
         Parameters
         ----------
         action : QtGui.QAction
         """
         pass
 
     def _updateTopToolbar(self):
-        """Update the top toolbar on state change like switch file."""
-        
+        """Update the top toolbar on state change like switch file.
+        """
         if self.ba is None:
             return
-
+        
         _sweepList = self.ba.fileLoader.sweepList
         self._blockComboBox = True
         self._sweepComboBox.clear()
-        self._sweepComboBox.addItem("All")
+        self._sweepComboBox.addItem('All')
         for _sweep in _sweepList:
             self._sweepComboBox.addItem(str(_sweep))
         _enabled = len(_sweepList) > 1
         self._sweepComboBox.setEnabled(_enabled)
-        if self.sweepNumber == "All":
+        if self.sweepNumber == 'All':
             self._sweepComboBox.setCurrentIndex(0)
         else:
-            self._sweepComboBox.setCurrentIndex(self.sweepNumber + 1)
+            self._sweepComboBox.setCurrentIndex(self.sweepNumber+1)
         self._blockComboBox = False
 
         # minimum of 2 (never 1 or 0)
         # because of annoying pClamp default short epoch 0
         _numEpochs = self.ba.fileLoader.numEpochs
         if _numEpochs is not None:
             self._blockComboBox = True
             self._epochComboBox.clear()
-            self._epochComboBox.addItem("All")
+            self._epochComboBox.addItem('All')
             for _epoch in range(_numEpochs):
                 self._epochComboBox.addItem(str(_epoch))
-            _enabled = True  # _numEpochs > 2
+            _enabled = _numEpochs > 2
             self._epochComboBox.setEnabled(_enabled)
-            if self.epochNumber == "All":
-                self._epochComboBox.setCurrentIndex(0)
-            else:
-                self._epochComboBox.setCurrentIndex(self.epochNumber + 1)
+            self._epochComboBox.setCurrentIndex(0)
             self._blockComboBox = False
-        else:
-            # no epochs defined
-            self._epochComboBox.setEnabled(False)
+            # for sweeps with not epochs
+            if not _enabled:
+                self._epochNumber = 1
 
         # filename = self.ba.getFileName()
         # self._fileLabel.setText(filename)
 
-    def _on_sweep_combo_box(self, idx: int):
+    def _on_sweep_combo_box(self, idx : int):
         """Respond to user selecting sweep combobox.
 
         Notes
         -----
         idx 0 is 'All', idx 1 is sweep 0
         """
         if self._blockComboBox:
             return
-
+        
         idx = idx - 1  # first item is always 'All'
         if idx == -1:
-            idx = "All"
+            idx = 'All'
         logger.info(idx)
         self._sweepNumber = idx
 
         if self.ba is None:
             return
-
+        
         self.replot()
 
-    def _on_epoch_combo_box(self, idx: int):
+    def _on_epoch_combo_box(self, idx : int):
         """Respond to user selecting epoch combobox.
 
         Notes
         -----
         idx 0 is 'All', idx 1 is epoch 0
         """
         if self._blockComboBox:
             return
-
+        
         idx = idx - 1  # first item is always 'All'
         if idx == -1:
-            idx = "All"
+            idx = 'All'
         logger.info(idx)
         self._epochNumber = idx
 
         if self.ba is None:
             return
-
+        
         self.replot()
 
     def _buildTopToolbarWidget(self) -> QtWidgets.QWidget:
-        """Top toolbar to show file, toggle responses on/off, etc"""
-
+        """Top toolbar to show file, toggle responses on/off, etc
+        """
+            
         # TODO: Super annoying that popups come up blank if using AlignLeft ???
-
+        
         #
         # first row of controls
         hLayout0 = QtWidgets.QHBoxLayout()
 
         # sweep popup
-        aLabel = QtWidgets.QLabel("Sweeps")
+        aLabel = QtWidgets.QLabel('Sweeps')
         # hLayout0.addWidget(aLabel, alignment=QtCore.Qt.AlignLeft)
         hLayout0.addWidget(aLabel)
         self._sweepComboBox = QtWidgets.QComboBox()
         self._sweepComboBox.currentIndexChanged.connect(self._on_sweep_combo_box)
-        # hLayout0.addWidget(self._sweepComboBox, alignment=QtCore.Qt.AlignLeft)
+        #hLayout0.addWidget(self._sweepComboBox, alignment=QtCore.Qt.AlignLeft)
         hLayout0.addWidget(self._sweepComboBox)
 
-        # hLayout0.addStretch()
+        #hLayout0.addStretch()
 
         # epoch popup
-        aLabel = QtWidgets.QLabel("Epochs")
+        aLabel = QtWidgets.QLabel('Epochs')
         hLayout0.addWidget(aLabel, alignment=QtCore.Qt.AlignLeft)
-        # hLayout0.addWidget(aLabel)
+        #hLayout0.addWidget(aLabel)
         self._epochComboBox = QtWidgets.QComboBox()
         self._epochComboBox.currentIndexChanged.connect(self._on_epoch_combo_box)
-        # hLayout0.addWidget(self._epochComboBox, alignment=QtCore.Qt.AlignLeft)
+        #hLayout0.addWidget(self._epochComboBox, alignment=QtCore.Qt.AlignLeft)
         hLayout0.addWidget(self._epochComboBox)
 
         # update on switch file
         # self._fileLabel = QtWidgets.QLabel('File')
         # hLayout0.addWidget(self._fileLabel, alignment=QtCore.Qt.AlignLeft)
 
         # update for all response types (switch file, set sweep, analyze, ...)
         # self._numSpikesLabel = QtWidgets.QLabel('unknown spikes')
         # hLayout0.addWidget(self._numSpikesLabel, alignment=QtCore.Qt.AlignLeft)
 
-        # hLayout0.addStretch()
+        #hLayout0.addStretch()
 
         #
         # second row of controls
         hLayout1 = QtWidgets.QHBoxLayout()
 
         # a checkbox for each 'respond to' in the ResponseType enum
         for item in ResponseType:
             aCheckbox = QtWidgets.QCheckBox(item.value)
             aCheckbox.setChecked(self.responseOptions[item.name])
-            aCheckbox.stateChanged.connect(
-                functools.partial(self.toggleResponseOptions, item)
-            )
+            aCheckbox.stateChanged.connect(functools.partial(self.toggleResponseOptions, item))
             hLayout1.addWidget(aCheckbox, alignment=QtCore.Qt.AlignLeft)
 
         hLayout1.addStretch()
 
-        # toolbar layout needs to be in a widget so it can be hidden
+        #toolbar layout needs to be in a widget so it can be hidden
         _mainWidget = QtWidgets.QWidget()
         _topToolbarLayout = QtWidgets.QVBoxLayout(_mainWidget)
         _topToolbarLayout.addLayout(hLayout0)
         _topToolbarLayout.addLayout(hLayout1)
 
         return _mainWidget
-
+    
     # def __on_checkbox_clicked(self, checkBoxName, checkBoxState):
     #     logger.info(checkBoxName, checkBoxState)
 
     def getWindowGeometry(self):
-        """Get the current window position."""
+        """Get the current window position.
+        """
         myRect = self.geometry()
         left = myRect.left()
         top = myRect.top()
         width = myRect.width()
         height = myRect.height()
         return left, top, width, height
 
-
 def test_plugin():
     import sys
     from PyQt5 import QtCore, QtWidgets, QtGui
     import sanpy
     import sanpy.interface
 
     # create a PyQt application
     app = QtWidgets.QApplication([])
 
     # load and analyze sample data
-    path = "/home/cudmore/Sites/SanPy/data/19114001.abf"
+    path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
     ba = sanpy.bAnalysis(path)
     ba.spikeDetect()
 
     # open the interface for the 'saveAnalysis' plugin.
     sa = sanpy.interface.plugins.plotScatter(ba=ba, startStop=None)
 
     sys.exit(app.exec_())
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     test_plugin()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/setSpikeStat.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/setSpikeStat.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,22 +1,21 @@
 from functools import partial
 
 from PyQt5 import QtWidgets, QtGui, QtCore
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
-
 class ComboBox(QtWidgets.QComboBox):
     # https://code.qt.io/cgit/qt/qtbase.git/tree/src/widgets/widgets/qcombobox.cpp?h=5.15.2#n3173
     def paintEvent(self, event):
+        
         painter = QtWidgets.QStylePainter(self)
         painter.setPen(self.palette().color(QtGui.QPalette.Text))
 
         # draw the combobox frame, focusrect and selected etc.
         opt = QtWidgets.QStyleOptionComboBox()
         self.initStyleOption(opt)
         painter.drawComplexControl(QtWidgets.QStyle.CC_ComboBox, opt)
@@ -28,209 +27,200 @@
             )
             if self.placeholderText():
                 opt.currentText = self.placeholderText()
 
         # draw the icon and text
         painter.drawControl(QtWidgets.QStyle.CE_ComboBoxLabel, opt)
 
-
 # setSpikeStatEvent = {
 #     'spikeList': [],
 #     'colStr': '',
 #     'value': ''
 # }
 
-
 class SetSpikeStat(sanpyPlugin):
-    """Plugin to provide an interface to set spike stats like condition, userType, include, etc.
-
+    """Plugin to provide an interface to set spike stats like condition, userType, isBad, etc.
+    
     Get stat names and variables from sanpy.bAnalysisUtil.getStatList()
     """
+    signalSetSpikeStat = QtCore.Signal(dict)
 
-    myHumanName = "Set Spike Stats"
+    myHumanName = 'Set Spike Stats'
     showInMenu = False
-
+    
     def __init__(self, **kwargs):
-        logger.info("")
+        logger.info('')
         super().__init__(**kwargs)
 
-        self.trueFalseItems = ["True", "False"]
-        self.userTypeItems = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
+        self.trueFalseItems = ['True', 'False']
+        self.userTypeItems = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
         self._buildUI()
 
         self._setState()
 
     def _buildUI(self):
         vBoxLayout = self.getVBoxLayout()
-        vBoxLayout.setAlignment(QtCore.Qt.AlignTop)
-        # vBoxLayout.setContentsMargins(0,0,0,0)
 
         # first row
         hBoxLayout = QtWidgets.QHBoxLayout()
-        # hBoxLayout.setContentsMargins(0,0,0,0)
         vBoxLayout.addLayout(hBoxLayout)
 
         # a button to set
-        self._setButton = QtWidgets.QPushButton("Set")
+        self._setButton = QtWidgets.QPushButton('Set')
         self._setButton.clicked.connect(self.on_set_button)
         hBoxLayout.addWidget(self._setButton, alignment=QtCore.Qt.AlignLeft)
 
         # a label to report spike selection
-        self._spikeLabel = QtWidgets.QLabel("0 Spikes")
+        self._spikeLabel = QtWidgets.QLabel('0 Spikes')
         hBoxLayout.addWidget(self._spikeLabel, alignment=QtCore.Qt.AlignLeft)
 
         # second row
         hBoxLayout = QtWidgets.QHBoxLayout()
-        # hBoxLayout.setContentsMargins(0,0,0,0)
         vBoxLayout.addLayout(hBoxLayout)
 
         # popup with column types
-        _items = ["condition", "userType", "include"]
+        _items = ['condition', 'userType', 'isBad']
         self._statComboBox = ComboBox()
         for item in _items:
             self._statComboBox.addItem(item)
-        # self._statComboBox.setPlaceholderText("Some placeholder text here")
+        # self._statComboBox.setPlaceholderText("Some placeholder text here")         
         # self._statComboBox.setCurrentIndex(-1)
         self._statComboBox.setCurrentIndex(0)
         self._statComboBox.currentIndexChanged.connect(self.on_stat_change)
         hBoxLayout.addWidget(self._statComboBox, alignment=QtCore.Qt.AlignLeft)
 
         # line edit for user to enter values
-        self._lineEdit = QtWidgets.QLineEdit("")
-        # self._lineEdit.setReadOnly(True)  # for now our 1 edit widget is not editable
-        # self._lineEdit.setKeyboardTracking(False) # don't trigger signal as user edits
-        # self._lineEdit.setValidator(QIntValidator())
-        # self._lineEdit.setMaxLength(4)
+        self._lineEdit = QtWidgets.QLineEdit('')
+        #self._lineEdit.setReadOnly(True)  # for now our 1 edit widget is not editable
+        #self._lineEdit.setKeyboardTracking(False) # don't trigger signal as user edits
+        #self._lineEdit.setValidator(QIntValidator())
+        #self._lineEdit.setMaxLength(4)
         self._lineEdit.setAlignment(QtCore.Qt.AlignLeft)
-        self._lineEdit.editingFinished.connect(
-            partial(self.on_text_edit, self._lineEdit)
-        )
+        self._lineEdit.editingFinished.connect(partial(self.on_text_edit, self._lineEdit))
         hBoxLayout.addWidget(self._lineEdit, alignment=QtCore.Qt.AlignLeft)
 
-        # popup with true false (for some column types like 'include')
+        # popup with true false (for some column types like 'isBad')
         # switch to userType [1,2,3,4, ...]
-        _items = ["True", "False"]
+        _items = ['True', 'False']
         self._valueComboBox = ComboBox()
         for item in _items:
             self._valueComboBox.addItem(item)
-        # self._valueComboBox.setPlaceholderText("Some placeholder text here")
+        # self._valueComboBox.setPlaceholderText("Some placeholder text here")         
         # self._valueComboBox.setCurrentIndex(-1)
         self._valueComboBox.setEnabled(False)
         self._valueComboBox.setCurrentIndex(0)
         hBoxLayout.addWidget(self._valueComboBox, alignment=QtCore.Qt.AlignLeft)
 
     def _setState(self):
-        """Set all ui based on state, the number of spikes and the popups selected."""
+        """Set all ui based on state, the number of spikes and the popups selected.
+        """
 
         _selectedSpikes = self.getSelectedSpikes()
 
-        if _selectedSpikes == []:
-            self._spikeLabel.setText("0 Spikes")
+        if  _selectedSpikes == []:
+            self._spikeLabel.setText('0 Spikes')
             self._setButton.setEnabled(False)
             self._statComboBox.setEnabled(False)
             self._lineEdit.setEnabled(False)
             self._valueComboBox.setEnabled(False)
             return
 
         self._setButton.setEnabled(True)
         self._statComboBox.setEnabled(True)
 
-        self._spikeLabel.setText(f"{len(_selectedSpikes)} Spikes")
+        self._spikeLabel.setText(f'{len(_selectedSpikes)} Spikes')
 
-        # include sets combobox to trueFalseItems
+        # isBad sets combobox to trueFalseItems
         # userType sets combobox to userTypeItems
         colStr = self._statComboBox.currentText()
 
         # like a radio button, either one or the other but not both (disjoint)
-        trueFalseEnabled = colStr in ["include", "userType"]
+        trueFalseEnabled = colStr in ['isBad', 'userType']
         self._lineEdit.setEnabled(not trueFalseEnabled)
         self._valueComboBox.setEnabled(trueFalseEnabled)
 
         # switch items in combobox
-        if "userType" in colStr:
+        if 'userType' in colStr:
             items = self.userTypeItems
-        elif colStr == "include":
+        elif colStr == 'isBad':
             items = self.trueFalseItems
         else:
             items = None
-
+        
         if trueFalseEnabled and items is not None:
             # set items in combo box and select item 0
             _numItems = self._valueComboBox.count()
             self._valueComboBox.clear()
-            # logger.info(f'adding {items}')
+            #logger.info(f'adding {items}')
             for item in items:
                 self._valueComboBox.addItem(item)
             self._valueComboBox.setCurrentIndex(0)
 
     def on_set_button(self):
-        """Respond to user clicking the 'set' button."""
+        """Respond to user clicking the 'set' button.
+        """
         colStr = self._statComboBox.currentText()
 
-        if colStr in ["include"]:
-            value = self._valueComboBox.currentText()
-            if value == 'True':
-                value = True
-            else:
-                value = False
-        elif colStr in ["userType"]:
+        if colStr in ['isBad', 'userType']:
             value = self._valueComboBox.currentText()
         else:
             value = self._lineEdit.text()
 
-        if colStr == "userType":
+        if colStr == 'userType':
             value = int(value)
-
-        # eventDict = setSpikeStatEvent
+            
+        #eventDict = setSpikeStatEvent
         setSpikeStatEvent = {}
-        setSpikeStatEvent['ba'] = self.ba
-        setSpikeStatEvent["spikeList"] = self.getSelectedSpikes()
-        setSpikeStatEvent["colStr"] = colStr
-        setSpikeStatEvent["value"] = value
-
-        logger.info(f"  -->> emit signalUpdateAnalysis:{setSpikeStatEvent}")
-        self.signalUpdateAnalysis.emit(setSpikeStatEvent)
-
-    def on_stat_change(self, index: int):
-        """User has selected an item in the stat combo box."""
+        setSpikeStatEvent['spikeList'] = self.getSelectedSpikes()
+        setSpikeStatEvent['colStr'] = colStr
+        setSpikeStatEvent['value'] = value
+
+        logger.info(f'  -->> emit setSpikeStatEvent:{setSpikeStatEvent}')
+        self.signalSetSpikeStat.emit(setSpikeStatEvent)
+        
+    def on_stat_change(self, index : int):
+        """User has selected an item in the stat combo box.
+        """
         self._setState()
 
-    def on_text_edit(self, widget: QtWidgets.QLineEdit):
-        """User has finished editing the text for a column."""
+    def on_text_edit(self, widget : QtWidgets.QLineEdit):
+        """User has finished editing the text for a column.
+        """
         text = widget.text()
-        logger.info(f"{text}")
+        logger.info(f'{text}')
 
     def replot(self):
-        """Inherited."""
+        """Inherited.
+        """
         self._setState()
 
     def selectSpikeList(self):
-        """Inherited."""
+        """Inherited.
+        """
         self.replot()
 
-
 def testSetSpikeStat():
     import sys
-
+    
     # load file
-    path = "/Users/cudmore/Dropbox/data/san-ap/20191009_0006.abf"
+    path = '/Users/cudmore/Dropbox/data/san-ap/20191009_0006.abf'
     ba = sanpy.bAnalysis(path)
-
+ 
     # get all detection presets
-    _detectionParams = sanpy.bDetection()
+    _detectionParams = sanpy.bDetection()    
     # select 'SA Node' presets
-    _dDict = _detectionParams.getDetectionDict("SA Node")
+    _dDict = _detectionParams.getDetectionDict('SA Node')
 
     ba.spikeDetect(_dDict)
     print(ba)
 
     # run the app
     app = QtWidgets.QApplication([])
 
     sss = SetSpikeStat(ba=ba)
     sss.show()
 
     sys.exit(app.exec_())
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     testSetSpikeStat()
+
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/spikeClips.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/spikeClips.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,652 +4,601 @@
 
 import numpy as np
 import pandas as pd
 
 from PyQt5 import QtCore, QtWidgets
 import pyqtgraph as pg
 
-# from matplotlib.backends import backend_qt5agg
+#from matplotlib.backends import backend_qt5agg
 import matplotlib as mpl
 import matplotlib.pyplot as plt
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
-
 class spikeClips(sanpyPlugin):
-    """Plot AP clips."""
-
-    myHumanName = "Plot Spike Clips"
+    """Plot AP clips.
+    """
+    myHumanName = 'Plot Spike Clips'
 
     def __init__(self, **kwargs):
         """
         Args:
             ba (bAnalysis): Not required
         """
         super().__init__(**kwargs)
 
         self.preClipWidth_ms = 100
         self.postClipWidth_ms = 500
         if self.ba is not None and self.ba.isAnalyzed():
-            # self.clipWidth_ms = self.ba.detectionClass['spikeClipWidth_ms']
-            self.preClipWidth_ms = self.ba._detectionDict["preSpikeClipWidth_ms"]
-            self.postClipWidth_ms = self.ba._detectionDict["postSpikeClipWidth_ms"]
+            #self.clipWidth_ms = self.ba.detectionClass['spikeClipWidth_ms']
+            self.preClipWidth_ms = self.ba._detectionDict['preSpikeClipWidth_ms']
+            self.postClipWidth_ms = self.ba._detectionDict['postSpikeClipWidth_ms']
 
-        self.respondTo = "All"  # ('All', 'X-Axis', 'Spike Selection')
+        self.respondTo = 'All' # ('All', 'X-Axis', 'Spike Selection')
 
         # keep track so we can export to clipboard
         self.x = None
         self.y = None
         self.yMean = None
 
         # for waterfall
         self.xMult = 0.1
         self.yMult = 0.1
 
-        # self.clipLines = None
-        # self.meanClipLine = None
+        #self.clipLines = None
+        #self.meanClipLine = None
         self.singleSpikeMultiLine = None
         self.spikeListMultiLine = None
 
         # main layout
         vLayout = QtWidgets.QVBoxLayout()
 
         #
         # controls
         hLayout2 = QtWidgets.QHBoxLayout()
 
-        self.numSpikesLabel = QtWidgets.QLabel("Num Spikes:None")
+        self.numSpikesLabel = QtWidgets.QLabel('Num Spikes:None')
         hLayout2.addWidget(self.numSpikesLabel)
 
-        self.colorCheckBox = QtWidgets.QCheckBox("Color")
+        self.colorCheckBox = QtWidgets.QCheckBox('Color')
         self.colorCheckBox.setChecked(False)
-        self.colorCheckBox.stateChanged.connect(lambda: self.replot())
+        self.colorCheckBox.stateChanged.connect(lambda:self.replot())
         hLayout2.addWidget(self.colorCheckBox)
 
-        self.meanCheckBox = QtWidgets.QCheckBox("Mean Trace (red)")
+        self.meanCheckBox = QtWidgets.QCheckBox('Mean Trace (red)')
         self.meanCheckBox.setChecked(True)
-        self.meanCheckBox.stateChanged.connect(lambda: self.replot())
+        self.meanCheckBox.stateChanged.connect(lambda:self.replot())
         hLayout2.addWidget(self.meanCheckBox)
 
-        self.varianceCheckBox = QtWidgets.QCheckBox("Variance")
+        self.varianceCheckBox = QtWidgets.QCheckBox('Variance')
         self.varianceCheckBox.setChecked(False)
-        self.varianceCheckBox.stateChanged.connect(lambda: self.replot())
+        self.varianceCheckBox.stateChanged.connect(lambda:self.replot())
         hLayout2.addWidget(self.varianceCheckBox)
 
-        self.phasePlotCheckBox = QtWidgets.QCheckBox("Phase")
+        self.phasePlotCheckBox = QtWidgets.QCheckBox('Phase')
         self.phasePlotCheckBox.setChecked(False)
-        self.phasePlotCheckBox.stateChanged.connect(lambda: self.replot())
+        self.phasePlotCheckBox.stateChanged.connect(lambda:self.replot())
         hLayout2.addWidget(self.phasePlotCheckBox)
 
         vLayout.addLayout(hLayout2)
 
         #
         hLayout2_5 = QtWidgets.QHBoxLayout()
 
-        self.waterfallCheckBox = QtWidgets.QCheckBox("Waterfall")
+        self.waterfallCheckBox = QtWidgets.QCheckBox('Waterfall')
         self.waterfallCheckBox.setChecked(False)
-        self.waterfallCheckBox.stateChanged.connect(lambda: self.replot())
+        self.waterfallCheckBox.stateChanged.connect(lambda:self.replot())
         hLayout2_5.addWidget(self.waterfallCheckBox)
 
         # x mult for waterfall
-        aLabel = QtWidgets.QLabel("X-Offset")
+        aLabel = QtWidgets.QLabel('X-Offset')
         hLayout2_5.addWidget(aLabel)
         self.xMultSpinBox = QtWidgets.QDoubleSpinBox()
         self.xMultSpinBox.setKeyboardTracking(False)
         self.xMultSpinBox.setSingleStep(0.05)
         self.xMultSpinBox.setRange(0, 1)
         self.xMultSpinBox.setValue(self.xMult)
-        self.xMultSpinBox.valueChanged.connect(partial(self._on_spinbox, aLabel))
+        self.xMultSpinBox.valueChanged.connect(partial(self.on_spinbox, aLabel))
         hLayout2_5.addWidget(self.xMultSpinBox)
 
         # y mult for waterfall
-        aLabel = QtWidgets.QLabel("Y-Offset")
+        aLabel = QtWidgets.QLabel('Y-Offset')
         hLayout2_5.addWidget(aLabel)
         self.yMultSpinBox = QtWidgets.QDoubleSpinBox()
         self.yMultSpinBox.setKeyboardTracking(False)
         self.yMultSpinBox.setSingleStep(0.05)
         self.yMultSpinBox.setRange(0, 1)
         self.yMultSpinBox.setValue(self.yMult)
-        self.yMultSpinBox.valueChanged.connect(partial(self._on_spinbox, aLabel))
+        self.yMultSpinBox.valueChanged.connect(partial(self.on_spinbox, aLabel))
         hLayout2_5.addWidget(self.yMultSpinBox)
 
         vLayout.addLayout(hLayout2_5)
 
         #
         hLayout3 = QtWidgets.QHBoxLayout()
 
-        aLabel = QtWidgets.QLabel("Pre (ms)")
+        aLabel = QtWidgets.QLabel('Pre (ms)')
         hLayout3.addWidget(aLabel)
         self.preClipWidthSpinBox = QtWidgets.QSpinBox()
         self.preClipWidthSpinBox.setKeyboardTracking(False)
         self.preClipWidthSpinBox.setRange(1, 2**16)
         self.preClipWidthSpinBox.setValue(self.preClipWidth_ms)
-        # self.clipWidthSpinBox.editingFinished.connect(partial(self.on_spinbox, aLabel))
-        self.preClipWidthSpinBox.valueChanged.connect(partial(self._on_spinbox, aLabel))
+        #self.clipWidthSpinBox.editingFinished.connect(partial(self.on_spinbox, aLabel))
+        self.preClipWidthSpinBox.valueChanged.connect(partial(self.on_spinbox, aLabel))
         hLayout3.addWidget(self.preClipWidthSpinBox)
 
-        aLabel = QtWidgets.QLabel("Post (ms)")
+        aLabel = QtWidgets.QLabel('Post (ms)')
         hLayout3.addWidget(aLabel)
         self.postClipWidthSpinBox = QtWidgets.QSpinBox()
         self.postClipWidthSpinBox.setKeyboardTracking(False)
         self.postClipWidthSpinBox.setRange(1, 2**16)
         self.postClipWidthSpinBox.setValue(self.postClipWidth_ms)
-        # self.clipWidthSpinBox.editingFinished.connect(partial(self.on_spinbox, aLabel))
-        self.postClipWidthSpinBox.valueChanged.connect(partial(self._on_spinbox, aLabel))
+        #self.clipWidthSpinBox.editingFinished.connect(partial(self.on_spinbox, aLabel))
+        self.postClipWidthSpinBox.valueChanged.connect(partial(self.on_spinbox, aLabel))
         hLayout3.addWidget(self.postClipWidthSpinBox)
 
         #
         # radio buttons
-        self.respondToAll = QtWidgets.QRadioButton("All")
+        self.respondToAll = QtWidgets.QRadioButton('All')
         self.respondToAll.setChecked(True)
         self.respondToAll.toggled.connect(self.on_radio)
         hLayout3.addWidget(self.respondToAll)
 
-        self.respondToAxisRange = QtWidgets.QRadioButton("X-Axis")
+        self.respondToAxisRange = QtWidgets.QRadioButton('X-Axis')
         self.respondToAxisRange.setChecked(False)
         self.respondToAxisRange.toggled.connect(self.on_radio)
         hLayout3.addWidget(self.respondToAxisRange)
 
-        self.respondToSpikeSel = QtWidgets.QRadioButton("Spike Selection")
+        self.respondToSpikeSel = QtWidgets.QRadioButton('Spike Selection')
         self.respondToSpikeSel.setChecked(False)
         self.respondToSpikeSel.toggled.connect(self.on_radio)
         hLayout3.addWidget(self.respondToSpikeSel)
 
         #
         vLayout.addLayout(hLayout3)
 
         #
         # pyqt graph
         self.view = pg.GraphicsLayoutWidget()
         self.clipPlot = self.view.addPlot(row=0, col=0)
-
+        
         self.clipPlot.enableAutoRange()
 
-        # self.clipPlot.hideButtons()
-        # self.clipPlot.setMenuEnabled(False)
-        # self.clipPlot.setMouseEnabled(x=False, y=False)
+        #self.clipPlot.hideButtons()
+        #self.clipPlot.setMenuEnabled(False)
+        #self.clipPlot.setMouseEnabled(x=False, y=False)
 
-        self.clipPlot.getAxis("left").setLabel("mV")
-        self.clipPlot.getAxis("bottom").setLabel("time (ms)")
+        self.clipPlot.getAxis('left').setLabel('mV')
+        self.clipPlot.getAxis('bottom').setLabel('time (ms)')
 
         # kymograph analysis
         self.variancePlot = self.view.addPlot(row=1, col=0)
 
-        vLayout.addWidget(self.view)  # , stretch=8)
+        vLayout.addWidget(self.view) #, stretch=8)
 
         # set the layout of the main window
-        # self.mainWidget.setLayout(vLayout)
-        # self.setLayout(vLayout)
+        #self.mainWidget.setLayout(vLayout)
+        #self.setLayout(vLayout)
         self.getVBoxLayout().addLayout(vLayout)
-
+        
         self.replot()
 
-    def slot_switchFile(
-        self, ba: sanpy.bAnalysis, rowDict: Optional[dict] = None, replot: bool = True
-    ):
-        # logger.info('')
-
+    def slot_switchFile(self,
+                        ba : sanpy.bAnalysis,
+                        rowDict : Optional[dict] = None,
+                        replot : bool = True):
+        #logger.info('')
+        
         # don't replot until we set our detectionClass
         replot = False
         super().slot_switchFile(ba, rowDict, replot=replot)
 
         if self.ba is not None and self.ba.isAnalyzed():
-            self.preClipWidth_ms = self.ba.getDetectionDict()["preSpikeClipWidth_ms"]
-            self.postClipWidth_ms = self.ba.getDetectionDict()["postSpikeClipWidth_ms"]
+            self.preClipWidth_ms = self.ba.getDetectionDict()['preSpikeClipWidth_ms']
+            self.postClipWidth_ms = self.ba.getDetectionDict()['postSpikeClipWidth_ms']
 
         self.replot()
 
     def on_radio(self):
         """
         Will receive this callback n times where n is # buttons/checkboxes in group
         Only one callback will have isChecked, all other will be !isChecked
         """
-        # logger.info('')
+        #logger.info('')
         sender = self.sender()
         senderText = sender.text()
         isChecked = sender.isChecked()
 
-        if senderText == "All" and isChecked:
-            self.respondTo = "All"
-        elif senderText == "X-Axis" and isChecked:
-            self.respondTo = "X-Axis"
-        elif senderText == "Spike Selection" and isChecked:
-            self.respondTo = "Spike Selection"
+        if senderText == 'All' and isChecked:
+            self.respondTo = 'All'
+        elif senderText == 'X-Axis' and isChecked:
+            self.respondTo = 'X-Axis'
+        elif senderText == 'Spike Selection' and isChecked:
+            self.respondTo = 'Spike Selection'
             # debug
-            # self.selectedSpikeList = [5, 7, 10]
+            #self.selectedSpikeList = [5, 7, 10]
 
         #
         if isChecked:
             self.replot()
 
-    def _on_spinbox(self, label):
-        # logger.info('')
+    def on_spinbox(self, label):
+        #logger.info('')
         # grab from interface
         self.preClipWidth_ms = self.preClipWidthSpinBox.value()
         self.postClipWidth_ms = self.postClipWidthSpinBox.value()
         self.xMult = self.xMultSpinBox.value()
         self.yMult = self.yMultSpinBox.value()
 
         self.replot()
 
     def setAxis(self):
         self.replot()
 
     def replot(self):
-        """Replot when analysis changes or file changes"""
+        """Replot when analysis changes or file changes
+        """
         self._myReplotClips()
         #
-        # self.mainWidget.repaint() # update the widget
+        #self.mainWidget.repaint() # update the widget
 
     '''
     def setAxis(self):
         """
         (self.startSec, self.stopSec) has been set by sanpyPlugins
         """
         self.replot()
     '''
 
     def _myReplotClips(self):
         """
         Note: This is the same code as in bDetectionWidget.refreshClips() MERGE THEM.
         """
 
-        # logger.info('')
+        #logger.info('')
 
         isPhasePlot = self.phasePlotCheckBox.isChecked()
 
         # always remove existing
         self.clipPlot.clear()
-
-        # self.clipPlot.enableAutoRange()
+        
+        #self.clipPlot.enableAutoRange()
 
         self.variancePlot.clear()
 
         if self.ba is None or self.ba.numSpikes == 0:
             return
 
         # TODO: Add option to select by selectSpikeList
 
         #
         # respond to x-axis selection
         startSec = None
         stopSec = None
         selectedSpikeList = []
-        logger.info(f'self.respondTo: {self.respondTo}')
-        if self.respondTo == "All":
+        if self.respondTo == 'All':
             startSec = 0
             stopSec = self.ba.fileLoader.recordingDur
-        elif self.respondTo == "X-Axis":
+        elif self.respondTo == 'X-Axis':
             startSec, stopSec = self.getStartStop()
             if startSec is None or stopSec is None:
                 startSec = 0
                 stopSec = self.ba.fileLoader.recordingDur
-        elif self.respondTo == "Spike Selection":
+        elif self.respondTo == 'Spike Selection':
             selectedSpikeList = self.getSelectedSpikes()
 
-        logger.info(f'  startSec:{startSec} stopSec:{stopSec}')
-
-        # print('=== selectedSpikeList:', selectedSpikeList)
+        #print('=== selectedSpikeList:', selectedSpikeList)
 
         # this returns x-axis in ms
         # theseClips is a [list] of clips
         # theseClips_x is in ms
-        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(
-            startSec,
-            stopSec,
-            spikeSelection=selectedSpikeList,
-            preSpikeClipWidth_ms=self.preClipWidth_ms,
-            postSpikeClipWidth_ms=self.postClipWidth_ms,
-            sweepNumber=self.sweepNumber,
-            epochNumber=self.epochNumber,
-            ignoreMinMax=False  # 20230418 trying to get sweeps/epochs working
-        )
+        theseClips, theseClips_x, meanClip = self.ba.getSpikeClips(startSec, stopSec,
+                                                spikeSelection=selectedSpikeList,
+                                                preSpikeClipWidth_ms=self.preClipWidth_ms,
+                                                postSpikeClipWidth_ms=self.postClipWidth_ms,
+                                                sweepNumber=self.sweepNumber)
         numClips = len(theseClips)
-        logger.info(f'  got numClips:{numClips}')
-        self.numSpikesLabel.setText(f"Num Spikes: {numClips}")
+        self.numSpikesLabel.setText(f'Num Spikes: {numClips}')
 
         if numClips == 0:
             return
 
         # convert clips to 2d ndarray ???
         xTmp = np.array(theseClips_x)
         xTmp /= 1000  # ms to seconds
         yTmp = np.array(theseClips)  # mV
 
         if isPhasePlot:
             # plot x mV versus y dV/dt
-            dvdt = np.zeros((yTmp.shape[0], yTmp.shape[1] - 1))  #
+            dvdt = np.zeros((yTmp.shape[0], yTmp.shape[1]-1))  #
             for i in range(dvdt.shape[0]):
-                dvdt[i, :] = np.diff(yTmp[i, :])
+                dvdt[i,:] = np.diff(yTmp[i,:])
                 # drop first pnt in x
 
             #
-            xTmp = yTmp[:, 1:]  # drop first column of mV and swap to x-axis
+            xTmp = yTmp[:, 1:] # drop first column of mV and swap to x-axis
             yTmp = dvdt
-            # print(xTmp.shape, yTmp.shape)
+            #print(xTmp.shape, yTmp.shape)
 
         # for waterfall we need x-axis to have different values for each spike
         if self.waterfallCheckBox.isChecked():
-            # print(xTmp.shape, yTmp.shape)
+            #print(xTmp.shape, yTmp.shape)
             # xTmp and yTmp are 2D with rows/clips and cols/data_pnts
             xMin = np.nanmin(xTmp)
             xMax = np.nanmax(xTmp)
             xRange = xMax - xMin
             yMin = np.nanmin(yTmp)
             yMax = np.nanmax(yTmp)
             yRange = yMax - yMin
             xOffset = 0
             yOffset = 0
-            xInc = xRange * self.xMult  # ms, xInc is 10% of x-range
+            xInc = xRange * self.xMult # ms, xInc is 10% of x-range
             yInc = yRange * self.yMult
             for i in range(xTmp.shape[0]):
-                xTmp[i, :] += xOffset
-                yTmp[i, :] += yOffset
-                xOffset += xInc  # ms
-                yOffset += yInc  # mV
+                xTmp[i,:] += xOffset
+                yTmp[i,:] += yOffset
+                xOffset += xInc # ms
+                yOffset += yInc # mV
 
         #
         # original, one multiline for all clips (super fast)
-        # self.clipLines = MultiLine(xTmp, yTmp, self, allowXAxisDrag=False, type='clip')
+        #self.clipLines = MultiLine(xTmp, yTmp, self, allowXAxisDrag=False, type='clip')
         #
         # each clip so we can set color
-        # cmap = pg.colormap.get('Greens', source='matplotlib') # prepare a linear color map
+        #cmap = pg.colormap.get('Greens', source='matplotlib') # prepare a linear color map
         numSpikes = xTmp.shape[0]
 
         doColor = self.colorCheckBox.isChecked()
         if doColor:
-            # cmap = pg.colormap.get('CET-L18') # prepare a linear color map
-            cmap = pg.colormap.get(
-                "gist_rainbow", source="matplotlib"
-            )  # prepare a linear color map
-
+            #cmap = pg.colormap.get('CET-L18') # prepare a linear color map
+            cmap = pg.colormap.get('gist_rainbow', source='matplotlib') # prepare a linear color map
+            
             tmpColors = cmap.getColors()
-            tmpLinSpace = np.linspace(
-                0, len(tmpColors), numSpikes, endpoint=False, dtype=np.uint16
-            )
-        # for tmp in tmps:
+            tmpLinSpace = np.linspace(0, len(tmpColors), numSpikes, endpoint=False, dtype=np.uint16)
+        #for tmp in tmps:
         #    print(tmp)
         for i in range(numSpikes):
-            # forcePenColor = cmap.getByIndex(i)  # returns PyQt5.QtGui.QColor
+            #forcePenColor = cmap.getByIndex(i)  # returns PyQt5.QtGui.QColor
             forcePenColor = None
             if doColor:
                 currentStep = tmpLinSpace[i]
                 forcePenColor = tmpColors[currentStep]
             else:
                 forcePenColor = self.getPenColor()
-
-            xPlot = xTmp[i, :]
-            yPlot = yTmp[i, :]
-            tmpClipLines = MultiLine(
-                xPlot,
-                yPlot,
-                self,
-                allowXAxisDrag=False,
-                forcePenColor=forcePenColor,
-                type="clip",
-            )
+                
+            xPlot = xTmp[i,:]
+            yPlot = yTmp[i,:]
+            tmpClipLines = MultiLine(xPlot, yPlot, self, allowXAxisDrag=False, forcePenColor=forcePenColor, type='clip')
             self.clipPlot.addItem(tmpClipLines)
 
         #
         # always calculate mean clip
         # x mean is redundant but works well for waterfall
-        xMeanClip = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+        xMeanClip = np.nanmean(xTmp, axis=0) # xTmp is in ms
         yMeanClip = np.nanmean(yTmp, axis=0)
 
         # plot if checkbox is on
         if self.meanCheckBox.isChecked():
-            tmpMeanClipLine = MultiLine(
-                xMeanClip,
-                yMeanClip,
-                self,
-                width=3,
-                allowXAxisDrag=False,
-                type="meanclip",
-            )
+            tmpMeanClipLine = MultiLine(xMeanClip, yMeanClip, self, width=3, allowXAxisDrag=False, type='meanclip')
             self.clipPlot.addItem(tmpMeanClipLine)
 
         #
         if not self.varianceCheckBox.isChecked():
             self.variancePlot.hide()
         else:
             self.variancePlot.show()
-            # self.variancePlot.clear()
-            xVarClip = np.nanmean(xTmp, axis=0)  # xTmp is in ms
+            #self.variancePlot.clear()
+            xVarClip = np.nanmean(xTmp, axis=0) # xTmp is in ms
             yVarClip = np.nanvar(yTmp, axis=0)
-            tmpVarClipLine = MultiLine(
-                xVarClip, yVarClip, self, width=3, allowXAxisDrag=False, type="meanclip"
-            )
+            tmpVarClipLine = MultiLine(xVarClip, yVarClip, self, width=3, allowXAxisDrag=False, type='meanclip')
             self.variancePlot.addItem(tmpVarClipLine)
-            self.variancePlot.getAxis("left").setLabel("Variance")
+            self.variancePlot.getAxis('left').setLabel('Variance')
+
 
         # set axis
-        xLabel = "time (s)"
+        xLabel = 'time (s)'
         yLabel = self.ba.fileLoader.get_yUnits()
         if isPhasePlot:
             xLabel = self.ba.fileLoader.get_yUnits()
-            yLabel = "d/dt"
-        self.clipPlot.getAxis("left").setLabel(yLabel)
-        self.clipPlot.getAxis("bottom").setLabel(xLabel)
+            yLabel = 'd/dt'
+        self.clipPlot.getAxis('left').setLabel(yLabel)
+        self.clipPlot.getAxis('bottom').setLabel(xLabel)
 
         # mar 27 2023
         self.clipPlot.autoRange()  # 20230327
 
         #
         # store so we can export
-        # print('  xTmp:', xTmp.shape)
-        # print('  yTmp:', yTmp.shape)
-        # print('  yMeanClip:', yMeanClip.shape)
+        #print('  xTmp:', xTmp.shape)
+        #print('  yTmp:', yTmp.shape)
+        #print('  yMeanClip:', yMeanClip.shape)
         self.x = xTmp  # 1D
         self.y = yTmp  # 2D
         self.yMean = yMeanClip
 
         # update pre/post clip (ms)
         self.preClipWidthSpinBox.setValue(self.preClipWidth_ms)
         self.postClipWidthSpinBox.setValue(self.postClipWidth_ms)
 
         #
         # replot any selected spikes
-        # self.old_selectSpike()
+        #self.old_selectSpike()
         self.selectSpikeList()
 
     def saveResultsFigure(self):
         super().saveResultsFigure(pgPlot=self.clipPlot)
-
+        
     def copyToClipboard(self):
         """
         Save instead
         Copy to clipboard is not going to work, data is too complex/big
         """
-
+        
         numSpikes = self.y.shape[0]
 
-        columns = ["time(ms)", "meanClip"]
+        columns = ['time(ms)', 'meanClip']
         # iterate through spikes
         for i in range(numSpikes):
-            columns.append(f"clip_{i}")
+            columns.append(f'clip_{i}')
         df = pd.DataFrame(columns=columns)
 
-        # print('self.x:', type(self.x), self.x.shape)
+        #print('self.x:', type(self.x), self.x.shape)
 
-        df["time(ms)"] = self.x[0, :]
-        df["meanClip"] = self.yMean
+        df['time(ms)'] = self.x[0,:]
+        df['meanClip'] = self.yMean
         for i in range(numSpikes):
-            df[f"clip_{i}"] = self.y[i]
+            df[f'clip_{i}'] = self.y[i]
 
         super().copyToClipboard(df=df)
-
+        
     def old_selectSpike(self, sDict=None):
         """
         Leave existing spikes and select one spike with a different color.
         The one spike might not be displayed, then do nothing.
         sDict (dict): NOT USED
         """
 
         if sDict is not None:
-            spikeNumber = sDict["spikeNumber"]
+            spikeNumber = sDict['spikeNumber']
         else:
             spikeNumber = self.selectedSpike
 
         x = np.zeros(1) * np.nan
         y = np.zeros(1) * np.nan
         if spikeNumber is not None:
             try:
                 x = self.x[spikeNumber]
                 y = self.y[spikeNumber]
-            except IndexError as e:
+            except (IndexError) as e:
                 pass
 
         # TODO: Fix this. Not sure how to recycle single spike selection
         #    replot is calling self.clipPlot.clear()
         if self.singleSpikeMultiLine is not None:
             self.clipPlot.removeItem(self.singleSpikeMultiLine)
         if spikeNumber is not None:
             # only add i fwe have a spike
-            self.singleSpikeMultiLine = MultiLine(
-                x,
-                y,
-                self,
-                width=3,
-                allowXAxisDrag=False,
-                forcePenColor="y",
-                type="spike selection",
-            )
+            self.singleSpikeMultiLine = MultiLine(x, y, self, width=3, allowXAxisDrag=False, forcePenColor='y', type='spike selection')
             self.clipPlot.addItem(self.singleSpikeMultiLine)
 
     def selectSpikeList(self):
         """Select spikes based on self.getSelectedSpikes().
 
         sDict (dict): NOT USED
         """
-        # logger.info(sDict)
+        #logger.info(sDict)
 
         x = np.zeros(1) * np.nan
         y = np.zeros(1) * np.nan
 
         _selectedSpikes = self.getSelectedSpikes()
 
         if len(_selectedSpikes) > 0:
             try:
                 x = self.x[_selectedSpikes]
                 y = self.y[_selectedSpikes]
-            except IndexError as e:
+            except (IndexError) as e:
                 pass
         if self.spikeListMultiLine is not None:
             self.clipPlot.removeItem(self.spikeListMultiLine)
         if len(_selectedSpikes) > 0:
-            self.spikeListMultiLine = MultiLine(
-                x,
-                y,
-                self,
-                width=3,
-                allowXAxisDrag=False,
-                forcePenColor="c",
-                type="spike list selection",
-            )
+            self.spikeListMultiLine = MultiLine(x, y, self,
+                                                width=3,
+                                                allowXAxisDrag=False,
+                                                forcePenColor='c',
+                                                type='spike list selection')
             self.clipPlot.addItem(self.spikeListMultiLine)
 
-
-# class MultiLine(pg.QtGui.QGraphicsPathItem):
+#class MultiLine(pg.QtGui.QGraphicsPathItem):
 class MultiLine(QtWidgets.QGraphicsPathItem):
     """
     This will display a time-series whole-cell recording efficiently
     It does this by converting the array of points to a QPath
 
     see: https://stackoverflow.com/questions/17103698/plotting-large-arrays-in-pyqtgraph/17108463#17108463
     """
-
-    def __init__(
-        self,
-        x,
-        y,
-        detectionWidget,
-        type,
-        width=1,
-        forcePenColor=None,
-        allowXAxisDrag=True,
-    ):
+    def __init__(self, x, y, detectionWidget, type, width=1, forcePenColor=None, allowXAxisDrag=True):
         """
         x and y are 2D arrays of shape (Nplots, Nsamples)
         type: (dvdt, vm)
         """
 
         self.exportWidgetList = []
 
         self.x = x
         self.y = y
         self.detectionWidget = detectionWidget
         self.myType = type
         self.allowXAxisDrag = allowXAxisDrag
 
-        self.xDrag = None  # if true, user is dragging x-axis, otherwise y-axis
+        self.xDrag = None # if true, user is dragging x-axis, otherwise y-axis
         self.xStart = None
         self.xCurrent = None
         self.linearRegionItem = None
 
         if len(x.shape) == 2:
             connect = np.ones(x.shape, dtype=bool)
-            connect[:, -1] = 0  # don't draw the segment between each trace
+            connect[:,-1] = 0 # don't draw the segment between each trace
             self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect.flatten())
         else:
-            self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect="all")
-        # pg.QtGui.QGraphicsPathItem.__init__(self, self.path)
+            self.path = pg.arrayToQPath(x.flatten(), y.flatten(), connect='all')
+        #pg.QtGui.QGraphicsPathItem.__init__(self, self.path)
         super().__init__(self.path)
 
         if forcePenColor is not None:
             penColor = forcePenColor
         else:
-            penColor = "k"
+            penColor = 'k'
         #
-        if self.myType == "meanclip":
-            penColor = "r"
+        if self.myType == 'meanclip':
+            penColor = 'r'
             width = 3
 
-        # print('MultiLine penColor:', penColor)
-        # logger.info(f'{self.myType} penColor: {penColor}')
+        #print('MultiLine penColor:', penColor)
+        #logger.info(f'{self.myType} penColor: {penColor}')
         pen = pg.mkPen(color=penColor, width=width)
 
         # testing gradient pen
-        """
+        '''
         cm = pg.colormap.get('CET-L17') # prepare a linear color map
         #cm.reverse()                    # reverse it to put light colors at the top
         pen = cm.getPen( span=(0.0,1.0), width=5 ) # gradient from blue (y=0) to white (y=1)
-        """
+        '''
 
         # this works
         self.setPen(pen)
 
     def shape(self):
         # override because QGraphicsPathItem.shape is too expensive.
-        # print(time.time(), 'MultiLine.shape()', pg.QtGui.QGraphicsItem.shape(self))
-        # return pg.QtGui.QGraphicsItem.shape(self)
+        #print(time.time(), 'MultiLine.shape()', pg.QtGui.QGraphicsItem.shape(self))
+        #return pg.QtGui.QGraphicsItem.shape(self)
         # now this
         return super().shape()
 
     def boundingRect(self):
-        # print(time.time(), 'MultiLine.boundingRect()', self.path.boundingRect())
+        #print(time.time(), 'MultiLine.boundingRect()', self.path.boundingRect())
         return self.path.boundingRect()
 
     def old_mouseClickEvent(self, event):
         if event.button() == QtCore.Qt.RightButton:
-            print("mouseClickEvent() right click", self.myType)
+            print('mouseClickEvent() right click', self.myType)
             self.contextMenuEvent(event)
 
     def old_contextMenuEvent(self, event):
         myType = self.myType
 
-        if myType == "clip":
-            print("WARNING: no export for clips, try clicking again")
+        if myType == 'clip':
+            print('WARNING: no export for clips, try clicking again')
             return
 
-        """
+        '''
         contextMenu = QtWidgets.QMenu()
         exportTraceAction = contextMenu.addAction(f'Export Trace {myType}')
         contextMenu.addSeparator()
         resetAllAxisAction = contextMenu.addAction(f'Reset All Axis')
         resetYAxisAction = contextMenu.addAction(f'Reset Y-Axis')
         #openAct = contextMenu.addAction("Open")
         #quitAct = contextMenu.addAction("Quit")
@@ -703,133 +652,123 @@
             #print('Reset Y-Axis', self.myType)
             self.detectionWidget.setAxisFull()
         elif actionText == 'Reset Y-Axis':
             #print('Reset Y-Axis', self.myType)
             self.detectionWidget.setAxisFull_y(self.myType)
         else:
             logger.warning(f'action not taken: {action}')
-        """
+        '''
 
     def old_slot_closeChildWindow(self, windowPointer):
-        # print('closeChildWindow()', windowPointer)
-        # print('  exportWidgetList:', self.exportWidgetList)
+        #print('closeChildWindow()', windowPointer)
+        #print('  exportWidgetList:', self.exportWidgetList)
 
         idx = self.exportWidgetList.index(windowPointer)
         if idx is not None:
             popedItem = self.exportWidgetList.pop(idx)
-            # print('  popedItem:', popedItem)
+            #print('  popedItem:', popedItem)
         else:
-            print(" slot_closeChildWindow() did not find", windowPointer)
+            print(' slot_closeChildWindow() did not find', windowPointer)
 
     def old_mouseDragEvent(self, ev):
         """
         default is to drag x-axis, use alt_drag for y-axis
         """
-        # print('MultiLine.mouseDragEvent():', type(ev), ev)
+        #print('MultiLine.mouseDragEvent():', type(ev), ev)
 
         if ev.button() != QtCore.Qt.LeftButton:
             ev.ignore()
             return
 
-        # modifiers = QtWidgets.QApplication.keyboardModifiers()
-        # isAlt = modifiers == QtCore.Qt.AltModifier
+        #modifiers = QtWidgets.QApplication.keyboardModifiers()
+        #isAlt = modifiers == QtCore.Qt.AltModifier
         isAlt = ev.modifiers() == QtCore.Qt.AltModifier
 
-        # xDrag = not isAlt # x drag is dafault, when alt is pressed, xDrag==False
+        #xDrag = not isAlt # x drag is dafault, when alt is pressed, xDrag==False
 
         # allowXAxisDrag is now used for both x and y
         if not self.allowXAxisDrag:
-            ev.accept()  # this prevents click+drag of plot
+            ev.accept() # this prevents click+drag of plot
             return
 
         if ev.isStart():
             self.xDrag = not isAlt
             if self.xDrag:
                 self.xStart = ev.buttonDownPos()[0]
-                self.linearRegionItem = pg.LinearRegionItem(
-                    values=(self.xStart, 0), orientation=pg.LinearRegionItem.Vertical
-                )
+                self.linearRegionItem = pg.LinearRegionItem(values=(self.xStart,0), orientation=pg.LinearRegionItem.Vertical)
             else:
                 # in y-drag, we need to know (vm, dvdt)
                 self.xStart = ev.buttonDownPos()[1]
-                self.linearRegionItem = pg.LinearRegionItem(
-                    values=(0, self.xStart), orientation=pg.LinearRegionItem.Horizontal
-                )
-            # self.linearRegionItem.sigRegionChangeFinished.connect(self.update_x_axis)
+                self.linearRegionItem = pg.LinearRegionItem(values=(0,self.xStart), orientation=pg.LinearRegionItem.Horizontal)
+            #self.linearRegionItem.sigRegionChangeFinished.connect(self.update_x_axis)
             # add the LinearRegionItem to the parent widget (Cannot add to self as it is an item)
             self.parentWidget().addItem(self.linearRegionItem)
         elif ev.isFinish():
             if self.xDrag:
-                set_xyBoth = "xAxis"
+                set_xyBoth = 'xAxis'
             else:
-                set_xyBoth = "yAxis"
-            # self.parentWidget().setXRange(self.xStart, self.xCurrent)
-            self.detectionWidget.setAxis(
-                self.xStart, self.xCurrent, set_xyBoth=set_xyBoth, whichPlot=self.myType
-            )
+                set_xyBoth = 'yAxis'
+            #self.parentWidget().setXRange(self.xStart, self.xCurrent)
+            self.detectionWidget.setAxis(self.xStart, self.xCurrent, set_xyBoth=set_xyBoth, whichPlot=self.myType)
 
             self.xDrag = None
             self.xStart = None
             self.xCurrent = None
 
-            """
+            '''
             if self.myType == 'clip':
                 if self.xDrag:
                     self.clipPlot.setXRange(self.xStart, self.xCurrent, padding=padding)
                 else:
                     self.clipPlot.setYRange(self.xStart, self.xCurrent, padding=padding)
             else:
                 self.parentWidget().removeItem(self.linearRegionItem)
-            """
+            '''
             self.parentWidget().removeItem(self.linearRegionItem)
 
             self.linearRegionItem = None
 
             return
 
         if self.xDrag:
             self.xCurrent = ev.pos()[0]
-            # print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
+            #print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
             self.linearRegionItem.setRegion((self.xStart, self.xCurrent))
         else:
             self.xCurrent = ev.pos()[1]
-            # print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
+            #print('xStart:', self.xStart, 'self.xCurrent:', self.xCurrent)
             self.linearRegionItem.setRegion((self.xStart, self.xCurrent))
         ev.accept()
 
-
-if __name__ == "__main__":
-    # path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
-    # path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
-    path = "/media/cudmore/data/rabbit-ca-transient/jan-12-2022/Control/220110n_0003.tif.frames/220110n_0003.tif"
+if __name__ == '__main__':
+    #path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
+    #path = '/home/cudmore/Sites/SanPy/data/19114001.abf'
+    path = '/media/cudmore/data/rabbit-ca-transient/jan-12-2022/Control/220110n_0003.tif.frames/220110n_0003.tif'
     ba = sanpy.bAnalysis(path)
 
-    """
+    '''
     detectionClass = sanpy.bDetection()
     print(type(detectionClass))
     detectionClass['dvdtThreshold'] = math.nan #if None then detect only using mvThreshold
     detectionClass['mvThreshold'] = -0 #0.5
-    """
+    '''
 
-    mvThreshold = 1.2  # 0
-    detectionClass = sanpy.bDetection()  # gets default detection class
+    mvThreshold = 1.2 #0
+    detectionClass = sanpy.bDetection() # gets default detection class
     detectionType = sanpy.bDetection.detectionTypes.mv
-    detectionClass[
-        "detectionType"
-    ] = detectionType  # set detection type to ('dvdt', 'vm')
-    detectionClass["dvdtThreshold"] = math.nan
-    detectionClass["mvThreshold"] = mvThreshold
-    detectionClass["preSpikeClipWidth_ms"] = 100
-    detectionClass["postSpikeClipWidth_ms"] = 1000
+    detectionClass['detectionType'] = detectionType  # set detection type to ('dvdt', 'vm')
+    detectionClass['dvdtThreshold'] = math.nan
+    detectionClass['mvThreshold'] = mvThreshold
+    detectionClass['preSpikeClipWidth_ms'] = 100
+    detectionClass['postSpikeClipWidth_ms'] = 1000
 
     ba.spikeDetect(detectionClass=detectionClass)
-    # ba.spikeDetect()
+    #ba.spikeDetect()
     print(ba)
 
-    # sys.exit(1)
+    #sys.exit(1)
 
     import sys
-
     app = QtWidgets.QApplication([])
     sc = spikeClips(ba=ba)
     sc.show()
     sys.exit(app.exec_())
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/plugins/stimGen.py` & `sanpy-ephys-0.1.6/sanpy/interface/plugins/stimGen.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,86 +28,84 @@
 
 from PyQt5 import QtCore, QtWidgets, QtGui
 
 import matplotlib as mpl
 import matplotlib.pyplot as plt
 from matplotlib.backends import backend_qt5agg
 
+#import qdarkstyle
+
 import sanpy
 from sanpy.interface.plugins import sanpyPlugin
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 def readFolderParams(folderPath):
     """
     Return a DataFrame, one row per file. Columns are stim parameters
     """
     dList = []
     for file in sorted(os.listdir(folderPath)):
-        if not file.endswith(".atf"):
+        if not file.endswith('.atf'):
             continue
         filePath = os.path.join(folderPath, file)
         d = readFileParams(filePath)
         dList.append(d)
     #
     df = pd.DataFrame(dList)
-    outFile = os.path.join(folderPath, "stimGen_db.csv")
-    print("saving:", outFile)
+    outFile = os.path.join(folderPath, 'stimGen_db.csv')
+    print('saving:', outFile)
     df.to_csv(outFile)
 
     return df
 
-
 def readFileParams(path):
     """
     Read stimGen params from one atf file
     """
     retDict = {}
-    with open(path, "r") as f:
+    with open(path, 'r') as f:
         while True:
-            # lines = f.readlines()
+            #lines = f.readlines()
             line = f.readline()
             if not line:
                 break  # EOF
             if line.startswith('"Comment='):
                 # looks like
                 # "Comment=version=0.2;numSweeps=5;sweepDurSeconds=30.0;stimType=Sin;stimStartSeconds=5.0;durSeconds=20.0;yStimOffset=0.0;amplitude=0.002;frequency=1.0;noiseAmplitude=0.0;amplitudeStep=0.0;frequencyStep=0.0;noiseStep=0.0;doRectify=False;"
-                line = line.replace('"Comment=', "")
+                line = line.replace('"Comment=','')
                 line = line[0:-2]  # remove trailing "
-                # print(line)
-                for param in line.split(";"):
-                    kv = param.split("=")
-                    # print(kv)
+                #print(line)
+                for param in line.split(';'):
+                    kv = param.split('=')
+                    #print(kv)
                     if len(kv) != 2:
                         continue
                     k = kv[0]
                     v = kv[1]
-                    # print(k, v)
+                    #print(k, v)
 
-                    if k == "stimType":
+                    if k == 'stimType':
                         pass
-                    elif k == "doRectify":
+                    elif k == 'doRectify':
                         v = bool(v)
-                    elif k == "numSweeps":
+                    elif k == 'numSweeps':
                         v = int(v)
                     else:
                         v = float(v)
                     #
                     retDict[k] = v
                 #
                 break
     #
     return retDict
 
-
 class stimGen(sanpyPlugin):
-    myHumanName = "Stim Gen"
+    myHumanName = 'Stim Gen'
 
     def __init__(self, myAnalysisDir=None, **kwargs):
         """
         Args:
             ba (bAnalysis): Not required
         """
         super(stimGen, self).__init__(**kwargs)
@@ -121,23 +119,23 @@
 
         self.numSweeps = 5
 
         self._data = [None] * self.numSweeps  # list of sweeps
         self._t = []
 
         self.stimTypes = [
-            "Sin",
-            "Chirp",
-            "Noise",
-            "Epsp train",
-            #'Stochastic HH',
-            "Integrate and Fire",
-        ]
+                        'Sin',
+                        'Chirp',
+                        'Noise',
+                        'Epsp train',
+                        #'Stochastic HH',
+                        'Integrate and Fire'
+                        ]
         # TODO: add (save index, ...)
-        self.stimType = "Sin"
+        self.stimType = 'Sin'
         self.sweepDurSeconds = 30.0
         self.stimStartSeconds = 5.0
         self.durSeconds = 20.0  # of stim
         self.yStimOffset = 0.0
         self.amplitude = 0.002
         self.frequency = 1.0
         self.noiseAmplitude = 0.0  # sqrt() of this is STD of Gaussian noise
@@ -149,67 +147,69 @@
 
         self.doRectify = False
         """ remove all <0 from output stim """
 
         self.scale = 1
         """ scale output stim by this factor"""
 
-        self.savePath = ""  # remember last save folder
+        self.savePath = ''  # remember last save folder
 
         # TODO: all params need to be in dictionary
         # when user clicks on interface (spinbox), we need to update this dict
         self.paramDict = self.defaultParams()
 
         self.buildUI()
 
         self.updateStim()
 
     def defaultParams(self):
         paramDict = {
-            "version": 0.3,
-            "stimType": "Sin",  # str of stim types
-            "fs": 10000,  # int, samples per second
-            "numSweeps": 5,  # int
-            "sweepDur_sec": 30.0,
-            "stimStart_sec": 5.0,
-            "stimDur_sec": 20.0,
-            "yOffset": 0.0,
+            'version': 0.3,
+            'stimType': 'Sin',  # str of stim types
+            'fs': 10000,  # int, samples per second
+            'numSweeps': 5,  # int
+            'sweepDur_sec': 30.0,
+            'stimStart_sec': 5.0,
+            'stimDur_sec': 20.0,
+            'yOffset': 0.0,
             # First sweep parameters
-            "stimFreq": 1.0,
-            "stimAmp": 0.002,
-            "stimNoiseAmp": 0.0,
+            'stimFreq': 1.0,
+            'stimAmp': 0.002,
+            'stimNoiseAmp': 0.0,
             # step parameters
-            "stimFreqStep": 0.0,
-            "stimAmpStep": 0.0,
-            "stimNoiseStep": 0.0,
+            'stimFreqStep': 0.0,
+            'stimAmpStep': 0.0,
+            'stimNoiseStep': 0.0,
             #
-            "rectify": False,
-            "scale": 1,
+            'rectify': False,
+            'scale': 1,
+
+
         }
 
     def getComment(self):
-        comment = ""  # '"Comment='
+        comment = '' # '"Comment='
 
-        comment += f"version={self.version};"
-        comment += f"numSweeps={self.numSweeps};"
-        comment += f"sweepDurSeconds={self.sweepDurSeconds};"
-        comment += f"stimType={self.stimType};"
-        comment += f"stimStartSeconds={self.stimStartSeconds};"
-        comment += f"durSeconds={self.durSeconds};"
-        comment += f"yStimOffset={self.yStimOffset};"
-        comment += f"amplitude={self.amplitude};"
-        comment += f"frequency={self.frequency};"
-        comment += f"noiseAmplitude={self.noiseAmplitude};"
-        comment += f"amplitudeStep={self.amplitudeStep};"
-        comment += f"frequencyStep={self.frequencyStep};"
-        comment += f"noiseStep={self.noiseStep};"
-        comment += f"doRectify={self.doRectify};"
+        comment +=  f'version={self.version};'
+        comment +=  f'numSweeps={self.numSweeps};'
+        comment +=  f'sweepDurSeconds={self.sweepDurSeconds};'
+        comment +=  f'stimType={self.stimType};'
+        comment +=  f'stimStartSeconds={self.stimStartSeconds};'
+        comment +=  f'durSeconds={self.durSeconds};'
+        comment +=  f'yStimOffset={self.yStimOffset};'
+        comment +=  f'amplitude={self.amplitude};'
+        comment +=  f'frequency={self.frequency};'
+        comment +=  f'noiseAmplitude={self.noiseAmplitude};'
+        comment +=  f'amplitudeStep={self.amplitudeStep};'
+        comment +=  f'frequencyStep={self.frequencyStep};'
+        comment +=  f'noiseStep={self.noiseStep};'
+        comment +=  f'doRectify={self.doRectify};'
 
         #
-        # comment += '"'
+        #comment += '"'
         return comment
 
     def getAtfHeader(self, numChannels=1):
         """
         See: https://github.com/christianrickert/Axon-Text-File/blob/master/data.atf
 
         File looks like this 20211119
@@ -225,70 +225,68 @@
         "SignalsExported=IN 0"
         "Signals="    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"
         "Time (s)"    "Trace #1 (pA)"    "Trace #2 (pA)"    "Trace #3 (pA)"    "Trace #4 (pA)"    "Trace #5 (pA)"    "Trace #6 (pA)"    "Trace #7 (pA)"    "Trace #8 (pA)"    "Trace #9 (pA)"    "Trace #10 (pA)"
         0    1.2207    1.2207    5.49316    2.44141    3.66211    0.610352    2.44141    5.49316    1.83105    2.44141
         1e-4    2.44141    1.2207    0.610352    2.44141    2.44141    0.610352    0.610352    1.2207    3.05176    3.05176
         """
 
-        myUnits = "pA"
-        # myComment = 'fill in with stim params'
+        myUnits = 'pA'
+        #myComment = 'fill in with stim params'
 
         numDataColumns = numChannels + 1  # time + number of channels
-        eol = "\n"
-        tab = "\t"
+        eol = '\n'
+        tab = '\t'
         ATF_HEADER = "ATF    1.0" + eol
-        ATF_HEADER += f"8\t{numDataColumns}" + eol
+        ATF_HEADER += f'8\t{numDataColumns}' + eol
 
         ATF_HEADER += '"AcquisitionMode=Episodic Stimulation"' + eol
 
         myComment = self.getComment()
         ATF_HEADER += f'"Comment={myComment}"' + eol
 
         ATF_HEADER += '"YTop=20000"' + eol
         ATF_HEADER += '"YBottom=-20000"' + eol
         ATF_HEADER += '"SyncTimeUnits=100"' + eol
 
         # for a 200 ms sweep, looks like this
         # "SweepStartTimesMS=21.000,221.000,421.000,621.000,821.000,1021.000,1221.000,1421.000,1621.000,1821.000"
-        # durMs = self.durSeconds *1000
-        durMs = self.sweepDurSeconds * 1000  # new 20211202
+        #durMs = self.durSeconds *1000
+        durMs = self.sweepDurSeconds *1000  # new 20211202
         numSweeps = self.numSweeps
         sweepRange = range(numSweeps)
         SweepStartTimesMS = '"SweepStartTimesMS='
         preRollMs = 21
         for sweepIdx, sweep in enumerate(sweepRange):
             currStartTime = preRollMs + (sweepIdx * durMs)
-            SweepStartTimesMS += f"{round(float(currStartTime),3)}" + ","
+            SweepStartTimesMS += f'{round(float(currStartTime),3)}' + ','
         # remove last comma
         SweepStartTimesMS = SweepStartTimesMS[0:-1]
         SweepStartTimesMS += '"'
         ATF_HEADER += SweepStartTimesMS + eol
 
         ATF_HEADER += '"SignalsExported=IN 0"' + eol
 
         # signals looks like this
         # "Signals="    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"    "IN 0"
-        Signals = '"Signals="' + "\t"
+        Signals = '"Signals="' + '\t'
         for sweepIdx, sweep in enumerate(sweepRange):
-            Signals += '"IN 0"' + "\t"
+            Signals += '"IN 0"' + '\t'
         # remove last tab
         Signals = Signals[0:-1]
         ATF_HEADER += Signals + eol
 
         ATF_HEADER += f'"Time (s)"' + tab
-        traceStr = ""
+        traceStr = ''
         for channel in range(numChannels):
-            traceStr += (
-                f'"Trace #{channel+1} ({myUnits})"' + tab
-            )  # not sure if trailing tab is ok???
+            traceStr += f'"Trace #{channel+1} ({myUnits})"' + tab  # not sure if trailing tab is ok???
         # remove last tab
         traceStr = traceStr[0:-1]
         ATF_HEADER += traceStr + eol
 
-        print("=== ATF_HEADER:")
+        print('=== ATF_HEADER:')
         print(ATF_HEADER)
 
         '''
         ATF_HEADER = """
         ATF    1.0
         8    3
         "AcquisitionMode=Episodic Stimulation"
@@ -301,19 +299,19 @@
         "Signals="    "IN 0"
         "Time (s)"    "Trace #1"    "Trace #2"
         """.strip()
         '''
 
         return ATF_HEADER
 
-    """
+    '''
     @property
     def data(self):
         return self._data
-    """
+    '''
 
     @property
     def t(self):
         return self._t
 
     @property
     def fs(self):
@@ -337,53 +335,40 @@
 
         self._data = [None] * self.numSweeps
         for sweepNum in range(self.numSweeps):
             currAmp = amp + (sweepNum * amplitudeStep)
             currFreq = freq + (sweepNum * frequencyStep)
             currNoiseAmp = noiseAmp + (sweepNum * noiseStep)
             autoPad = False
-
-            # print(
-            #     f"  makeStim() {type} sweep:{sweepNum} durSec:{durSec} amp:{currAmp} freq:{currFreq} noiseAmp:{currNoiseAmp}"
-            # )
-
-            self._data[sweepNum] = sanpy.atfStim.makeStim(
-                type,
-                sweepDurSec=sweepDurSeconds,
-                startStimSec=stimStartSeconds,
-                durSec=durSec,
-                yStimOffset=yStimOffset,
-                amp=currAmp,
-                freq=currFreq,
-                fs=fs,
-                noiseAmp=currNoiseAmp,
-                rectify=doRectify,
-                autoPad=autoPad,
-                autoSave=False,
-            )
+            print(f'  makeStim() {type} sweep:{sweepNum} durSec:{durSec} amp:{currAmp} freq:{currFreq} noiseAmp:{currNoiseAmp}')
+            self._data[sweepNum] = sanpy.atfStim.makeStim(type, sweepDurSec=sweepDurSeconds,
+                            startStimSec=stimStartSeconds, durSec=durSec,
+                            yStimOffset=yStimOffset, amp=currAmp,
+                            freq=currFreq, fs=fs, noiseAmp=currNoiseAmp, rectify=doRectify,
+                            autoPad=autoPad, autoSave=False)
             if self._data[sweepNum] is None:
-                print(f"makeStim() error making {type} at sweep number {sweepNum}")
+                print(f'makeStim() error making {type} at sweep number {sweepNum}')
             #
             # scale
             self._data[sweepNum] *= self.scale
-            print("  self._data[sweepNum].dtype:", self._data[sweepNum].dtype)
+            print('  self._data[sweepNum].dtype:', self._data[sweepNum].dtype)
 
         self._t = np.arange(len(self._data[0])) / fs  # just using first sweep
 
-    """
+    '''
     def plotStim(self):
         logger.info(f'_t:{self._t.shape}')
         logger.info(f'_data:{self._data.shape}')
         plt.plot(self._t, self._data)
-    """
+    '''
 
-    """
+    '''
     def saveStim(Self):
         sanpy.atfStim.saveAtf(self.data, fileName="output.atf", fs=10000)
-    """
+    '''
 
     def _grabParams(self):
         """
         Grab all interface parameters in member variables
         """
 
         self.sweepDurSeconds = self.sweepDurationSpinBox.value()  # new 20211202
@@ -399,36 +384,36 @@
         self.amplitudeStep = self.amplitudeStepSpinBox.value()
         self.frequencyStep = self.frequencyStepSpinBox.value()
         self.noiseStep = self.noiseStepSpinBox.value()
 
         self.doRectify = self.rectifyCheckBox.isChecked()
         self._fs = self.fsSpinBox.value()
 
-        """
+        '''
         rmsMult = 1/np.sqrt(2)
         sinRms = self.amplitude * rmsMult
         sinRms = round(sinRms,2)
         aName = f'RMS:{sinRms}'
         self.sinRms.setText(aName)
-        """
+        '''
 
     def updateStim(self):
         self._grabParams()
         self.makeStim()
         self.replot()
 
     def on_spin_box2(self, name, obj):
         print(name, obj.value())
 
     def on_spin_box(self, name):
         logger.info(name)
-        if name == "Number Of Sweeps":
+        if name == 'Number Of Sweeps':
             numSweeps = self.numSweepsSpinBox.value()
             self._updateNumSweeps(numSweeps)
-        elif name == "Save Index":
+        elif name == 'Save Index':
             saveStimIndex = self.saveIndexSpinBox.value()
             self.saveStimIndex = saveStimIndex
             #
         self.updateStim()
 
     def on_stim_type(self, type):
         logger.info(type)
@@ -438,279 +423,275 @@
     def on_scale(self, scale):
         logger.info(type)
         self.scale = float(scale)
         self.updateStim()
 
     def on_button_click(self, name):
         logger.info(name)
-        if name == "Make Stimulus":
+        if name == 'Make Stimulus':
             self.makeStim()
-        elif name == "Save As...":
+        elif name == 'Save As...':
             # TODO: srt a feeback red as we save, set to green when done
             # self.saveAsButton
             self.saveAs()
         else:
             logger.info(f'name "{name}" not understood.')
 
     def on_checkbox_clicked(self, name):
         self.updateStim()
 
     def buildUI(self):
         # main layout
         vLayout = QtWidgets.QVBoxLayout()
         controlLayout = QtWidgets.QHBoxLayout()
 
-        """
+        '''
         aName = 'Make Stimulus'
         aButton = QtWidgets.QPushButton(aName)
         aButton.clicked.connect(partial(self.on_button_click,aName))
         controlLayout.addWidget(aButton)
-        """
+        '''
 
-        aName = "Save As..."
+        aName = 'Save As...'
         self.saveAsButton = QtWidgets.QPushButton(aName)
-        self.saveAsButton.clicked.connect(partial(self.on_button_click, aName))
+        self.saveAsButton.clicked.connect(partial(self.on_button_click,aName))
         controlLayout.addWidget(self.saveAsButton)
 
-        aName = "Save Index"
+        aName = 'Save Index'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout.addWidget(aLabel)
         self.saveIndexSpinBox = QtWidgets.QSpinBox()
         self.saveIndexSpinBox.setKeyboardTracking(False)
         self.saveIndexSpinBox.setRange(0, 9999)
         self.saveIndexSpinBox.setValue(self.saveStimIndex)
         self.saveIndexSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
-        # self.saveIndexSpinBox.valueChanged.connect(partial(self.on_spin_box2, aName, self.saveIndexSpinBox))
+        #self.saveIndexSpinBox.valueChanged.connect(partial(self.on_spin_box2, aName, self.saveIndexSpinBox))
         controlLayout.addWidget(self.saveIndexSpinBox)
 
-        aName = "Stim Type"
+        aName = 'Stim Type'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout.addWidget(aLabel)
         self.stimTypeDropdown = QtWidgets.QComboBox()
         for type in self.stimTypes:
             self.stimTypeDropdown.addItem(type)
         self.stimTypeDropdown.currentTextChanged.connect(self.on_stim_type)
         controlLayout.addWidget(self.stimTypeDropdown)
 
-        aName = "Sweep Duration(s)"
+        aName = 'Sweep Duration(s)'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout.addWidget(aLabel)
         self.sweepDurationSpinBox = QtWidgets.QDoubleSpinBox()
         self.sweepDurationSpinBox.setKeyboardTracking(False)
         self.sweepDurationSpinBox.setRange(0, 2**16)
         self.sweepDurationSpinBox.setValue(self.sweepDurSeconds)
         self.sweepDurationSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout.addWidget(self.sweepDurationSpinBox)
 
-        aName = "Number Of Sweeps"
+        aName = 'Number Of Sweeps'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout.addWidget(aLabel)
         self.numSweepsSpinBox = QtWidgets.QSpinBox()
         self.numSweepsSpinBox.setKeyboardTracking(False)
         self.numSweepsSpinBox.setRange(1, 100)
         self.numSweepsSpinBox.setValue(self.numSweeps)
         self.numSweepsSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout.addWidget(self.numSweepsSpinBox)
 
-        vLayout.addLayout(controlLayout)  # add mpl canvas
+        vLayout.addLayout(controlLayout) # add mpl canvas
 
         # row 1.5
         controlLayout_row1_5 = QtWidgets.QHBoxLayout()
 
-        aName = "Stim Start(s)"
+        aName = 'Stim Start(s)'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row1_5.addWidget(aLabel)
         self.stimStartSpinBox = QtWidgets.QDoubleSpinBox()
         self.stimStartSpinBox.setKeyboardTracking(False)
         self.stimStartSpinBox.setRange(0, 2**16)
         self.stimStartSpinBox.setValue(self.stimStartSeconds)
         self.stimStartSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row1_5.addWidget(self.stimStartSpinBox)
 
-        aName = "Stim Duration(s)"
+        aName = 'Stim Duration(s)'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row1_5.addWidget(aLabel)
         self.durationSpinBox = QtWidgets.QDoubleSpinBox()
         self.durationSpinBox.setKeyboardTracking(False)
         self.durationSpinBox.setRange(0, 2**16)
         self.durationSpinBox.setValue(self.durSeconds)
         self.durationSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row1_5.addWidget(self.durationSpinBox)
 
-        aName = "Stim Offset(y)"
+        aName = 'Stim Offset(y)'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row1_5.addWidget(aLabel)
         self.yStimOffsetSpinBox = QtWidgets.QDoubleSpinBox()
         self.yStimOffsetSpinBox.setKeyboardTracking(False)
         self.yStimOffsetSpinBox.setRange(-1e9, 2**16)
         self.yStimOffsetSpinBox.setValue(self.yStimOffset)
         self.yStimOffsetSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row1_5.addWidget(self.yStimOffsetSpinBox)
 
-        vLayout.addLayout(controlLayout_row1_5)  # add mpl canvas
+        vLayout.addLayout(controlLayout_row1_5) # add mpl canvas
 
         # 2nd row
         controlLayout_row2 = QtWidgets.QGridLayout()
         rowSpan = 1
         colSpan = 1
         row = 0
         col = 0
 
-        aName = "Amplitude"
+        aName = 'Amplitude'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, row, col, rowSpan, colSpan)
         self.amplitudeSpinBox = QtWidgets.QDoubleSpinBox()
         self.amplitudeSpinBox.setKeyboardTracking(False)
         self.amplitudeSpinBox.setRange(0, 2**16)
         self.amplitudeSpinBox.setDecimals(5)
         self.amplitudeSpinBox.setValue(self.amplitude)
         self.amplitudeSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.amplitudeSpinBox, 0, 1, rowSpan, colSpan)
 
         # rms of sin (amp and freq)
-        """
+        '''
         rmsMult = 1/np.sqrt(2)
         sinRms = self.amplitude * rmsMult
         sinRms = round(sinRms,2)
         aName = f'RMS:{sinRms}'
         self.sinRms = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(self.sinRms, 0, 2, rowSpan, colSpan)
-        """
+        '''
 
-        aName = "Frequency (Hz)"
+        aName = 'Frequency (Hz)'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, 0, 3, rowSpan, colSpan)
         self.frequencySpinBox = QtWidgets.QDoubleSpinBox()
         self.frequencySpinBox.setKeyboardTracking(False)
         self.frequencySpinBox.setRange(0, 2**16)
         self.frequencySpinBox.setValue(self.frequency)
         self.frequencySpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.frequencySpinBox, 0, 4, rowSpan, colSpan)
 
-        aName = "Noise Amplitude"
+        aName = 'Noise Amplitude'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, 0, 5, rowSpan, colSpan)
         self.noiseAmpSpinBox = QtWidgets.QDoubleSpinBox()
         self.noiseAmpSpinBox.setKeyboardTracking(False)
         self.noiseAmpSpinBox.setDecimals(5)
         self.noiseAmpSpinBox.setSingleStep(0.01)
         self.noiseAmpSpinBox.setRange(0, 2**16)
         self.noiseAmpSpinBox.setValue(self.noiseAmplitude)
         self.noiseAmpSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.noiseAmpSpinBox, 0, 6, rowSpan, colSpan)
 
         #
         # row 2
-        # controlLayout_row2 = QtWidgets.QHBoxLayout()
+        #controlLayout_row2 = QtWidgets.QHBoxLayout()
 
-        aName = "Amplitude Step"
+        aName = 'Amplitude Step'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, 1, 0, rowSpan, colSpan)
         self.amplitudeStepSpinBox = QtWidgets.QDoubleSpinBox()
         self.amplitudeStepSpinBox.setKeyboardTracking(False)
         self.amplitudeStepSpinBox.setDecimals(5)
         self.amplitudeStepSpinBox.setSingleStep(0.01)
         self.amplitudeStepSpinBox.setRange(0, 2**16)
         self.amplitudeStepSpinBox.setValue(self.amplitudeStep)
         self.amplitudeStepSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.amplitudeStepSpinBox, 1, 1, rowSpan, colSpan)
 
-        aName = "Frequency Step"
+        aName = 'Frequency Step'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, 1, 3, rowSpan, colSpan)
         self.frequencyStepSpinBox = QtWidgets.QDoubleSpinBox()
         self.frequencyStepSpinBox.setKeyboardTracking(False)
         self.frequencyStepSpinBox.setSingleStep(0.1)
         self.frequencyStepSpinBox.setRange(0, 2**16)
         self.frequencyStepSpinBox.setValue(self.frequencyStep)
         self.frequencyStepSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.frequencyStepSpinBox, 1, 4, rowSpan, colSpan)
 
         # first row in grid has freq rms
 
-        aName = "Noise Step"
+        aName = 'Noise Step'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row2.addWidget(aLabel, 1, 5, rowSpan, colSpan)
         self.noiseStepSpinBox = QtWidgets.QDoubleSpinBox()
         self.noiseStepSpinBox.setKeyboardTracking(False)
         self.noiseStepSpinBox.setDecimals(5)
         self.noiseStepSpinBox.setSingleStep(0.01)
         self.noiseStepSpinBox.setRange(0, 2**16)
         self.noiseStepSpinBox.setValue(self.frequencyStep)
         self.noiseStepSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row2.addWidget(self.noiseStepSpinBox, 1, 6, rowSpan, colSpan)
 
         #
-        vLayout.addLayout(controlLayout_row2)  # add mpl canvas
+        vLayout.addLayout(controlLayout_row2) # add mpl canvas
 
         controlLayout_row3 = QtWidgets.QHBoxLayout()
 
-        checkboxName = "Rectify"
+        checkboxName = 'Rectify'
         self.rectifyCheckBox = QtWidgets.QCheckBox(checkboxName)
         self.rectifyCheckBox.setChecked(self.doRectify)
-        self.rectifyCheckBox.stateChanged.connect(
-            partial(self.on_checkbox_clicked, checkboxName)
-        )
+        self.rectifyCheckBox.stateChanged.connect(partial(self.on_checkbox_clicked, checkboxName))
         controlLayout_row3.addWidget(self.rectifyCheckBox)
 
-        aName = "Samples Per Second"
+        aName = 'Samples Per Second'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row3.addWidget(aLabel)
         self.fsSpinBox = QtWidgets.QSpinBox()
         self.fsSpinBox.setKeyboardTracking(False)
         self.fsSpinBox.setRange(1, 100000)  # TODO: Fix hard coding of 100000
         self.fsSpinBox.setValue(self._fs)
         self.fsSpinBox.valueChanged.connect(partial(self.on_spin_box, aName))
         controlLayout_row3.addWidget(self.fsSpinBox)
 
-        aName = "Scale"
+        aName = 'Scale'
         aLabel = QtWidgets.QLabel(aName)
         controlLayout_row3.addWidget(aLabel)
         self.scaleDropdown = QtWidgets.QComboBox()
         scales = [0.001, 0.01, 0.1, 1, 10, 100, 1000]
         for scale in scales:
             scaleStr = str(scale)
             self.scaleDropdown.addItem(scaleStr)
         startIndex = 3
         self.scaleDropdown.setCurrentIndex(startIndex)
         self.scaleDropdown.currentTextChanged.connect(self.on_scale)
         controlLayout_row3.addWidget(self.scaleDropdown)
 
         #
-        vLayout.addLayout(controlLayout_row3)  # add mpl canvas
+        vLayout.addLayout(controlLayout_row3) # add mpl canvas
 
         vSplitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)
         vLayout.addWidget(vSplitter)
 
         # plt.style.use('dark_background')
         if self.darkTheme:
-            plt.style.use("dark_background")
+            plt.style.use('dark_background')
         else:
             plt.rcParams.update(plt.rcParamsDefault)
 
         self.fig = mpl.figure.Figure(constrained_layout=True)
         self.static_canvas = backend_qt5agg.FigureCanvas(self.fig)
-        self.static_canvas.setFocusPolicy(QtCore.Qt.ClickFocus)
+        self.static_canvas.setFocusPolicy( QtCore.Qt.ClickFocus )
         self.static_canvas.setFocus()
 
-        # can do self.mplToolbar.hide()
-        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(
-            self.static_canvas, self.static_canvas
-        )
+        #can do self.mplToolbar.hide()
+        self.mplToolbar = mpl.backends.backend_qt5agg.NavigationToolbar2QT(self.static_canvas, self.static_canvas)
 
         self._updateNumSweeps(self.numSweeps)
-        # self.rawAxes = self.static_canvas.figure.add_subplot(self.numSweeps,1,1)
-        # self.plotLine, = self.rawAxes[0].plot([], [], '-w', linewidth=1)
+        #self.rawAxes = self.static_canvas.figure.add_subplot(self.numSweeps,1,1)
+        #self.plotLine, = self.rawAxes[0].plot([], [], '-w', linewidth=1)
 
-        vSplitter.addWidget(self.static_canvas)  # add mpl canvas
-        vSplitter.addWidget(self.mplToolbar)  # add mpl canvas
+        vSplitter.addWidget(self.static_canvas) # add mpl canvas
+        vSplitter.addWidget(self.mplToolbar) # add mpl canvas
 
         #
         # finalize
-        # self.mainWidget = QtWidgets.QWidget()
+        #self.mainWidget = QtWidgets.QWidget()
         # if qdarkstyle is not None:
         #     self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
         # else:
         #     self.setStyleSheet("")
 
         # set the layout of the main window
         # self.setLayout(vLayout)
@@ -725,43 +706,39 @@
         self.static_canvas.figure.clear()
 
         self.plotLine = [None] * numSweeps
         self.rawAxes = [None] * numSweeps
 
         for i in range(numSweeps):
             if i == 0:
-                self.rawAxes[i] = self.static_canvas.figure.add_subplot(
-                    numSweeps, 1, i + 1
-                )  # +1 because subplot index is 1 based
+                self.rawAxes[i] = self.static_canvas.figure.add_subplot(numSweeps,1, i+1)  # +1 because subplot index is 1 based
             else:
-                self.rawAxes[i] = self.static_canvas.figure.add_subplot(
-                    numSweeps, 1, i + 1, sharex=self.rawAxes[0]
-                )  # +1 because subplot index is 1 based
-            (self.plotLine[i],) = self.rawAxes[i].plot([], [], "-w", linewidth=0.5)
+                self.rawAxes[i] = self.static_canvas.figure.add_subplot(numSweeps,1, i+1, sharex=self.rawAxes[0])  # +1 because subplot index is 1 based
+            self.plotLine[i], = self.rawAxes[i].plot([], [], '-w', linewidth=0.5)
 
-            self.rawAxes[i].spines["right"].set_visible(False)
-            self.rawAxes[i].spines["top"].set_visible(False)
+            self.rawAxes[i].spines['right'].set_visible(False)
+            self.rawAxes[i].spines['top'].set_visible(False)
 
             lastSweep = i == (numSweeps - 1)
             if not lastSweep:
-                self.rawAxes[i].spines["bottom"].set_visible(False)
-                self.rawAxes[i].tick_params(axis="x", labelbottom=False)  # no labels
+                self.rawAxes[i].spines['bottom'].set_visible(False)
+                self.rawAxes[i].tick_params(axis="x", labelbottom=False) # no labels
 
     def replot(self):
-        logger.info(f"t:{len(self._t)}, data:{len(self._data)}")
+        logger.info(f't:{len(self._t)}, data:{len(self._data)}')
 
         yMin = 1e9
         yMax = -1e9
 
         for i in range(self.numSweeps):
             self.plotLine[i].set_xdata(self._t)
             self.plotLine[i].set_ydata(self._data[i])
             #
             self.rawAxes[i].relim()
-            self.rawAxes[i].autoscale_view(True, True, True)
+            self.rawAxes[i].autoscale_view(True,True,True)
 
             thisMin = np.nanmin(self._data[i])
             thisMax = np.nanmax(self._data[i])
             if thisMin < yMin:
                 yMin = thisMin
             if thisMax > yMax:
                 yMax = thisMax
@@ -785,60 +762,55 @@
 
         If use specifies .atf then save as .atf
         If user specifies .csv then save as .csv
         """
         fileName = self.getFileName()
         options = QtWidgets.QFileDialog.Options()
         savePath = os.path.join(self.savePath, fileName)
-        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(
-            self,
-            "Save .atf file",
-            savePath,
-            "Atf Files (*.atf);;CSV Files (*.csv)",
-            options=options,
-        )
+        fileName, _ = QtWidgets.QFileDialog.getSaveFileName(self,"Save .atf file",
+                            savePath,"Atf Files (*.atf);;CSV Files (*.csv)", options=options)
         if not fileName:
             return
 
         self.savePath = os.path.split(fileName)[0]
 
-        if fileName.endswith(".atf"):
+        if fileName.endswith('.atf'):
             numSweeps = self.numSweeps
             out = self.getAtfHeader(numChannels=numSweeps)
             data = self._data  # list of sweeps
             fs = self._fs
 
-            # if numChannels == 2:
+            #if numChannels == 2:
             #    myNoise = np.random.normal(scale=np.sqrt(5), size=data.shape)
 
             # TODO: getAtfHeader needs to append trailing eol
             #         Then here we don't pre-pend with \n but append each line
-            eol = "\n"
+            eol = '\n'
             pntsPerSweep = len(self._data[0])
             for i in range(pntsPerSweep):
                 for sweepNumber in range(self.numSweeps):
-                    # sweepData = self._data[sweepNumber]
+                    #sweepData = self._data[sweepNumber]
                     val = self._data[sweepNumber][i]
                     # TODO: Convert to f'' format
                     if sweepNumber == 0:
                         # time and sweep 0
-                        out += "%.05f\t%.05f" % (i / fs, val)
+                        out += '%.05f\t%.05f'%(i/fs,val)
                     else:
                         # append value for next sweep
-                        out += "\t%.05f" % (val)
+                        out += '\t%.05f'%(val)
                 #
                 out += eol
             #
-            with open(fileName, "w") as f:
+            with open(fileName,'w') as f:
                 f.write(out)
 
-        elif fileName.endswith(".csv"):
-            df = pd.DataFrame(columns=["sec", "pA"])
-            df["sec"] = self._t
-            df["pA"] = self._data
+        elif fileName.endswith('.csv'):
+            df = pd.DataFrame(columns=['sec', 'pA'])
+            df['sec'] = self._t
+            df['pA'] = self._data
             df.to_csv(fileName, index=False)
         #
         logger.info(f'Saved: "{fileName}"')
 
     def getFileName(self):
         stimType = self.stimType
         numSweeps = self.numSweeps
@@ -860,21 +832,21 @@
         filename = f'{stimType}_s{numSweeps}_sd{durSeconds}_a{amplitude}_f{frequency}_g{noiseAmplitude}'
         if numSweeps > 1:
             filename += f'_ns{noiseStep}'
         filename += '.atf'
         return filename
         """
 
-        filename = "sanpy_" + datetime.today().strftime("%Y%m%d")
-        filename += "_"
+        filename = 'sanpy_' + datetime.today().strftime('%Y%m%d')
+        filename += '_'
 
         saveStimIndex = self.saveStimIndex
-        filename += f"{saveStimIndex:04}"
+        filename += f'{saveStimIndex:04}'
 
-        filename += ".atf"
+        filename += '.atf'
 
         # increment for next save
         self.saveStimIndex += 1
 
         # update interface
         self.saveIndexSpinBox.setValue(self.saveStimIndex)
 
@@ -884,51 +856,48 @@
         """
         build from dict constructed from saved abt file using readParams()
 
         TODO: Does not work because we do not update Qt interface with values from dict
         """
         myVars = vars(self)
         print(myVars)
-        for k, v in d.items():
+        for k,v in d.items():
             print(k, v, type(v))
             myVars[k] = v
 
         self.replot()
 
-
 def run():
     app = QtWidgets.QApplication(sys.argv)
 
     sg = stimGen()
     sg.show()
 
     sys.exit(app.exec_())
 
-
 def testDict():
-    folderPath = "/home/cudmore/Sites/SanPy"
+    folderPath = '/home/cudmore/Sites/SanPy'
     df = readFolderParams(folderPath)
 
     sys.exit(1)
 
-    path = "/home/cudmore/Sites/SanPy/sanpy_20211206_0000.atf"
-    path = "/home/cudmore/Sites/SanPy/sanpy_20211206_0001.atf"
+    path = '/home/cudmore/Sites/SanPy/sanpy_20211206_0000.atf'
+    path = '/home/cudmore/Sites/SanPy/sanpy_20211206_0001.atf'
 
     d = readFileParams(path)
-    for k, v in d.items():
-        print(k, v)
+    for k,v in d.items():
+        print(k,v)
 
-    """
+    '''
     app = QtWidgets.QApplication(sys.argv)
     sg = stimGen()
     sg.buildFromDict(d)
 
     sg.show()
 
     sys.exit(app.exec_())
-    """
-
+    '''
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     run()
 
-    # testDict()
+    #testDict()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/preferences.py` & `sanpy-ephys-0.1.6/sanpy/interface/preferences.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,241 +4,233 @@
 from json.decoder import JSONDecodeError
 
 import sanpy
 import sanpy.interface
 import sanpy.interface.sanpy_app as sanpy_app
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
-class preferences:
+class preferences():
     """Class to hold GUI preferences.
-
+    
     Created and used by sanpy app SanPyWindow.
     """
-
-    def __init__(self, sanpyApp: sanpy_app):
+    def __init__(self, sanpyApp : sanpy_app):
         super().__init__()
         self._sanpyApp = sanpyApp
-
+        
         # bump this when we change, sanpy app will rebuild if loaded preerences are out of date
-        # self._version = 1.2  # increment when we change preferences
+        #self._version = 1.2  # increment when we change preferences
         self._version = 1.3  # added set spike
         self._version = 1.4  # converted plugins from list[str] to dict to include externalWindow option
         self._version = 1.5  # adding keys to plugins (l, t, w, h)
-
+        
         self._maxRecent = 7  # a lucky number
         self._configDict = self.load()
 
     def __setitem__(self, key, item):
         self._configDict[key] = item
 
     def __getitem__(self, key):
         return self._configDict[key]
 
     @property
     def configDict(self):
         return self._configDict
-
-    def addFolder(self, path: str):
-        """Add a folder to preferences."""
-        logger.info(f"{path}")
-
+    
+    def addFolder(self, path : str):
+        """Add a folder to preferences.
+        """
+        logger.info(f'{path}')
+        
         # add if not in recentFolders
-        if not path in self.configDict["recentFolders"]:
-            self.configDict["recentFolders"].append(path)
-            # limit list to last _maxNumUndo
-            self.configDict["recentFolders"] = self.configDict["recentFolders"][
-                -self._maxRecent :
-            ]
-
+        if not path in self.configDict['recentFolders']:
+            self.configDict['recentFolders'].append(path)
+            # limit list to last _maxNumUndo 
+            self.configDict['recentFolders'] = self.configDict['recentFolders'][-self._maxRecent:] 
+    
         # always set as the most recent folder
-        self.configDict["mostRecentFolder"] = path
+        self.configDict['mostRecentFolder'] = path
 
-    def addPlugin(self, pluginName: str, externalWindow: bool, ltwhTuple: tuple):
-        """Add plugin to preferences."""
+    def addPlugin(self, pluginName : str, externalWindow : bool,
+                  ltwhTuple : tuple):
+        """Add plugin to preferences.
+        """
         # was this as list
         # if not pluginName in self.configDict['pluginPanels']:
         #     self.configDict['pluginPanels'].append(pluginName)
-        if not pluginName in self.configDict["pluginPanels"].keys():
-            self.configDict["pluginPanels"][pluginName] = {
-                "externalWindow": externalWindow,
-                "l": ltwhTuple[0],
-                "t": ltwhTuple[1],
-                "w": ltwhTuple[2],
-                "h": ltwhTuple[3],
-            }
+        if not pluginName in self.configDict['pluginPanels'].keys():
+            self.configDict['pluginPanels'][pluginName] = {'externalWindow': externalWindow,
+                                                           'l': ltwhTuple[0],
+                                                           't': ltwhTuple[1],
+                                                           'w': ltwhTuple[2],
+                                                           'h': ltwhTuple[3],
+                                                           }
 
-    def removePlugin(self, pluginName: str):
-        """Remove plugin from preferences."""
+    def removePlugin(self, pluginName : str):
+        """Remove plugin from preferences.
+        """
         # was this as list
         # if pluginName in self.configDict['pluginPanels']:
         #     self.configDict['pluginPanels'].remove(pluginName)
-        if pluginName in self.configDict["pluginPanels"].keys():
-            self.configDict["pluginPanels"].pop(pluginName)
+        if pluginName in self.configDict['pluginPanels'].keys():
+            self.configDict['pluginPanels'].pop(pluginName)
 
     def getMostRecentFolder(self):
-        return self.configDict["mostRecentFolder"]
-
+        return self.configDict['mostRecentFolder']
+        
     def getRecentFolder(self):
-        return self.configDict["recentFolders"]
+        return self.configDict['recentFolders']
 
     def preferencesSet(self, key1, key2, val):
         """Set a preference. See `getDefaults()` for key values."""
         try:
             self._configDict[key1][key2] = val
 
             # actually show hide some widgets
-            # if key1=='display' and key2=='showScatter':
+            #if key1=='display' and key2=='showScatter':
             #    if val:
             #        self.myScatterPlotWidget.show()
             #    else:
             #        self.myScatterPlotWidget.hide()
 
-            # if key1=='display' and key2=='showErrors':
+            #if key1=='display' and key2=='showErrors':
             #    if val:
             #        self.myErrorTable.show()
             #    else:
             #        self.myErrorTable.hide()
 
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'Did not set preference with keys "{key1}" and "{key2}"')
 
     def preferencesGet(self, key1, key2):
         """Get a preference. See `getDefaults()` for key values."""
         try:
             return self._configDict[key1][key2]
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'Did not get preference with keys "{key1}" and "{key2}"')
 
     def getPreferencesFile(self):
         userPreferencesFolder = sanpy._util._getUserPreferencesFolder()
-        optionsFile = pathlib.Path(userPreferencesFolder) / "sanpy_preferences.json"
+        optionsFile = pathlib.Path(userPreferencesFolder) / 'sanpy_preferences.json'
         return optionsFile
 
     def load(self):
         """
         Always load preferences from:
             <user>/Documents/SanPy/preferences/sanpy_preferences.json
         """
 
         preferencesFile = self.getPreferencesFile()
 
         useDefault = True
         if os.path.isfile(preferencesFile):
-            logger.info(f"Loading preferences file")
-            logger.info(f"  {preferencesFile}")
+            logger.info(f'Loading preferences file')
+            logger.info(f'  {preferencesFile}')
             try:
                 with open(preferencesFile) as f:
                     loadedJson = json.load(f)
-                    loadedVersion = loadedJson["version"]
-                    logger.info(f"  loaded preferences version {loadedVersion}")
+                    loadedVersion = loadedJson['version']
+                    logger.info(f'  loaded preferences version {loadedVersion}')
                     if loadedVersion < self._version:
                         # use default
-                        logger.warning(
-                            "  older version found, reverting to current defaults"
-                        )
-                        logger.warning(
-                            f"  loadedVersion:{loadedVersion} currentVersion:{self._version}"
-                        )
+                        logger.warning('  older version found, reverting to current defaults')
+                        logger.warning(f'  loadedVersion:{loadedVersion} currentVersion:{self._version}')
                         pass
                     else:
                         return loadedJson
-            except JSONDecodeError as e:
+            except (JSONDecodeError) as e:
                 logger.error(e)
-            except TypeError as e:
+            except (TypeError) as e:
                 logger.error(e)
         if useDefault:
-            logger.info(f"Using default options")
+            logger.info(f'Using default options')
             return self.getDefaults()
 
     def getDefaults(self) -> dict:
         """Get default preferences.
 
         Be sure to increment self._version when making changes.
         """
         configDict = {}  # OrderedDict()
 
-        configDict["version"] = self._version
-        configDict["useDarkStyle"] = True
-        configDict[
-            "autoDetect"
-        ] = True  # FALSE DOES NOT WORK!!!! auto detect on file selection and/or sweep selection
-
-        configDict["recentFolders"] = []
-        configDict["mostRecentFolder"] = ""
-
-        configDict["windowGeometry"] = {}
-        configDict["windowGeometry"]["x"] = 100
-        configDict["windowGeometry"]["y"] = 100
-        configDict["windowGeometry"]["width"] = 1000
-        configDict["windowGeometry"]["height"] = 1000
-
-        configDict["filePanels"] = {}
-        configDict["filePanels"]["File Panel"] = True
+        configDict['version'] = self._version
+        configDict['useDarkStyle'] = True
+        configDict['autoDetect'] = True # FALSE DOES NOT WORK!!!! auto detect on file selection and/or sweep selection
+
+        configDict['recentFolders'] = []
+        configDict['mostRecentFolder'] = ''
+
+        configDict['windowGeometry'] = {}
+        configDict['windowGeometry']['x'] = 100
+        configDict['windowGeometry']['y'] = 100
+        configDict['windowGeometry']['width'] = 1000
+        configDict['windowGeometry']['height'] = 1000
+        
+        configDict['filePanels'] = {}
+        configDict['filePanels']['File Panel'] = True
 
         # panels withing detectionWidget -> myDetectionToolbar
-        configDict["detectionPanels"] = {}
-        configDict["detectionPanels"]["Detection Panel"] = True  # main panel
-        configDict["detectionPanels"]["Detection"] = True
-        configDict["detectionPanels"]["Display"] = True
-        configDict["detectionPanels"]["Plot Options"] = False
-        configDict["detectionPanels"]["Set Spikes"] = False
-
+        configDict['detectionPanels'] = {}
+        configDict['detectionPanels']['Detection Panel'] = True  # main panel
+        configDict['detectionPanels']['Detection'] = True
+        configDict['detectionPanels']['Display'] = True
+        configDict['detectionPanels']['Plot Options'] = False
+        configDict['detectionPanels']['Set Spikes'] = False
+        
         # plugins to show at startup
         # 20230325 convert from List[str] to dict
-        configDict["pluginPanels"] = {}
+        configDict['pluginPanels'] = {}
 
         # values in detectionWidget -> myDetectionToolbar
-        configDict["detect"] = {}
-        configDict["detect"]["detectDvDt"] = 20
-        configDict["detect"]["detectMv"] = -20
+        configDict['detect'] = {}
+        configDict['detect']['detectDvDt'] = 20
+        configDict['detect']['detectMv'] = -20
 
         # display options within detectionWidget -> myDetectionToolbar
-        configDict["rawDataPanels"] = {}
-        configDict["rawDataPanels"]["plotEveryPoint"] = 10  # not used?
-        configDict["rawDataPanels"]["Full Recording"] = True  #
-        configDict["rawDataPanels"]["Derivative"] = False  #
-        configDict["rawDataPanels"]["DAC"] = False  #
+        configDict['rawDataPanels'] = {}
+        configDict['rawDataPanels']['plotEveryPoint'] = 10 # not used?
+        configDict['rawDataPanels']['Full Recording'] = True #
+        configDict['rawDataPanels']['Derivative'] = False #
+        configDict['rawDataPanels']['DAC'] = False #
 
         return configDict
 
     def save(self):
         preferencesFile = self.getPreferencesFile()
-
+        
         logger.info(f'Saving preferences file as: "{preferencesFile}"')
 
         # get the current position and size of the main window
         left, top, width, height = self._sanpyApp.getWindowGeometry()
-
-        self._configDict["windowGeometry"]["x"] = left
-        self._configDict["windowGeometry"]["y"] = top
-        self._configDict["windowGeometry"]["width"] = width
-        self._configDict["windowGeometry"]["height"] = height
+        
+        self._configDict['windowGeometry']['x'] = left
+        self._configDict['windowGeometry']['y'] = top
+        self._configDict['windowGeometry']['width'] = width
+        self._configDict['windowGeometry']['height'] = height
 
         # TODO: extend to a list
-        # self._configDict['lastPath'] = self._sanpyApp.path
+        #self._configDict['lastPath'] = self._sanpyApp.path
 
         # TODO: get window position and size of all open plugins
         # self.configDict['pluginPanels'][pluginName] = {'externalWindow': externalWindow,
         #                                                    'l': ltwhTuple[0],
         #                                                    't': ltwhTuple[1],
         #                                                    'w': ltwhTuple[2],
         #                                                    'h': ltwhTuple[3],
         #                                                    }
         _openSet = self._sanpyApp.myPlugins._openSet
         for _onePlugin in _openSet:
             pluginName = _onePlugin.myHumanName
             ltwhTuple = _onePlugin.getWindowGeometry()
-            self.configDict["pluginPanels"][pluginName]["l"] = ltwhTuple[0]
-            self.configDict["pluginPanels"][pluginName]["t"] = ltwhTuple[1]
-            self.configDict["pluginPanels"][pluginName]["w"] = ltwhTuple[2]
-            self.configDict["pluginPanels"][pluginName]["h"] = ltwhTuple[3]
+            self.configDict['pluginPanels'][pluginName]['l'] = ltwhTuple[0]
+            self.configDict['pluginPanels'][pluginName]['t'] = ltwhTuple[1]
+            self.configDict['pluginPanels'][pluginName]['w'] = ltwhTuple[2]
+            self.configDict['pluginPanels'][pluginName]['h'] = ltwhTuple[3]
 
         #
         # save
-        with open(preferencesFile, "w") as outfile:
+        with open(preferencesFile, 'w') as outfile:
             json.dump(self._configDict, outfile, indent=4, sort_keys=True)
 
-        self._sanpyApp.slot_updateStatus("Saved preferences")
+        self._sanpyApp.slot_updateStatus('Saved preferences')
```

### Comparing `sanpy-ephys-0.1.13/sanpy/interface/sanpy_app.py` & `sanpy-ephys-0.1.6/sanpy/interface/sanpy_app.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,231 +1,218 @@
 # Author: Robert H Cudmore
 # Date: 20190719
 
 from curses.panel import bottom_panel
 import os, sys
-
-# import traceback # to print call stack
+#import traceback # to print call stack
 from functools import partial
 from collections import OrderedDict
 import platform
 import pathlib
 from datetime import datetime
 
 from typing import Union, Dict, List, Tuple
 
 import pandas as pd
 
 import pyqtgraph as pg
 
 # v1
-# import qdarkstyle  # the one we originally used
+#import qdarkstyle  # the one we originally used
 
 # v2
 import qdarktheme
-
 # Enable HiDPI.
 qdarktheme.enable_hi_dpi()
 
 import webbrowser  # to open online help
 
-from qtpy import QtCore, QtWidgets, QtGui
+from PyQt5 import QtCore, QtWidgets, QtGui
 
 import sanpy._util
 import sanpy.interface
 import sanpy.interface.preferences
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 # This causes mkdocs to infinite recurse when running locally as 'mkdocs serve'
-# logger.info('SanPy app.py is starting up')
+#logger.info('SanPy app.py is starting up')
 
 # turn off qdarkstyle logging
 import logging
-
 # logging.getLogger('qdarkstyle').setLevel(logging.WARNING)
 
 # turn off numexpr 'INFO' logging
-logging.getLogger("numexpr").setLevel(logging.WARNING)
-
-# basedir = os.path.dirname(__file__)
-# print('sanpy_app basedir:', basedir)
+logging.getLogger('numexpr').setLevel(logging.WARNING)
 
+#basedir = os.path.dirname(__file__)
+#print('sanpy_app basedir:', basedir)
 
 class SanPyWindow(QtWidgets.QMainWindow):
-    # TODO: define parameter block for all signals.
 
-    signalSetXAxis = QtCore.Signal(object)
+    #TODO: define parameter block for all signals.
+    
+    signalSetXAxis = QtCore.pyqtSignal(object)
     """Emit set axis."""
 
-    signalSwitchFile = QtCore.Signal(object, object)
+    signalSwitchFile = QtCore.pyqtSignal(object, object)
     """Emit on switch file."""
 
-    signalSelectSweep = QtCore.Signal(object, object)  # (ba, sweepNumber)
+    signalSelectSweep = QtCore.pyqtSignal(object, object)  # (ba, sweepNumber)
     """Emit set sweep."""
 
-    signalUpdateAnalysis = QtCore.Signal(object)
+    signalUpdateAnalysis = QtCore.pyqtSignal(object)
     """Emit on detect."""
 
-    signalSelectSpike = QtCore.Signal(object)
+    signalSelectSpike = QtCore.pyqtSignal(object)
     """Emit spike selection."""
 
-    signalSelectSpikeList = QtCore.Signal(object)
+    signalSelectSpikeList = QtCore.pyqtSignal(object)
     """Emit spike list selection."""
 
     def __init__(self, path=None, parent=None):
         """
         Parameters
         ----------
         path : str
             Full path to folder with raw files (abf,csv,tif).
         """
 
         super().__init__(parent)
 
-        logger.info(f"Constructing SanPyWindow")
-        date_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-        logger.info(f'{date_time_str}')
-
-        _version = self._getVersionInfo()
-        for k,v in _version.items():
-            logger.info(f'{k}: {v}')
-
         self.setAcceptDrops(True)
 
         # TODO: if first time run (no <user>/Documents/SanPy) then warn user to quit and restart
 
         # create directories in <user>/Documents and add to python path
         firstTimeRunning = sanpy._util.addUserPath()
         if firstTimeRunning:
-            logger.info("  We created <user>/Documents/Sanpy and need to restart")
+            logger.info('  We created <user>/Documents/Sanpy and need to restart')
 
         self._fileLoaderDict = sanpy.fileloaders.getFileLoaders()
         self._detectionClass = sanpy.bDetection()
 
         # create an empty model for file list
         dfEmpty = pd.DataFrame(columns=sanpy.analysisDir.sanpyColumns.keys())
         self.myModel = sanpy.interface.bFileTable.pandasModel(dfEmpty)
 
         self.fileFromDatabase = True  # if False then from folder
 
         self.startSec = None
         self.stopSec = None
 
-        # TODO: put font size in options file
+        #TODO: put font size in options file
         # removed mar 26 2023
-        """
+        '''
         myFontSize = 10
         myFont = self.font();
         myFont.setPointSize(myFontSize)
         self.setFont(myFont)
-        """
+        '''
 
         if path is not None and os.path.isdir(path):
-            windowTitle = f"SanPy {path}"
+            windowTitle = f'SanPy {path}'
         else:
-            windowTitle = "SanPy"
+            windowTitle = 'SanPy'
         self.setWindowTitle(windowTitle)
 
         self._rowHeight = 11
 
         # path to loaded folder (using bAnalysisDir)
-        self.configDict: sanpy.interface.preferences = sanpy.interface.preferences(self)
+        self.configDict : sanpy.interface.preferences = sanpy.interface.preferences(self)
         self.myAnalysisDir = None
         lastPath = self.configDict.getMostRecentFolder()
         logger.info(f'  preferences lastPath is "{lastPath}"')
         if path is not None:
             self.path = path
         elif lastPath is not None and os.path.isdir(lastPath):
             self.path = lastPath
         else:
             self.path = None
 
-        # TODO: refactor dark to light theme
-        self.useDarkStyle = self.configDict["useDarkStyle"]
-        # self.useDarkStyle = True
+        #TODO: refactor dark to light theme
+        self.useDarkStyle = self.configDict['useDarkStyle']
+        #self.useDarkStyle = True
         self.toggleStyleSheet(self.useDarkStyle, buildingInterface=True)
 
         #
         # set window geometry
         self.setMinimumSize(640, 480)
-        self.left = self.configDict["windowGeometry"]["x"]
-        self.top = self.configDict["windowGeometry"]["y"]
-        self.width = self.configDict["windowGeometry"]["width"]
-        self.height = self.configDict["windowGeometry"]["height"]
+        self.left = self.configDict['windowGeometry']['x']
+        self.top = self.configDict['windowGeometry']['y']
+        self.width = self.configDict['windowGeometry']['width']
+        self.height = self.configDict['windowGeometry']['height']
         self.setGeometry(self.left, self.top, self.width, self.height)
 
         self.myPlugins = sanpy.interface.bPlugins(sanpyApp=self)
 
         # order matter, _buildMenus uses objects created in _buildUI
         self._buildUI()
         self._buildMenus()
 
         # 20210803, loadFolder was above? Still works down here
         # needed to update detection widget after buildUI()
-        if self.path is not None and len(self.path) > 0:
+        if self.path is not None and len(self.path)>0:
             self.slot_loadFolder(self.path)
 
         # self.raise_()  # bring to front, raise is a python keyword
         # self.activateWindow()  # bring to front
 
-        self.slot_updateStatus("Ready")
-        logger.info("SanPy started")
+        self.slot_updateStatus('Ready')
+        logger.info('SanPy started')
 
     def getDetectionClass(self):
         return self._detectionClass
 
     def getFileLoaderDict(self):
         return self._fileLoaderDict
-
+    
     def dragEnterEvent(self, event):
-        logger.info("")
+        logger.info('')
         if event.mimeData().hasUrls():
             event.accept()
         else:
             event.ignore()
 
     def dropEvent(self, event):
-        logger.info("")
+        logger.info('')
         folders = [u.toLocalFile() for u in event.mimeData().urls()]
         if len(folders) > 1:
             return
         oneFolder = folders[0]
         if os.path.isdir(oneFolder):
             self.slot_loadFolder(path=oneFolder)
 
     def _promptIfDirty(self) -> bool:
         """Prompt user if there is unsaved analysis.
-
+        
         If this return False, do not proceed with caller action.
         e.g. on 'load folder'
 
         If this returns True then proceed with caller action
         """
         acceptAndContinue = True
         if self.myAnalysisDir is not None:
             tableIsDirty = self.myAnalysisDir.isDirty
             analysisIsDirty = self.myAnalysisDir.hasDirty()
             if tableIsDirty or analysisIsDirty:
                 userResp = sanpy.interface.bDialog.yesNoCancelDialog(
-                    "There is analysis that is not saved.\nDo you want to save?"
-                )
+                                    'There is analysis that is not saved.\nDo you want to save?')
                 if userResp == QtWidgets.QMessageBox.Yes:
                     self.saveFilesTable()
                     acceptAndContinue = True
                 elif userResp == QtWidgets.QMessageBox.No:
                     acceptAndContinue = True
                 else:  # userResp == QtWidgets.QMessageBox.Cancel:
                     acceptAndContinue = False
         return acceptAndContinue
 
     def closeEvent(self, event):
         """Called when user closes main window or selects quit.
-
+        
         Parameters
         ----------
         event : PyQt5.QtGui.QCloseEvent
         """
 
         logger.info(event)
 
@@ -234,260 +221,245 @@
         alreadyAsked = False
         # self.myAnalysisDir is only defined after we load a folder
         if self.myAnalysisDir is not None:
             tableIsDirty = self.myAnalysisDir.isDirty
             analysisIsDirty = self.myAnalysisDir.hasDirty()
             if tableIsDirty or analysisIsDirty:
                 alreadyAsked = True
-                userResp = sanpy.interface.bDialog.yesNoCancelDialog(
-                    "There is analysis that is not saved.\nDo you want to save?"
-                )
+                userResp = sanpy.interface.bDialog.yesNoCancelDialog('There is analysis that is not saved.\nDo you want to save?')
                 if userResp == QtWidgets.QMessageBox.Yes:
                     self.saveFilesTable()
                     event.accept()
                 elif userResp == QtWidgets.QMessageBox.No:
                     event.accept()
                 else:
                     event.ignore()
                     doQuit = False
         if doQuit:
             if not alreadyAsked:
-                userResp = sanpy.interface.bDialog.okCancelDialog(
-                    "Are you sure you want to quit SanPy?", informativeText=None
-                )
+                userResp = sanpy.interface.bDialog.okCancelDialog('Are you sure you want to quit SanPy?', informativeText=None)
                 if userResp == QtWidgets.QMessageBox.Cancel:
                     event.ignore()
                     doQuit = False
 
             if doQuit:
-                logger.info("SanPy is quiting")
+                logger.info('SanPy is quiting')
                 QtCore.QCoreApplication.quit()
 
     def getOptions(self):
         return self.configDict
 
     def getWindowGeometry(self):
-        """Get the current window position."""
+        """Get the current window position.
+        """
         myRect = self.geometry()
         left = myRect.left()
         top = myRect.top()
         width = myRect.width()
         height = myRect.height()
         return left, top, width, height
 
     def toggleStyleSheet(self, doDark=None, buildingInterface=False):
-        logger.info("")
+        logger.info('')
         if doDark is None:
             doDark = not self.useDarkStyle
         self.useDarkStyle = doDark
         if doDark:
             # v1
-            # self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
+            #self.setStyleSheet(qdarkstyle.load_stylesheet(qt_api='pyqt5'))
             # v2
-            qdarktheme.setup_theme("dark")
+            qdarktheme.setup_theme('dark')
 
-            pg.setConfigOption("background", "k")
-            pg.setConfigOption("foreground", "w")
+            pg.setConfigOption('background', 'k')
+            pg.setConfigOption('foreground', 'w')
         else:
             # v1
             # self.setStyleSheet('')
             # v2
-            qdarktheme.setup_theme("light")
+            qdarktheme.setup_theme('light')
 
-            pg.setConfigOption("background", "w")
-            pg.setConfigOption("foreground", "k")
+            pg.setConfigOption('background', 'w')
+            pg.setConfigOption('foreground', 'k')
 
-        self.configDict["useDarkStyle"] = self.useDarkStyle
+        self.configDict['useDarkStyle'] = self.useDarkStyle
 
         if not buildingInterface:
-            # self.myScatterPlotWidget.defaultPlotLayout()
-            # self.myScatterPlotWidget.buildUI(doRebuild=True)
+            #self.myScatterPlotWidget.defaultPlotLayout()
+            #self.myScatterPlotWidget.buildUI(doRebuild=True)
             self.myDetectionWidget.mySetTheme()
 
         if buildingInterface:
             pass
         else:
             pass
             # msg = QtWidgets.QMessageBox()
             # msg.setIcon(QtWidgets.QMessageBox.Warning)
             # msg.setText("Theme Changed")
             # msg.setInformativeText('Please restart SanPy for changes to take effect.')
             # msg.setWindowTitle("Theme Changed")
             # retval = msg.exec_()
 
-            # self.configDict.save()
+            #self.configDict.save()
 
-    def slot_loadFolder(self, path="", folderDepth=None):
+    def slot_loadFolder(self, path='', folderDepth=None):
         """Load a folder of raw data files.
 
         Parameters
         ----------
         path : str
         folderDepth : int or None
         """
 
         if folderDepth is None:
             # get the depth from file list widget
             folderDepth = self._fileListWidget.getDepth()
 
-        logger.info(f"Loading depth:{folderDepth} path: {path}")
+        logger.info(f'Loading depth:{folderDepth} path: {path}')
 
         # if folder is already loaded, ask to save
         acceptAndContinue = self._promptIfDirty()
         if not acceptAndContinue:
             return
 
         # ask user for folder
-        if path is None or isinstance(path, bool) or len(path) == 0:
-            path = str(
-                QtWidgets.QFileDialog.getExistingDirectory(
-                    self, "Select Directory With Recordings"
-                )
-            )
+        if path is None or isinstance(path,bool) or len(path)==0:
+            path = str(QtWidgets.QFileDialog.getExistingDirectory(self, "Select Directory With Recordings"))
             if len(path) == 0:
                 return
         elif os.path.isdir(path):
             pass
         else:
             logger.warning(f'    Did not load path "{path}"')
             return
 
-        self.path = path  # path to loaded bAnalysisDir folder
+        self.path = path # path to loaded bAnalysisDir folder
 
-        # logger.info(f'Loading path: {path}')
+        #logger.info(f'Loading path: {path}')
 
         # will create/load hd5 file for folder
-        self.myAnalysisDir = sanpy.analysisDir(
-            path, folderDepth=folderDepth, myApp=self
-        )
+        self.myAnalysisDir = sanpy.analysisDir(path, folderDepth=folderDepth, myApp=self)
 
         # set myAnalysisDir to file list model
         self.myModel = sanpy.interface.bFileTable.pandasModel(self.myAnalysisDir)
-        # self.myModel.signalMyDataChanged.connect(self.slot_dataChanged)
-        # self.myModel.signalMyDataChanged.connect(self.myDetectionWidget.slot_dataChanged)
+        #self.myModel.signalMyDataChanged.connect(self.slot_dataChanged)
+        #self.myModel.signalMyDataChanged.connect(self.myDetectionWidget.slot_dataChanged)
 
-        # try:
+        #try:
         if 1:
             self._fileListWidget.mySetModel(self.myModel)
-            self.myModel.signalMyDataChanged.connect(
-                self.myDetectionWidget.slot_dataChanged
-            )
-        """
+            self.myModel.signalMyDataChanged.connect(self.myDetectionWidget.slot_dataChanged)
+        '''
         except (AttributeError) as e:
             # needed when we call loadFolder from __init__
             # logger.warning('OK: no tableView during load folder')
             pass
-        """
+        '''
 
         # set window title
         if self.path is not None and os.path.isdir(self.path):
-            windowTitle = f"SanPy: {self.path}"
+            windowTitle = f'SanPy: {self.path}'
         else:
-            windowTitle = "SanPy"
+            windowTitle = 'SanPy'
         self.setWindowTitle(windowTitle)
 
         # add to preferences recent folders
         self.configDict.addFolder(path)
 
         # save preferences
-        # self.configDict.save()
-
+        #self.configDict.save()
+        
     '''
     def slot_dataChanged(self, columnName, value, rowDict):
         """User has edited main file table.
         Update detection widget for columns (Start(s), Stop(s), dvdtThreshold, mvThreshold)
         """
         logger.info(f'{columnName} {value}')
         print('  ', rowDict)
     '''
-
     def selectSpike(self, spikeNumber, doZoom=False):
         eDict = {
-            "spikeNumber": spikeNumber,
-            "doZoom": doZoom,
-            "ba": self.get_bAnalysis(),
-        }
+                'spikeNumber': spikeNumber,
+                'doZoom': doZoom,
+                'ba': self.get_bAnalysis(),
+                }
         self.signalSelectSpike.emit(eDict)
 
-    def selectSpikeList(self, spikeList: List[int], doZoom: bool = False):
+    def selectSpikeList(self, spikeList : List[int], doZoom : bool = False):
         eDict = {
-            "spikeList": spikeList,
-            "doZoom": doZoom,
-            "ba": self.get_bAnalysis(),
-        }
-        logger.info(f'-->> emit signalSelectSpikeList {eDict}')
+                'spikeList': spikeList,
+                'doZoom': doZoom,
+                'ba': self.get_bAnalysis(),
+                }
         self.signalSelectSpikeList.emit(eDict)
 
     def mySignal(self, this, data=None):
         """Receive signals from children widgets.
 
         Parameters
         ----------
         this : str
             The signal name
         data : type depends on signal (this)
             For example, signal 'set x axis' uses data=[min,max]
         """
-        # print('=== sanpy_app.mySignal() "' + this +'"')
+        #print('=== sanpy_app.mySignal() "' + this +'"')
 
-        if this == "select spike":
+        if this == 'select spike':
             logger.warning('\n\nTODO: GET RID OF "select spike"\n\n')
-            spikeNumber = data["spikeNumber"]
-            doZoom = data["isShift"]
+            spikeNumber = data['spikeNumber']
+            doZoom = data['isShift']
             self.selectSpike(spikeNumber, doZoom=doZoom)
-            # self.signalSelectSpike.emit(data)
+            #self.signalSelectSpike.emit(data)
 
-        elif this == "set x axis":
+        elif this == 'set x axis':
             logger.info(f'"set x axis" {data}')
 
             self.startSec = data[0]
             self.stopSec = data[1]
             # old
-            # self.myScatterPlotWidget.selectXRange(data[0], data[1])
+            #self.myScatterPlotWidget.selectXRange(data[0], data[1])
             # new
-            logger.info(f'"-->> emit signalSetXAxis set full x axis" {data[0]} {data[1]}')
             self.signalSetXAxis.emit([data[0], data[1]])  # emits to scatter plot ONLY
 
-        elif this == "set full x axis":
+        elif this == 'set full x axis':
             self.startSec = 0
             if self.get_bAnalysis() is not None:
                 self.stopSec = self.get_bAnalysis().fileLoader.recordingDur
             else:
                 self.stopSec = None
-            logger.info(f'"-->> emit signalSetXAxis set full x axis" {self.startSec} {self.stopSec}')
-            self.signalSetXAxis.emit(
-                [self.startSec, self.stopSec]
-            )  # emits to scatter plot ONLY
+            logger.info(f'"set full x axis" {self.startSec} {self.stopSec}')
+            self.signalSetXAxis.emit([self.startSec, self.stopSec])  # emits to scatter plot ONLY
+
+        elif this == 'cancel all selections':
 
-        elif this == "cancel all selections":
             self.selectSpike(None)
             self.selectSpikeList([])
 
         else:
             logger.warning(f'Did not understand this: "{this}"')
 
     def old_keyPressEvent(self, event):
         """Respond to key press
-
+        
         TODO: does not seem to work?
         """
         key = event.key()
         text = event.text()
-        logger.info(f"text:{text} key:{key} event:{event}")
+        logger.info(f'text:{text} key:{key} event:{event}')
 
         # handled in bDetectionWidget
         # set full axis
-        # if key in [70, 82]: # 'r' or 'f'
+        #if key in [70, 82]: # 'r' or 'f'
         # if key in [QtCore.Qt.Key.Key_R, QtCore.Qt.Key.Key_F]:
         #     self.myDetectionWidget.setAxisFull()
 
-        """
+        '''
         if key in [QtCore.Qt.Key.Key_P]: # 'r' or 'f'
             self.myDetectionWidget.myPrint()
-        """
+        '''
 
         # handled in bDetectionWidget
         # cancel all selections
         # if key == QtCore.Qt.Key.Key_Escape:
         #     self.mySignal('cancel all selections')
 
         # handled in bDetectionWidget
@@ -513,647 +485,531 @@
 
     def getSelectedFileDict(self):
         """
         Used by detection widget to get info in selected file.
 
         todo: remove, pass this dict in signal emit from file table
         """
-
+        
         fileDict = self._fileListWidget.getTableView().getSelectedRowDict()
         return fileDict
 
         # was this
-        """
+        '''
         selectedRows = self._fileListWidget.selectionModel().selectedRows()
         if len(selectedRows) == 0:
             return None
         else:
             selectedItem = selectedRows[0]
             selectedRow = selectedItem.row()
 
         rowDict = self.myModel.myGetRowDict(selectedRow)
         return rowDict
-        """
+        '''
 
     def slot_fileTableClicked(self, row, rowDict, selectingAgain):
         """Respond to selections in file table."""
 
-        """
+        '''
         row (int):
         rowDict (dict):
         selectingAgain (bool): True if row was already selected
-        """
+        '''
 
         if selectingAgain:
             self.slot_updateStatus(f'Refreshing file "{rowDict["File"]}"')
         else:
             self.slot_updateStatus(f'Loading file "{rowDict["File"]}" ... please wait')
 
         # TODO: try and remove this
-        self.startSec = rowDict["Start(s)"]
-        self.stopSec = rowDict["Stop(s)"]
+        self.startSec = rowDict['Start(s)']
+        self.stopSec = rowDict['Stop(s)']
 
         # This will load if necc, otherwise just fetch a pointer
         if self.myAnalysisDir is not None:
-            ba = self.myAnalysisDir.getAnalysis(row)  # if None then problem loading
+            ba = self.myAnalysisDir.getAnalysis(row) # if None then problem loading
 
             if ba is not None:
                 self.signalSwitchFile.emit(ba, rowDict)
                 if selectingAgain:
                     pass
                 else:
-                    self.slot_updateStatus(
-                        f'Loaded file "{ba.fileLoader.filename}"'
-                    )  # this will load ba if necc
+                    self.slot_updateStatus(f'Loaded file "{ba.fileLoader.filename}"')# this will load ba if necc
 
     def _buildMenus(self):
-        mainMenu = self.menuBar()
 
-        #self.aboutAction = QtWidgets.QAction("&About", self)
+        mainMenu = self.menuBar()
 
         # load
-        loadFolderAction = QtWidgets.QAction("Load Folder ...", self)
-        loadFolderAction.setShortcut("Ctrl+O")
+        loadFolderAction = QtWidgets.QAction('Load Folder ...', self)
+        loadFolderAction.setShortcut('Ctrl+O')
         loadFolderAction.triggered.connect(self.slot_loadFolder)
 
         # open recent (submenu)
-        self.openRecentMenu = QtWidgets.QMenu("Load Recent ...")
+        self.openRecentMenu = QtWidgets.QMenu('Load Recent ...')
         self.openRecentMenu.aboutToShow.connect(self._refreshOpenRecent)
 
-        saveDatabaseAction = QtWidgets.QAction("Save Folder Analysis", self)
-        saveDatabaseAction.setShortcut("Ctrl+S")
+        saveDatabaseAction = QtWidgets.QAction('Save Folder Analysis', self)
+        saveDatabaseAction.setShortcut('Ctrl+S')
         saveDatabaseAction.triggered.connect(self.saveFilesTable)
 
-        # buildDatabaseAction = QtWidgets.QAction('Build Big Database ...', self)
-        # buildDatabaseAction.triggered.connect(self.buildDatabase)
+        #buildDatabaseAction = QtWidgets.QAction('Build Big Database ...', self)
+        #buildDatabaseAction.triggered.connect(self.buildDatabase)
 
-        savePreferencesAction = QtWidgets.QAction("Save Preferences", self)
+        savePreferencesAction = QtWidgets.QAction('Save Preferences', self)
         savePreferencesAction.triggered.connect(self.configDict.save)
 
-        # showLogAction = QtWidgets.QAction("Show Log", self)
-        # showLogAction.triggered.connect(self.openLog)
-
-        fileMenu = mainMenu.addMenu("&File")
+        showLogAction = QtWidgets.QAction('Show Log', self)
+        showLogAction.triggered.connect(self.openLog)
 
+        fileMenu = mainMenu.addMenu('&File')
         fileMenu.addAction(loadFolderAction)
         fileMenu.addMenu(self.openRecentMenu)
-
         fileMenu.addSeparator()
         fileMenu.addAction(saveDatabaseAction)
-
         fileMenu.addSeparator()
-        # fileMenu.addAction(buildDatabaseAction)
-        # fileMenu.addSeparator()
+        #fileMenu.addAction(buildDatabaseAction)
+        #fileMenu.addSeparator()
         fileMenu.addAction(savePreferencesAction)
-
-        # fileMenu.addSeparator()
-        # fileMenu.addAction(showLogAction)
+        fileMenu.addSeparator()
+        fileMenu.addAction(showLogAction)
 
         # view menu to toggle widgets on/off
-        self.viewMenu = mainMenu.addMenu("&View")
+        self.viewMenu = mainMenu.addMenu('&View')
         self.viewMenu.aboutToShow.connect(self._refreshViewMenu)
         self._refreshViewMenu()
-        # self._populateViewMenu()
+        #self._populateViewMenu()
 
-        self.windowsMenu = mainMenu.addMenu('&Window')
-        self.windowsMenu.aboutToShow.connect(self._refreshWindowsMenu)
-        self._refreshWindowsMenu()
+        # self.windowsMenu = mainMenu.addMenu('&Window')
+        # self.windowsMenu.aboutToShow.connect(self._refreshWindowsMenu)
+        # self._refreshWindowsMenu()
 
         #
         # plugins menu
-        pluginsMenu = mainMenu.addMenu("&Plugins")
+        pluginsMenu = mainMenu.addMenu('&Plugins')
         # list of plugin names
         # pluginList = self.myPlugins.pluginList()
         # each key is the name of theplugin
         pluginDict = self.myPlugins.pluginDict
-        # print('pluginDict:', pluginDict)
+        #print('pluginDict:', pluginDict)
         _foundUserPlugin = False
-        for __humanName, v in pluginDict.items():
-            if not v["showInMenu"]:
+        for __humanName,v in pluginDict.items():
+            if not v['showInMenu']:
                 continue
-
-            # logger.info(f'adding plugin: {plugin}')
-
+            
+            #logger.info(f'adding plugin: {plugin}')
+            
             sanpyPluginAction = QtWidgets.QAction(__humanName, self)
 
             # TODO: Add spacer between system and user plugins
-            # fileMenu.addSeparator()
+            #fileMenu.addSeparator()
 
-            """
+            '''
             type = self.myPlugins.getType(plugin)
             if type == 'system':
                 print(plugin, 'system -->> bold')
                 f = sanpyPluginAction.font()
                 f.setBold(True);
                 f.setItalic(True);
                 sanpyPluginAction.setFont(f);
-            """
+            '''
 
-            # print(v['type'])
-            if v["type"] == "user":
+            #print(v['type'])
+            if v['type'] == 'user':
                 if not _foundUserPlugin:
                     pluginsMenu.addSeparator()
                     _foundUserPlugin = True
                 _font = sanpyPluginAction.font()
-                # _font.setBold(True)
-                _font.setItalic(True)
+                #_font.setBold(True)    
+                _font.setItalic(True)    
                 sanpyPluginAction.setFont(_font)
 
-            sanpyPluginAction.triggered.connect(
-                lambda checked, pluginName=__humanName: self.sanpyPlugin_action(
-                    pluginName
-                )
-            )
+            sanpyPluginAction.triggered.connect(lambda checked, pluginName=__humanName: self.sanpyPlugin_action(pluginName))
             pluginsMenu.addAction(sanpyPluginAction)
 
-        """
+        '''
         pluginDir = os.path.join(self._getBundledDir(), 'plugins', '*.txt')
         pluginList = glob.glob(pluginDir)
         logger.info(f'pluginList: {pluginList}')
         pluginsMenu = mainMenu.addMenu('&Plugins')
         oneAction = 'plotRecording'
         sanpyPluginAction = QtWidgets.QAction(oneAction, self)
         #sanpyPluginAction.triggered.connect(self.sanpyPlugin_action)
         sanpyPluginAction.triggered.connect(lambda checked, oneAction=oneAction: self.sanpyPlugin_action(oneAction))
         pluginsMenu.addAction(sanpyPluginAction)
-        """
+        '''
 
         #
         # a dynamic menu to show open plugins
         # self.windowsMenu = mainMenu.addMenu('&Windows')
         # self.windowsMenu.aboutToShow.connect(self._populateOpenPlugins)
 
-        """
+        '''
         # windows menu to toggle scatter plot widget
         windowsMenu = mainMenu.addMenu('&Windows')
         mainWindowAction = QtWidgets.QAction('Main', self)
         #
         openScatterAction = QtWidgets.QAction('Scatter Plot', self)
         openScatterAction.triggered.connect(self.openScatterWindow)
         #mainWindowAction.triggered.connect(self.toggleStyleSheet)
         mainWindowAction.setCheckable(True)
         mainWindowAction.setChecked(True)
         windowsMenu.addAction(mainWindowAction)
         windowsMenu.addAction(openScatterAction)
-        """
+        '''
 
         # help menu
-        helpMenu = mainMenu.addMenu("&Help")
-
-        name = "SanPy Help (Opens In Browser)"
+        helpMenu = mainMenu.addMenu('&Help')
+        name = 'SanPy Help (Opens In Browser)'
         action = QtWidgets.QAction(name, self)
         action.triggered.connect(partial(self._onHelpMenuAction, name))
         helpMenu.addAction(action)
 
-        # this actually does not show up in the help menu!
-        # PyQt reroutes it to the main python/SanPy menu
-        name = "About SanPy"
-        action = QtWidgets.QAction(name, self)
-        action.triggered.connect(self._onAboutMenuAction)
-        helpMenu.addAction(action)
-
-        # like the help menu, this gets rerouted to the main python/sanp menu
-        name = "Preferences ..."
-        action = QtWidgets.QAction(name, self)
-        action.triggered.connect(self._onPreferencesMenuAction)
-        helpMenu.addAction(action)
-
-    def _onHelpMenuAction(self, name: str):
-        if name == "SanPy Help (Opens In Browser)":
-            url = "https://cudmore.github.io/SanPy/desktop-application"
+    def _onHelpMenuAction(self, name : str):
+        if name == 'SanPy Help (Opens In Browser)':
+            url = 'https://cudmore.github.io/SanPy/desktop-application'
             webbrowser.open(url, new=2)
-
-    def _onPreferencesMenuAction(self):
-        logger.info('')
-
-    def _onAboutMenuAction(self):
-        """Show a dialog with help.
-        """
-        print(self._getVersionInfo())
-
-        dlg = QtWidgets.QDialog(self)
-        dlg.setWindowTitle('About SanPy')
-
-        vLayout = QtWidgets.QVBoxLayout()
-
-        _versionInfo = self._getVersionInfo()
-        for k,v in _versionInfo.items():
-            aText = k + ' ' + str(v)
-            aLabel = QtWidgets.QLabel(aText)
-
-            if 'https' in v:
-                aLabel.setText(f'{k} <a href="{v}">{v}</a>')
-                aLabel.setTextFormat(QtCore.Qt.RichText)
-                aLabel.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)
-                aLabel.setOpenExternalLinks(True)
-
-            if k == 'email':
-                # <a href = "mailto: abc@example.com">Send Email</a>
-                aLabel.setText(f'{k} <a href="mailto:{v}">{v}</a>')
-                aLabel.setTextFormat(QtCore.Qt.RichText)
-                aLabel.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)
-                aLabel.setOpenExternalLinks(True)
-            
-            vLayout.addWidget(aLabel)
-
-        dlg.setLayout(vLayout)
-
-        dlg.exec()
-  
-    def _getVersionInfo(self) -> dict:
-        retDict = {}
-
-        from sanpy.version import __version__
-
-        retDict['SanPy version'] = __version__
-        retDict['Python version'] = platform.python_version()
-        retDict['Python platform'] = platform.platform()
-        retDict['PyQt version'] = QtCore.__version__  # when using import qtpy
-        # retDict['Bundle folder'] = sanpy._util.getBundledDir()
-        # retDict['Log file'] = sanpy.sanpyLogger.getLoggerFile()
-        retDict['GitHub'] = 'https://github.com/cudmore/sanpy'
-        retDict['Documentation'] = 'https://cudmore.github.io/SanPy/'
-        retDict['email'] = 'rhcudmore@ucdavis.edu'
-
-        return retDict
-    
+        
     def _refreshOpenRecent(self):
-        """Dynamically generate the open recent file menu."""
+        """Dynamically generate the open recent file menu.
+        """
         self.openRecentMenu.clear()
         for recentFolder in self.configDict.getRecentFolder():
+
             loadFolderAction = QtWidgets.QAction(recentFolder, self)
-            # loadFolderAction.setShortcut('Ctrl+O')
-            loadFolderAction.triggered.connect(
-                partial(self.slot_loadFolder, recentFolder)
-            )
+            #loadFolderAction.setShortcut('Ctrl+O')
+            loadFolderAction.triggered.connect(partial(self.slot_loadFolder, recentFolder))
 
             self.openRecentMenu.addAction(loadFolderAction)
 
     def _refreshWindowsMenu(self):
         self.windowsMenu.clear()
 
-        name = "SanPy Window"
+        name = 'SanPy Window'
         action = QtWidgets.QAction(name, self, checkable=True)
-        action.setChecked(self.isActiveWindow())
-        action.triggered.connect(partial(self._windowsMenuAction, self, name))
+        action.setChecked(self.isVisible())
+        action.triggered.connect(partial(self._windowsMenuAction, 'xxx', name))
         self.windowsMenu.addAction(action)
 
-        for _widget in QtWidgets.QApplication.topLevelWidgets():
-            if 'sanpy.interface.plugins' in str(type(_widget)):
-                myHumanName = _widget.myHumanName
-                print(f'{myHumanName} {_widget}')
-                action = QtWidgets.QAction(myHumanName, self, checkable=True)
-                action.setChecked(_widget.isActiveWindow())
-                action.triggered.connect(partial(self._windowsMenuAction, _widget, myHumanName))
-                self.windowsMenu.addAction(action)
-
     def _refreshViewMenu(self):
-        """Dynamically create the main 'View' menu each time it is selected."""
-
+        """Dynamically create the main 'View' menu each time it is selected.
+        """
+        
         self.viewMenu.clear()
 
         self.viewMenu.addSeparator()
 
-        key1 = "filePanels"
-        name = "File Panel"
-        checkedMainPanel = self.configDict[key1]["File Panel"]
+        key1 = 'filePanels'
+        name = 'File Panel'
+        checkedMainPanel = self.configDict[key1]['File Panel']
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checkedMainPanel)
-        action.setShortcut(QtGui.QKeySequence("F"))
+        action.setShortcut(QtGui.QKeySequence('F'))
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
         self.viewMenu.addSeparator()
 
-        key1 = "detectionPanels"
+        key1 = 'detectionPanels'
 
-        name = "Detection Panel"
-        checkedMainPanel = self.configDict[key1]["Detection Panel"]
+        name = 'Detection Panel'
+        checkedMainPanel = self.configDict[key1]['Detection Panel']
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checkedMainPanel)
-        action.setShortcut(QtGui.QKeySequence("D"))
+        action.setShortcut(QtGui.QKeySequence('D'))
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
         self.viewMenu.addSeparator()
 
-        name = "Detection"
-        checked = self.configDict["detectionPanels"][name]
+        name = 'Detection'
+        checked = self.configDict['detectionPanels'][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         action.setEnabled(checkedMainPanel)
         self.viewMenu.addAction(action)
 
-        name = "Display"
-        checked = self.configDict["detectionPanels"][name]
+        name = 'Display'
+        checked = self.configDict['detectionPanels'][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         action.setEnabled(checkedMainPanel)
         self.viewMenu.addAction(action)
 
-        # mar 11
-        name = "Set Spikes"
-        checked = self.configDict["detectionPanels"][name]
+        name = 'Plot Options'
+        checked = self.configDict['detectionPanels'][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         action.setEnabled(checkedMainPanel)
         self.viewMenu.addAction(action)
 
-        name = "Plot Options"
-        checked = self.configDict["detectionPanels"][name]
+        # mar 11
+        name = 'Set Spikes'
+        checked = self.configDict['detectionPanels'][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         action.setEnabled(checkedMainPanel)
         self.viewMenu.addAction(action)
 
         self.viewMenu.addSeparator()
 
         # traces (globalvm, dvdt, dac)
-        key1 = "rawDataPanels"
+        key1 = 'rawDataPanels'
 
-        name = "Full Recording"
+        name = 'Full Recording'
         checked = self.configDict[key1][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
-        name = "Derivative"
+        name = 'Derivative'
         checked = self.configDict[key1][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
-        name = "DAC"
+        name = 'DAC'
         checked = self.configDict[key1][name]
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
         self.viewMenu.addSeparator()
 
         # show/hide plugin 1/2 dock widgets
-        key1 = "pluginDocks"
-        name = "Plugins 1"
-        # checkedMainPanel = self.configDict[key1]['File Panel']
+        key1 = 'pluginDocks'
+        name = 'Plugins 1'
+        #checkedMainPanel = self.configDict[key1]['File Panel']
         _isVisible = self.pluginDock1.isVisible()  # assuming we _buildUI
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(_isVisible)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
 
-        """
+        '''
         key1 = 'pluginDocks'
         name = 'Plugins 2'
         _isVisible = self.pluginDock2.isVisible()  # assuming we _buildUI
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(_isVisible)
         action.triggered.connect(partial(self._viewMenuAction, key1, name))
         self.viewMenu.addAction(action)
-        """
+        '''
 
         self.viewMenu.addSeparator()
 
-        # TODO: refactor switching themes
-        name = "Dark Theme"
+        #TODO: refactor switching themes
+        name = 'Dark Theme'
         checked = self.useDarkStyle
         action = QtWidgets.QAction(name, self, checkable=True)
         action.setChecked(checked)
-        # action.setEnabled(False)
+        #action.setEnabled(False)
         action.triggered.connect(partial(self._viewMenuAction, "Dark Theme", name))
         self.viewMenu.addAction(action)
 
-    def _windowsMenuAction(self, widget, name, isChecked):
-        """
-        Parameters
-        ----------
-        widget : QtWidgets.QWidget
-            Either self or an open plugin widget
-        name : str
-            Name of the window
-        """
-        
-        # don't toggle visibility
-        # widget.setVisible(not widget.isVisible())
 
-        QtWidgets.QApplication.setActiveWindow(widget)
-        widget.activateWindow()
-        widget.raise_()
 
-    def _viewMenuAction(self, key1, name, isChecked):
-        """Respond to user selection in view menu."""
-        logger.info(f"{key1}, {name}, {isChecked}")
+    def _windowsMenuAction(self, key1, name, isChecked):
+        self.setVisible(not self.isVisible())
 
+    def _viewMenuAction(self, key1, name, isChecked):
+        """Respond to user selection in view menu.
+        """
+        logger.info(f'{key1}, {name}, {isChecked}')
+        
         try:
             self.configDict[key1][name] = isChecked
-        except KeyError as e:
+        except (KeyError) as e:
             pass
 
-        if key1 == "filePanels":
+        if key1 == 'filePanels':
             self.toggleInterface(name, isChecked)
 
-        elif key1 == "pluginDocks":
+        elif key1 == 'pluginDocks':
             self.toggleInterface(name, isChecked)
 
-        elif key1 == "rawDataPanels":
-            # self.toggleInterface(name, isChecked)
+        elif key1 == 'rawDataPanels':
+            #self.toggleInterface(name, isChecked)
             self.myDetectionWidget.toggleInterface(name, isChecked)
 
-        elif key1 == "detectionPanels":
+        elif key1 == 'detectionPanels':
             self.myDetectionWidget.toggleInterface(name, isChecked)
 
-        elif key1 == "Dark Theme":
+        elif key1 == 'Dark Theme':
             # doDark = not self.useDarkStyle
             # self.toggleStyleSheet(doDark=doDark)
             self.toggleStyleSheet()
         else:
             logger.warning(f'  no action for key1: "{key1}"')
 
     def toggleInterface(self, name, on):
         """Toggle named interface widgets show and hide.
-
+        
         Parameters
         ----------
         name : str
             Name of the widget
         on : bool
             If True then show, otherwise hide.
         """
-        if name == "File Panel":
+        if name == 'File Panel':
             self._fileListWidget.setVisible(on)
             # if on:
             #     self.fileDock.show()
             # else:
             #     self.fileDock.hide()
-        elif name == "Plugins 1":
+        elif name == 'Plugins 1':
             if on:
                 self.pluginDock1.show()
             else:
                 self.pluginDock1.hide()
-        elif name == "Plugins 2":
+        elif name == 'Plugins 2':
             if on:
                 self.pluginDock2.show()
             else:
                 self.pluginDock2.hide()
 
     def old_populateOpenPlugins(self):
-        """Depreciated. Was to be a dynamic menu to show open plugins."""
+        """Depreciated. Was to be a dynamic menu to show open plugins.
+        """
         self.windowsMenu.clear()
         actions = []
         for plugin in self.myPlugins._openSet:
             name = plugin.myHumanName
             windowTitle = plugin.windowTitle
             action = QtWidgets.QAction(windowTitle, self)
-            action.triggered.connect(
-                partial(self.old_showOpenPlugin, name, plugin, windowTitle)
-            )
+            action.triggered.connect(partial(self.old_showOpenPlugin, name, plugin, windowTitle))
             actions.append(action)
         self.windowsMenu.addActions(actions)
 
     def old_showOpenPlugin(self, name, plugin, windowTitle, selected):
         logger.info(name)
         logger.info(plugin)
         logger.info(windowTitle)
         logger.info(selected)
         plugin.bringToFront()
 
     def _buildUI(self):
-        """ "
+        """"
         File List : sanpy.interface.fileListWidget
         Detection Widget: sanpy.interface.bDetectionWidget
         """
-        # self.toggleStyleSheet(buildingInterface=True)
+        #self.toggleStyleSheet(buildingInterface=True)
 
         self.statusBar = QtWidgets.QStatusBar()
         self.setStatusBar(self.statusBar)
 
         # typical wrapper for PyQt, we can't use setLayout(), we need to use setCentralWidget()
         _mainWidget = QtWidgets.QWidget()
         _mainVLayout = QtWidgets.QVBoxLayout()
         _mainWidget.setLayout(_mainVLayout)
         self.setCentralWidget(_mainWidget)
 
         #
         # list of files (in a dock)
         self._fileListWidget = sanpy.interface.fileListWidget(self.myModel)
-        # self._fileListWidget.signalUpdateStatus.connect(self.slot_updateStatus)  # never used
+        #self._fileListWidget.signalUpdateStatus.connect(self.slot_updateStatus)  # never used
         self._fileListWidget.signalLoadFolder.connect(self.slot_loadFolder)
-        self._fileListWidget.getTableView().signalSelectRow.connect(
-            self.slot_fileTableClicked
-        )
-        # self._fileListWidget.getTableView().signalSetDefaultDetection.connect(self.slot_setDetectionParams)
+        self._fileListWidget.getTableView().signalSelectRow.connect(self.slot_fileTableClicked)
+        #self._fileListWidget.getTableView().signalSetDefaultDetection.connect(self.slot_setDetectionParams)
 
         # update dvdtThreshold, mvThreshold Start(s), Stop(s)
-        self.signalUpdateAnalysis.connect(
-            self._fileListWidget.getTableView().slot_detect
-        )
-        # self.myDetectionWidget.signalDetect.connect(self._fileListWidget.slot_detect)
+        self.signalUpdateAnalysis.connect(self._fileListWidget.getTableView().slot_detect)
+        #self.myDetectionWidget.signalDetect.connect(self._fileListWidget.slot_detect)
 
         # file list as a widget
-        #_mainVLayout.addWidget(self._fileListWidget)
+        _mainVLayout.addWidget(self._fileListWidget)
 
         # file list as a dock
-        self.fileDock = QtWidgets.QDockWidget('Files',self)
-        self.fileDock.setWidget(self._fileListWidget)
-        self.fileDock.setFeatures(QtWidgets.QDockWidget.NoDockWidgetFeatures | \
-                                  QtWidgets.QDockWidget.DockWidgetVerticalTitleBar)
-        self.fileDock.setFloating(False)
-        self.fileDock.setTitleBarWidget(QtWidgets.QWidget())
-        self.addDockWidget(QtCore.Qt.TopDockWidgetArea, self.fileDock)
+        # self.fileDock = QtWidgets.QDockWidget('Files',self)
+        # self.fileDock.setWidget(self._fileListWidget)
+        # self.fileDock.setFloating(False)
+        # self.fileDock.visibilityChanged.connect(self.on_fileDock_visibilityChanged)
+        # self.fileDock.topLevelChanged.connect(self.slot_topLevelChanged)
+        # self.fileDock.setAllowedAreas(QtCore.Qt.TopDockWidgetArea | QtCore.Qt.BottomDockWidgetArea)
+        # self.fileDock.dockLocationChanged.connect(partial(self.slot_dockLocationChanged, self.fileDock))
+        # self.addDockWidget(QtCore.Qt.TopDockWidgetArea, self.fileDock)
 
         #
         # Detection widget
         baNone = None
-        self.myDetectionWidget = sanpy.interface.bDetectionWidget(
-            ba=baNone, mainWindow=self
-        )
-
+        self.myDetectionWidget = sanpy.interface.bDetectionWidget(ba=baNone, mainWindow=self)
+        
         # show/hide
-        on = self.configDict["detectionPanels"]["Detection Panel"]
-        self.myDetectionWidget.toggleInterface("Detection Panel", on)
+        on = self.configDict['detectionPanels']['Detection Panel']
+        self.myDetectionWidget.toggleInterface('Detection Panel', on)
 
-        # (1) detection widget in main v layout
         _mainVLayout.addWidget(self.myDetectionWidget)
 
         # myDetectionWidget listens to self
         self.signalSwitchFile.connect(self.myDetectionWidget.slot_switchFile)
         self.signalSelectSpike.connect(self.myDetectionWidget.slot_selectSpike)
         self.signalSelectSpikeList.connect(self.myDetectionWidget.slot_selectSpikeList)
         self.signalUpdateAnalysis.connect(self.myDetectionWidget.slot_updateAnalysis)
 
         # self listens to myDetectionWidget
         self.myDetectionWidget.signalSelectSpike.connect(self.slot_selectSpike)
         self.myDetectionWidget.signalSelectSpikeList.connect(self.slot_selectSpikeList)
         self.myDetectionWidget.signalSelectSweep.connect(self.slot_selectSweep)
         self.myDetectionWidget.signalDetect.connect(self.slot_detect)
 
-        # (2) detection widget as a dock
+        # detection widget is persistent
+        # removed mar 26 2023
+        # self.setCentralWidget(self.myDetectionWidget)
+        
+        # TODO: detection widget as a dock
         #  detection widget has left panel of controls and right panel of plots
         #  just make left controls a dock widget
         # self.detectionDock = QtWidgets.QDockWidget('Detection',self)
         # self.detectionDock.setWidget(self.myDetectionWidget)
-        # self.detectionDock.setFeatures(QtWidgets.QDockWidget.NoDockWidgetFeatures | \
-        #                           QtWidgets.QDockWidget.DockWidgetVerticalTitleBar)
         # self.detectionDock.setFloating(False)
-        # self.detectionDock.setTitleBarWidget(QtWidgets.QWidget())
         # self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.detectionDock)
 
-        # self.setLayout(_mainVLayout)
+        #self.setLayout(_mainVLayout)
 
         #
         # 2x docks for plugins
         self.myPluginTab1 = QtWidgets.QTabWidget()
         self.myPluginTab1.setMovable(True)
         self.myPluginTab1.setTabsClosable(True)
-        self.myPluginTab1.tabCloseRequested.connect(
-            partial(self.slot_closeTab, sender=self.myPluginTab1)
-        )
-        self.myPluginTab1.currentChanged.connect(
-            partial(self.slot_changeTab, sender=self.myPluginTab1)
-        )
+        self.myPluginTab1.tabCloseRequested.connect(partial(self.slot_closeTab, sender=self.myPluginTab1))
+        self.myPluginTab1.currentChanged.connect(partial(self.slot_changeTab, sender=self.myPluginTab1))
         # re-wire right-click
-        self.myPluginTab1.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
-        self.myPluginTab1.customContextMenuRequested.connect(
-            partial(self.on_plugin_contextMenu, sender=self.myPluginTab1)
-        )
+        self.myPluginTab1.setContextMenuPolicy(QtCore.Qt.CustomContextMenu);
+        self.myPluginTab1.customContextMenuRequested.connect(partial(self.on_plugin_contextMenu, sender=self.myPluginTab1))
 
-        _openPlugins = self.configDict["pluginPanels"]  # dict of
+        _openPlugins = self.configDict['pluginPanels'] # dict of
         for _openPlugin, _externalWindow in _openPlugins.items():
-            _externalWindow = _externalWindow["externalWindow"]
-            logger.info(
-                f"  _openPlugin:{_openPlugin} _externalWindow:{_externalWindow}"
-            )
-            _oneOpenPlugin = self.myPlugins.runPlugin(_openPlugin, ba=None, show=True)
+            _externalWindow = _externalWindow['externalWindow']
+            logger.info(f'  _openPlugin:{_openPlugin} _externalWindow:{_externalWindow}')
+            _oneOpenPlugin = self.myPlugins.runPlugin(_openPlugin, ba=None, show=False)
             if _oneOpenPlugin is not None:
                 if _externalWindow:
-                    # april 30, 2023. Removed! We were opening plugins twice
-                    # self.sanpyPlugin_action(_openPlugin)
-                    pass
+                    self.sanpyPlugin_action(_openPlugin)
                 else:
                     # on add tab, the QTabWIdget makes a copy !!!
                     self.myPluginTab1.addTab(_oneOpenPlugin, _oneOpenPlugin.myHumanName)
 
-        self.pluginDock1 = QtWidgets.QDockWidget("Plugins", self)
+        self.pluginDock1 = QtWidgets.QDockWidget('Plugins 1',self)
         self.pluginDock1.setWidget(self.myPluginTab1)
-        self.pluginDock1.setVisible(self.myPluginTab1.count() > 0)
+        self.pluginDock1.setVisible(self.myPluginTab1.count()>0)
         self.pluginDock1.setFloating(False)
-        self.pluginDock1.dockLocationChanged.connect(
-            partial(self.slot_dockLocationChanged, self.pluginDock1)
-        )
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.pluginDock1)
+        self.pluginDock1.dockLocationChanged.connect(partial(self.slot_dockLocationChanged, self.pluginDock1))
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea,self.pluginDock1)
 
         #
         # tabs
-        """
+        '''
         self.myPluginTab2 = QtWidgets.QTabWidget()
         self.myPluginTab2.setMovable(True)
         self.myPluginTab2.setTabsClosable(True)
         self.myPluginTab2.tabCloseRequested.connect(partial(self.slot_closeTab, sender=self.myPluginTab2))
         self.myPluginTab2.currentChanged.connect(partial(self.slot_changeTab, sender=self.myPluginTab2))
         # re-wire right-click
         self.myPluginTab2.setContextMenuPolicy(QtCore.Qt.CustomContextMenu);
@@ -1161,129 +1017,101 @@
 
         self.pluginDock2 = QtWidgets.QDockWidget('Plugins 2',self)
         self.pluginDock2.setWidget(self.myPluginTab2)
         self.pluginDock2.setFloating(False)
         self.pluginDock2.hide() # initially hide 'Plugins 2'
         self.pluginDock2.dockLocationChanged.connect(partial(self.slot_dockLocationChanged, self.pluginDock2))
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.pluginDock2)
-        """
+        '''
 
     def sanpyPlugin_action(self, pluginName):
         """Responds to main menu 'Plugins'.
-
+        
         Run a plugin using curent ba.
-
+        
         Notes:
             See also on_plugin_contextMenu for running a plugin in a tab
         """
         logger.info(f'opening pluginName: "{pluginName}"')
         ba = self.get_bAnalysis()
-
+        
         # run the plugin
         _runningPlugin = self.myPlugins.runPlugin(pluginName, ba)
 
         ltwhTuple = _runningPlugin.getWindowGeometry()
 
         # add plugin to preferences so it opens next time we run the app
         if _runningPlugin is not None:
-            self.configDict.addPlugin(
-                _runningPlugin.getHumanName(), externalWindow=True, ltwhTuple=ltwhTuple
-            )
-
-    def slot_updateAnalysis(self, sDict : dict):
-        """Respond to both detect and user setting columns in ba.
-        
-        sDict : dict
-            setSpikeStatEvent = {}
-            setSpikeStatEvent['ba'] = self.ba
-            setSpikeStatEvent["spikeList"] = self.getSelectedSpikes()
-            setSpikeStatEvent["colStr"] = colStr
-            setSpikeStatEvent["value"] = value
-        """
-        
-        logger.info('')
-        
-        # do the actual update
-        ba = sDict['ba']
-        spikeList = sDict['spikeList']
-        colStr = sDict['colStr']
-        value = sDict['value']
-        if spikeList is not None and colStr is not None and value is not None:
-            logger.info(f'setting backend: {spikeList} colStr: {colStr} to value:{value}')
-            ba.setSpikeStat(spikeList, colStr, value)
-
-        self.signalUpdateAnalysis.emit(sDict)
+            self.configDict.addPlugin(_runningPlugin.getHumanName(),
+                                      externalWindow=True,
+                                      ltwhTuple = ltwhTuple)
 
     def slot_selectSpike(self, sDict):
-        spikeNumber = sDict["spikeNumber"]
-        doZoom = sDict["doZoom"]
+        spikeNumber = sDict['spikeNumber']
+        doZoom = sDict['doZoom']
         self.selectSpike(spikeNumber, doZoom)
 
     def slot_selectSpikeList(self, sDict):
-        spikeList = sDict["spikeList"]
-        doZoom = sDict["doZoom"]
+        spikeList = sDict['spikeList']
+        doZoom = sDict['doZoom']
         self.selectSpikeList(spikeList, doZoom)
 
     def slot_selectSweep(self, ba, sweepNumber):
         """Set view to new sweep.
-
+        
         Parameters
         ----------
         ba : sanpy.bAnalysis
         sweepNumber : int
         """
         self.signalSelectSweep.emit(ba, sweepNumber)
 
     def saveFilesTable(self):
-        """Save the folder hdf5 file."""
-        # logger.info('')
+        """Save the folder hdf5 file.
+        """
+        #logger.info('')
         self.myAnalysisDir.saveHdf()
-        self.slot_updateStatus(f"Save analysis for folder: {self.myAnalysisDir.path}")
+        self.slot_updateStatus(f'Save analysis for folder: {self.myAnalysisDir.path}')
 
-    def slot_updateStatus(self, text: str):
-        """Update the bottom status bar with new str"""
+    def slot_updateStatus(self, text : str):
+        """Update the bottom status bar with new str
+        """
         logger.info(text)
-
+        
         # having trouble with an immediate update?
         self.statusBar.showMessage(text)
         self.statusBar.repaint()
-        # self.statusBar.update()
+        #self.statusBar.update()
         self.repaint()
-        # self.update()
+        #self.update()
         QtWidgets.qApp.processEvents()
 
     def _old_slot_setDetectionParams(self, row, cellType):
         """Set detection parameters to presets.
 
         Parameters
         ----------
         row : int
             Selected row in file table
         cellType : str
             One of ('SA Node Params', 'Ventricular Params', 'Neuron Params')
         """
-        logger.info(f"row:{row} cellType:{cellType}")
+        logger.info(f'row:{row} cellType:{cellType}')
         self.myModel.mySetDetectionParams(row, cellType)
 
     def slot_detect(self, ba):
         """Respond to spike detection.
-
+        
         Usually comes from the sanpy.interface.bDetectionWidget
         """
 
-        setSpikeStatEvent = {}
-        setSpikeStatEvent['ba'] = ba
-        setSpikeStatEvent["spikeList"] = None  # self.getSelectedSpikes()
-        setSpikeStatEvent["colStr"] = None  # colStr
-        setSpikeStatEvent["value"] = None  # value
-
         # sweep number does not change
-        self.signalUpdateAnalysis.emit(setSpikeStatEvent)
+        self.signalUpdateAnalysis.emit(ba)
 
-        self.slot_updateStatus(f"Detected {ba.numSpikes} spikes")
+        self.slot_updateStatus(f'Detected {ba.numSpikes} spikes')
 
     def on_plugin_contextMenu(self, point, sender):
         """On right-click in dock, build a menu of plugins.
 
         On user selection, run the plugin in a tab.
 
         Notes:
@@ -1291,15 +1119,15 @@
 
         Parameters
         ----------
         point :QtCore.QPoint)
             Not used
         sender : QTabWidget
         """
-        # logger.info(f'point:{point}, sender:{sender}')
+        #logger.info(f'point:{point}, sender:{sender}')
 
         # list of available plugins
         pluginList = self.myPlugins.pluginList()
 
         contextMenu = QtWidgets.QMenu(self)
 
         for plugin in pluginList:
@@ -1319,87 +1147,86 @@
         newPlugin = self.myPlugins.runPlugin(pluginName, ba, show=False)
 
         # only add if plugin wants to be shown
         if not newPlugin.getInitError() and newPlugin.getShowSelf():
             # add tab
 
             # 1) either this
-            # newPlugin.insertIntoScrollArea()
-            """
+            #newPlugin.insertIntoScrollArea()
+            '''
             scrollArea = newPlugin.insertIntoScrollArea()
             if scrollArea is not None:
                 newTabIndex = sender.addTab(scrollArea, pluginName)
             else:
                 newTabIndex = sender.addTab(newPlugin, pluginName)
-            """
+            '''
             # 2) or this
-            # newTabIndex = sender.addTab(newPlugin, pluginName)  # addTab takes ownership
-            newTabIndex = sender.addTab(
-                newPlugin.getWidget(), pluginName
-            )  # addTab takes ownership
+            #newTabIndex = sender.addTab(newPlugin, pluginName)  # addTab takes ownership
+            newTabIndex = sender.addTab(newPlugin.getWidget(), pluginName)  # addTab takes ownership
 
-            # widgetPointer = sender.widget(newTabIndex)
-            # widgetPointer.insertIntoScrollArea()
+            #widgetPointer = sender.widget(newTabIndex)
+            #widgetPointer.insertIntoScrollArea()
 
             # bring tab to front
             sender.setCurrentIndex(newTabIndex)
 
             ltwhTuple = newPlugin.getWindowGeometry()
 
             if newPlugin is not None:
-                self.configDict.addPlugin(
-                    newPlugin.getHumanName(), externalWindow=False, ltwhTuple=ltwhTuple
-                )
-
+                self.configDict.addPlugin(newPlugin.getHumanName(),
+                                        externalWindow=False,
+                                        ltwhTuple=ltwhTuple)
+                
     def slot_dockLocationChanged(self, dock, area):
         """Top level dock changed
-
+        
         Parameters
         ----------
         dock : xxx
         area : enum QtCore.Qt.DockWidgetArea
             Basically left/top/right/bottom.
 
         Not triggered when user 'floats' a dock (See self.slot_topLevelChanged())
         """
         logger.info(f'not implemented, dock:"{dock.windowTitle()}" area enum: {area}')
         return
 
-    def on_fileDock_visibilityChanged(self, visible: bool):
-        """The file dock visibility was changed."""
-        self._viewMenuAction("filePanels", "File Panel", visible)
+    def on_fileDock_visibilityChanged(self, visible : bool):
+        """The file dock visibility was changed.
+        """
+        self._viewMenuAction('filePanels', 'File Panel', visible)
 
     def slot_topLevelChanged(self, topLevel):
         """
         topLevel (bool): True if the dock widget is now floating; otherwise False.
 
         This is triggered twice, once while dragging and once when finished
         """
         sender = self.sender()  # PyQt5.QtWidgets.QDockWidget
-        logger.info(f"topLevel:{topLevel} sender:{sender}")
+        logger.info(f'topLevel:{topLevel} sender:{sender}')
         return
 
     def slot_closeTab(self, index, sender):
         """Close an open plugin tab.
 
         Parameters
         ----------
         index : int
             The index into sender that gives us the tab, sender.widget(index)
         sender : PyQt5.QtWidgets.QTabWidget
             The tab group where a single tab was was closed
         """
 
-        logger.info(f"index:{index} sender:{type(sender)}")
+        logger.info(f'index:{index} sender:{type(sender)}')
 
         # remove plugin from self.xxx
         # pluginInstancePointer is full class to actual plugin, like
         # sanpy.interface.plugins.detectionParams.detectionParams
         pluginInstancePointer = sender.widget(index)
-        logger.info(f"  closing pluginInstancePointer:{type(pluginInstancePointer)}")
+        logger.info(f'  closing pluginInstancePointer:{type(pluginInstancePointer)}')
 
         # remove from preferences
         # if pluginInstancePointer is not None:
         #     self.configDict.removePlugin(pluginInstancePointer.getHumanName())
 
         self.myPlugins.slot_closeWindow(pluginInstancePointer)
 
@@ -1407,150 +1234,103 @@
         sender.removeTab(index)
 
     def slot_changeTab(self, index, sender):
         """User brought a different tab to the front
 
         Make sure only front tab (plugins) receive signals
         """
-        logger.info(f"not implemented, index:{index} sender:{sender}")
+        logger.info(f'not implemented, index:{index} sender:{sender}')
         pass
 
-    def _old_openLog(self):
-        """Open sanpy.log"""
+    def openLog(self):
+        """Open sanpy.log
+        """
         logFilePath = sanpy.sanpyLogger.getLoggerFile()
-        logFilePath = "file://" + logFilePath
+        logFilePath = 'file://' + logFilePath
         url = QtCore.QUrl(logFilePath)
         QtGui.QDesktopServices.openUrl(url)
 
-
 def runFft(sanpyWindow):
-    logger.info("")
+    logger.info('')
     sanpyWindow._fileListWidget._onLeftClick(0)
-    sanpyWindow.myDetectionWidget.setAxis(2.1, 156.8)
+    sanpyWindow.myDetectionWidget.setAxis(2.1,156.8)
 
     ba = sanpyWindow.get_bAnalysis()
-    pluginName = "FFT"
+    pluginName = 'FFT'
     fftPlugin = sanpyWindow.myPlugins.runPlugin(pluginName, ba)
     resultsStr = fftPlugin.getResultStr()
 
-    print("BINGO")
+    print('BINGO')
     print(resultsStr)
 
     sanpyWindow._fileListWidget._onLeftClick(1)
     sanpyWindow.myDetectionWidget.setAxis(0, 103.7)
     resultsStr = fftPlugin.getResultStr()
 
     sanpyWindow._fileListWidget._onLeftClick(2)
     sanpyWindow.myDetectionWidget.setAxis(16.4, 28.7)
     resultsStr = fftPlugin.getResultStr()
 
-    print("BINGO")
+    print('BINGO')
     print(resultsStr)
 
-
 def testFFT(sanpyWindow):
     sanpyWindow._fileListWidget._onLeftClick(1)
-    # sanpyWindow.myDetectionWidget.setAxis(2.1,156.8)
+    #sanpyWindow.myDetectionWidget.setAxis(2.1,156.8)
 
     ba = sanpyWindow.get_bAnalysis()
-    pluginName = "FFT"
+    pluginName = 'FFT'
     fftPlugin = sanpyWindow.myPlugins.runPlugin(pluginName, ba)
 
-def _old__getVersionInfo() -> dict:
-    retDict = {}
-
-    from sanpy.version import __version__
-
-    retDict['SanPy version'] = __version__
-    retDict['Python version'] = platform.python_version()
-    retDict['Python platform'] = platform.platform()
-    retDict['PyQt version'] = QtCore.__version__  # when using import qtpy
-    retDict['Bundle folder'] = sanpy._util.getBundledDir()
-    retDict['Log file'] = sanpy.sanpyLogger.getLoggerFile()
-    return retDict
-
-    logger.info(f'    Python version is {platform.python_version()}')
-    logger.info(f'    Python platform is {platform.platform()}')
-
-    # when using import PyQt5
-    #logger.info(f"    PyQt version is {QtCore.QT_VERSION_STR}")
-    # when using import qtpy
-    logger.info(f"    PyQt version is {QtCore.__version__}")
-
-    bundle_dir = sanpy._util.getBundledDir()
-    logger.info(f'    bundle_dir is "{bundle_dir}"')
-
-    _logFilePath = sanpy.sanpyLogger.getLoggerFile()
-    logger.info(f"    logging to file {_logFilePath}")
-
-def getAppIconPath():
-    bundle_dir = sanpy._util.getBundledDir()
-    if getattr(sys, "frozen", False):
-        appIconPath = (
-            pathlib.Path(bundle_dir) / "sanpy_transparent.png"
-        )
-    else:
-        appIconPath = (
-            pathlib.Path(bundle_dir) / "interface" / "icons" / "sanpy_transparent.png"
-        )
-    return str(appIconPath)
-
 def main():
     """Main entry point for the SanPy desktop app.
-
+    
     Configured in setup.py
     """
-    logger.info(f"Starting sanpy_app.py in main()")
-    # date_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-    # logger.info(f'    {date_time_str}')
-
-    # _version = _getVersionInfo()
-    # for k,v in _version.items():
-    #     logger.info(f'{k} {v}')
+    logger.info(f'Starting sanpy_app.py in __main__()')
 
-    '''
-    logger.info(f'    Python version is {platform.python_version()}')
-    logger.info(f'    Python platform is {platform.platform()}')
+    date_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
+    logger.info(f'    {date_time_str}')
 
-    # when using import PyQt5
-    #logger.info(f"    PyQt version is {QtCore.QT_VERSION_STR}")
-    # when using import qtpy
-    logger.info(f"    PyQt version is {QtCore.__version__}")
+    logger.info(f'    Python version is {platform.python_version()}')
+    logger.info(f'    PyQt version is {QtCore.QT_VERSION_STR}')
 
     bundle_dir = sanpy._util.getBundledDir()
     logger.info(f'    bundle_dir is "{bundle_dir}"')
 
     _logFilePath = sanpy.sanpyLogger.getLoggerFile()
-    logger.info(f"    logging to file {_logFilePath}")
-    '''
+    logger.info(f'    logging to file {_logFilePath}')
 
     # for qdarkstyle
-    # os.environ['PYQTGRAPH_QT_LIB'] = 'PyQt5'
+    #os.environ['PYQTGRAPH_QT_LIB'] = 'PyQt5'
 
     app = QtWidgets.QApplication(sys.argv)
 
     app.setQuitOnLastWindowClosed(True)
 
     # for manuscript we need to allow user to set light/dark theme
     # was this
     # v1
-    # app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api=os.environ['PYQTGRAPH_QT_LIB']))
+    #app.setStyleSheet(qdarkstyle.load_stylesheet(qt_api=os.environ['PYQTGRAPH_QT_LIB']))
     # v2
     qdarktheme.setup_theme()
 
-    appIconPath = getAppIconPath()    
-    if os.path.isfile(appIconPath):
-        logger.info(f'  app.setWindowIcon with: "{appIconPath}"')
-        app.setWindowIcon(QtGui.QIcon(appIconPath))
+    #appIconPath = os.path.join(bundle_dir, 'interface/icons/sanpy_transparent.png')
+    appIconPath = pathlib.Path(bundle_dir) / 'interface' / 'icons' / 'sanpy_transparent.png'
+    appIconPathStr = str(appIconPath)
+    #logger.info(f'appIconPath is "{appIconPath}"')
+    if os.path.isfile(appIconPathStr):
+        logger.info(f'    setting app window icon with: "{appIconPath}"')
+        app.setWindowIcon(QtGui.QIcon(appIconPathStr))
     else:
-        logger.warning(f"    Did not find appIconPath: {appIconPath}")
+        logger.warning(f'    Did not find appIconPath: {appIconPathStr}')
 
     w = SanPyWindow()
-
     w.show()
+
     w.raise_()  # bring to front, raise is a python keyword
     w.activateWindow()  # bring to front
 
     sys.exit(app.exec_())
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     main()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/kymAnalysis.py` & `sanpy-ephys-0.1.6/sanpy/kymAnalysis.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,168 +6,163 @@
     - Detect peaks in diameter
 
 This will replace code on bAnalysis (abfText)
 """
 
 import os
 from pprint import pprint
-
-# from re import T
+#from re import T
 import time
 import numpy as np
 import pandas as pd
 from skimage.measure import profile
 import scipy
 import tifffile
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
 from sanpy._util import _loadLineScanHeader
 
-
 class kymRect:
-    """Class to represent a rectangle as [l, t, r, b]"""
-
+    """Class to represent a rectangle as [l, t, r, b]
+    """
     def __init__(self, l, t, r, b):
         self._l = l
         self._t = t
         self._r = r
         self._b = b
-
-    def setTop(self, t):
+    
+    def setTop(self,t):
         self._t = t
 
     def setBottom(self, b):
         self._b = b
 
     def getWidth(self):
         return self._r - self._l
-
+    
     def getHeight(self):
         return self._t - self._b
 
     def getLeft(self):
         return self._l
-
+        
     def getTop(self):
         return self._t
-
+        
     def getRight(self):
         return self._r
-
+        
     def getBottom(self):
         return self._b
-
+        
     def getMatPlotLibExtent(self):
-        """Get matplotlib extend for imshow in (l,r,b,t)"""
+        """Get matplotlib extend for imshow in (l,r,b,t)
+        """
         return (self._l, self._r, self._b, self._t)
 
     def __str__(self):
-        return f"l:{self._l} t:{self._t} r:{self._r} b:{self._b}"
+        return f'l:{self._l} t:{self._t} r:{self._r} b:{self._b}'
 
-
-class kymAnalysis:
-    def __init__(self, path: str, autoLoad: bool = True):
+class kymAnalysis():
+    def __init__(self, path : str, autoLoad : bool =True):
         """
-
+        
         Args:
             path: full path to .tif file
             autoLoad: auto load analysis
         """
-        self._version = "0.0.2"
+        self._version = '0.0.2'
 
         self._path = path
         # path to tif file
 
         # (line scan, pixels)
-        self._kymImage: np.ndarray = tifffile.imread(path)
+        self._kymImage : np.ndarray = tifffile.imread(path)
 
         self._kymImageFiltered = None
         # create this as needed, see self._kymImageFilterKernel
 
         _size = len(self._kymImage.shape)
-        if _size < 2 or _size > 3:
+        if  _size < 2 or _size > 3:
             # TODO: raise custom exception
-            logger.error(f"image must be 2d but is {self._kymImage.shape}")
+            logger.error(f'image must be 2d but is {self._kymImage.shape}')
 
         # image must be shape[0] is time/big, shape[1] is space/small
         if self._kymImage.shape[0] < self._kymImage.shape[1]:
-            logger.info(f"rotating image with shape: {self._kymImage.shape}")
-            self._kymImage = np.rot90(
-                self._kymImage, 3
-            )  # ROSIE, so lines are not backward
+            logger.info(f'rotating image with shape: {self._kymImage.shape}')
+            self._kymImage = np.rot90(self._kymImage, 3)  # ROSIE, so lines are not backward
 
         # this is what we extract line profiles from
         # we create filtered version at start of detect()
-        self._filteredImage: np.ndarray = self._kymImage
-
-        logger.info(f"final image shape is: {self._kymImage.shape}")
+        self._filteredImage : np.ndarray = self._kymImage
+        
+        logger.info(f'final image shape is: {self._kymImage.shape}')
 
         # load the header from Olympus exported .txt file
-
+        
         self._umPerPixel = 1
         # default for pixels is unity of 1 pixel
 
-        self._secondsPerLine = 0.001  # 0.001  #0.001  # make ms per bin = 1
+        self._secondsPerLine = 0.001 #0.001  #0.001  # make ms per bin = 1
         # default for time (lines) is 1 ms = 0.001 s
 
         _olympusHeader = _loadLineScanHeader(path)
         if _olympusHeader is not None:
-            self._umPerPixel = _olympusHeader["umPerPixel"]
-            self._secondsPerLine = _olympusHeader["secondsPerLine"]
-
+            self._umPerPixel = _olympusHeader['umPerPixel']
+            self._secondsPerLine = _olympusHeader['secondsPerLine']
+        
         self._reduceFraction = 0.15
         # percentage to reduce t/b of full rect roi to make best guess
 
-        self._roiRect: kymRect = self.getBestGuessRectRoi()
+        self._roiRect : kymRect = self.getBestGuessRectRoi()
         # rectangular roi [l, t, r, b']
 
         # analysis parameters
         self._lineWidth = 1
         # Actual line width to extract a line profile.
         # If >1 will get 10x-100x slower
         # TODO: write multiprocessing code
 
         self._percentOfMax = 0.2
         # to find start/stop of diameter fit along one line profile
 
         self._kymImageFilterKernel = 0
         # on analysis, pre-filter image with median kernel
-
+        
         self._lineFilterKernel = 0
         # on analysis, pre-filter each line with median kernel
 
         # analysis results
         _numLineScans = self.numLineScans()
         self._results = self.getDefaultResultsDict()
 
         # load saved analysis if it exists
         if autoLoad:
             self.loadAnalysis()
 
     def getDefaultResultsDict(self):
         _numLineScans = self.numLineScans()
         theDict = {
-            "time_bin": [np.nan] * _numLineScans,
-            "time_sec": [np.nan] * _numLineScans,
-            "sumintensity": [np.nan] * _numLineScans,
-            "diameter_pnts": [np.nan] * _numLineScans,
-            "diameter_um": [np.nan] * _numLineScans,
-            "left_pnt": [np.nan] * _numLineScans,
-            "right_pnt": [np.nan] * _numLineScans,
+            'time_bin': [np.nan] * _numLineScans,
+            'time_sec': [np.nan] * _numLineScans,
+            'sumintensity': [np.nan] * _numLineScans,
+            'diameter_pnts': [np.nan] * _numLineScans,
+            'diameter_um': [np.nan] * _numLineScans,
+            'left_pnt': [np.nan] * _numLineScans,
+            'right_pnt': [np.nan] * _numLineScans,
         }
         return theDict
 
     def getReport(self):
         """Get a dict of all parameters and results.
-
+        
         This can be appended to a pandas dataframe.
         """
         folder, fileName = os.path.split(self._path)
         folder, _tmp = os.path.split(folder)  # _tmp is Olympus export folder
         folder, folderName = os.path.split(folder)
         _tmp, grandParentFolder = os.path.split(folder)
 
@@ -190,590 +185,581 @@
         
         # sum along the entire line scan (to find cell wide Ca2+ spikes)
         minSum: The minimum (sum all pixels in line scan / numPixels)
         maxSum: The maximum ...
         sumChange: (maxSum-minSUm) to quickly find kymographs that have a large change in diameter
         """
         theDict = {
-            "folder": folderName,
-            "grandParentFolder": grandParentFolder,
-            "file": fileName,
-            "numLines": self.numLineScans(),
-            "numPixels": self.numPixels(),
-            "secondsPerLine": self._secondsPerLine,
-            "umPerPixel": self._umPerPixel,
-            "dur_sec": self.numLineScans() * self._secondsPerLine,
-            "dist_um": self.numPixels() * self._umPerPixel,
-            "tifMin": np.nanmin(self._kymImage),  # TODO: make this for ROI rect
-            "tifMax": np.nanmax(self._kymImage),
+            'folder': folderName,
+            'grandParentFolder': grandParentFolder,
+            'file': fileName,
+            'numLines': self.numLineScans(),
+            'numPixels': self.numPixels(),
+            'secondsPerLine': self._secondsPerLine,
+            'umPerPixel': self._umPerPixel,
+            'dur_sec': self.numLineScans() * self._secondsPerLine,
+            'dist_um': self.numPixels() * self._umPerPixel,
+            'tifMin': np.nanmin(self._kymImage),  # TODO: make this for ROI rect
+            'tifMax': np.nanmax(self._kymImage),
             #
-            "minDiam": self._results["minDiam"],
-            "maxDiam": self._results["maxDiam"],
-            "diamChange": self._results["diamChange"],
+            'minDiam': self._results['minDiam'],
+            'maxDiam': self._results['maxDiam'],
+            'diamChange': self._results['diamChange'],
             #
-            "minSum": self._results["minSum"],
-            "maxSum": self._results["maxSum"],
-            "sumChange": self._results["sumChange"],
+            'minSum': self._results['minSum'],
+            'maxSum': self._results['maxSum'],
+            'sumChange': self._results['sumChange'],
         }
         return theDict
 
     def pnt2um(self, point):
         return point * self._umPerPixel
-
+    
     def getResults(self, key) -> list:
         return self._results[key]
 
     @property
     def sweepX(self):
         """Get full time array across all line scans
-
+        
         Time is in sec. Same as bAnalysis.sweepX
         """
 
         ret = np.arange(0, self.numLineScans(), 1)
         ret = np.multiply(ret, self._secondsPerLine)
-
+        
         return ret
 
     def getImageRect(self):
         l = 0
         t = self.pointsPerLineScan() * self._umPerPixel
         r = self.numLineScans() * self._secondsPerLine
         b = 0
         return kymRect(l, t, r, b)
 
     def getBestGuessRectRoi(self):
         """Get a best guess of a rectangular roi.
-
+        
         Args:
-            asRect: If True, return [l,t,r,b] else return (pos, size)
+            asRect: If True, return [l,t,r,b] else return (pos, size) 
         """
+        
+        _rect :kymRect = self.getImageRect()  # [left, top, r, b]
 
-        _rect: kymRect = self.getImageRect()  # [left, top, r, b]
-
-        logger.info(f"before reduction _rect:{_rect}")
+        logger.info(f'before reduction _rect:{_rect}')
         # reduce top/bottom (space) by 0.15 percent
         percentReduction = _rect.getHeight() * self._reduceFraction
-
-        newTop = _rect.getTop() - 2 * percentReduction
+        
+        newTop = _rect.getTop() - 2*percentReduction
         newBottom = _rect.getBottom() + percentReduction
-        _rect.setTop(newTop)
-        _rect.setBottom(newBottom)
+        _rect.setTop(newTop) 
+        _rect.setBottom(newBottom) 
 
-        logger.info(f"after reduction _rect:{_rect}")
+        logger.info(f'after reduction _rect:{_rect}')
 
         # self._pos = (_rect[0], _rect[1])  # (0,0)
-        # self._size = (_rect[2], _rect[3])  #(self.getImageShape()[0], self.getImageShape()[1])
-
+        # self._size = (_rect[2], _rect[3])  #(self.getImageShape()[0], self.getImageShape()[1])        
+        
         return _rect
 
     def getRoiRect(self, asInt=True) -> kymRect:
-        """Get the current roi rectangle."""
+        """Get the current roi rectangle.
+        """
         return self._roiRect
 
     def setRectRoi(self, newRect):
         """
         Args:
             newRect is [l, t, r, b]
         """
         l = newRect[0]
         t = newRect[1]
         r = newRect[2]
         b = newRect[3]
         self._roiRect = kymRect(l, t, r, b)
 
     def setPercentOfMax(self, percent):
-        """Set the percent of max used in analyze()."""
+        """Set the percent of max used in analyze().
+        """
         self._percentOfMax = percent
-
+    
     def getPercentOfMax(self):
         return self._percentOfMax
-
+    
     def getLineWidth(self) -> int:
         return self._lineWidth
-
-    def setLineWidth(self, width: int):
+    
+    def setLineWidth(self, width : int):
         self._lineWidth = width
-
+    
     def old_rotateImage(self):
         self._kymImage = np.rot90(self._kymImage)
         return self._kymImage
 
     def getImage(self):
         return self._kymImage
 
     def getImageContrasted(self, theMin, theMax, rot90=False):
         bitDepth = 8
-        lut = np.arange(2**bitDepth, dtype="uint8")
-        lut = self._getContrastedImage(lut, theMin, theMax)  # get a copy of the image
+        lut = np.arange(2**bitDepth, dtype='uint8')
+        lut = self._getContrastedImage(lut, theMin, theMax) # get a copy of the image
         theRet = np.take(lut, self._kymImage)
-
+        
         if rot90:
             theRet = np.rot90(theRet)
-
+        
         return theRet
 
-    def _getContrastedImage(
-        self, image, display_min, display_max
-    ):  # copied from Bi Rico
+    def _getContrastedImage(self, image, display_min, display_max): # copied from Bi Rico
         # Here I set copy=True in order to ensure the original image is not
         # modified. If you don't mind modifying the original image, you can
         # set copy=False or skip this step.
         bitDepth = 8
-
+        
         image = np.array(image, dtype=np.uint8, copy=True)
         image.clip(display_min, display_max, out=image)
         image -= display_min
-        np.floor_divide(
-            image,
-            (display_max - display_min + 1) / (2**bitDepth),
-            out=image,
-            casting="unsafe",
-        )
-        # np.floor_divide(image, (display_max - display_min + 1) / 256,
+        np.floor_divide(image, (display_max - display_min + 1) / (2**bitDepth), out=image, casting='unsafe')
+        #np.floor_divide(image, (display_max - display_min + 1) / 256,
         #                out=image, casting='unsafe')
-        # return image.astype(np.uint8)
+        #return image.astype(np.uint8)
         return image
 
     def getImageShape(self):
         return self._kymImage.shape  # (w, h)
 
     def numLineScans(self):
-        """Number of line scans in kymograph."""
+        """Number of line scans in kymograph.
+        """
         return self.getImageShape()[0]
 
     def pointsPerLineScan(self):
-        """Number of points in each line scan."""
+        """Number of points in each line scan.
+        """
         return self.getImageShape()[1]
 
     def getAnalysisFile(self):
-        """Get full path to analysis file we save/load."""
+        """Get full path to analysis file we save/load.
+        """
         savePath, saveFile = os.path.split(self._path)
         saveFileBase, ext = os.path.splitext(saveFile)
-        saveFile = saveFileBase + "-kymanalysis.csv"
+        saveFile = saveFileBase + '-kymanalysis.csv'
         savePath = os.path.join(savePath, saveFile)
         return savePath
 
     def _getFileHeader(self):
-        """Get one line header to save with analysis."""
-        header = ""
+        """Get one line header to save with analysis.
+        """
+        header = ''
 
         lineWidth = self.getLineWidth()
         percentOfMax = self.getPercentOfMax()
         roiRect = self.getRoiRect()
 
-        header += f"version={self._version};"
+        header += f'version={self._version};'
 
         filePath, fileName = os.path.split(self._path)
-        header += f"file={fileName};"
-
-        header += f"linewidth={lineWidth};"
-        header += f"percentofmax={percentOfMax};"
-
+        header += f'file={fileName};'
+        
+        header += f'linewidth={lineWidth};'
+        header += f'percentofmax={percentOfMax};'
+        
         # don't put tuple in header, expand
-        # header += f'roiRect={roiRect};'
-        header += f"lrectroi={roiRect.getLeft()};"
-        header += f"trectroi={roiRect.getTop()};"
-        header += f"rrectroi={roiRect.getRight()};"
-        header += f"brectroi={roiRect.getBottom()};"
+        #header += f'roiRect={roiRect};'
+        header += f'lrectroi={roiRect.getLeft()};'
+        header += f'trectroi={roiRect.getTop()};'
+        header += f'rrectroi={roiRect.getRight()};'
+        header += f'brectroi={roiRect.getBottom()};'
 
         # TODO: ad other params like (image median kernel, line median kernel, ...)
 
         return header
 
     def _parseFileHeader(self, header):
         """Parse one line header into member variables.
-
+        
         This is parsing header we save with analysis.
         """
-        kvList = header.split(";")
+        kvList = header.split(';')
         for kv in kvList:
             if not kv:
                 # handle trailing ';'
                 continue
-            k, v = kv.split("=")
-            # print('    k:', k, 'v:', v)
-            if k == "lrectroi":
+            k,v = kv.split('=')
+            #print('    k:', k, 'v:', v)
+            if k == 'lrectroi':
                 left = float(v)
-            elif k == "trectroi":
+            elif k == 'trectroi':
                 top = float(v)
-            elif k == "rrectroi":
+            elif k == 'rrectroi':
                 right = float(v)
-            elif k == "brectroi":
+            elif k == 'brectroi':
                 bottom = float(v)
 
-            elif k == "linewidth":
+            elif k == 'linewidth':
                 self._lineWidth = int(v)
-            elif k == "percentofmax":
+            elif k == 'percentofmax':
                 self._percentOfMax = float(v)
 
-        width = right - left  # + 1
-        height = top - bottom  # + 1
-
+        width = right - left #+ 1
+        height = top - bottom #+ 1
+        
         self._pos = (left, bottom)
         self._size = (width, height)
 
         # print('left:', left)
         # print('top:', top)
         # print('right:', right)
         # print('bottom:', bottom)
-        logger.info(f"  _pos: {self._pos}")
-        logger.info(f"  _size: {self._size}")
-
-    def saveAnalysis(self, path: str = None):
+        logger.info(f'  _pos: {self._pos}')
+        logger.info(f'  _size: {self._size}')
+        
+    def saveAnalysis(self, path : str = None):
         """Save kymograph analysis.
-
+        
         This includes:
             - time bins
             - sum of each line scan
             - diameter calculation for each line scan
             ...
         """
 
         if path is None:
             savePath = self.getAnalysisFile()
         else:
             savePath = path
 
         header = self._getFileHeader()
 
-        with open(savePath, "w") as f:
+        with open(savePath, 'w') as f:
             f.write(header)
-            f.write("\n")
-
+            f.write('\n')
+        
         df = pd.DataFrame(self._results)
 
-        logger.info(f"saving {len(df)} lines to {savePath}")
+        logger.info(f'saving {len(df)} lines to {savePath}')
 
-        df.to_csv(savePath, mode="a")
+        df.to_csv(savePath, mode='a')
 
     def loadAnalysis(self):
         """Load <file>-kymanalysis.csv
-
-        Look in parent folder of .tif file
+        
+            Look in parent folder of .tif file
         """
         savePath = self.getAnalysisFile()
         if not os.path.isfile(savePath):
-            logger.info(f"did not find file: {savePath}")
+            logger.info(f'did not find file: {savePath}')
             return
 
-        logger.info(f"loading analysis from: {savePath}")
+        logger.info(f'loading analysis from: {savePath}')
 
         with open(savePath) as f:
             header = f.readline().rstrip()
-
+        
         self._parseFileHeader(header)  # parse header of saved analysis
 
         df = pd.read_csv(savePath, header=1)
 
         # parse df into self._results dictionary
-        """
+        '''
         self._results = {
             'time_ms': [],
             'sumintensity': [],
             'diameter': [],
             'leftpnt': [],
             'rightpnt': [],
         }
-        """
+        '''
         try:
-            self._results["time_ms"] = df["time_ms"].values
-            self._results["sumintensity"] = df["sumintensity"].values
-            self._results["diameter_pnts"] = df["diameter_pnts"].values
-            self._results["diameter_um"] = df["diameter_um"].values
-            self._results["left_pnt"] = df["left_pnt"].values
-            self._results["right_pnt"] = df["right_pnt"].values
-            self._results["diameter_pixels"] = df["diameter_pixels"].values
-        except KeyError as e:
+            self._results['time_ms'] = df['time_ms'].values
+            self._results['sumintensity'] = df['sumintensity'].values
+            self._results['diameter_pnts'] = df['diameter_pnts'].values
+            self._results['diameter_um'] = df['diameter_um'].values
+            self._results['left_pnt'] = df['left_pnt'].values
+            self._results['right_pnt'] = df['right_pnt'].values
+            self._results['diameter_pixels'] = df['diameter_pixels'].values
+        except (KeyError) as e:
             # if we did not find a scale in rosie rosetta
-            logger.error(f"DID NOT FIND KEY {e}")
-            # self._results = None
+            logger.error(f'DID NOT FIND KEY {e}')
+            #self._results = None
 
     def loadPeaks(self):
         """
         Load foot/peaks from manual detection.
         """
-        # self._fpAnalysis = None  # Pandas dataframe with xFoot, yFoot, xPeak, yPeak
-
-        fpFilePath = self._path.replace(".tif", "-fpAnalysis2.csv")
+        #self._fpAnalysis = None  # Pandas dataframe with xFoot, yFoot, xPeak, yPeak
+        
+        fpFilePath = self._path.replace('.tif', '-fpAnalysis2.csv')
         fpFileName = os.path.split(fpFilePath)[1]
         if not os.path.isfile(fpFilePath):
-            logger.error(f"Did not find manual peak file:{fpFileName}")
-            print("  fpFilePath:", fpFilePath)
+            logger.error(f'Did not find manual peak file:{fpFileName}')
+            print('  fpFilePath:', fpFilePath)
             return
-
-        logger.info(f"loading fpFilePath:{fpFileName}")
-        print("  fpFilePath:", fpFilePath)
+        
+        logger.info(f'loading fpFilePath:{fpFileName}')
+        print('  fpFilePath:', fpFilePath)
 
         _fpAnalysis = pd.read_csv(fpFilePath)
 
         return _fpAnalysis
 
     def pnt2um(self, point):
         return point * self._umPerPixel
-
+    
     def seconds2pnt(self, seconds):
         return int(seconds / self._secondsPerLine)
 
     def um2pnt(self, um):
         return int(um / self._umPerPixel)
 
     def analyze(self, imageMedianKernel=None, lineMedianKernel=None):
         """Analyze the diameter of each line scan.
-
+        
         Args:
             imageMedianKernel: filter the raw tif with this median kernel
                             If None then use self._kymImageFilterKernel
                             If not None then set self._kymImageFilterKernel
             lineMedianKernel: filter the each line of the raw tif with this median kernel
                             If None then use self._lineFilterKernel
                             If not None then set self._lineFilterKernel
         """
         startSeconds = time.time()
-
+        
         if imageMedianKernel is None:
             imageMedianKernel = self._kymImageFilterKernel
         else:
             self._kymImageFilterKernel = imageMedianKernel
 
         if lineMedianKernel is None:
             lineMedianKernel = self._lineFilterKernel
         else:
             self._lineFilterKernel = lineMedianKernel
 
-        logger.info("")
-        logger.info(f"  filtering entire image with median kernel {imageMedianKernel}")
-        logger.info(f"  filtering each line with median kernel {lineMedianKernel}")
-
-        if imageMedianKernel > 0:
-            self._filteredImage = scipy.signal.medfilt(
-                self._kymImage, imageMedianKernel
-            )
+        logger.info('')
+        logger.info(f'  filtering entire image with median kernel {imageMedianKernel}')
+        logger.info(f'  filtering each line with median kernel {lineMedianKernel}')
+
+        if imageMedianKernel>0:
+            self._filteredImage = scipy.signal.medfilt(self._kymImage, imageMedianKernel)
         else:
             self._filteredImage = self._kymImage
 
         theRect = self.getRoiRect()
 
-        logger.info(f"  (l,t,r,b) is {theRect}")
+        logger.info(f'  (l,t,r,b) is {theRect}')
         leftRect_sec = theRect.getLeft()
         rightRect_sec = theRect.getRight()
-
+                
         # convert left/right of rect in seconds to line scan inex
         leftRect_line = int(leftRect_sec / self._secondsPerLine)
         rightRect_line = int(rightRect_sec / self._secondsPerLine)
-
-        logger.info(f"  leftRect_line:{leftRect_line} rightRect_line:{rightRect_line}")
-        logger.info(f"  self.numLineScans():{self.numLineScans()}")
-        logger.info(f"  self._umPerPixel:{self._umPerPixel}")
-        logger.info(f"  self._percentOfMax:{self._percentOfMax}")
+        
+        logger.info(f'  leftRect_line:{leftRect_line} rightRect_line:{rightRect_line}')
+        logger.info(f'  self.numLineScans():{self.numLineScans()}')
+        logger.info(f'  self._umPerPixel:{self._umPerPixel}')
+        logger.info(f'  self._percentOfMax:{self._percentOfMax}')
 
         sumIntensity = [np.nan] * self.numLineScans()
         left_idx_list = [np.nan] * self.numLineScans()
         right_idx_list = [np.nan] * self.numLineScans()
         diameter_idx_list = [np.nan] * self.numLineScans()
-
+                        
         lineRange = np.arange(leftRect_line, rightRect_line)
         for line in lineRange:
+
             # get line profile using line width
             # outside roi rect will be nan
-            intensityProfile, left_idx, right_idx = self._getFitLineProfile(
-                line, lineMedianKernel
-            )
+            intensityProfile, left_idx, right_idx = \
+                            self._getFitLineProfile(line, lineMedianKernel)
 
             # logger.info(f'  len(intensityProfile):{len(intensityProfile)} \
             #             left_idx:{left_idx} \
             #             right_idx:{right_idx}')
 
             # normalize to number of points in line scan
             sumIntensity[line] = np.nansum(intensityProfile)
             sumIntensity[line] /= self._kymImage.shape[1]
 
             left_idx_list[line] = left_idx
             right_idx_list[line] = right_idx
             diameter_idx_list[line] = right_idx - left_idx + 1
 
-        self._results["time_sec"] = self.sweepX.tolist()
-        self._results["sumintensity"] = sumIntensity
-
+        self._results['time_sec'] = self.sweepX.tolist()
+        self._results['sumintensity'] = sumIntensity
+        
         # filter
         diameter_um = np.multiply(diameter_idx_list, self._umPerPixel)
         # kernelSize = 5
         # diameter_um = scipy.signal.medfilt(diameter_um, kernelSize)
-        self._results["diameter_pnts"] = diameter_idx_list
-        self._results["diameter_um"] = diameter_um
-
-        self._results["left_pnt"] = left_idx_list
-        self._results["right_pnt"] = right_idx_list
+        self._results['diameter_pnts'] = diameter_idx_list
+        self._results['diameter_um'] = diameter_um
+        
+        self._results['left_pnt'] = left_idx_list
+        self._results['right_pnt'] = right_idx_list
 
         # smooth
-        # kernelSize = 3
-        # logger.info(f'put kernel size at user option, kernelSize: {kernelSize}')
-        # diameter_um = self._results['diameter_um']
-        # diameter_um_f = scipy.signal.medfilt(diameter_um, kernelSize)
+        #kernelSize = 3
+        #logger.info(f'put kernel size at user option, kernelSize: {kernelSize}')
+        #diameter_um = self._results['diameter_um']
+        #diameter_um_f = scipy.signal.medfilt(diameter_um, kernelSize)
 
-        sumintensity = self._results["sumintensity"]
-        # sumintensity_f = scipy.signal.medfilt(sumintensity, kernelSize)
+        sumintensity = self._results['sumintensity']
+        #sumintensity_f = scipy.signal.medfilt(sumintensity, kernelSize)
 
         #
-        self._results["minDiam"] = np.nanmin(diameter_um)
-        self._results["maxDiam"] = np.nanmax(diameter_um)
-        self._results["diamChange"] = (
-            self._results["maxDiam"] - self._results["minDiam"]
-        )
+        self._results['minDiam'] = np.nanmin(diameter_um)
+        self._results['maxDiam'] = np.nanmax(diameter_um)
+        self._results['diamChange'] = self._results['maxDiam'] - self._results['minDiam']
         #
-        self._results["minSum"] = np.nanmin(sumintensity)
-        self._results["maxSum"] = np.nanmax(sumintensity)
-        self._results["sumChange"] = self._results["maxSum"] - self._results["minSum"]
+        self._results['minSum'] = np.nanmin(sumintensity)
+        self._results['maxSum'] = np.nanmax(sumintensity)
+        self._results['sumChange'] = self._results['maxSum'] - self._results['minSum']
 
         stopSeconds = time.time()
-        durSeconds = round(stopSeconds - startSeconds, 2)
-        logger.info(f"  analyzed {len(lineRange)} line scans in {durSeconds} seconds")
+        durSeconds = round(stopSeconds-startSeconds,2)
+        logger.info(f'  analyzed {len(lineRange)} line scans in {durSeconds} seconds')
 
-    def _getFitLineProfile(self, lineScanNumber: int, medianKernel: int):
+    def _getFitLineProfile(self, lineScanNumber : int, medianKernel : int):
         """Get one line profile.
 
         - Returns points
         - Get the full line, do not look at rect roi
 
         Args:
             medianKernel: Use 0 for no filtering
         """
-
+        
         # TODO: want to get based on rect roi
 
         # we know the scan line, determine start/stop based on roi
         roiRect = self.getRoiRect()  # (l, t, r, b) in um and seconds (float)
         src_pnt_space = self.um2pnt(roiRect.getBottom())
         dst_pnt_space = self.um2pnt(roiRect.getTop())
-
+        
         # intensityProfile will always have len() of number of pixels in line scane
         if self._lineWidth == 1:
-            intensityProfile = self._filteredImage[lineScanNumber, :]
-
+            intensityProfile = self._filteredImage[lineScanNumber,:]
+            
             # oct-7-2022
             intensityProfile = np.flip(intensityProfile)  # FLIPPED
-
-            # intensityProfile = intensityProfile.astype(float)  # we need nan
+            
+            #intensityProfile = intensityProfile.astype(float)  # we need nan
 
         else:
             # FLIPPED
-            src = (lineScanNumber, self.numPixels() - 1)
-            dst = (
-                lineScanNumber,
-                0,
-            )  # -1 because profile_line uses last pnt (unlike numpy)
-
-            intensityProfile = profile.profile_line(
-                self._filteredImage, src, dst, linewidth=self._lineWidth
-            )
+            src = (lineScanNumber, self.numPixels()-1)
+            dst = (lineScanNumber, 0)  # -1 because profile_line uses last pnt (unlike numpy)
+            
+            intensityProfile = \
+                    profile.profile_line(self._filteredImage, src, dst, linewidth=self._lineWidth)
 
         # median filter line profile
         if medianKernel > 0:
             intensityProfile = scipy.signal.medfilt(intensityProfile, medianKernel)
 
-        x = np.arange(0, len(intensityProfile) + 1)
+        x = np.arange(0, len(intensityProfile)+1)
 
         # Nan out before/after roi
         intensityProfile = intensityProfile.astype(float)  # we need nan
         intensityProfile[0:src_pnt_space] = np.nan
         intensityProfile[dst_pnt_space:] = np.nan
-
-        # fwhm, left_idx, right_idx = self.FWHM(x, intensityProfile)
+        
+        #fwhm, left_idx, right_idx = self.FWHM(x, intensityProfile)
 
         # FWHM
         _intMax = np.nanmax(intensityProfile)
-        half_max = _intMax * self._percentOfMax  # 0.2
+        half_max = _intMax * self._percentOfMax  #0.2
         whr = np.asarray(intensityProfile > half_max).nonzero()
         if len(whr[0]) > 2:
             # whr is (array,), only interested in whr[0]
             left_idx = whr[0][0]
             right_idx = whr[0][-1]
-            # fwhm = X[right_idx] - X[left_idx]
+            #fwhm = X[right_idx] - X[left_idx]
         else:
             left_idx = np.nan
             right_idx = np.nan
-            # fwhm = np.nan
+            #fwhm = np.nan
 
-        """
+        '''
         if lineScanNumber < 5:
             logger.info(f'  line:{lineScanNumber} src_pnt_space:{src_pnt_space} dst_pnt_space:{dst_pnt_space}')
             logger.info(f'    intensityProfile:{len(intensityProfile)}')
             logger.info(f'    left_idx:{left_idx}')
             logger.info(f'    right_idx:{right_idx}')
             logger.info(f'    _intMax:{_intMax}')
             logger.info(f'    half_max:{half_max}')
 
             # import matplotlib.pyplot as plt
             # plt.plot(intensityProfile)
             # plt.show()
-        """
+        '''
 
         return intensityProfile, left_idx, right_idx
 
     def old_FWHM(self, X, Y):
         """
         see: https://stackoverflow.com/questions/10582795/finding-the-full-width-half-maximum-of-a-peak
         """
-        # logger.info(f'_percentOfMax:{self._percentOfMax}')
-
-        # Y = scipy.signal.medfilt(Y, 3)
-
-        # half_max = max(Y) / 2.
-        # half_max = max(Y) * 0.7
-        half_max = np.nanmax(Y) * self._percentOfMax  # 0.2
+        #logger.info(f'_percentOfMax:{self._percentOfMax}')
+        
+        #Y = scipy.signal.medfilt(Y, 3)
+        
+        #half_max = max(Y) / 2.
+        #half_max = max(Y) * 0.7
+        half_max = np.nanmax(Y) * self._percentOfMax  #0.2
 
         # for explanation of this wierd syntax
         # see: https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html
-        # whr = np.where(Y > half_max)
-        # print('   half_max:', half_max)
+        #whr = np.where(Y > half_max)
+        #print('   half_max:', half_max)
         whr = np.asarray(Y > half_max).nonzero()
         if len(whr[0]) > 2:
             # whr is (array,), only interested in whr[0]
             left_idx = whr[0][0]
             right_idx = whr[0][-1]
             fwhm = X[right_idx] - X[left_idx]
         else:
             left_idx = np.nan
             right_idx = np.nan
             fwhm = np.nan
-        return fwhm, left_idx, right_idx  # return the difference (full width)
+        return fwhm, left_idx, right_idx  #return the difference (full width)
 
 
-def plotKym(ka: kymAnalysis):
-    """Plot a kym image using matplotlib."""
+def plotKym(ka : kymAnalysis):
+    """Plot a kym image using matplotlib.
+    """
     import matplotlib.pyplot as plt
 
     sharex = False
     fig, axs = plt.subplots(3, 1, sharex=sharex)
 
     # extent is [l, r, b, t]
     _extent = ka.getImageRect().getMatPlotLibExtent()  # [l, t, r, b]
-    logger.info(f"_extent [left, right, bottom, top]:{_extent}")
+    logger.info(f'_extent [left, right, bottom, top]:{_extent}')
     tifDataCopy = ka.getImage().copy()
     tifDataCopy = np.rot90(tifDataCopy)
-    # axs[0].imshow(tifDataCopy, extent=_extent)
+    #axs[0].imshow(tifDataCopy, extent=_extent)
     axs[0].imshow(tifDataCopy)
 
     sweepX = ka.sweepX
-    print("sweepX:", type(sweepX), sweepX.shape)
-
-    sumIntensity = ka.getResults("sumintensity")
-    print("sumIntensity", type(sumIntensity), len(sumIntensity))
+    print('sweepX:', type(sweepX), sweepX.shape)
+    
+    sumIntensity = ka.getResults('sumintensity')
+    print('sumIntensity', type(sumIntensity), len(sumIntensity))
     axs[1].plot(ka.sweepX, sumIntensity)
-
+    
     # TODO: Add filtering of diameter per line scan
-    diameter_pnts = ka.getResults("diameter_pnts")
+    diameter_pnts = ka.getResults('diameter_pnts')
     axs[2].plot(ka.sweepX, diameter_pnts)
-
+    
     plt.show()
 
-
-if __name__ == "__main__":
-    path = "/Users/cudmore/data/rosie/Raw data for contraction analysis/Female Old/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif"
+if __name__ == '__main__':
+    path = '/Users/cudmore/data/rosie/Raw data for contraction analysis/Female Old/filter median 1 C2-0-255 Cell 2 CTRL  2_5_21 female wt old.tif'
     ka = kymAnalysis(path)
     ka.analyze()
 
-    # ka.saveAnalysis()
+    #ka.saveAnalysis()
 
-    # plotKym(ka)
-    # plotKym_plotly(ka)
-    # plotDash(ka)
+    #plotKym(ka)
+    #plotKym_plotly(ka)
+    #plotDash(ka)
```

### Comparing `sanpy-ephys-0.1.13/sanpy/sanpyLogger.py` & `sanpy-ephys-0.1.6/sanpy/sanpyLogger.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,143 +8,138 @@
 DEBUG
 INFO
 WARNING
 ERROR
 CRITICAL
 """
 
-"""
+'''
 LOGLEVEL = os.environ.get('LOGLEVEL', 'WARNING').upper()
 print('LOGLEVEL:', LOGLEVEL)
 print('os.environ')
 for k,v in os.environ.items():
     print(f'  {k}: {v}')
 sys.exit(1)
-"""
+'''
 
-# basedir = os.path.dirname(__file__)
-# print('sanpyLogger basedir:', basedir)
-
-# from sanpy._util import _getUserPreferencesFolder
+#basedir = os.path.dirname(__file__)
+#print('sanpyLogger basedir:', basedir)
 
+#from sanpy._util import _getUserPreferencesFolder
 
 def getLoggerFile():
     """Get the path to save the log file.
-
+    
     If <user>/Documents/SanPy/preferences exists
     else MEIPASS
     """
     # logPath = sanpy._util._getUserPreferencesFolder()
     # logPath = os.path.join(logPath, 'sanpy.log')
     # return logPath
 
     userPath = pathlib.Path.home()
-    userPreferencesFolder = os.path.join(userPath, "Documents", "SanPy", "preferences")
-    # print('looking for userPreferencesFolder:', userPreferencesFolder)
+    userPreferencesFolder = os.path.join(userPath, 'Documents', 'SanPy', 'preferences')
+    #print('looking for userPreferencesFolder:', userPreferencesFolder)
     if os.path.isdir(userPreferencesFolder):
         myPath = userPreferencesFolder
-        # print('  my path 1:', myPath)
-    elif getattr(sys, "frozen", False):
+        #print('  my path 1:', myPath)
+    elif getattr(sys, 'frozen', False):
         # running in a bundle (frozen)
         myPath = sys._MEIPASS
-        # print('  my path 2:', myPath)
+        #print('  my path 2:', myPath)
     else:
         # running in a normal Python environment
-        # myPath = os.path.dirname(os.path.abspath(__file__))
+        #myPath = os.path.dirname(os.path.abspath(__file__))
         myPath = pathlib.Path(__file__).parent.absolute()
-        # print('  my path 3:', myPath)
+        #print('  my path 3:', myPath)
 
-    fileName = "sanpy.log"
+    fileName = 'sanpy.log'
     logPath = os.path.join(myPath, fileName)
     return logPath
 
-
 def get_logger(name, level=logging.DEBUG):
-    """ """
-
+    """
+    """
+    
     # if getattr(sys, 'frozen', False):
     #     # running in a bundle (frozen)
     #     myPath = sys._MEIPASS
     # else:
     #     # running in a normal Python environment
     #     myPath = pathlib.Path(__file__).parent.absolute()
 
     # fileName = 'sanpy.log'
     # logPath = os.path.join(myPath, fileName)
 
     logPath = getLoggerFile()
 
-    # print('logPath:', logPath)
+    #print('logPath:', logPath)
 
     # Create a custom logger
     logger = logging.getLogger(name)
     logger.setLevel(level)  # abb 20220609
 
     # abb removed 20220609
     logger.propagate = False  # don't propogate to root (o.w. prints twice)
-    # print('   ', logger, 'level:', level)
+    #print('   ', logger, 'level:', level)
     if not logger.handlers:
-        # print('=== sanpyLogger.get_logger() creating handlers')
-        # print('    ', logger.handlers)
+        #print('=== sanpyLogger.get_logger() creating handlers')
+        #print('    ', logger.handlers)
 
         # Create handlers
         c_handler = logging.StreamHandler()
         f_handler = RotatingFileHandler(logPath, maxBytes=500, backupCount=0)
-        # f_handler = logging.FileHandler(logPath)
+        #f_handler = logging.FileHandler(logPath)
 
         c_handler.setLevel(level)
         f_handler.setLevel(level)
 
         # Create formatters and add it to handlers
-        consoleFormat = "%(levelname)5s %(name)8s  %(filename)s %(funcName)s() line:%(lineno)d -- %(message)s"
+        consoleFormat = '%(levelname)5s %(name)8s  %(filename)s %(funcName)s() line:%(lineno)d -- %(message)s'
         c_format = logging.Formatter(consoleFormat)
 
-        fileFormat = "%(asctime)s  %(levelname)5s %(name)8s  %(filename)s %(funcName)s() line:%(lineno)d -- %(message)s"
+        fileFormat = '%(asctime)s  %(levelname)5s %(name)8s  %(filename)s %(funcName)s() line:%(lineno)d -- %(message)s'
         f_format = logging.Formatter(fileFormat)
 
         c_handler.setFormatter(c_format)
         f_handler.setFormatter(f_format)
 
         # Add handlers to the logger
         logger.addHandler(c_handler)
         logger.addHandler(f_handler)
-    #
+#
     #
     return logger
 
-
-# see: https://stackoverflow.com/questions/6234405/logging-uncaught-exceptions-in-python
+#see: https://stackoverflow.com/questions/6234405/logging-uncaught-exceptions-in-python
 def handle_exception(exc_type, exc_value, exc_traceback):
     if issubclass(exc_type, KeyboardInterrupt):
         sys.__excepthook__(exc_type, exc_value, exc_traceback)
         return
 
     logger.error("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))
 
-
 sys.excepthook = handle_exception
 
 # This does not seem like a good idea, without it, we get exception calling
 # logger.error in handle_exception (above)
 logger = get_logger(__name__)
 
-
 def test():
-    logger.error("111")
+    logger.error('111')
 
-
-if __name__ == "__main__":
+if __name__ == '__main__':
     logger = get_logger(__name__)
-    logger.error("WORKS")
+    logger.error('WORKS')
 
     test()
 
-    # print(1/0)
+    #print(1/0)
 
-    """
+    '''
     a = 5
     b = 0
     try:
         c = a / b
     except Exception as e:
         logger.exception("Exception occurred")
-    """
+    '''
```

### Comparing `sanpy-ephys-0.1.13/sanpy/scatterwidget/bScatterPlotWidget2.py` & `sanpy-ephys-0.1.6/sanpy/interface/bScatterPlotWidget2.py`

 * *Files 11% similar despite different names*

```diff
@@ -19,342 +19,306 @@
     matplotlib
     seaborn
     mplcursors
     openpyxl # to load xlsx
 """
 
 import os, sys, io, csv
+from functools import partial
 from collections import OrderedDict
 import traceback
 import pandas as pd
 import numpy as np
+
 from PyQt5 import QtCore, QtGui, QtWidgets
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
 from matplotlib.figure import Figure
 import matplotlib.gridspec as gridspec
-import matplotlib.pyplot as plt  # abb 202012 added to set theme
+import matplotlib.pyplot as plt # abb 202012 added to set theme
 import seaborn as sns
-import mplcursors  # popup on hover
+import mplcursors # popup on hover
 
-# sysPath = os.path.dirname(sys.path[0])
-# sysPath = os.path.join(sysPath, 'sanpy')
-# print('bScatterPlotWidget2.py sysPath:', sysPath)
-# sys.path.append(sysPath)
-
-# print('os.getcwd():', os.getcwd())
-# import sanpy
-# import bUtil # from sanpy folder, for pandas model
+# originally, I wanted this to not rely on sanpy
+import sanpy
 
+from sanpy.sanpyLogger import get_logger
+logger = get_logger(__name__)
 
 def old_loadDatabase(path):
     """
     path: full path to .csv file generated with reanalyze.py
     """
-    # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+    #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
     masterDf = None
     if not os.path.isfile(path):
-        print("eror: bUtil.loadDatabase() did not find file:", path)
-    elif path.endswith(".csv"):
-        masterDf = pd.read_csv(path, header=0)  # , dtype={'ABF File': str})
-    elif path.endswith(".xls"):
-        masterDf = pd.read_excel(path, header=0)  # , dtype={'ABF File': str})
-    elif path.endswith(".xlsx"):
-        masterDf = pd.read_excel(
-            path, header=0, engine="openpyxl"
-        )  # , dtype={'ABF File': str})
+        logger.error('did not find file:', path)
+    elif path.endswith('.csv'):
+        masterDf = pd.read_csv(path, header=0) #, dtype={'ABF File': str})
+    elif path.endswith('.xls'):
+        masterDf = pd.read_excel(path, header=0) #, dtype={'ABF File': str})
+    elif path.endswith('.xlsx'):
+        masterDf = pd.read_excel(path, header=0, engine='openpyxl') #, dtype={'ABF File': str})
     else:
-        print("error: file type not supported. Expecting csv/xls/xlsx. Path:", path)
+        print('error: file type not supported. Expecting csv/xls/xlsx. Path:', path)
 
-    # self.masterDfColumns = self.masterDf.columns.to_list()
+    #self.masterDfColumns = self.masterDf.columns.to_list()
 
     # not sure what this was for ???
     # 20210112, put back in if necc
-    # self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
-    # self.masterCatColumns = self.categoricalList
+    #self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
+    #self.masterCatColumns = self.categoricalList
 
-    # print(self.masterDf.head())
-    """
+    #print(self.masterDf.head())
+    '''
     print(masterDf.info())
     print('masterDf.iloc[0,3]:', masterDf.iloc[0,3], type(masterDf.iloc[0,3]))
     print('start seconds:', masterDf['Start Seconds'].dtype.type)
     print('start seconds:', masterDf['Start Seconds'].dtype)
-    """
+    '''
     #
     return masterDf
 
-
 def printDict(d, withType=False):
-    for k, v in d.items():
+    for k,v in d.items():
         if withType:
-            print(f"  {k}: {v} {type(v)}")
+            print(f'  {k}: {v} {type(v)}')
         else:
-            print(f"  {k}: {v}")
-
+            print(f'  {k}: {v}')
 
 class myPandasModel(QtCore.QAbstractTableModel):
+
     def __init__(self, data):
         """
         data: pandas dataframe
         """
         QtCore.QAbstractTableModel.__init__(self)
         self.verbose = False
         self._data = data
         columnList = self._data.columns.values.tolist()
-        if "include" in columnList:
-            self.includeCol = columnList.index("include")
+        if 'include' in columnList:
+            self.includeCol = columnList.index('include')
         else:
             self.includeCol = None
-        # print('pandasModel.__init__() self.includeCol:', self.includeCol)
-        self.columns_boolean = ["include"]
+        #print('pandasModel.__init__() self.includeCol:', self.includeCol)
+        self.columns_boolean = ['include']
 
     def rowCount(self, parent=None):
-        # if self.verbose: print('myPandasModel.rowCount()')
+        #if self.verbose: print('myPandasModel.rowCount()')
         return self._data.shape[0]
 
     def columnCount(self, parnet=None):
-        # if self.verbose: print('myPandasModel.columnCount()')
+        #if self.verbose: print('myPandasModel.columnCount()')
         return self._data.shape[1]
 
     def data(self, index, role=QtCore.Qt.DisplayRole):
-        if self.verbose:
-            print("myPandasModel.data()")
+        if self.verbose: print('myPandasModel.data()')
         if index.isValid():
             if role == QtCore.Qt.DisplayRole:
-                # return QtCore.QVariant()
 
-                # return str(self._data.iloc[index.row(), index.column()])
+                #return QtCore.QVariant()
+
+                #return str(self._data.iloc[index.row(), index.column()])
                 retVal = self._data.iloc[index.row(), index.column()]
                 if isinstance(retVal, np.float64):
                     retVal = float(retVal)
-                    retVal = round(retVal, 4)  # round everything to 4 decimal places
+                    retVal = round(retVal,4) # round everything to 4 decimal places
                     if np.isnan(retVal):
-                        retVal = ""
+                        retVal = ''
                 elif isinstance(retVal, np.int64):
                     retVal = int(retVal)
                 #
                 return retVal
             elif role == QtCore.Qt.BackgroundRole:
-                # return
+                #return
                 return QtCore.QVariant()
 
         return None
 
     def update(self, dataIn):
-        if self.verbose:
-            print("myPandasModel.update()")
+        if self.verbose: print('myPandasModel.update()')
 
     def setData(self, index, value, role=QtCore.Qt.DisplayRole):
         """
         This is curently limited to only handle checkbox
         todo: extend to allow editing
 
         Returns:
             True if value is changed. Calls layoutChanged after update.
             False if value is not different from original value.
         """
-        if self.verbose:
-            print("myPandasModel.setData()")
-        print(
-            "  myPandasModel.setData() row:",
-            index.row(),
-            "column:",
-            index.column(),
-            "value:",
-            value,
-            type(value),
-        )
-        # if index.column() == self.includeCol:
+        if self.verbose: print('myPandasModel.setData()')
+        print('  myPandasModel.setData() row:', index.row(), 'column:', index.column(), 'value:', value, type(value))
+        #if index.column() == self.includeCol:
 
         # dataChanged is inherited from QAbstractItemModel
-        # topLeftIndex = index
-        # bottomRightIndex = index
-        # self.dataChanged.emit(index, index)
+        #topLeftIndex = index
+        #bottomRightIndex = index
+        #self.dataChanged.emit(index, index)
 
         if 1:
-            # print('value:', value, type(value))
+
+            #print('value:', value, type(value))
             v = self._data.iloc[index.row(), index.column()]
-            # print('before v:',v, type(v))
-            # print('isinstance:', isinstance(v, np.float64))
+            #print('before v:',v, type(v))
+            #print('isinstance:', isinstance(v, np.float64))
             if isinstance(v, np.float64):
                 try:
                     value = float(value)
-                except ValueError as e:
-                    print("please enter a number")
+                except (ValueError) as e:
+                    print('please enter a number')
                     return False
 
             # set
             self._data.iloc[index.row(), index.column()] = value
 
             v = self._data.iloc[index.row(), index.column()]
-            print("    after v:", v, type(v))
+            print('    after v:',v, type(v))
             return True
         return True
 
     def flags(self, index):
         if self.verbose:
-            print("myPandasModel.flags()")
-            print("  index.column():", index.column())
+            print('myPandasModel.flags()')
+            print('  index.column():', index.column())
         if 1:
             # turn on editing (limited to checkbox for now)
             if index.column() in self.columns_boolean:
-                # print('  return with columns_boolean')
+                #print('  return with columns_boolean')
                 return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsUserCheckable
-            # print('  return with ...')
-            return (
-                QtCore.Qt.ItemIsEditable
-                | QtCore.Qt.ItemIsEnabled
-                | QtCore.Qt.ItemIsSelectable
-            )
+            #print('  return with ...')
+            return QtCore.Qt.ItemIsEditable | QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable
         else:
             return QtCore.Qt.ItemIsEnabled
 
     def headerData(self, col, orientation, role):
-        # if self.verbose: print('myPandasModel.headerData()')
+        #if self.verbose: print('myPandasModel.headerData()')
         if orientation == QtCore.Qt.Horizontal and role == QtCore.Qt.DisplayRole:
             return self._data.columns[col]
         return None
 
-
 # see: https://stackoverflow.com/questions/17748546/pyqt-column-of-checkboxes-in-a-qtableview
 class myCheckBoxDelegate(QtWidgets.QItemDelegate):
     """
     A delegate that places a fully functioning QCheckBox cell of the column to which it's applied.
     """
-
     def __init__(self, parent):
         QtWidgets.QItemDelegate.__init__(self, parent)
         self.verbose = False
-        if self.verbose:
-            print("myCheckBoxDelegate.__init__()")
+        if self.verbose: print('myCheckBoxDelegate.__init__()')
 
     def createEditor(self, parent, option, index):
         """
         Important, otherwise an editor is created if the user clicks in this cell.
         """
-        if self.verbose:
-            print("myCheckBoxDelegate.createEditor()")
+        if self.verbose: print('myCheckBoxDelegate.createEditor()')
         return None
 
     def paint(self, painter, option, index):
         """
         Paint a checkbox without the label.
 
         option: PyQt5.QtWidgets.QStyleOptionViewItem
         index: PyQt5.QtCore.QModelIndex
         """
-        if self.verbose:
-            print("myCheckBoxDelegate.paint()")
-        # print('  option:', option, 'index:', index)
-        # print('  index.data():', type(index.data()), index.data())
-        # HasCheckIndicator = QtWidget.QStyleOptionViewItem.HasCheckIndicator
+        if self.verbose: print('myCheckBoxDelegate.paint()')
+        #print('  option:', option, 'index:', index)
+        #print('  index.data():', type(index.data()), index.data())
+        #HasCheckIndicator = QtWidget.QStyleOptionViewItem.HasCheckIndicator
         # options.HasCheckIndicator returns hex 4, value of enum
         # how do i query it?
-        # print('  ', option.ViewItemFeatures().HasCheckIndicator) # returns PyQt5.QtWidgets.QStyleOptionViewItem.ViewItemFeature
-        # print('  ', option.features)
-        # print('  ', index.data(QtCore.Qt.CheckStateRole)  )
-        # state = index.data(QtCore.Qt.CheckStateRole)
-        # print('  state:', state, 'option.HasCheckIndicator:', option.HasCheckIndicator)
-        self.drawCheck(
-            painter,
-            option,
-            option.rect,
-            QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked,
-        )
+        #print('  ', option.ViewItemFeatures().HasCheckIndicator) # returns PyQt5.QtWidgets.QStyleOptionViewItem.ViewItemFeature
+        #print('  ', option.features)
+        #print('  ', index.data(QtCore.Qt.CheckStateRole)  )
+        #state = index.data(QtCore.Qt.CheckStateRole)
+        #print('  state:', state, 'option.HasCheckIndicator:', option.HasCheckIndicator)
+        self.drawCheck(painter, option, option.rect, QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked)
 
     def editorEvent(self, event, model, option, index):
-        """
+        '''
         Change the data in the model and the state of the checkbox
         if the user presses the left mousebutton and this cell is editable. Otherwise do nothing.
-        """
-        if self.verbose:
-            print("myCheckBoxDelegate.editorEvent()")
+        '''
+        if self.verbose: print('myCheckBoxDelegate.editorEvent()')
         if not int(index.flags() & QtCore.Qt.ItemIsEditable) > 0:
             return False
 
-        if (
-            event.type() == QtCore.QEvent.MouseButtonRelease
-            and event.button() == QtCore.Qt.LeftButton
-        ):
+        if event.type() == QtCore.QEvent.MouseButtonRelease and event.button() == QtCore.Qt.LeftButton:
             # Change the checkbox-state
             self.setModelData(None, model, index)
             return True
 
         return False
 
+
     def setModelData(self, editor, model, index):
-        """
+        '''
         The user wanted to change the old state in the opposite.
-        """
+        '''
         if self.verbose:
-            print("myCheckBoxDelegate.setModelData()")
-            print("  editor:", editor)
-            print("  model:", model)
-            print("  index:", index)
-            print("  index.data():", type(index.data()), index.data())
-        # data = index.data()
-        # if isinstance(data, str):
+            print('myCheckBoxDelegate.setModelData()')
+            print('  editor:', editor)
+            print('  model:', model)
+            print('  index:', index)
+            print('  index.data():', type(index.data()), index.data())
+        #data = index.data()
+        #if isinstance(data, str):
         #    return
         newValue = 1 if int(index.data()) == 0 else 0
         model.setData(index, newValue, QtCore.Qt.EditRole)
 
-
-# class MainWindow(QtWidgets.QWidget):
-myInterfaceDefaults = OrderedDict(
-    {
-        "X Statistic": None,
-        "Y Statistic": None,
-        "Hue": None,
-        "Group By": None,
-    }
-)
-
+#class MainWindow(QtWidgets.QWidget):
+myInterfaceDefaults = OrderedDict({
+    'X Statistic': None,
+    'Y Statistic': None,
+    'Hue': None,
+    'Group By': None,
+})
 
 class myTableView(QtWidgets.QTableView):
     def __init__(self, dataType, parent=None):
         """
         dataType: in ['All Spikes', 'File Mean']
         """
         super(myTableView, self).__init__(parent)
 
         self.dataType = dataType
 
-        self.doIncludeCheckbox = False  # todo: turn this on
+        self.doIncludeCheckbox = False # todo: turn this on
         self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
 
-        # self.setFont(QtGui.QFont('Arial', 10))
-        self.setSizePolicy(
-            QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        )
+        #self.setFont(QtGui.QFont('Arial', 10))
+        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                  QtWidgets.QSizePolicy.Expanding)
         self.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
 
-        p = self.palette()
-        color1 = QtGui.QColor("#dddddd")
-        color2 = QtGui.QColor("#ffffff")
-        p.setColor(QtGui.QPalette.Base, color1)
-        p.setColor(QtGui.QPalette.AlternateBase, color2)
+        p = self.palette();
+        color1 = QtGui.QColor('#dddddd')
+        color2 = QtGui.QColor('#ffffff')
+        p.setColor(QtGui.QPalette.Base, color1);
+        p.setColor(QtGui.QPalette.AlternateBase, color2);
         self.setAlternatingRowColors(True)
-        self.setPalette(p)
+        self.setPalette(p);
 
     def slotSelectRow(self, selectDict):
         """
         only selecct if selectDict['dataType'] matches what we are showing
         """
-        if self.dataType != selectDict["dataType"]:
+        if self.dataType != selectDict['dataType']:
             return
 
-        print("slotSelectRow() selectDict:", selectDict)
-        ind = selectDict["index"]
-        """
+        print('slotSelectRow() selectDict:', selectDict)
+        ind = selectDict['index']
+        '''
         plotDf = selectDict['plotDf']
         index = plotDf.at[ind, 'index']
         index = int(index)
-        """
+        '''
         index = ind
-        index -= 1  # !!! MY VISUAL INDEX IN TABLE IS ONE BASED !!!
+        index -= 1 # !!! MY VISUAL INDEX IN TABLE IS ONE BASED !!!
         column = 0
         modelIndex = self.model().index(index, column)
         self.setCurrentIndex(modelIndex)
 
     def slotSwitchTableDf(self, newDf):
         """
         set model from df
@@ -365,624 +329,690 @@
             model = myPandasModel(newDf)
         self.slotSwitchTableModel(model)
 
     def slotSwitchTableModel(self, newModel):
         """
         switch between full .csv model and getMeanDf model
         """
-        # print('myTableView.slotSwitchTableModel()')
+        #print('myTableView.slotSwitchTableModel()')
         self.setModel(newModel)
 
         if newModel is None:
             return
 
         colList = newModel._data.columns.values.tolist()
-        # print('  todo: slotSwitchTableModel() set all columns to default delegate itemDelegate()')
+        #print('  todo: slotSwitchTableModel() set all columns to default delegate itemDelegate()')
         for idx, col in enumerate(colList):
             # default delegate is self.tableView.itemDelegate()
             self.setItemDelegateForColumn(idx, self.itemDelegate())
 
         # install checkboxes in 'incude' column
-        if self.doIncludeCheckbox and "include" in colList:
-            includeColIndex = colList.index("include")
-            print(
-                f"_switchTableModel() setting include column {includeColIndex} to myCheckBoxDelegate"
-            )
-            # self.tableView.setItemDelegateForColumn(includeColIndex, myCheckBoxDelegate(None))
+        if self.doIncludeCheckbox and 'include' in colList:
+            includeColIndex = colList.index('include')
+            print(f'_switchTableModel() setting include column {includeColIndex} to myCheckBoxDelegate')
+            #self.tableView.setItemDelegateForColumn(includeColIndex, myCheckBoxDelegate(None))
             self.setItemDelegateForColumn(includeColIndex, self.keepCheckBoxDelegate)
 
+class myStatListWidget(QtWidgets.QWidget):
+    """
+    Widget to display a table with selectable stats.
+
+    Gets list of stats from: sanpy.bAnalysisUtil.getStatList()
+    """
+    def __init__(self, myParent, statList=None, headerStr='Stat', parent=None):
+        """
+        Parameters
+        ----------
+        myParent : sanpy.interface.plugins.sanpyPlugin
+        statList : dict
+            from sanpy.bAnalysisUtil.getStatList()
+        headerStr : str
+            Show as label aove stat list
+        """
+        super().__init__(parent)
+
+        self.myParent = myParent
+        if statList is not None:
+            self.statList = statList
+        else:
+            # from main sanpy
+            # for pooling we have some addition columns like 'file number'
+            self.statList = sanpy.bAnalysisUtil.getStatList()
+
+        self._rowHeight = 9
+
+        self.myQVBoxLayout = QtWidgets.QVBoxLayout(self)
+
+        self.myTableWidget = QtWidgets.QTableWidget()
+        self.myTableWidget.setWordWrap(False)
+        self.myTableWidget.setRowCount(len(self.statList))
+        self.myTableWidget.setColumnCount(1)
+        self.myTableWidget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
+        self.myTableWidget.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
+        self.myTableWidget.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
+        self.myTableWidget.cellClicked.connect(self.on_scatter_toolbar_table_click)
+
+        # set font size of table (default seems to be 13 point)
+        fnt = self.font()
+        fnt.setPointSize(self._rowHeight)
+        self.myTableWidget.setFont(fnt)
+
+        headerLabels = [headerStr]
+        self.myTableWidget.setHorizontalHeaderLabels(headerLabels)
+
+        header = self.myTableWidget.horizontalHeader()
+        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
+        # QHeaderView will automatically resize the section to fill the available space. The size cannot be changed by the user or programmatically.
+        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
+
+        for idx, stat in enumerate(self.statList):
+            item = QtWidgets.QTableWidgetItem(stat)
+            self.myTableWidget.setItem(idx, 0, item)
+            self.myTableWidget.setRowHeight(idx, self._rowHeight)
+
+        # assuming dark theme
+        # does not work
+        '''
+        p = self.myTableWidget.palette()
+        color1 = QtGui.QColor('#222222')
+        color2 = QtGui.QColor('#555555')
+        p.setColor(QtGui.QPalette.Base, color1)
+        p.setColor(QtGui.QPalette.AlternateBase, color2)
+        self.myTableWidget.setPalette(p)
+        self.myTableWidget.setAlternatingRowColors(True)
+        '''
+        self.myQVBoxLayout.addWidget(self.myTableWidget)
+
+        # select a default stat
+        self.myTableWidget.selectRow(0) # hard coding 'Spike Frequency (Hz)'
 
-# class myMplCanvas(FigureCanvas):
+    def getCurrentRow(self):
+        return self.myTableWidget.currentRow()
+
+    def getCurrentStat(self):
+        # assuming single selection
+        row = self.getCurrentRow()
+        humanStat = self.myTableWidget.item(row,0).text()
+
+        # convert from human readbale to backend
+        try:
+            stat = self.statList[humanStat]['name']
+        except (KeyError) as e:
+            logger.error(f'Did not find humanStat:"{humanStat}"')
+            humanStat = None
+            stat = None
+
+        return humanStat, stat
+
+    @QtCore.pyqtSlot()
+    def on_scatter_toolbar_table_click(self):
+        """
+        replot the stat based on selected row
+        """
+        #print('*** on table click ***')
+        row = self.myTableWidget.currentRow()
+        if row == -1 or row is None:
+            return
+        yStat = self.myTableWidget.item(row,0).text()
+        self.myParent.replot()
+
+    '''
+    @QtCore.pyqtSlot()
+    def on_button_click(self, name):
+        print('=== myStatPlotToolbarWidget.on_button_click() name:', name)
+    '''
+
+#class myMplCanvas(FigureCanvas):
 class myMplCanvas(QtWidgets.QFrame):
     """
     hold an fig/plot canvas, in scatter plot we can have 1-4 of these
     """
-
     signalSelectFromPlot = QtCore.Signal(object)
     signalSelectSquare = QtCore.Signal(object, object)
 
     def __init__(self, plotNumber=None, parent=None):
-        super(myMplCanvas, self).__init__(parent)  # FigureCanvas
 
-        # self.plotType = None
+        super().__init__(parent) # FigureCanvas
 
-        # self.setFrameWidth(5)
-        # self.setStyleSheet("background-color: rgb(0, 255, 0)")
-        # self.setContentsMargins(0, 0, 0, 0)
-        # self.setContentsMargins(-20, 0, 5, 0)
+        #self.plotType = None
+
+        #self.setFrameWidth(5)
+        #self.setStyleSheet("background-color: rgb(0, 255, 0)")
+        #self.setContentsMargins(0, 0, 0, 0)
+        #self.setContentsMargins(-20, 0, 5, 0)
         self.setFrameShape(QtWidgets.QFrame.Box)
         self.setLineWidth(0)
 
         pal = self.palette()
-        pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor("red"))
+        pal.setColor(QtGui.QPalette.WindowText, QtGui.QColor('red'))
         self.setPalette(pal)
 
         #
         self.plotNumber = plotNumber
         self.stateDict = None
         self.plotDf = None
         self.whatWeArePlotting = None
         self.mplCursorHover = None
 
         # needed to show canvas in widget
-        self.layout = QtWidgets.QVBoxLayout()  # any will do
+        self.layout = QtWidgets.QVBoxLayout() # any will do
 
         self.fig = Figure(constrained_layout=True)
 
         self.canvas = FigureCanvas(self.fig)
 
-        self.canvas.axes = self.fig.add_subplot(111)  # was this
-        # self.canvas.axes = self.fig.add_axes([0.1, 0.1, 0.9, 0.9]) # [x, y, w, h]
-        # gs1 = gridspec.GridSpec(1, 1)
-        # gs1.tight_layout(self.fig, rect=[0.5, 0, 1, 1], h_pad=0.5)
-        # self.canvas.axes = self.fig.add_subplot(gs1[0])
-
-        self.cid2 = self.canvas.mpl_connect("pick_event", self.on_pick_event)
+        self.canvas.axes = self.fig.add_subplot(111) # was this
+        #self.canvas.axes = self.fig.add_axes([0.1, 0.1, 0.9, 0.9]) # [x, y, w, h]
+        #gs1 = gridspec.GridSpec(1, 1)
+        #gs1.tight_layout(self.fig, rect=[0.5, 0, 1, 1], h_pad=0.5)
+        #self.canvas.axes = self.fig.add_subplot(gs1[0])
+
+        # user clicks on plot point
+        self.cid2 = self.canvas.mpl_connect('pick_event', self.on_pick_event)
+        # user clicks in the figure
+        self.cid3 = self.canvas.mpl_connect('button_press_event', self.on_pick_event2)
 
         self.scatterPlotSelection = None
 
-        self.mplToolbar = NavigationToolbar2QT(
-            self.canvas, self.canvas
-        )  # params are (canvas, parent)
-        self.mplToolbar.hide()  # initially hidden
-
-        self.canvas.setSizePolicy(
-            QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding
-        )
+        self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
+        self.mplToolbar.hide() # initially hidden
+
+        # 20210829
+        '''
+        print('1 creating empty legend')
+        self.myLegend = self.canvas.axes.legend()
+        self.myLegend.set_visible(False)  #hide()
+        '''
+
+        self.canvas.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
+                                  QtWidgets.QSizePolicy.Expanding)
         self.canvas.updateGeometry()
 
-        # fig.subplots_adjust(wspace=0.3, hspace=0.3)
-        # self.fig.tight_layout(pad = 3.0) # Padding between the figure edge and the edges of subplots, as a fraction of the font size.
-        # self.fig.subplots_adjust(left=0.15,right=0.9,
+        #fig.subplots_adjust(wspace=0.3, hspace=0.3)
+        #self.fig.tight_layout(pad = 3.0) # Padding between the figure edge and the edges of subplots, as a fraction of the font size.
+        #self.fig.subplots_adjust(left=0.15,right=0.9,
         #                            bottom=0.1,top=0.9,
         #                            hspace=0.2,wspace=0.2)
 
         #
         self.layout.addWidget(self.canvas)
         self.setLayout(self.layout)
 
     def buildUI(self):
         pass
 
     def mousePressEvent(self, event):
-        print("myMplCanvas.mousePressEvent()")
-        print(
-            "  todo: set all controls to match the plot just clicked on using self.stateDict!!!"
-        )
-        # print('  stateDict:', self.stateDict)
+        logger.info('===')
+        print('  todo: set all controls to match the plot just clicked on using self.stateDict!!!')
+        #print('  stateDict:', self.stateDict)
         self.signalSelectSquare.emit(self.plotNumber, self.stateDict)
 
     def contextMenuEvent(self, event):
-        print("myMplCanvas.contextMenuEvent()")
+        print('myMplCanvas.contextMenuEvent()')
         contextMenu = QtWidgets.QMenu(self)
         saveAsAction = contextMenu.addAction("Save As...")
         action = contextMenu.exec_(self.mapToGlobal(event.pos()))
         if action == saveAsAction:
-            print("todo: save as")
-            self.fig.savefig("", dpi=600)
+            print('todo: save as')
+            self.fig.savefig('', dpi=600)
 
     def on_pick_event(self, event):
         try:
-            print("myMplCanvas.on_pick_event() event:", event)
-            print("  event.ind:", event.ind)
+            logger.info(f'=== event: "{event.ind}"')
 
             if len(event.ind) < 1:
                 return
             spikeNumber = event.ind[0]
-            print("  selected:", spikeNumber)
+            #print('  selected:', spikeNumber)
 
             # propagate a signal to parent
-            # self.myMainWindow.mySignal('select spike', data=spikeNumber)
-            # self.selectSpike(spikeNumber)
-        except AttributeError as e:
+            #self.myMainWindow.mySignal('select spike', data=spikeNumber)
+            #self.selectSpike(spikeNumber)
+        except (AttributeError) as e:
             pass
 
+    def on_pick_event2(self, event):
+        logger.info('===')
+
+        #print(self.stateDict)
+        for k,v in self.stateDict.items():
+            if k == 'masterDf':
+                print(f'  {k}: length is {len(v)}')
+            else:
+                print(f'  {k}: {v}')
+        #
+        self.signalSelectSquare.emit(self.plotNumber, self.stateDict)
+
     def onPick(self, event):
         """
         when user clicks on a point in the graph
 
         todo: this makes perfect sense for scatter but maybe not other plots???
         """
-        print("=== myMplCanvas.onPick()")  #' event:', type(event), event)
+        print('=== myMplCanvas.onPick()') #' event:', type(event), event)
         line = event.artist
 
         # filter out clicks on 'Annotation' used by mplcursors
         try:
             # when Scatter, line is 'PathCollection', a list of (x,y)
             offsets = line.get_offsets()
-        except AttributeError as e:
+        except (AttributeError) as e:
             return
 
-        ind = event.ind  # ind is a list []
-        if len(ind) == 0:
+        ind = event.ind # ind is a list []
+        if len(ind)==0:
             return
         ind = ind[0]
 
         # ind is the ith element in (x,y) list of offsets
         # ind 10 (0 based) is index 11 (1 based) in table list
-        print(f"  selected from plot ind:{ind}, offsets values are {offsets[ind]}")
+        print(f'  selected from plot ind:{ind}, offsets values are {offsets[ind]}')
         selectDict = self.getAnnotation(ind)
 
         # to do, just put copy of state dict ???
-        selectDict["plotType"] = self.stateDict["plotType"]
-        selectDict["dataType"] = self.stateDict["dataType"]
+        selectDict['plotType'] = self.stateDict['plotType']
+        selectDict['dataType'] = self.stateDict['dataType']
         #
         # emit
-        print("  myMplCanvas.signalSelectFromPlot.emit()", selectDict)
+        logger.info(f'  myMplCanvas.signalSelectFromPlot.emit() {selectDict}')
         self.signalSelectFromPlot.emit(selectDict)
 
     def _selectInd(self, ind):
         """
         visually select a point in scatter plot
         """
-        print("myMplCanvas._selectInd() ind:", ind)
-        if ind > len(self.plotDf) - 1:
+        print('myMplCanvas._selectInd() ind:', ind)
+        if ind > len(self.plotDf)-1:
             return
-        xVal = self.plotDf.at[ind, self.stateDict["xStat"]]
-        yVal = self.plotDf.at[ind, self.stateDict["yStat"]]
+        xVal = self.plotDf.at[ind, self.stateDict['xStat']]
+        yVal = self.plotDf.at[ind, self.stateDict['yStat']]
         if self.scatterPlotSelection is not None:
-            print("  scatterPlotSelection x:", xVal, "y:", yVal)
+            print('  scatterPlotSelection x:', xVal, 'y:', yVal)
             self.scatterPlotSelection.set_data(xVal, yVal)
         self.fig.canvas.draw()
 
     def getAnnotation(self, ind):
         if not np.issubdtype(ind, np.integer):
-            print("myMplCanvas.getAnnotation() got bad ind:", ind, type(ind))
+            print('myMplCanvas.getAnnotation() got bad ind:', ind, type(ind))
             return
 
-        xStat = self.stateDict["xStat"]
-        yStat = self.stateDict["yStat"]
-        groupByColumnName = self.stateDict["groupByColumnName"]
+        xStat = self.stateDict['xStat']
+        yStat = self.stateDict['yStat']
+        groupByColumnName = self.stateDict['groupByColumnName']
 
         analysisName = self.plotDf.at[ind, groupByColumnName]
-        index = self.plotDf.at[ind, "index"]
+        index = self.plotDf.at[ind, 'index']
         try:
-            region = self.plotDf.at[ind, "Region"]  # not all will have this
-        except KeyError as e:
-            region = "n/a"
+            region = self.plotDf.at[ind, 'Region'] # not all will have this
+        except (KeyError) as e:
+            region = 'n/a'
         xVal = self.plotDf.at[ind, xStat]
         yVal = self.plotDf.at[ind, yStat]
 
         returnDict = {
-            "ind": ind,
-            "index": index,
-            "analysisName": analysisName,
-            "region": region,
-            "xVal": xVal,
-            "yVal": yVal,
-            #'plotDf': self.plotDf, # potentially very big
-        }
+                    'ind': ind,
+                    'index': index,
+                    'analysisName': analysisName,
+                    'region': region,
+                    'xVal': xVal,
+                    'yVal': yVal,
+                    #'plotDf': self.plotDf, # potentially very big
+            }
         return returnDict
 
     def slotSelectSquare(self, plotNumber, stateDict):
-        # print('myMplCanvas.slotSelectSquare()', plotNumber, 'self.plotNumber:', self.plotNumber)
+        #print('myMplCanvas.slotSelectSquare()', plotNumber, 'self.plotNumber:', self.plotNumber)
         if plotNumber == self.plotNumber:
             self.setLineWidth(1)
         else:
             self.setLineWidth(0)
 
     def slotSelectInd(self, selectDict):
-        if self.stateDict["plotType"] == selectDict["plotType"]:
+        if self.stateDict['plotType'] == selectDict['plotType']:
             # only select if same plot type, o/w selections are out of synch
-            self._selectInd(selectDict["ind"])
+            self._selectInd(selectDict['ind'])
 
     def slotCancelSelection(self):
         if self.scatterPlotSelection is not None:
             self.scatterPlotSelection.set_data([], [])
-        # self.draw()
+        #self.draw()
         # cancel mplCursorHover hover selection
         if self.mplCursorHover is not None:
             selections = self.mplCursorHover.selections
-            if len(selections) == 1:
+            if len(selections) ==1 :
                 self.mplCursorHover.remove_selection(selections[0])
 
         # never cancel red square, we always wan't one
-        # self.slotSelectSquare(None)
+        #self.slotSelectSquare(None)
 
         #
-        # self.draw() # to update hover
+        #self.draw() # to update hover
         self.fig.canvas.draw()
 
     def updateTheme(self):
         """
         redraw using stored self.state
         """
         self.myUpdate(stateDict=None)
 
     def myUpdateGlobal(self, stateDict):
         """
         update globals but do not plot
+
+        globals are things shared across all plots like mpl toolbar and legend (???)
         """
-        self.canvas.axes.legend().set_visible(stateDict["showLegend"])
+        self.canvas.axes.legend().set_visible(stateDict['showLegend'])
+        #self.myLegend.set_visible(stateDict['showLegend'])
 
-        if stateDict["showMplToolbar"]:
+        if stateDict['showMplToolbar']:
             self.mplToolbar.show()
         else:
             self.mplToolbar.hide()
 
-        if stateDict["doHover"] and self.whatWeArePlotting is not None:
+        if stateDict['doHover'] and self.whatWeArePlotting is not None:
             self.mplCursorHover = mplcursors.cursor(self.whatWeArePlotting, hover=True)
-
             @self.mplCursorHover.connect("add")
             def _(sel):
-                # sel.annotation.get_bbox_patch().set(fc="white")
-                sel.annotation.arrow_patch.set(
-                    arrowstyle="simple", fc="white", alpha=0.5
-                )
+                #sel.annotation.get_bbox_patch().set(fc="white")
+                sel.annotation.arrow_patch.set(arrowstyle="simple", fc="white", alpha=.5)
                 # row in df is from sel.target.index
-                # print('sel.target.index:', sel.target.index)
+                #print('sel.target.index:', sel.target.index)
                 ind = sel.target.index
                 annotationDict = self.getAnnotation(ind)
-                myText = ""
-                for k, v in annotationDict.items():
-                    myText += f"{k}: {v}\n"
+                myText = ''
+                for k,v in annotationDict.items():
+                    myText += f'{k}: {v}\n'
                 sel.annotation.set_text(myText)
-
-        elif not stateDict["doHover"]:
+        elif not stateDict['doHover']:
             # cancel mplCursorHover hover selection
             if self.mplCursorHover is not None:
                 selections = self.mplCursorHover.selections
-                if len(selections) == 1:
+                if len(selections) ==1 :
                     self.mplCursorHover.remove_selection(selections[0])
-        # self.mplCursorHover = None
+        #self.mplCursorHover = None
 
         #
-        # self.draw() # to update hover
+        #self.draw() # to update hover
         self.fig.canvas.draw()
 
     def myUpdate(self, stateDict=None):
         """
         update plot based on control interface
         """
 
         # store stateDict so we can replot on changing dark theme
         if stateDict is None and self.stateDict is not None:
             # re-use our stateDict
             stateDict = self.stateDict
         else:
             self.stateDict = stateDict.copy()
 
-        dataType = stateDict["dataType"]
-        hue = stateDict["hue"]
-        groupByColumnName = stateDict["groupByColumnName"]
+        dataType = stateDict['dataType']
+        hue = stateDict['hue']
+        groupByColumnName = stateDict['groupByColumnName']
 
-        plotType = stateDict["plotType"]
-        # self.plotType = plotType
+        plotType = stateDict['plotType']
+        #self.plotType = plotType
 
-        xStatHuman = stateDict["xStatHuman"]
-        yStatHuman = stateDict["yStatHuman"]
+        xStatHuman = stateDict['xStatHuman']
+        yStatHuman = stateDict['yStatHuman']
 
-        xStat = stateDict["xStat"]
-        yStat = stateDict["yStat"]
+        xStat = stateDict['xStat']
+        yStat = stateDict['yStat']
 
-        """
+        '''
         print('=== myMplCanvas.myUpdate()')
         print('  ', plotType)
         print('  ', 'xStatHuman:', xStatHuman, 'yStatHuman:', yStatHuman)
         print('  ', 'xStat:', xStat, 'yStat:', yStat)
-        """
+        '''
 
-        xIsCategorical = stateDict["xIsCategorical"]
-        yIsCategorical = stateDict["yIsCategorical"]
+        xIsCategorical = stateDict['xIsCategorical']
+        yIsCategorical = stateDict['yIsCategorical']
 
-        masterDf = stateDict["masterDf"]
-        meanDf = stateDict["meanDf"]
+        masterDf = stateDict['masterDf']
+        meanDf = stateDict['meanDf']
 
         self.plotDf = meanDf
 
         self.canvas.axes.clear()
 
         picker = 5
-        if plotType in ["Scatter Plot", "Scatter + Raw + Mean"]:
+        if plotType in ['Scatter Plot', 'Scatter + Raw + Mean']:
             # scatter plot user selection
-            (self.scatterPlotSelection,) = self.canvas.axes.plot(
-                [], [], "oy", markersize=12, fillstyle="none"
-            )
+            self.scatterPlotSelection, = self.canvas.axes.plot([], [], 'oy',
+                                    markersize=12, fillstyle='none')
 
             # main scatter
             try:
-                self.whatWeArePlotting = sns.scatterplot(
-                    x=xStat,
-                    y=yStat,
-                    hue=hue,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                    zorder=0,
-                )
-            except ValueError as e:
+                self.whatWeArePlotting = sns.scatterplot(x=xStat, y=yStat, hue=hue,
+                                data=meanDf, ax=self.canvas.axes, picker=picker,
+                                zorder=0)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
                 print('  EXCEPTION: in myUpdate() "Scatter Plot", exception is:')
-                print("  ", e)
-                print("  ", "hue:", hue)
+                print('  ', e)
+                print('  ', 'hue:', hue)
 
             # sem in both x and y, pulling from masterDf
-            if dataType == "File Mean" or plotType == "Scatter + Raw + Mean":
+            if dataType=='File Mean' or plotType=='Scatter + Raw + Mean':
                 # we need to do this for each hue???
                 # if x or y is in categorical (e.g. a string) then do not do this ...
                 if xIsCategorical or yIsCategorical:
                     pass
                 else:
-                    print(
-                        "  grabbing mean +- sem for self.groupByColumnName:",
-                        groupByColumnName,
-                    )
-                    color = "k"
-                    xd = masterDf.groupby(groupByColumnName).mean()[xStat]
-                    xerrd = masterDf.groupby(groupByColumnName).sem()[xStat]
-                    yd = masterDf.groupby(groupByColumnName).mean()[yStat]
-                    yerrd = masterDf.groupby(groupByColumnName).sem()[yStat]
-                    self.canvas.axes.errorbar(
-                        xd,
-                        yd,
-                        xerr=xerrd,
-                        yerr=yerrd,
-                        fmt="none",
-                        capsize=0,
-                        zorder=10,
-                        color=color,
-                        alpha=0.5,
-                    )
-
-        elif plotType == "Histogram":
-            yStatHuman = "Count"
-            doKde = False  # stateDict['doKDE']
+                    logger.info(f'  grabbing mean +- sem for self.groupByColumnName: {groupByColumnName}')
+                    color = 'k'
+                    xd = masterDf.groupby(groupByColumnName).mean(numeric_only=True)[xStat]
+                    xerrd = masterDf.groupby(groupByColumnName).sem(numeric_only=True)[xStat]
+                    yd = masterDf.groupby(groupByColumnName).mean(numeric_only=True)[yStat]
+                    yerrd = masterDf.groupby(groupByColumnName).sem(numeric_only=True)[yStat]
+                    self.canvas.axes.errorbar(xd, yd, xerr=xerrd, yerr=yerrd,
+                        fmt='none', capsize=0, zorder=10, color=color, alpha=0.5);
+
+        elif plotType == 'Histogram':
+            yStatHuman = 'Count'
+            doKde = False #stateDict['doKDE']
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    kde=doKde,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, kde=doKde,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTIONin Histogram:", e)
+                print('EXCEPTIONin Histogram:', e)
 
-        elif plotType == "Cumulative Histogram":
-            yStatHuman = "Probability"
+        elif plotType == 'Cumulative Histogram':
+            yStatHuman = 'Probability'
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    cumulative=True,
-                    stat="density",
-                    element="step",
-                    fill=False,
-                    common_norm=False,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, cumulative=True, stat='density',
+                                element="step", fill=False, common_norm=False,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTION in Cumulative Histogram:", e)
+                print('EXCEPTION in Cumulative Histogram:', e)
 
-        elif plotType == "Cumulative Histogram":
-            yStatHuman = "Probability"
+        elif plotType == 'Cumulative Histogram':
+            yStatHuman = 'Probability'
             try:
-                g = sns.histplot(
-                    x=xStat,
-                    hue=hue,
-                    cumulative=True,
-                    stat="density",
-                    element="step",
-                    fill=False,
-                    common_norm=False,
-                    data=meanDf,
-                    ax=self.canvas.axes,
-                    picker=picker,
-                )
-            except ValueError as e:
+                g = sns.histplot(x=xStat, hue=hue, cumulative=True, stat='density',
+                                element="step", fill=False, common_norm=False,
+                                data=meanDf, ax=self.canvas.axes, picker=picker)
+            except (ValueError) as e:
                 self.fig.canvas.draw()
-                print("EXCEPTION in Cumulative Histogram:", e)
+                print('EXCEPTION in Cumulative Histogram:', e)
 
-        elif plotType == "Violin Plot":
+        elif plotType == 'Violin Plot':
             if not xIsCategorical:
-                warningStr = "Violin plot requires a categorical x statistic"
+                warningStr = 'Violin plot requires a categorical x statistic'
             else:
-                g = sns.violinplot(
-                    x=xStat, y=yStat, hue=hue, data=meanDf, ax=self.canvas.axes
-                )
+                g = sns.violinplot(x=xStat, y=yStat, hue=hue,
+                        data=meanDf, ax=self.canvas.axes)
 
-        elif plotType == "Box Plot":
+        elif plotType == 'Box Plot':
             if not xIsCategorical:
-                warningStr = "Box plot requires a categorical x statistic"
+                warningStr = 'Box plot requires a categorical x statistic'
             else:
-                g = sns.boxplot(
-                    x=xStat, y=yStat, hue=hue, data=meanDf, ax=self.canvas.axes
-                )
+                g = sns.boxplot(x=xStat, y=yStat, hue=hue,
+                        data=meanDf, ax=self.canvas.axes)
 
-        elif plotType == "Raw + Mean Plot":
+        elif plotType == 'Raw + Mean Plot':
             if not xIsCategorical:
-                warningStr = "Raw + Mean plot requires a categorical x statistic"
+                warningStr = 'Raw + Mean plot requires a categorical x statistic'
             else:
                 try:
                     # does not work here for categorical x
-                    # self.scatterPlotSelection, = self.canvas.axes[0].plot([], [], 'oy',
+                    #self.scatterPlotSelection, = self.canvas.axes[0].plot([], [], 'oy',
                     #                markersize=12, fillstyle='none')
 
-                    """
+                    '''
                     colorList = [('red'), ('green'), 'b', 'c', 'm', 'y']
                     hueList = meanDf[hue].unique()
                     palette = {}
                     for idx, hue in enumerate(hueList):
                         palette[hue] = colorList[idx]
                     print(palette)
-                    """
+                    '''
 
                     palette = sns.color_palette("Paired")
-                    # palette = ['r', 'g', 'b']
+                    #palette = ['r', 'g', 'b']
 
                     # stripplot
-                    # g = sns.swarmplot(x=xStat, y=yStat,
-                    g = sns.stripplot(
-                        x=xStat,
-                        y=yStat,
-                        hue=hue,
-                        palette=palette,
-                        data=meanDf,
-                        ax=self.canvas.axes,
-                        # color = color,
-                        dodge=True,
-                        alpha=0.6,
-                        picker=picker,
-                        zorder=1,
-                    )
+                    #g = sns.swarmplot(x=xStat, y=yStat,
+                    g = sns.stripplot(x=xStat, y=yStat,
+                            hue=hue,
+                            palette=palette,
+                            data=meanDf,
+                            ax=self.canvas.axes,
+                            #color = color,
+                            dodge=True,
+                            alpha=0.6,
+                            picker=picker,
+                            zorder=1)
+
 
-                    # g.legend().remove()
+                    #logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
                     self.canvas.axes.legend().remove()
 
+                    #logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
+                    print('\n\n\nREMAKING LEGEND\n\n\n')
                     handles, labels = self.canvas.axes.get_legend_handles_labels()
-                    l = self.canvas.axes.legend(
-                        handles[0:2],
-                        labels[0:2],
-                        bbox_to_anchor=(1.05, 1),
-                        loc=2,
-                        borderaxespad=0.0,
-                    )
+                    l = self.canvas.axes.legend(handles[0:2], labels[0:2], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
+                    #self.myLegend = self.canvas.axes.Legend(handles[0:2], labels[0:2], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
 
-                    """
+                    '''
                     if self.darkTheme:
                         color = 'w'
                     else:
                         color = 'k'
                     color = [color] * len(hueList)
                     print('color:', color)
-                    """
+                    '''
 
-                    self.whatWeArePlotting = sns.pointplot(
-                        x=xStat,
-                        y=yStat,
-                        hue=hue,
-                        # palette=palette,
-                        data=meanDf,
-                        estimator=np.nanmean,
-                        ci=68,
-                        capsize=0.1,
-                        ax=self.canvas.axes,
-                        color="r",
-                        # legend='full',
-                        zorder=10,
+                    self.whatWeArePlotting = sns.pointplot(x=xStat, y=yStat,
+                            hue=hue,
+                            #palette=palette,
+                            data=meanDf,
+                            estimator=np.nanmean,
+                            ci=68, capsize=0.1,
+                            ax=self.canvas.axes,
+                            color='r',
+                            #legend='full',
+                            #zorder=10)
                     )
-
-                except ValueError as e:
+                except (ValueError) as e:
                     print('EXCEPTION in "Raw + Mean Plot":', e)
                     traceback.print_exc()
 
-        elif plotType == "Regression Plot":
+        elif plotType == 'Regression Plot':
             # regplot does not have hue
             if xIsCategorical or yIsCategorical:
-                warningStr = "Regression plot requires continuous x and y statistics"
+                warningStr = 'Regression plot requires continuous x and y statistics'
             else:
                 # todo: loop and make a regplot
                 # for each unique() name in
                 # hue (like Region, Sex, Condition)
                 hueList = masterDf[hue].unique()
                 for oneHue in hueList:
-                    if oneHue == "None":
+                    if oneHue == 'None':
                         continue
-                    tmpDf = meanDf[meanDf[hue] == oneHue]
-                    # print('regplot oneHue:', oneHue, 'len(tmpDf)', len(tmpDf))
-                    sns.regplot(x=xStat, y=yStat, data=tmpDf, ax=self.canvas.axes)
+                    tmpDf = meanDf [ meanDf[hue]==oneHue ]
+                    #print('regplot oneHue:', oneHue, 'len(tmpDf)', len(tmpDf))
+                    sns.regplot(x=xStat, y=yStat, data=tmpDf,
+                            ax=self.canvas.axes);
         else:
-            print("  did not understand plot type:", plotType)
+            print('  did not understand plot type:', plotType)
+
 
         #
         # update
         self.canvas.axes.figure.canvas.mpl_connect("pick_event", self.onPick)
 
         self.mplCursorHover = None
-        if stateDict["doHover"] and self.whatWeArePlotting is not None:
+        if stateDict['doHover'] and self.whatWeArePlotting is not None:
             self.mplCursorHover = mplcursors.cursor(self.whatWeArePlotting, hover=True)
-
             @self.mplCursorHover.connect("add")
             def _(sel):
-                # sel.annotation.get_bbox_patch().set(fc="white")
-                sel.annotation.arrow_patch.set(
-                    arrowstyle="simple", fc="white", alpha=0.5
-                )
+                #sel.annotation.get_bbox_patch().set(fc="white")
+                sel.annotation.arrow_patch.set(arrowstyle="simple", fc="white", alpha=.5)
                 # row in df is from sel.target.index
-                # print('sel.target.index:', sel.target.index)
+                #print('sel.target.index:', sel.target.index)
                 ind = sel.target.index
                 annotationDict = self.getAnnotation(ind)
-                myText = ""
-                for k, v in annotationDict.items():
-                    myText += f"{k}: {v}\n"
+                myText = ''
+                for k,v in annotationDict.items():
+                    myText += f'{k}: {v}\n'
                 sel.annotation.set_text(myText)
 
         #
-        # self.mySetStatusBar(warningStr)
+        #self.mySetStatusBar(warningStr)
 
-        self.canvas.axes.spines["right"].set_visible(False)
-        self.canvas.axes.spines["top"].set_visible(False)
+        self.canvas.axes.spines['right'].set_visible(False)
+        self.canvas.axes.spines['top'].set_visible(False)
 
-        if not stateDict["showLegend"]:
-            self.canvas.axes.legend().remove()
+        if not stateDict['showLegend']:
+            #print('self.canvas.axes.legend():', self.canvas.axes.legend())
+            #print('self.canvas.axes.legend:', self.canvas.axes.legend)
+            #if self.canvas.axes.legend() is not None:
+            if 1:
+                #logger.error('!!!!!!!!!!!! grabbing get_legend_handles_labels()')
+                self.canvas.axes.legend().remove()
 
-        # print('myUpdate() self.plotSize:', self.plotSize)
+        #print('myUpdate() self.plotSize:', self.plotSize)
         self.canvas.axes.set_xlabel(xStatHuman)
         self.canvas.axes.set_ylabel(yStatHuman)
-        """
+        '''
         if self.plotSize == 'paper':
             fontsize = 10
             self.canvas.axes[0].set_xlabel(xStatHuman, fontsize=fontsize)
             self.canvas.axes[0].set_ylabel(yStatHuman, fontsize=fontsize)
         else:
             self.canvas.axes[0].set_xlabel(xStatHuman)
             self.canvas.axes[0].set_ylabel(yStatHuman)
-        """
+        '''
 
         # subplots_adjust
-        # self.fig.canvas.draw_idle()
+        #self.fig.canvas.draw_idle()
         self.fig.canvas.draw()
 
 
 class bScatterPlotMainWindow(QtWidgets.QMainWindow):
-    # send_fig = QtCore.pyqtSignal(str)
+    #send_fig = QtCore.pyqtSignal(str)
     signalStateChange = QtCore.Signal(object)
     signalSelectFromPlot = QtCore.Signal(object)
     signalCancelSelection = QtCore.Signal()
     signalMeanModelChange = QtCore.Signal(object)
     signal_xModelChange = QtCore.Signal(object)
     signal_yModelChange = QtCore.Signal(object)
 
-    def __init__(
-        self,
-        path,
-        categoricalList,
-        hueTypes,
-        analysisName,
-        sortOrder=None,
-        statListDict=None,
-        interfaceDefaults=None,
-        masterDf=None,
-        parent=None,
-    ):
+    def __init__(self, path,
+                    categoricalList, hueTypes, analysisName, sortOrder=None,
+                    statListDict=None,
+                    interfaceDefaults=None,
+                    masterDf=None,
+                    limitToCol=None,  # col like 'epoch' to create popup to limit to one value (like 0)
+                    parent=None):
         """
         path: full path to .csv file generated with reanalyze
         categoricalList: specify columns that are categorical
             would just like to use 'if column is string' but sometimes number like 1/2/3 need to be categorical
         hueTypes:
         analysisName: column used for group by
         sortOrder:
@@ -993,17 +1023,17 @@
                     used by main sanpy interface
         parent: not used, parent sanpy app
 
         todo: make pure text columns categorical
         todo: remove analysisName and add as 'groupby' popup from categorical columns
             depending on 'analysisName' popup, group differently in getMeanDf
         """
-        super(bScatterPlotMainWindow, self).__init__(parent)
+        super().__init__(parent)
 
-        # self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
+        #self.keepCheckBoxDelegate = myCheckBoxDelegate(None)
 
         if interfaceDefaults is None:
             interfaceDefaults = myInterfaceDefaults
         self.shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+w"), self)
         self.shortcut.activated.connect(self.myCloseAction)
 
         self.statusBar = QtWidgets.QStatusBar()
@@ -1013,129 +1043,156 @@
 
         self.buildMenus()
 
         # assigns self.masterDf
         # if masterDf is not None will use masterDf rather than loading path
         self.loadPath(path, masterDf=masterDf, categoricalList=categoricalList)
 
+        # dec 2022
+        self._limitToCol = limitToCol
+
         # statListDict is a dict with key=humanstat name and yStat=column name in csv
-        # self.statListDict = sanpy.bAnalysisUtil.getStatList()
+        #self.statListDict = sanpy.bAnalysisUtil.getStatList()
         # 20210305 done in loadPath()
         if statListDict is not None:
             self.statListDict = statListDict
             # append all categorical
             if categoricalList is not None:
                 for categorical in categoricalList:
-                    self.statListDict[categorical] = {"yStat": categorical}
-        """
+                    self.statListDict[categorical] = {'yStat':categorical}
+                    self.statListDict[categorical] = {'name':categorical}  # we need both yStat and name !!!
+
+        # statListDict now has categorical like 'File Number'
+        for k,v in self.statListDict.items():
+            print('    ', k, v)
+
+        '''
         if statListDict is None:
             # build statListDict from columns of csv path
             self.statListDict = {}
             for colStr in self.masterDfColumns:
                 self.statListDict[colStr] = {'yStat': colStr}
         else:
             self.statListDict = statListDict
-        """
+        '''
 
-        # categoricalList = ['Condition', 'Sex', 'Region', 'File Number', 'File Name']
+        #categoricalList = ['Condition', 'Sex', 'Region', 'File Number', 'File Name']
         # 20210305 done in load path
-        """
+        '''
         for categorical in categoricalList:
             self.statListDict[categorical] = {'yStat': categorical}
         # this was originally in self.load() ???
         self.masterCatColumns = categoricalList
-        """
+        '''
 
-        """
+        '''
         self.stateDict = {}
         self.stateDict['groupByColumnName'] = analysisName
         self.stateDict['sortOrder'] = sortOrder
         self.stateDict['hue'] = hue
         self.stateDict['darkTheme'] = True
         self.stateDict['doKDE'] = False
         self.stateDict['doHover'] = False
         self.stateDict['plotSize'] = 'paper'
         self.stateDict['showLegend'] = True
         self.stateDict['plotType'] = 'Scatter Plot'
         self.stateDict['dataType'] = 'File Mean'
-        """
+        '''
 
         # unique identifyer to group by
         # for sanpy this is 'analysisName', for bImPy this is xxx
         self.groupByColumnName = analysisName
         self.sortOrder = sortOrder
 
         # 20210112 moved up
-        # self.loadPath(path)
+        #self.loadPath(path)
 
-        self.whatWeArePlotting = None  # return from sns scatter plot (all plots)
+        self.whatWeArePlotting = None # return from sns scatter plot (all plots)
         self.scatterPlotSelection = None
-        self.xDf = None  #
-        self.yDf = None  #
-        self.plotDF = None  # df we are plotting (can be same as mean yDf)
-        # use this to get row on self.onPick
+        self.xDf = None #
+        self.yDf = None #
+        self.plotDF = None # df we are plotting (can be same as mean yDf)
+                            # use this to get row on self.onPick
         self.plotStatx = None
         self.plotStaty = None
 
-        # self.main_widget = QtWidgets.QWidget(self)
+        #self.main_widget = QtWidgets.QWidget(self)
 
         # this is causing tons of problems/crashes
-        if interfaceDefaults["Hue"] is not None:
-            self.hue = interfaceDefaults["Hue"]
+        if interfaceDefaults['Hue'] is not None:
+            self.hue = interfaceDefaults['Hue']
         else:
-            self.hue = "None"  # self.hueTypes[0]
+            self.hue = 'None' #self.hueTypes[0]
 
         self.darkTheme = False
-        self.doKDE = False  # fits on histogram plots
-        self.showMplToolbar = False  # fits on histogram plots
+        self.doKDE = False # fits on histogram plots
+        self.showMplToolbar = False # fits on histogram plots
 
         self.doHover = False
 
-        self.plotSizeList = ["paper", "talk", "poster"]
-        self.plotSize = "paper"
-        self.plotLayoutList = ["1x", "1x2", "2x1", "2x2"]
-        self.plotLayoutType = "2x2"
-        self.updatePlot = None  # which plot to update 1,2,3,4
+        self.plotSizeList = ['paper', 'talk', 'poster']
+        self.plotSize = 'paper'
+        self.plotLayoutList = ['1x', '1x2', '2x1', '2x2']
+        self.plotLayoutType = '2x2'
+        self.updatePlot = None # which plot to update 1,2,3,4
 
         self.showLegend = False
-        self.plotType = "Scatter Plot"
+        self.plotType = 'Scatter Plot'
 
-        self.dataTypes = ["All Spikes", "File Mean"]
-        self.dataType = "File Mean"  # (Raw, File Mean)
+        self.dataTypes = ['All Spikes', 'File Mean']
+        self.dataType = 'File Mean' # (Raw, File Mean)
 
         self.buildUI(interfaceDefaults=interfaceDefaults)
 
-        # bar = self.menuBar()
-        # file = bar.addMenu("Load")
+        #bar = self.menuBar()
+        #file = bar.addMenu("Load")
 
-        self.show()
+        # abb removed 20210828
+        #self.show()
 
         # self.updatePlotSize() # calls update2()
         self.update2()
 
+    def _mySetWindowTitle(self, windowTitle):
+        """Required to interact with sanpyPlugin."""
+        self.setWindowTitle(windowTitle)
+
+    def _buildPlotOptionsLayout(self):
+        hBoxLayout = QtWidgets.QHBoxLayout()
+
+        hueList = ['None'] + self.hueTypes # prepend 'None'
+        hueDropdown = QtWidgets.QComboBox()
+        hueDropdown.addItems(hueList)
+        # if interfaceDefaults['Hue'] is not None:
+        #     defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults['Hue'])
+        # else:
+        #     defaultIdx = 0
+        defaultIdx = 0
+        hueDropdown.setCurrentIndex(defaultIdx) # 1 because we pre-pended 'None'
+        hueDropdown.currentIndexChanged.connect(self.updateHue)
+
+        hBoxLayout.addWidget(hueDropdown)
+        return hBoxLayout
+
     def buildUI(self, interfaceDefaults):
-        # if self.darkTheme:
-        #     plt.style.use('dark_background')
         if self.darkTheme:
-            plt.style.use("dark_background")
-        else:
-            plt.rcParams.update(plt.rcParamsDefault)
+            plt.style.use('dark_background')
 
         # HBox for control and plot grid
         self.hBoxLayout = QtWidgets.QHBoxLayout(self)
 
         # this is confusing, beacaue we are a QMainWindow
         # we need to create a central widget, set its layout
         # and then set the central widget of self (QMainWindow)
         centralWidget = QtWidgets.QWidget()
         centralWidget.setLayout(self.hBoxLayout)
         self.setCentralWidget(centralWidget)
 
         # switch to 2x2
-        """
+        '''
         # allow 1-4 plots
         tmpNumRow = 1
         tmpNumCol = 1
         numPlot = tmpNumRow * tmpNumCol
 
         self.fig = Figure()
         self.fig.tight_layout()
@@ -1146,385 +1203,426 @@
         # maybe use
         #self.toolbar = NavigationToolbar(self.canvas, self)
         self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
 
         self.canvas.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                                   QtWidgets.QSizePolicy.Expanding)
         self.canvas.updateGeometry()
-        """
+        '''
 
         # to hold popups
         self.layout = QtWidgets.QGridLayout()
         self.hBoxLayout.addLayout(self.layout)
 
         def _defaultDropdownIdx(keyList, name):
             # if name not in keys, return 0
             theRet = 0
             try:
                 theRet = keyList.index(name)
-            except ValueError as e:
-                print(
-                    f'WARNING: _defaultDropdownIdx() did not find "{name}"" in keyList: {keyList}'
-                )
+            except (ValueError) as e:
+                print(f'WARNING: _defaultDropdownIdx() did not find "{name}"" in keyList: {keyList}')
                 theRet = 0
             return theRet
 
+        # removed 20210828
+        '''
         keys = list(self.statListDict.keys())
-        # keys += self.hueTypes
+        #keys += self.hueTypes
         self.xDropdown = QtWidgets.QComboBox()
         self.xDropdown.addItems(keys)
-        if interfaceDefaults["X Statistic"] is not None:
-            defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults["X Statistic"])
+        if interfaceDefaults['X Statistic'] is not None:
+            defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults['X Statistic'])
         else:
             defaultIdx = 0
         self.xDropdown.setCurrentIndex(defaultIdx)
+        self.xDropdown.currentIndexChanged.connect(self.update2)
 
         self.yDropdown = QtWidgets.QComboBox()
         self.yDropdown.addItems(keys)
-        if interfaceDefaults["Y Statistic"] is not None:
-            defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults["Y Statistic"])
+        if interfaceDefaults['Y Statistic'] is not None:
+            defaultIdx = _defaultDropdownIdx(keys, interfaceDefaults['Y Statistic'])
         else:
             defaultIdx = 0
         self.yDropdown.setCurrentIndex(defaultIdx)
+        self.yDropdown.currentIndexChanged.connect(self.update2)
+        '''
 
         #
         # hue, to control colors in plot
-        hueList = ["None"] + self.hueTypes  # prepend 'None'
+        hueList = ['None'] + self.hueTypes # prepend 'None'
         self.hueDropdown = QtWidgets.QComboBox()
         self.hueDropdown.addItems(hueList)
-        if interfaceDefaults["Hue"] is not None:
-            defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults["Hue"])
+        if interfaceDefaults['Hue'] is not None:
+            defaultIdx = _defaultDropdownIdx(hueList, interfaceDefaults['Hue'])
         else:
             defaultIdx = 0
-        self.hueDropdown.setCurrentIndex(defaultIdx)  # 1 because we pre-pended 'None'
+        self.hueDropdown.setCurrentIndex(defaultIdx) # 1 because we pre-pended 'None'
         self.hueDropdown.currentIndexChanged.connect(self.updateHue)
 
         #
         # group by, to control grouping in table
         # todo: get 'None' implemented
-        # groupByList = ['None'] + self.hueTypes # prepend 'None'
+        #groupByList = ['None'] + self.hueTypes # prepend 'None'
         groupByList = self.hueTypes
         self.groupByDropdown = QtWidgets.QComboBox()
         self.groupByDropdown.addItems(groupByList)
-        if interfaceDefaults["Group By"] is not None:
-            defaultIdx = _defaultDropdownIdx(groupByList, interfaceDefaults["Group By"])
+        if interfaceDefaults['Group By'] is not None:
+            defaultIdx = _defaultDropdownIdx(groupByList, interfaceDefaults['Group By'])
         else:
             defaultIdx = 0
-        self.groupByDropdown.setCurrentIndex(
-            defaultIdx
-        )  # 1 because we pre-pended 'None'
+        self.groupByDropdown.setCurrentIndex(defaultIdx) # 1 because we pre-pended 'None'
         self.groupByDropdown.currentIndexChanged.connect(self.updateGroupBy)
 
         # color
-        # colorTypes = ['Region', 'Sex', 'Condition', 'File Number'] #, 'File Name'] #, 'None']
-        # self.color = 'Region'
-        """
+        #colorTypes = ['Region', 'Sex', 'Condition', 'File Number'] #, 'File Name'] #, 'None']
+        #self.color = 'Region'
+        '''
         self.color = self.colorTypes[0]
         self.colorDropdown = QtWidgets.QComboBox()
         self.colorDropdown.addItems(self.colorTypes)
         self.colorDropdown.setCurrentIndex(0)
         self.colorDropdown.currentIndexChanged.connect(self.updateColor)
-        """
+        '''
 
         self.typeDropdown = QtWidgets.QComboBox()
-        self.typeDropdown.addItems(
-            [
-                "Scatter Plot",
-                "Scatter + Raw + Mean",
-                "Regression Plot",
-                "Violin Plot",
-                "Box Plot",
-                "Raw + Mean Plot",
-                "Histogram",
-                "Cumulative Histogram",
-            ]
-        )
+        self.typeDropdown.addItems(['Scatter Plot', 'Scatter + Raw + Mean', 'Regression Plot', 'Violin Plot', 'Box Plot', 'Raw + Mean Plot', 'Histogram', 'Cumulative Histogram'])
         self.typeDropdown.setCurrentIndex(0)
+        self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
 
         self.dataTypeDropdown = QtWidgets.QComboBox()
-        self.dataTypeDropdown.setToolTip(
-            "All Spikes is all spikes \n File Mean is the mean within each analysis file"
-        )
+        self.dataTypeDropdown.setToolTip('All Spikes is all spikes \n File Mean is the mean within each analysis file')
         self.dataTypeDropdown.addItems(self.dataTypes)
         self.dataTypeDropdown.setCurrentIndex(1)
-
-        self.xDropdown.currentIndexChanged.connect(self.update2)
-        self.yDropdown.currentIndexChanged.connect(self.update2)
-        self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
         self.dataTypeDropdown.currentIndexChanged.connect(self.updateDataType)
 
-        showLegendCheckBox = QtWidgets.QCheckBox("Legend")
+        #self.xDropdown.currentIndexChanged.connect(self.update2)
+        #self.yDropdown.currentIndexChanged.connect(self.update2)
+        #self.typeDropdown.currentIndexChanged.connect(self.updatePlotType)
+        #self.dataTypeDropdown.currentIndexChanged.connect(self.updateDataType)
+
+        showLegendCheckBox = QtWidgets.QCheckBox('Legend')
         showLegendCheckBox.setChecked(self.showLegend)
         showLegendCheckBox.stateChanged.connect(self.setShowLegend)
 
         # swap the sort order
-        swapSortButton = QtWidgets.QPushButton("Swap Sort Order")
-        swapSortButton.clicked.connect(self.setSwapSort)
+        aName = 'Swap Sort Order'
+        swapSortButton = QtWidgets.QPushButton(aName)
+        swapSortButton.clicked.connect(partial(self.on_button_click, aName))
         # works fine
-        """
+        '''
         darkThemeCheckBox = QtWidgets.QCheckBox('Dark Theme')
         darkThemeCheckBox.setChecked(self.darkTheme)
         darkThemeCheckBox.stateChanged.connect(self.setTheme)
         darkThemeCheckBox.setDisabled(True)
         darkThemeCheckBox.setEnabled(False)
-        """
+        '''
 
-        """
+        '''
         kdeCheckBox = QtWidgets.QCheckBox('kde (hist)')
         kdeCheckBox.setChecked(self.doKDE)
         kdeCheckBox.stateChanged.connect(self.setKDE)
-        """
-        mplToolbar = QtWidgets.QCheckBox("Toolbar")
+        '''
+        mplToolbar = QtWidgets.QCheckBox('Toolbar')
         mplToolbar.setChecked(self.showMplToolbar)
         mplToolbar.stateChanged.connect(self.setMplToolbar)
 
-        hoverCheckbox = QtWidgets.QCheckBox("Hover Info")
+        hoverCheckbox = QtWidgets.QCheckBox('Hover Info')
         hoverCheckbox.setChecked(self.doHover)
         hoverCheckbox.stateChanged.connect(self.setHover)
 
         # work fine
-        """
+        '''
         self.plotSizeDropdown = QtWidgets.QComboBox()
         self.plotSizeDropdown.setToolTip('Set size of fonts for paper, talk, or poster')
         self.plotSizeDropdown.addItems(self.plotSizeList)
         self.plotSizeDropdown.setCurrentIndex(0) # paper
         self.plotSizeDropdown.currentIndexChanged.connect(self.updatePlotSize)
         self.plotSizeDropdown.setDisabled(True)
-        """
+        '''
 
         # works fine
-        """
+        '''
         self.plotLayoutDropdown = QtWidgets.QComboBox()
         self.plotLayoutDropdown.setToolTip('1, 2, or 4 plots')
         self.plotLayoutDropdown.addItems(self.plotLayoutList)
         self.plotLayoutDropdown.setCurrentIndex(3) #
         self.plotLayoutDropdown.currentIndexChanged.connect(self.updatePlotLayout)
         self.plotLayoutDropdown.setDisabled(True)
-        """
+        '''
 
         # not needed beccause we now clik plot to show red square
-        """
+        '''
         self.plotUpdateList = ['1', '2', '3', '4']
         self.plotUpdateDropdown = QtWidgets.QComboBox()
         self.plotUpdateDropdown.setToolTip('Which plot to update')
         self.plotUpdateDropdown.addItems(self.plotUpdateList)
         self.plotUpdateDropdown.setCurrentIndex(0) # paper
         self.plotUpdateDropdown.currentIndexChanged.connect(self.updatePlotUpdate)
-        """
+        '''
+
+        # 20210828
+        # table view of x stat
+        row = 4
+        col = 0
+        rowSpan = 1
+        colSpan = 2
+        self.xStatTableView = myStatListWidget(myParent=self, headerStr='X-Stat', statList=self.statListDict)
+        self.layout.addWidget(self.xStatTableView, row, col, rowSpan, colSpan)
+        # table view of y stat
+        row = 4
+        col = 2
+        rowSpan = 1
+        colSpan = 2
+        self.yStatTableView = myStatListWidget(myParent=self, headerStr='Y-Stat', statList=self.statListDict)
+        self.layout.addWidget(self.yStatTableView, row, col, rowSpan, colSpan)
 
-        self.layout.addWidget(QtWidgets.QLabel("X Statistic"), 0, 0)
-        self.layout.addWidget(self.xDropdown, 0, 1)
-        self.layout.addWidget(QtWidgets.QLabel("Y Statistic"), 1, 0)
-        self.layout.addWidget(self.yDropdown, 1, 1)
-        self.layout.addWidget(QtWidgets.QLabel("Hue"), 2, 0)
-        self.layout.addWidget(self.hueDropdown, 2, 1)
-        self.layout.addWidget(QtWidgets.QLabel("Group By"), 3, 0)
-        self.layout.addWidget(self.groupByDropdown, 3, 1)
-        # self.layout.addWidget(QtWidgets.QLabel("Color"), 3, 0)
-        # self.layout.addWidget(self.colorDropdown, 3, 1)
-        #
-        self.layout.addWidget(QtWidgets.QLabel("Plot Type"), 0, 2)
-        self.layout.addWidget(self.typeDropdown, 0, 3)
-        self.layout.addWidget(QtWidgets.QLabel("Data Type"), 1, 2)
-        self.layout.addWidget(self.dataTypeDropdown, 1, 3)
-        self.layout.addWidget(showLegendCheckBox, 2, 2)
+        col = 0
+        # removed 20210828
+        '''
+        self.layout.addWidget(QtWidgets.QLabel("X Statistic"), 0, col)
+        self.layout.addWidget(self.xDropdown, 0, col+1)
+        self.layout.addWidget(QtWidgets.QLabel("Y Statistic"), 1, col)
+        self.layout.addWidget(self.yDropdown, 1, col+1)
+        '''
+        
+        aName = 'Replot'
+        aButton = QtWidgets.QPushButton(aName)
+        aButton.clicked.connect(partial(self.on_button_click, aName))
+        self.layout.addWidget(aButton, 1, 0)
+
+        self.layout.addWidget(QtWidgets.QLabel("Hue (Plot)"), 2, col)
+        self.layout.addWidget(self.hueDropdown, 2, col+1)
+
+        self.layout.addWidget(QtWidgets.QLabel("Group By (Stats)"), 3, col)
+        self.layout.addWidget(self.groupByDropdown, 3, col+1)
+        #self.layout.addWidget(QtWidgets.QLabel("Color"), 3, 0)
+        #self.layout.addWidget(self.colorDropdown, 3, 1)
+
+        #dec2022
+        # print(self._limitToCol)
+        # self.limitToDropdown = QtWidgets.QComboBox()
+        # if self._limitToCol is not None:
+        #     self.limitToDropdown.addItem('None')
+        #     for _x in self._limitToCol:
+        #         self.limitToDropdown.addItem(_x)
+        # self.limitToDropdown.setCurrentIndex(0)
+        # self.limitToDropdown.currentIndexChanged.connect(self.updateLimitTo)
+        # self.layout.addWidget(self.limitToDropdown, 3, col+1)
+
+        #
+        col += 2
+        self.layout.addWidget(QtWidgets.QLabel("Plot Type"), 0, col)
+        self.layout.addWidget(self.typeDropdown, 0, col+1)
+        self.layout.addWidget(QtWidgets.QLabel("Data Type"), 1, col)
+        self.layout.addWidget(self.dataTypeDropdown, 1, col+1)
+        self.layout.addWidget(showLegendCheckBox, 2, col)
         # works fine
-        # self.layout.addWidget(darkThemeCheckBox, 2, 3)
-        self.layout.addWidget(swapSortButton, 2, 3)
-        self.layout.addWidget(mplToolbar, 3, 2)
-        self.layout.addWidget(hoverCheckbox, 3, 3)
+        #self.layout.addWidget(darkThemeCheckBox, 2, 3)
+        self.layout.addWidget(swapSortButton, 2, col+1)
+        self.layout.addWidget(mplToolbar, 3, col)
+        self.layout.addWidget(hoverCheckbox, 3, col+1)
+
         # works fine
-        # self.layout.addWidget(QtWidgets.QLabel("Plot Size"), 4, 2)
-        # self.layout.addWidget(self.plotSizeDropdown, 4, 3)
+        #self.layout.addWidget(QtWidgets.QLabel("Plot Size"), 4, 2)
+        #self.layout.addWidget(self.plotSizeDropdown, 4, 3)
         # works fine
-        # self.layout.addWidget(QtWidgets.QLabel("Plot Layout"), 4, 0) # out of order
-        # self.layout.addWidget(self.plotLayoutDropdown, 4, 1)
+        #self.layout.addWidget(QtWidgets.QLabel("Plot Layout"), 4, 0) # out of order
+        #self.layout.addWidget(self.plotLayoutDropdown, 4, 1)
 
-        # self.layout.addWidget(QtWidgets.QLabel("Update Plot"), 5, 0) # out of order
-        # self.layout.addWidget(self.plotUpdateDropdown, 5, 1)
+        #self.layout.addWidget(QtWidgets.QLabel("Update Plot"), 5, 0) # out of order
+        #self.layout.addWidget(self.plotUpdateDropdown, 5, 1)
 
-        nextRow = 5  # for text table
+        nextRow = 5 # for text table
         rowSpan = 1
-        colSpan = 4
-        # self.layout.addWidget(self.canvas, 3, 0, rowSpan, colSpan)
+        colSpan = 5
+        #self.layout.addWidget(self.canvas, 3, 0, rowSpan, colSpan)
 
         #
         # grid of plots (myMplCanvas)
         self.plotLayout = QtWidgets.QGridLayout()
-        self.plotLayout.setContentsMargins(0, 0, 0, 0)
+        self.plotLayout.setContentsMargins(0,0,0,0)
         self.plotLayout.setHorizontalSpacing(0)
         self.plotLayout.setVerticalSpacing(0)
 
         self.myPlotCanvasList = [None] * 4
 
         self.updatePlotLayoutGrid()
 
         # append
         self.hBoxLayout.addLayout(self.plotLayout)
 
-        """
+        '''
         self.myToolbar = QtWidgets.QToolBar()
         self.myToolbar.setFloatable(True)
         self.myToolbar.setMovable(True)
         self.tmpToolbarAction = self.myToolbar.addWidget(self.canvas)
         self.addToolBar(QtCore.Qt.RightToolBarArea, self.myToolbar)
-        """
+        '''
 
+        #
+        # tabs to show (raw, x, y) stat tables
         tabwidget = QtWidgets.QTabWidget()
 
         # hold main df database (imutable except for 'include'
-        self.rawTableView = myTableView("All Spikes")
+        # table-view to insert into tab
+        self.rawTableView = myTableView('All Spikes')
         self.rawTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.rawTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.rawTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.rawTableView.slotSwitchTableDf(self.masterDf)
 
         # self.xDf
-        self.xTableView = myTableView("File Mean")
+        # table-view to insert into tab
+        self.xTableView = myTableView('File Mean')
         self.xTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.xTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.xTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.xTableView.slotSwitchTableDf(self.xDf)
 
         # self.yDf
-        self.yTableView = myTableView("File Mean")
+        self.yTableView = myTableView('File Mean')
+        # table-view to insert into tab
         self.yTableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.yTableView.clearSelection)
         self.signalSelectFromPlot.connect(self.yTableView.slotSelectRow)
         # never switch rawTableView model, dust update column 'include'
-        # self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
+        #self.signalMeanModelChange.connect(self.rawTableView.slotSwitchTableModel)
         self.yTableView.slotSwitchTableDf(self.yDf)
 
         # todo: make this mean across yDf with stat test
         # mean table with pandas dataframe
-        """
+        '''
         self.tableView = myTableView('Not Sure')
         self.tableView.clicked.connect(self.slotTableViewClicked)
         self.signalCancelSelection.connect(self.tableView.clearSelection)
         self.signalSelectFromPlot.connect(self.tableView.slotSelectRow)
         self.signalMeanModelChange.connect(self.tableView.slotSwitchTableModel)
-        """
+        '''
 
         #
-        # self.layout.addWidget(self.tableView, nextRow, 0, rowSpan, colSpan)
-        tabwidget.addTab(self.rawTableView, "Raw")
-        # tabwidget.addTab(self.tableView, "Mean")
-        tabwidget.addTab(self.xTableView, "X-Stats")
-        tabwidget.addTab(self.yTableView, "Y-Stats")
-        self.layout.addWidget(tabwidget, nextRow, 0, rowSpan, colSpan)
+        #self.layout.addWidget(self.tableView, nextRow, 0, rowSpan, colSpan)
+        tabwidget.addTab(self.xTableView, 'X-Stats')
+        tabwidget.addTab(self.yTableView, 'Y-Stats')
+        tabwidget.addTab(self.rawTableView, 'Raw')
+        #tabwidget.addTab(self.tableView, "Mean")
+        rowSpan = 1
+        colSpan = 5
+        self.layout.addWidget(tabwidget, nextRow, 0, rowSpan, colSpan) # add widget takes ownership
+
+        # 20210828
+        #self.setLayout(self.layout)
 
     def updatePlotLayoutGrid(self):
         """
         use this to switch between (1x, 1x2, 2x1, 2x2)
         """
 
-        print("updatePlotLayoutGrid()")
-        plotLayoutType = self.plotLayoutType  # 1x, 1x2, 2x1, 2x2
-        if plotLayoutType == "1x":
+        print('updatePlotLayoutGrid()')
+        plotLayoutType = self.plotLayoutType # 1x, 1x2, 2x1, 2x2
+        if plotLayoutType == '1x':
             numPlots = 1
-        elif plotLayoutType == "1x2":
+        elif plotLayoutType == '1x2':
             numPlots = 2
-        elif plotLayoutType == "2x1":
+        elif plotLayoutType == '2x1':
             numPlots = 2
-        elif plotLayoutType == "2x2":
+        elif plotLayoutType == '2x2':
             numPlots = 4
 
         # remove all widgets from self.plotLayout
         n = self.plotLayout.count()
         for i in range(n):
             item = self.plotLayout.itemAt(i)
             if item is None:
-                print("  warning: updatePlotLayoutGrid() got None item at step", i)
+                print('  warning: updatePlotLayoutGrid() got None item at step', i)
                 continue
             widget = item.widget()
-            print("  updatePlotLayoutGrid() removing i:", i, "item:", type(item))
+            print('  updatePlotLayoutGrid() removing i:', i, 'item:', type(item))
             self.plotLayout.removeWidget(widget)
-            # self.plotLayout.removeItem(item)
+            #self.plotLayout.removeItem(item)
 
         state = self.getState()
         for i in range(numPlots):
-            if i == 0:
+            if i==0:
                 row = 0
                 col = 0
-            elif i == 1:
-                if plotLayoutType == "1x2":
+            elif i==1:
+                if plotLayoutType == '1x2':
                     row = 0
                     col = 1
-                elif plotLayoutType == "2x1":
+                elif plotLayoutType == '2x1':
                     row = 1
                     col = 0
-                elif plotLayoutType == "2x2":
+                elif plotLayoutType == '2x2':
                     row = 0
                     col = 1
-            elif i == 2:
+            elif i==2:
                 row = 1
                 col = 0
-            elif i == 3:
+            elif i==3:
                 row = 1
                 col = 1
             #
             oneCanvas = myMplCanvas(plotNumber=i)
-            oneCanvas.myUpdate(state)  # initial plot
+            oneCanvas.myUpdate(state) # initial plot
             self.signalCancelSelection.connect(oneCanvas.slotCancelSelection)
             self.myPlotCanvasList[i] = oneCanvas
 
             #
             self.plotLayout.addWidget(oneCanvas, row, col)
 
         # connect each canvas to all other canvas
         for i in range(numPlots):
             iCanvas = self.myPlotCanvasList[i]
             iCanvas.signalSelectSquare.connect(self.slotSelectSquare)
             iCanvas.signalSelectFromPlot.connect(self.slotSelectFromPlot)
             for j in range(numPlots):
-                # if i==j:
+                #if i==j:
                 #    continue
                 jCanvas = self.myPlotCanvasList[j]
                 iCanvas.signalSelectFromPlot.connect(jCanvas.slotSelectInd)
                 iCanvas.signalSelectSquare.connect(jCanvas.slotSelectSquare)
 
         #
         # select the firsr plot
-        self.myPlotCanvasList[0].signalSelectSquare.emit(0, None)  # slotSelectSquare(0)
+        self.myPlotCanvasList[0].signalSelectSquare.emit(0, None) #slotSelectSquare(0)
 
     def keyPressEvent(self, event):
-        print("keyPressEvent()")
+        logger.info('keyPressEvent()')
         if event.key() == QtCore.Qt.Key_Escape:
             self.cancelSelection()
-        elif event.type() == QtCore.QEvent.KeyPress and event.matches(
-            QtGui.QKeySequence.Copy
-        ):
+        elif (event.type() == QtCore.QEvent.KeyPress and
+                        event.matches(QtGui.QKeySequence.Copy)):
             self.copySelection2()
         #
         event.accept()
 
     def copySelection2(self):
         dfCopy = None
         if self.xDf is not None:
             dfCopy = self.xDf.copy()
-            # self.xDf.to_clipboard(sep='\t', index=False)
-            # print('Copied to clipboard')
-            # print(self.xDf)
+            #self.xDf.to_clipboard(sep='\t', index=False)
+            #print('Copied to clipboard')
+            #print(self.xDf)
         if self.yDf is not None:
             if dfCopy is None:
                 dfCopy = self.yDf.copy()
             else:
                 # append row then yDf
                 dfCopy.append(pd.Series(), ignore_index=True)
                 dfCopy.append(self.yDf, ignore_index=True)
-            # self.yDf.to_clipboard(sep='\t', index=False)
-            # print('Copied to clipboard')
-            # print(self.yDf)
+            #self.yDf.to_clipboard(sep='\t', index=False)
+            #print('Copied to clipboard')
+            #print(self.yDf)
         #
         if dfCopy is not None:
-            dfCopy.to_clipboard(sep="\t", index=False)
+            dfCopy.to_clipboard(sep='\t', index=False)
             print(dfCopy)
 
     """
     def eventFilter(self, source, event):
         if (event.type() == QtCore.QEvent.KeyPress and
                         event.matches(QtGui.QKeySequence.Copy)):
             self.copySelection2()
@@ -1535,99 +1633,99 @@
     def cancelSelection(self):
         self.signalCancelSelection.emit()
 
     def _switchTableModel(self, newModel):
         """
         switch model for mean table (Self.xxx)
         """
-        # print('bScatterPlotMainWindow._switchTableModel()')
+        #print('bScatterPlotMainWindow._switchTableModel()')
         self.signalMeanModelChange.emit(newModel)
 
     def getState(self):
         """
         query all controls and create dict with state
 
         used by myMplCanvas.update()
         """
         stateDict = {}
 
-        stateDict["dataType"] = self.dataType  # ['All spikes', 'File Mean']
-        stateDict["groupByColumnName"] = self.groupByColumnName
+        stateDict['dataType'] = self.dataType # ['All spikes', 'File Mean']
+        stateDict['groupByColumnName'] = self.groupByColumnName
 
         plotType = self.plotType
-        stateDict["plotType"] = plotType
+        stateDict['plotType'] = plotType
 
-        xStatHuman = self.xDropdown.currentText()
-        yStatHuman = self.yDropdown.currentText()
-        stateDict["xStatHuman"] = xStatHuman
-        stateDict["yStatHuman"] = yStatHuman
-        xStat = self.statListDict[xStatHuman]["yStat"]  # statListDict always used yStat
-        yStat = self.statListDict[yStatHuman]["yStat"]
-        stateDict["xStat"] = xStat
-        stateDict["yStat"] = yStat
-        stateDict["xIsCategorical"] = pd.api.types.is_string_dtype(
-            self.masterDf[xStat].dtype
-        )
-        stateDict["yIsCategorical"] = pd.api.types.is_string_dtype(
-            self.masterDf[yStat].dtype
-        )
+        # was this, replacing dropdown with listview
+        #xStatHuman = self.xDropdown.currentText()
+        #yStatHuman = self.yDropdown.currentText()
+        xStatHuman, xStat = self.xStatTableView.getCurrentStat()
+        yStatHuman, yStat = self.yStatTableView.getCurrentStat()
+
+        stateDict['xStatHuman'] = xStatHuman
+        stateDict['yStatHuman'] = yStatHuman
+        #xStat = self.statListDict[xStatHuman]['yStat'] # statListDict always used yStat
+        #yStat = self.statListDict[yStatHuman]['yStat']
+        stateDict['xStat'] = xStat
+        stateDict['yStat'] = yStat
+        stateDict['xIsCategorical'] = pd.api.types.is_string_dtype(self.masterDf[xStat].dtype)
+        stateDict['yIsCategorical'] = pd.api.types.is_string_dtype(self.masterDf[yStat].dtype)
 
-        if self.hue == "None":
+        if self.hue == 'None':
             # special case, we do not want None in self.statNameMap
             hue = None
         else:
             hue = self.hue
-        stateDict["hue"] = hue
+        stateDict['hue'] = hue
 
-        stateDict["darkTheme"] = self.darkTheme
-        stateDict["showLegend"] = self.showLegend
-        stateDict["doHover"] = self.doHover
-        stateDict["showMplToolbar"] = self.showMplToolbar
+        stateDict['darkTheme'] = self.darkTheme
+        stateDict['showLegend'] = self.showLegend
+        stateDict['doHover'] = self.doHover
+        stateDict['showMplToolbar'] = self.showMplToolbar
 
-        if self.dataType == "All Spikes":
+        if self.dataType == 'All Spikes':
             meanDf = self.masterDf
             if self.sortOrder is not None:
                 # need to sort so onPick works
-                print("  ", "(1) sorting by self.sortOrder:", self.sortOrder)
+                print('  ', '(1) sorting by self.sortOrder:', self.sortOrder)
                 meanDf = meanDf.sort_values(self.sortOrder)
 
             # remove rows that have nan in our x or y stat
             meanDf = meanDf[~meanDf[xStat].isnull()]
             meanDf = meanDf[~meanDf[yStat].isnull()]
             meanDf = meanDf.reset_index()
 
-        elif self.dataType == "File Mean":
+        elif self.dataType == 'File Mean':
             meanDf = self.getMeanDf(xStat, yStat)
         else:
-            print("error in self.dataType:", self.dataType)
+            print('error in self.dataType:', self.dataType)
 
-        stateDict["masterDf"] = self.masterDf
-        stateDict["meanDf"] = meanDf
+        stateDict['masterDf'] = self.masterDf
+        stateDict['meanDf'] = meanDf
         return stateDict
 
     def myCloseAction(self):
-        print("myCloseAction()")
+        print('myCloseAction()')
 
     def mySetStatusBar(self, text):
-        self.statusBar.showMessage(text)  # ,2000)
+        self.statusBar.showMessage(text) #,2000)
 
-    """
+    '''
     def copyTable(self):
         headerList = []
         for i in self.tableView.model().columnCount():
             headers.append(self.tableView.model().headerData(i, QtCore.Qt.Horizontal).toString()
         print('copyTable()')
         print('  headers:', headers)
         m = self.tableView.rowCount()
         n = self.tableView.columnCount()
         table = [[''] * n for x in range(m+1)]
         #for i in m:
-    """
+    '''
 
-    """
+    '''
     def copySelection(self):
         #self.copyTable()
 
         selection = self.tableView.selectedIndexes()
         if selection:
             rows = sorted(index.row() for index in selection)
             columns = sorted(index.column() for index in selection)
@@ -1637,193 +1735,184 @@
             for index in selection:
                 row = index.row() - rows[0]
                 column = index.column() - columns[0]
                 table[row][column] = index.data()
             stream = io.StringIO()
             csv.writer(stream).writerows(table)
             QtWidgets.QApplication.clipboard().setText(stream.getvalue())
-    """
+    '''
 
     def buildMenus(self):
-        loadAction = QtWidgets.QAction("Load database.xlsx", self)
+        loadAction = QtWidgets.QAction('Load database.xlsx', self)
         loadAction.triggered.connect(self.loadPathMenuAction)
 
         menubar = self.menuBar()
-        fileMenu = menubar.addMenu("&File")
+        fileMenu = menubar.addMenu('&File')
         fileMenu.addAction(loadAction)
 
     def loadPathMenuAction(self):
         """
         prompt user for database.xlsx
         run reanalyze.py on that xlsx database
         load resultant _master.csv
         """
-        print("loadPathMenuAction")
+        print('loadPathMenuAction')
 
     def loadPath(self, path, masterDf=None, categoricalList=None):
         """
         path: full path to .csv file generated with reanalyze.py
         """
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
         if masterDf is not None:
             self.masterDf = masterDf
         else:
-            if path.endswith(".csv"):
-                self.masterDf = pd.read_csv(
-                    path, header=0
-                )  # , dtype={'ABF File': str})
-            elif path.endswith(".xls"):
-                self.masterDf = pd.read_excel(
-                    path, header=0
-                )  # , dtype={'ABF File': str})
-            elif path.endswith(".xlsx"):
-                self.masterDf = pd.read_excel(
-                    path, header=0, engine="openpyxl"
-                )  # , dtype={'ABF File': str})
+            if path.endswith('.csv'):
+                self.masterDf = pd.read_csv(path, header=0) #, dtype={'ABF File': str})
+            elif path.endswith('.xls'):
+                self.masterDf = pd.read_excel(path, header=0) #, dtype={'ABF File': str})
+            elif path.endswith('.xlsx'):
+                self.masterDf = pd.read_excel(path, header=0, engine='openpyxl') #, dtype={'ABF File': str})
             else:
-                print(
-                    "error: file type not supported. Expecting csv/xls/xlsx. Path:",
-                    path,
-                )
+                print('error: file type not supported. Expecting csv/xls/xlsx. Path:', path)
 
         # 20210426
         # combine some columns into new encoding
         # like, 'male+superior' as 'ms'
         # moved to reanalyze
         # want to move to reanalyze
         # but my base analysis does not have region/sex/condition etc
-        tmpNewCol = "RegSex"
-        self.masterDf[tmpNewCol] = ""
-        for tmpRegion in ["Superior", "Inferior"]:
-            for tmpSex in ["Male", "Female"]:
-                newEncoding = tmpRegion[0] + tmpSex[0]
-                regSex = self.masterDf[
-                    (self.masterDf["Region"] == tmpRegion)
-                    & (self.masterDf["Sex"] == tmpSex)
-                ]
-                regSex = (self.masterDf["Region"] == tmpRegion) & (
-                    self.masterDf["Sex"] == tmpSex
-                )
-                print("newEncoding:", newEncoding, "regSex:", regSex.shape)
-                self.masterDf.loc[regSex, tmpNewCol] = newEncoding
+        if 'Region' in self.masterDf.columns and 'Sex' in self.masterDf.columns:
+            tmpNewCol = 'RegSex'
+            self.masterDf[tmpNewCol] = ''
+            for tmpRegion in ['Superior', 'Inferior']:
+                for tmpSex in ['Male', 'Female']:
+                    newEncoding = tmpRegion[0] + tmpSex[0]
+                    regSex = self.masterDf[ (self.masterDf['Region']==tmpRegion) & (self.masterDf['Sex']==tmpSex)]
+                    regSex = (self.masterDf['Region']==tmpRegion) & (self.masterDf['Sex']==tmpSex)
+                    print('newEncoding:', newEncoding, 'regSex:', regSex.shape)
+                    self.masterDf.loc[regSex, tmpNewCol] = newEncoding
 
-        # sys.exit()
+        #sys.exit()
 
         self.masterDfColumns = self.masterDf.columns.to_list()
 
         #
         # try and guess categorical columns
         # if int64 and unique()<20 then assume it is category (works for date yyyymmdd)
-        # print('loadPath() dtypes:')
-        # print(self.masterDf.dtypes)
+        #print('loadPath() dtypes:')
+        #print(self.masterDf.dtypes)
         if categoricalList is None:
             categoricalList = []
             for colStr, dtype in self.masterDf.dtypes.items():
-                if dtype == object:
-                    print("colStr:", colStr, "is", dtype)
+                if dtype==object:
+                    print('colStr:', colStr, 'is', dtype)
                     categoricalList.append(colStr)
-                elif dtype == np.int64:
+                elif dtype==np.int64:
                     unique = self.masterDf[colStr].unique()
                     numUnique = len(unique)
-                    print("colStr:", colStr, "is", dtype, "numUnique:", numUnique)
+                    print('colStr:', colStr, 'is', dtype, 'numUnique:', numUnique)
                     categoricalList.append(colStr)
 
         self.masterCatColumns = categoricalList
         self.hueTypes = categoricalList
 
         self.statListDict = {}
         for colStr in self.masterDfColumns:
-            self.statListDict[colStr] = {"yStat": colStr}
+            self.statListDict[colStr] = {'yStat': colStr}
 
         # not sure what this was for ???
         # 20210112, put back in if necc
-        # self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
-        # self.masterCatColumns = self.categoricalList
+        #self.masterCatColumns = ['Condition', 'File Number', 'Sex', 'Region', 'filename', 'analysisname']
+        #self.masterCatColumns = self.categoricalList
 
         # todo: put this somewhere better
         self.setWindowTitle(path)
 
-    def setSwapSort(self):
+    def on_button_click(self, name):
         """
-        rotate the sort key to be able to sort by different keys, like 'sex' versus 'region'
         """
-        # print('=== setSwapSort()')
-        # print('  sortOrder was:', self.sortOrder)
-        self.sortOrder = self.sortOrder[1:] + self.sortOrder[:1]
-        # print('  sortOrder now:', self.sortOrder)
-        self.mySetStatusBar(f"Sort order is now: {self.sortOrder}")
+        logger.info(f'=== {name}')
+
+        if name == 'Replot':
+            self.update2()
+        elif name == 'Swap Sort Order':
+            # rotate the sort key to be able to sort by different keys, like 'sex' versus 'region'
+            #print('  sortOrder was:', self.sortOrder)
+            self.sortOrder = self.sortOrder[1:] + self.sortOrder[:1]
+            #print('  sortOrder now:', self.sortOrder)
+            self.mySetStatusBar(f'Sort order is now: {self.sortOrder}')
+        else:
+            logger.warning(f'Did not understand button: "{name}"')
 
     def setShowLegend(self, state):
-        print("setShowLegend() state:", state)
+        logger.info(f'setShowLegend() state: {state}')
         self.showLegend = state
         self.updateGlobal()
 
-    """
+    '''
     def setKDE(self, state):
         # only used in histograms
         self.doKDE = state
         self.updateGlobal()
-    """
+    '''
 
     def setMplToolbar(self, state):
         # only used in histograms
         self.showMplToolbar = state
         self.updateGlobal()
 
     def setHover(self, state):
         # used in scatterplots and point plots
         self.doHover = state
-        # self.signalStateChange.emit(self.getState())
+        #self.signalStateChange.emit(self.getState())
         self.updateGlobal()
 
     def setTheme(self, state):
-        print("setTheme() state:", state)
+        print('setTheme() state:', state)
 
         self.darkTheme = state
         if self.darkTheme:
-            plt.style.use("dark_background")
-            # sns.set_context('talk')
+            plt.style.use('dark_background')
+            #sns.set_context('talk')
 
         else:
-            # print(plt.style.available)
+            #print(plt.style.available)
             plt.rcParams.update(plt.rcParamsDefault)
-            # sns.set_context('paper')
+            #sns.set_context('paper')
 
-        # self.updateGlobal()
+        #self.updateGlobal()
         n = len(self.myPlotCanvasList)
         for i in range(n):
             if self.myPlotCanvasList[i] is not None:
                 self.myPlotCanvasList[i].updateTheme()
 
         ###
         return
         ###
 
         ###
         ###
         # remove
-        # self.plotVBoxLayout.removeWidget(self.toolbar)
+        #self.plotVBoxLayout.removeWidget(self.toolbar)
         # need this !!! removeWidget does not work
-        # self.myToolbar.removeAction(self.tmpToolbarAction)
+        #self.myToolbar.removeAction(self.tmpToolbarAction)
         self.hBoxLayout.removeWidget(self.canvas)
         self.canvas.setParent(None)
 
-        self.fig = None  # ???
+        self.fig = None # ???
         self.mplToolbar = None
         self.canvas = None
 
         self.fig = Figure()
         self.canvas = FigureCanvas(self.fig)
-        tmpAx = self.fig.add_subplot(111)  # self.ax1 not used
+        tmpAx = self.fig.add_subplot(111) # self.ax1 not used
         self.axes = [tmpAx]
-        self.cid = self.canvas.mpl_connect("pick_event", self.on_pick_event)
+        self.cid = self.canvas.mpl_connect('pick_event', self.on_pick_event)
         # matplotlib navigation toolbar
-        self.mplToolbar = NavigationToolbar2QT(
-            self.canvas, self.canvas
-        )  # params are (canvas, parent)
+        self.mplToolbar = NavigationToolbar2QT(self.canvas, self.canvas) # params are (canvas, parent)
         self.hBoxLayout.addWidget(self.canvas)
 
         #
         # add a second plot
         if self.canvas2 is not None:
             self.hBoxLayout.removeWidget(self.canvas2)
             self.canvas2.setParent(None)
@@ -1836,57 +1925,56 @@
         # original plot
         self.update2()
 
     def updatePlotLayout(self):
         """
         set number of plots [1x, 1x2, 2x1, 2x2]
         """
-        self.plotLayoutType = (
-            self.plotLayoutDropdown.currentText()
-        )  # ['paper', 'poster', 'talk']
+        self.plotLayoutType = self.plotLayoutDropdown.currentText() # ['paper', 'poster', 'talk']
 
         self.updatePlotLayoutGrid()
 
         self.update2()
 
     def updatePlotSize(self):
-        self.plotSize = (
-            self.plotSizeDropdown.currentText()
-        )  # ['paper', 'poster', 'talk']
-        sns.set_context(self.plotSize)  # , font_scale=1.4)
+        self.plotSize = self.plotSizeDropdown.currentText() # ['paper', 'poster', 'talk']
+        sns.set_context(self.plotSize) #, font_scale=1.4)
         self.updateGlobal()
 
     def updateHue(self):
         hue = self.hueDropdown.currentText()
         self.hue = hue
-        # self.signalStateChange.emit(self.getState())
+        #self.signalStateChange.emit(self.getState())
         self.update2()
 
     def updateGroupBy(self):
         self.groupByColumnName = self.groupByDropdown.currentText()
-        self.update2()  # todo: don't update plot, update table
+        self.update2() # todo: don't update plot, update table
 
-    """
+    def updateLimitTo(self):
+        logger.info('')
+
+    '''
     def updateColor(self):
         color = self.colorDropdown.currentText()
         self.color = color
         self.update2()
-    """
+    '''
 
     def updatePlotType(self):
         plotType = self.typeDropdown.currentText()
         self.plotType = plotType
         self.update2()
 
     def updateDataType(self):
         dataType = self.dataTypeDropdown.currentText()
         self.dataType = dataType
         self.update2()
 
-    """
+    '''
     def old_on_pick_event(self, event):
         try:
             print('on_pick_event() event:', event)
             print('event.ind:', event.ind)
 
             if len(event.ind) < 1:
                 return
@@ -1894,153 +1982,141 @@
             print('  selected:', spikeNumber)
 
             # propagate a signal to parent
             #self.myMainWindow.mySignal('select spike', data=spikeNumber)
             #self.selectSpike(spikeNumber)
         except (AttributeError) as e:
             pass
-    """
+    '''
 
     def getMeanDf(self, xStat, yStat, verbose=False):
         # need to get all categorical columns from orig df
         # these do not change per file (sex, condition, region)
-        print("=== getMeanDf() xStat:", xStat, "yStat:", yStat)
-        print("  self.groupByColumnName:", self.groupByColumnName)
+        print('=== getMeanDf() xStat:', xStat, 'yStat:', yStat)
+        print('  self.groupByColumnName:', self.groupByColumnName)
 
         xIsCategorical = pd.api.types.is_string_dtype(self.masterDf[xStat].dtype)
         yIsCategorical = pd.api.types.is_string_dtype(self.masterDf[yStat].dtype)
 
-        groupByNone = self.groupByColumnName == "None"
+        groupByNone = self.groupByColumnName == 'None'
 
-        aggList = ["count", "mean", "std", "sem", "median"]
+        aggList = ['count', 'mean', 'std', 'sem', 'median']
         if xIsCategorical or groupByNone:
             self.xDf = None
         else:
-            self.xDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                xStat
-            ].agg(aggList)
+            self.xDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[xStat].agg(aggList)
             self.xDf = self.xDf.reset_index()
-            self.xDf.insert(1, "stat", xStat)  # column 1, in place
+            self.xDf.insert(1, 'stat', xStat) # column 1, in place
 
         if yIsCategorical or groupByNone:
             self.yDf = None
         else:
-            self.yDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                yStat
-            ].agg(aggList)
+            self.yDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[yStat].agg(aggList)
             self.yDf = self.yDf.reset_index()
-            self.yDf.insert(1, "stat", yStat)  # column 1, in place
+            self.yDf.insert(1, 'stat', yStat) # column 1, in place
 
         if xStat == yStat:
             groupList = [xStat]
         else:
             groupList = [xStat, yStat]
         if groupByNone:
             meanDf = None
         else:
-            meanDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                groupList
-            ].mean()
+            meanDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[groupList].mean()
             meanDf = meanDf.reset_index()
 
         #
         # 20210211 get median/std/sem/n
         # try and add median/std/sem/sem/n
         if 0:
-            tmpDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[
-                groupList
-            ].median()
-            # print('tmpDf:', tmpDf)
-            meanDf["median"] = tmpDf[self.groupByColumnName]
+            tmpDf = self.masterDf.groupby(self.groupByColumnName, as_index=False)[groupList].median()
+            #print('tmpDf:', tmpDf)
+            meanDf['median'] = tmpDf[self.groupByColumnName]
 
-        """
+        '''
         for catName in self.masterCatColumns:
             #if catName == 'analysisname':
             if catName == self.groupByColumnName:
                 # this is column we grouped by, already in meanDf
                 continue
             meanDf[catName] = ''
-        """
+        '''
 
         # for each row, update all categorical columns using self.masterCatColumns
         fileNameList = meanDf[self.groupByColumnName].unique()
-        # print('  getMeanDf() updating all categorical columns for rows in fileNameList:')#, fileNameList)
-        # print('    categorical columns are self.masterCatColumns:', self.masterCatColumns)
+        #print('  getMeanDf() updating all categorical columns for rows in fileNameList:')#, fileNameList)
+        #print('    categorical columns are self.masterCatColumns:', self.masterCatColumns)
         for i, analysisname in enumerate(fileNameList):
-            tmpDf = self.masterDf[self.masterDf[self.groupByColumnName] == analysisname]
+            tmpDf = self.masterDf[ self.masterDf[self.groupByColumnName]==analysisname ]
             if len(tmpDf) == 0:
-                print("  ERROR: got 0 length for analysisname:", analysisname)
+                print('  ERROR: got 0 length for analysisname:', analysisname)
                 continue
             # need to limit this to pre-defined catecorical columns
             for catName in self.masterCatColumns:
-                # if i==0:
+                #if i==0:
                 #    print('analysisname:', analysisname, 'catName:', catName)
 
-                # if catName == self.groupByColumnName:
+                #if catName == self.groupByColumnName:
                 #    # this is column we grouped by, already in meanDf
                 #    continue
 
                 # find value of catName column from 1st instance in masterDf
                 # if more than one unique value, don't put into table
                 numUnique = len(tmpDf[catName].unique())
                 if numUnique == 1:
-                    # print('    updating categorical colum with catName:', catName)
+                    #print('    updating categorical colum with catName:', catName)
                     catValue = tmpDf[catName].iloc[0]
 
-                    theseRows = (
-                        meanDf[self.groupByColumnName] == analysisname
-                    ).tolist()
-                    # if catName == self.groupByColumnName:
+                    theseRows = (meanDf[self.groupByColumnName]==analysisname).tolist()
+                    #if catName == self.groupByColumnName:
                     meanDf.loc[theseRows, catName] = catValue
                     if self.xDf is not None:
                         self.xDf.loc[theseRows, catName] = catValue
                     if self.yDf is not None:
                         self.yDf.loc[theseRows, catName] = catValue
-                    # print('catName:', catName, 'catValue:', type(catValue), catValue)
+                    #print('catName:', catName, 'catValue:', type(catValue), catValue)
                 else:
-                    print(
-                        "warning catName:", catName, "has", numUnique, "unique values"
-                    )
+                    print('warning catName:', catName, 'has', numUnique, 'unique values')
                     pass
-                    # print(f'not adding {catName} to table, numUnique: {numUnique}')
+                    #print(f'not adding {catName} to table, numUnique: {numUnique}')
         #
         # sort
-        # meanDf = meanDf.sort_values(['Region', 'Sex', 'Condition'])
+        #meanDf = meanDf.sort_values(['Region', 'Sex', 'Condition'])
         if self.sortOrder is not None:
-            print("  ", "sorting by self.sortOrder:", self.sortOrder)
+            print('  ', 'sorting by self.sortOrder:', self.sortOrder)
             try:
                 meanDf = meanDf.sort_values(self.sortOrder)
                 if self.xDf is not None:
                     self.xDf = self.xDf.sort_values(self.sortOrder)
                 if self.yDf is not None:
                     self.yDf = self.yDf.sort_values(self.sortOrder)
-            except KeyError as e:
-                print("    ", "sorting (2) failed with:", e)
+            except (KeyError) as e:
+                print('    ', 'sorting (2) failed with:', e)
         #
-        meanDf["index"] = [x + 1 for x in range(len(meanDf))]
+        meanDf['index'] = [x+1 for x in range(len(meanDf))]
         meanDf = meanDf.reset_index()
         if self.xDf is not None:
-            self.xDf["index"] = [x + 1 for x in range(len(self.xDf))]
+            self.xDf['index'] = [x+1 for x in range(len(self.xDf))]
             self.xDf = self.xDf.reset_index()
         if self.yDf is not None:
-            self.yDf["index"] = [x + 1 for x in range(len(self.yDf))]
+            self.yDf['index'] = [x+1 for x in range(len(self.yDf))]
             self.yDf = self.yDf.reset_index()
 
         # drop extra columns
-        # modelMeanDf = meanDf.drop(['level_0'], axis=1)
-        if self.xDf is not None and "level_0" in self.xDf.columns:
-            self.xDf = self.xDf.drop(["level_0"], axis=1)
-        if self.yDf is not None and "level_0" in self.yDf.columns:
-            self.yDf = self.yDf.drop(["level_0"], axis=1)
+        #modelMeanDf = meanDf.drop(['level_0'], axis=1)
+        if self.xDf is not None and 'level_0' in self.xDf.columns:
+            self.xDf = self.xDf.drop(['level_0'], axis=1)
+        if self.yDf is not None and 'level_0' in self.yDf.columns:
+            self.yDf = self.yDf.drop(['level_0'], axis=1)
         # we need to round for the table, but NOT the plot !!!!!
-        # meanDf = meanDf.round(3)
+        #meanDf = meanDf.round(3)
 
         #
         if verbose:
-            print("getMeanDf():")
+            print('getMeanDf():')
             print(meanDf)
         #
         return meanDf
 
     def updateGlobal(self):
         """
         update all plots
@@ -2048,69 +2124,70 @@
         """
         state = self.getState()
         n = len(self.myPlotCanvasList)
         for i in range(n):
             if self.myPlotCanvasList[i] is not None:
                 self.myPlotCanvasList[i].myUpdateGlobal(state)
 
+    def replot(self):
+        self.update2()
+
     def update2(self):
-        # self.updatePlot is the plot to update 1,2,3,4
+        #self.updatePlot is the plot to update 1,2,3,4
+        logger.info('')
         updateIndex = self.updatePlot
         if updateIndex is None:
-            print(
-                "update2() found no plots to update with self.updatePlot:",
-                self.updatePlot,
-            )
-            self.mySetStatusBar("Please select a plot to update")
+            logger.info(f'Found no plots to update with self.updatePlot: {self.updatePlot}')
+            self.mySetStatusBar('Please select a plot to update')
             return
 
         state = self.getState()
 
         # update table model
-        meanDf = state["meanDf"]
-        # modelMeanDf = meanDf.drop(['level_0'], axis=1)
-        # self.myModel = myPandasModel(meanDf) # todo: don't need self.myModel
-        myModel = myPandasModel(meanDf)  # todo: don't need self.myModel
-        # print('calling _switchTableModel from update2() updateIndex:', updateIndex)
+        meanDf = state['meanDf']
+        #modelMeanDf = meanDf.drop(['level_0'], axis=1)
+        #self.myModel = myPandasModel(meanDf) # todo: don't need self.myModel
+        myModel = myPandasModel(meanDf) # todo: don't need self.myModel
+        #print('calling _switchTableModel from update2() updateIndex:', updateIndex)
         self._switchTableModel(myModel)
 
         self.xTableView.slotSwitchTableDf(self.xDf)
         self.yTableView.slotSwitchTableDf(self.yDf)
 
         # update plots
         n = len(self.myPlotCanvasList)
         for i in range(n):
-            if i == updateIndex:
+            if i==updateIndex:
                 if self.myPlotCanvasList[i] is not None:
                     self.myPlotCanvasList[i].myUpdate(state)
 
     def old_getAnnotation(self, ind):
         # todo: replace with _getStatFromPlot
 
         if not np.issubdtype(ind, np.integer):
-            print("getAnnotation() got bad ind:", ind, type(ind))
+            print('getAnnotation() got bad ind:', ind, type(ind))
             return
 
         analysisName = self.plotDf.at[ind, self.groupByColumnName]
-        index = self.plotDf.at[ind, "index"]
+        index = self.plotDf.at[ind, 'index']
         try:
-            region = self.plotDf.at[ind, "Region"]  # not all will have this
-        except KeyError as e:
-            region = "n/a"
+            region = self.plotDf.at[ind, 'Region'] # not all will have this
+        except (KeyError) as e:
+            region = 'n/a'
         xVal = self.plotDf.at[ind, self.plotStatx]
         yVal = self.plotDf.at[ind, self.plotStaty]
 
         returnDict = {
-            "index": index,
-            "analysisName": analysisName,
-            "region": region,
-            "xVal": xVal,
-            "yVal": yVal,
-            #'plotDf': self.plotDf, # potentially very big
-        }
+                    'index': index,
+                    'analysisName': analysisName,
+                    'region': region,
+                    'xVal': xVal,
+                    'yVal': yVal,
+                    #'plotDf': self.plotDf, # potentially very big
+            }
         return returnDict
 
     # see: https://stackoverflow.com/questions/7908636/possible-to-make-labels-appear-when-hovering-over-a-point-in-matplotlib
     """
     def old_onHover(self, event):
         print('onHover:', type(event), 'inaxes:', event.inaxes)
         if event.inaxes == self.axes[0]:
@@ -2143,182 +2220,171 @@
     '''
 
     def slotSelectFromPlot(self, selectDict):
         """
         A point in one of plots was selected
         pass this to parent app
         """
-        print("bScatterPlotMainWindow.slotSelectFromPlot() ", selectDict)
+        print('bScatterPlotMainWindow.slotSelectFromPlot() ', selectDict)
 
     def slotSelectSquare(self, plotNumber, stateDict):
-        print("bScatterPlotMainWindow.slotSelectSquare()", plotNumber)
-        # print('  stateDict:', stateDict)
-        print("  todo: fill in all interface using stateDict")
+        logger.info(f'plotNumber:{plotNumber}')
+        #print('  stateDict:', stateDict)
+        print('  todo: fill in all interface using stateDict')
         self.updatePlot = plotNumber
 
     def slotTableViewClicked(self, clickedIndex):
         """
         Respond to signal self.tableView.clicked
         clickedIndex: PyQt5.QtCore.QModelIndex
         """
-        row = clickedIndex.row()
-        model = clickedIndex.model()
-        print(
-            "bScatterPlotMainWindow.slotTableViewClicked() row:",
-            row,
-            "clickedIndex:",
-            clickedIndex,
-        )
+        row=clickedIndex.row()
+        model=clickedIndex.model()
+        logger.info(f'row:{row} clickedIndex:{clickedIndex}')
 
         # select in plot
-        # self._selectInd(row) # !!!! visually, index start at 1
-
+        #self._selectInd(row) # !!!! visually, index start at 1
 
-if __name__ == "__main__":
+def test():
     """
     20210112, extending this to work with any csv. Starting with nodes/edges from bimpy
     """
 
     # todo: using 'analysisname' for group by, I think I can also use 'File Number'
-    statListDict = None  # list of dict mapping human readbale to column names
+    statListDict = None # list of dict mapping human readbale to column names
     masterDf = None
     interfaceDefaults = None
 
     # machine learning db
     if 0:
         # this is from mac laptop
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
-        path = "/Users/cudmore/data/laura-ephys/SANdatabaseForMachineLearning.xlsx"
-        analysisName = "File Number"
-        # statListDict = None #sanpy.bAnalysisUtil.getStatList()
-        categoricalList = ["LOCATION", "SEX", "File Number"]  # , 'File Name']
-        hueTypes = ["LOCATION", "SEX", "File Number"]  # , 'File Name'] #, 'None']
-        sortOrder = ["LOCATION", "SEX", "File Number"]
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/SANdatabaseForMachineLearning.xlsx'
+        analysisName = 'File Number'
+        #statListDict = None #sanpy.bAnalysisUtil.getStatList()
+        categoricalList = ['LOCATION', 'SEX', 'File Number']#, 'File Name']
+        hueTypes = ['LOCATION', 'SEX', 'File Number'] #, 'File Name'] #, 'None']
+        sortOrder = ['LOCATION', 'SEX', 'File Number']
 
     # sanpy database
-    if 1:
-        # import sanpy
-        # sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
-        # import bAnalysisUtil
-        # statListDict = bAnalysisUtil.statList
+    if 0:
+        #import sanpy
+        #sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
+        #import bAnalysisUtil
+        #statListDict = bAnalysisUtil.statList
         import statlist
-
         statListDict = statlist.statList
 
         # this is from mac laptop
-        # path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
-        path = "../examples/Superior vs Inferior database_master.csv"
-        path = "/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv"
-        path = (
-            "/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv"
-        )
-        path = "/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master_20210402.csv"
-
-        # path = 'data/Superior vs Inferior database_master_20210402.csv'
-        path = "data/Superior vs Inferior database_master_20210402.csv"
-        # path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
-        path = "data/Superior vs Inferior database_13_Feb_master.csv"
-        analysisName = "analysisname"
-        # statListDict = None #sanpy.bAnalysisUtil.getStatList()
-        categoricalList = [
-            "include",
-            "Condition",
-            "Region",
-            "Sex",
-            "RegSex",
-            "File Number",
-            "analysisname",
-        ]  # , 'File Name']
-        hueTypes = [
-            "Region",
-            "Sex",
-            "RegSex",
-            "Condition",
-            "File Number",
-            "analysisname",
-        ]  # , 'File Name'] #, 'None']
-        sortOrder = ["Region", "Sex", "Condition"]
-
-        interfaceDefaults = {
-            "Y Statistic": "Spike Frequency (Hz)",
-            "X Statistic": "Region",
-            "Hue": "Region",
-            "Group By": "File Number",
-        }
+        #path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '../examples/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master.csv'
+        path = '/Users/cudmore/data/laura-ephys/Superior vs Inferior database_master_20210402.csv'
+
+        #path = 'data/Superior vs Inferior database_master_20210402.csv'
+        path = 'data/Superior vs Inferior database_master_20210402.csv'
+        #path = '/Users/cudmore/data/laura-ephys/Superior_Inferior_database_master_jan25.csv'
+        path = 'data/Superior vs Inferior database_13_Feb_master.csv'
+        analysisName = 'analysisname'
+        #statListDict = None #sanpy.bAnalysisUtil.getStatList()
+        categoricalList = ['include', 'condition', 'region', 'Sex', 'RegSex', 'File Number', 'analysisname']#, 'File Name']
+        hueTypes = ['region', 'sex', 'RegSex', 'condition', 'File Number', 'analysisname'] #, 'File Name'] #, 'None']
+        sortOrder = ['region', 'sex', 'condition']
+
+        interfaceDefaults = {'Y Statistic': 'Spike Frequency (Hz)',
+                            'X Statistic': 'region',
+                            'Hue': 'region',
+                            'Group By': 'File Number'}
     # bimpy database
     if 0:
-        path = "../examples/edges_db.csv"
-        analysisName = "fileNumber"
-        categoricalList = ["san", "region", "path", "file", "fileNumber", "nCon"]
+        path = '../examples/edges_db.csv'
+        analysisName = 'fileNumber'
+        categoricalList = ['san', 'region', 'path', 'file', 'fileNumber', 'nCon']
         hueTypes = categoricalList
-        sortOrder = ["san", "region"]
+        sortOrder = ['san', 'region']
 
     # dualAnalysis database
     if 0:
         # grab our list of dict mapping human readable to .csv column names
-        sys.path.append(os.path.join(os.path.dirname(sys.path[0]), "sanpy"))
+        sys.path.append(os.path.join(os.path.dirname(sys.path[0]),'sanpy'))
         import bAnalysisUtil
-
         statListDict = bAnalysisUtil.statList
 
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/dualAnalysis_final_db.csv"
-        analysisName = "fileNumber"  # # rows in .xlsx database, one recording per row
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/dualAnalysis_final_db.csv'
+        analysisName = 'fileNumber' # # rows in .xlsx database, one recording per row
         # trial is 1a/1b/1c... trial withing cellNumber
-        categoricalList = [
-            "include",
-            "region",
-            "fileNumber",
-            "cellNumber",
-            "trial",
-            "quality",
-        ]
+        categoricalList = ['include', 'region', 'fileNumber', 'cellNumber', 'trial', 'quality']
         hueTypes = categoricalList
-        sortOrder = ["region"]
+        sortOrder = ['region']
 
     # sparkmaster lcr database
     if 0:
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcr-database.csv"
-        analysisName = "fileNumber"  # # rows in .xlsx database, one recording per row
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcr-database.csv'
+        analysisName = 'fileNumber' # # rows in .xlsx database, one recording per row
         # trial is 1a/1b/1c... trial withing cellNumber
-        categoricalList = ["quality", "region", "fileNumber", "dateFolder", "tifFile"]
+        categoricalList = ['quality', 'region', 'fileNumber', 'dateFolder', 'tifFile']
         hueTypes = categoricalList
-        sortOrder = ["region"]
+        sortOrder = ['region']
 
     # lcr/vm analysis using lcrPicker.py
     if 0:
-        # basePath = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/'
-        # path = basePath + 'dual-data/20210115/20210115__0002_lcrPicker.csv'
-        # path = basePath + 'dual-data/20210115/20210115__0001_lcrPicker.csv'
+        #basePath = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/'
+        #path = basePath + 'dual-data/20210115/20210115__0002_lcrPicker.csv'
+        #path = basePath + 'dual-data/20210115/20210115__0001_lcrPicker.csv'
 
         # output of lcrPicker.py ... mergeDatabase()
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcrPicker-db.csv"
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/lcrPicker-db.csv'
         categoricalList = None
         hueTypes = None
-        analysisName = "tifFile"
+        analysisName= 'tifFile'
         sortOrder = None
 
     # merged sanpy+lcr pre spike slope
     # generated by dualAnalysis.py xxx()
     # usnig to compare lcr slope to edddr for fig 9
     if 0:
-        path = "/Users/cudmore/Sites/SanPy/examples/dual-analysis/combined-sanpy-lcr-db.csv"
+        path = '/Users/cudmore/Sites/SanPy/examples/dual-analysis/combined-sanpy-lcr-db.csv'
         statListDict = None
         categoricalList = None
         hueTypes = None
-        analysisName = "filename"
+        analysisName= 'filename'
         sortOrder = None
 
+    if 1:
+        path = 'data'
+        ad = sanpy.analysisDir(path, autoLoad=True)
+        for row in range(len(ad)):
+            ad.getAnalysis(row)
+        masterDf = ad.pool_build()
+        categoricalList = ['file', 'File Number']
+        hueTypes = ['file', 'File Number']
+        analysisName = 'file'
+        from sanpy.bAnalysisUtil import statList as statListDict
+        sortOrder = ['file', 'File Number']
+        interfaceDefaults = {'Y Statistic': 'Spike Frequency (Hz)',
+                            'X Statistic': 'Spike Number',
+                            'Hue': 'file',
+                            'Group By': 'file'}
+
     #
     app = QtWidgets.QApplication(sys.argv)
 
-    ex = bScatterPlotMainWindow(
-        path,
-        categoricalList,
-        hueTypes,
-        analysisName,
-        sortOrder,
-        statListDict=statListDict,
-        masterDf=masterDf,
-        interfaceDefaults=interfaceDefaults,
-    )
+    ex = bScatterPlotMainWindow(path, categoricalList, hueTypes,
+                    analysisName, sortOrder, statListDict=statListDict,
+                    masterDf = masterDf,
+                    interfaceDefaults = interfaceDefaults)
+    ex.show()
 
     sys.exit(app.exec_())
+
+def testDec2022():
+    import sanpy.interface
+    app = QtWidgets.QApplication(sys.argv)
+    df = pd.read_csv('/Users/cudmore/Desktop/tmpDf-20221231.csv')
+    ptp = sanpy.interface.plugins.plotToolPool(tmpMasterDf=df)
+    ptp.show()
+    sys.exit(app.exec_())
+
+if __name__ == '__main__':
+    # test()
+    testDec2022()
```

### Comparing `sanpy-ephys-0.1.13/sanpy/user_analysis/baseUserAnalysis.py` & `sanpy-ephys-0.1.6/sanpy/user_analysis/baseUserAnalysis.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,26 +1,23 @@
 import glob
 import importlib
-
-# import inspect
+#import inspect
 import os
 import traceback  # to print call stack on exception
 from typing import List, Union
 
 import sanpy
 
 from sanpy.sanpyLogger import get_logger
-
 logger = get_logger(__name__)
 
-
 # TODO: put this in _util.py
 def _module_from_file(module_name, file_path):
     """Load a module from a file.
-
+    
     Parameters
     ----------
     module_name : str
         Name of the module.
     file_path : str
         Full path to the file
 
@@ -29,172 +26,168 @@
     module
     """
     spec = importlib.util.spec_from_file_location(module_name, file_path)
     module = importlib.util.module_from_spec(spec)
     spec.loader.exec_module(module)
     return module
 
-
-def _getObjectList(verbose=False) -> List[dict]:
+def _getObjectList(verbose = False) -> List[dict]:
     """Return a list of classes defined in sanpy.userAnalysis.
 
     Each of these is an object we can (i) construct or (ii) interrogate statis class members
-
+    
     Returns
     -------
     list of dict
     """
 
     verbose = False
-
+    
     if verbose:
-        logger.info("")
+        logger.info('')
 
     #
     # user plugins from files in folder <user>/SanPy/analysis
     userAnalysisFolder = sanpy._util._getUserAnalysisFolder()
-    files = glob.glob(os.path.join(userAnalysisFolder, "*.py"))
+    files = glob.glob(os.path.join(userAnalysisFolder, '*.py'))
 
     pluginDict = {}
     loadedModuleList = []
 
     for file in files:
-        if file.endswith("__init__.py"):
+        if file.endswith('__init__.py'):
             continue
 
         moduleName = os.path.split(file)[1]
         moduleName = os.path.splitext(moduleName)[0]
-        fullModuleName = "sanpy.user_analysis." + moduleName  # + "." + moduleName
+        fullModuleName = 'sanpy.user_analysis.' + moduleName  # + "." + moduleName
 
         loadedModule = _module_from_file(fullModuleName, file)
 
         if verbose:
-            logger.info("")
-            logger.info(f"    file: {file}")
-            logger.info(f"    fullModuleName: {fullModuleName}")
-            logger.info(f"    moduleName: {moduleName}")
-            logger.info(f"    loadedModule: {loadedModule}")
+            logger.info('')
+            logger.info(f'    file: {file}')
+            logger.info(f'    fullModuleName: {fullModuleName}')
+            logger.info(f'    moduleName: {moduleName}')
+            logger.info(f'    loadedModule: {loadedModule}')
 
         # class based user analysis
         oneConstructor = None
         try:
-            oneConstructor = getattr(
-                loadedModule, moduleName
-            )  # moduleName is derived from file name (must match)
+            oneConstructor = getattr(loadedModule, moduleName)  # moduleName is derived from file name (must match)
             if verbose:
-                logger.info(f"    oneConstructor: {oneConstructor}")
-                logger.info(f"    type(oneConstructor): {type(oneConstructor)}")
-        except AttributeError as e:
-            logger.error(
-                f'Make sure filename and class name are the same,  file name is "{moduleName}"'
-            )
+                logger.info(f'    oneConstructor: {oneConstructor}')
+                logger.info(f'    type(oneConstructor): {type(oneConstructor)}')
+        except (AttributeError) as e:
+            logger.error(f'Make sure filename and class name are the same,  file name is "{moduleName}"')
 
         # instantiate the object and it will create a dictionary of new stats
         _tmpObj = oneConstructor(ba=None)
         _statStatDict = _tmpObj._getUserStatDict()
 
-        # humanName = oneConstructor.myHumanName
+        #humanName = oneConstructor.myHumanName
         pluginDict = {
-            "pluginClass": moduleName,
-            "type": "user",
-            "module": fullModuleName,
-            "path": file,
-            "constructor": oneConstructor,
-            "staticStatDict": _statStatDict,
-        }
+            'pluginClass': moduleName,
+            'type': 'user',
+            'module': fullModuleName,
+            'path': file,
+            'constructor': oneConstructor,
+            'staticStatDict': _statStatDict,
+            }
 
         if verbose:
             logger.info(f'loading user analysis from file: "{file}"')
-
+                
         loadedModuleList.append(pluginDict)
 
     # print out the entire list
     # logger.info('')
     # for loadedModuleDict in loadedModuleList:
     #     for k,v in loadedModuleDict.items():
     #         logger.info(f'    {k} : {v}')
     #
     return loadedModuleList  # list of dict
 
-
 def findUserAnalysisStats() -> List[dict]:
-    """Get the stat names of all user defined analysis."""
-    userStatList: List[dict] = []
+    """Get the stat names of all user defined analysis.
+    """
+    userStatList : List[dict] = []
     objList = _getObjectList()  # list of dict
     for obj in objList:
         # sanpy._util.pprint(obj)
         # print('')
-
+        
         # instantiate the object
-        userObj = obj["constructor"](ba=None)
+        userObj = obj['constructor'](ba=None)
 
         userObjStatDict = userObj._getUserStatDict()
 
         for k, v in userObjStatDict.items():
             oneUserStatDict = {k: v}
             userStatList.append(oneUserStatDict)
 
     return userStatList
 
-
 def runAllUserAnalysis(ba, verbose=False):
     """Run all user defined analysis.
-
+    
     Notes
     -----
     Called at end of sanpy.bAnalysis.detect()
     """
 
     # step through each
     objList = _getObjectList()  # list of dict
 
     if verbose:
-        logger.info(f"objList: {objList}")
+        logger.info(f'objList: {objList}')
     for obj in objList:
         # instantiate and call run (will add values for stats
         # was this
-        # userObj = obj(ba)
-        # userObj.run()
+        #userObj = obj(ba)
+        #userObj.run()
 
         try:
             # instantiate a user object
-            userObj = obj["constructor"](ba)
+            userObj = obj['constructor'](ba)
 
             # run the analysis
             userObj.run()  # run the analysis and append to actual ba object
-        except Exception as e:
-            logger.error(f"Exception in running user defined analysis: {e}")
+        except (Exception) as e:
+            logger.error(f'Exception in running user defined analysis: {e}')
             logger.error(traceback.format_exc())
 
-
 class baseUserAnalysis:
-    """Create a userAnalysis object after bAnalysis has been analyzed with the core analysis results."""
-
-    def __init__(self, ba: "sanpy.bAnalysis"):
-        self._myAnalysis: sanpy.bAnalysis = ba
+    """Create a userAnalysis object after bAnalysis has been analyzed with the core analysis results.
+    """
 
-        self._userStatDict: dict = {}
+    def __init__(self, ba : "sanpy.bAnalysis"):
+        self._myAnalysis : sanpy.bAnalysis = ba
+        
+        self._userStatDict : dict = {}
         # add to this with addUserStat()
 
         self.defineUserStats()
 
     def _getUserStatDict(self):
-        """Get dict of user defined stats, one key per stat."""
+        """Get dict of user defined stats, one key per stat.
+        """
         return self._userStatDict
-
+        
     def defineUserStats(self):
         """Derived classes add each stat with addUserStat().
 
         See Also
         --------
         addUserStat
         """
         pass
-
-    def addUserStat(self, humanName: str, internalName: str):
+    
+        
+    def addUserStat(self, humanName :str, internalName : str):
         """Add a user stat. Derived classes do this in defineUserStats().
 
         Parameters
         ----------
         humanName : str
             Human readable name for the stat, like 'Threshold Potential (mV)'
         internalName : str
@@ -215,20 +208,20 @@
                 }
         }
         """
         if humanName in self._userStatDict.keys():
             logger.error(f'User stat with human name "{humanName}" already exists')
             return
         statDict = {
-            "name": internalName,
-            "units": None,
-            "yStat": None,
-            "yStatUnits": None,
-            "xStat": None,
-            "xStatUnits": None,
+            'name': internalName,
+            'units': None,
+            'yStat': None,
+            'yStatUnits': None,
+            'xStat': None,
+            'xStatUnits': None,
         }
         self._userStatDict[humanName] = statDict
 
     @property
     def ba(self):
         """Get the underlying [sanpy.bAnalysis][sanpy.bAnalysis] object"""
         return self._myAnalysis
@@ -266,20 +259,18 @@
         KeyError
             If theKey is not a key in analysis results.
         IndexError
             If spikeIdx is beyond number of spikes -1.
         """
         try:
             self.ba.spikeDict[spikeIdx][theKey] = theVal
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'User internal stat does not exist "{theKey}"')
-        except IndexError as e:
-            logger.error(
-                f"spikeIdx {spikeIdx} is out of range, max value is {self.ba.numSpikes}"
-            )
+        except (IndexError) as e:
+            logger.error(f'spikeIdx {spikeIdx} is out of range, max value is {self.ba.numSpikes}')
 
     def getSpikeValue(self, spikeIdx, theKey):
         """Get a single spike analysis result from key.
 
         Parameters
         ----------
         spikeIdx : int
@@ -293,22 +284,20 @@
             If theKey is not a key in analysis results.
         IndexError
             If spikeIdx is beyond number of spikes -1.
         """
         try:
             theRet = self.ba.spikeDict[spikeIdx][theKey]
             return theRet
-        except KeyError as e:
+        except (KeyError) as e:
             logger.error(f'User internal stat does not exist "{theKey}"')
-        except IndexError as e:
-            logger.error(
-                f"spikeIdx {spikeIdx} is out of range, max value is {self.ba.numSpikes}"
-            )
+        except (IndexError) as e:
+            logger.error(f'spikeIdx {spikeIdx} is out of range, max value is {self.ba.numSpikes}')
 
     def run(self):
-        """Run user analysis. Calculate values for each new user stat."""
-
+        """Run user analysis. Calculate values for each new user stat.
+        """
 
-if __name__ == "__main__":
-    # test1()
+if __name__ == '__main__':
+    #test1()
     # _getObjectList()
     findUserAnalysisStats()
```

### Comparing `sanpy-ephys-0.1.13/sanpy_ephys.egg-info/SOURCES.txt` & `sanpy-ephys-0.1.6/sanpy_ephys.egg-info/SOURCES.txt`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 LICENSE
-README.md
 pyproject.toml
 setup.py
 sanpy/__init__.py
 sanpy/_util.py
 sanpy/analysisDir.py
 sanpy/analysisPlot.py
 sanpy/analysisUtil.py
@@ -40,29 +39,34 @@
 sanpy/interface/bScatterPlotWidget2.py
 sanpy/interface/bTableView.py
 sanpy/interface/fileListWidget.py
 sanpy/interface/kymographPlugin2.py
 sanpy/interface/preferences.py
 sanpy/interface/sanpy_app.py
 sanpy/interface/plugins/__init__.py
+sanpy/interface/plugins/analysisSummary.py
 sanpy/interface/plugins/basePlotTool.py
+sanpy/interface/plugins/detectionErrors.py
 sanpy/interface/plugins/detectionParams.py
 sanpy/interface/plugins/exportTrace.py
 sanpy/interface/plugins/fftPlugin.py
+sanpy/interface/plugins/kymographPlugin.py
 sanpy/interface/plugins/plotFi.py
 sanpy/interface/plugins/plotRecording.py
 sanpy/interface/plugins/plotScatter.py
 sanpy/interface/plugins/plotTool.py
 sanpy/interface/plugins/plotToolPool.py
+sanpy/interface/plugins/resultsTable.py
+sanpy/interface/plugins/resultsTable2.py
 sanpy/interface/plugins/sanpyLog.py
 sanpy/interface/plugins/sanpyPlugin.py
 sanpy/interface/plugins/setSpikeStat.py
 sanpy/interface/plugins/spikeClips.py
 sanpy/interface/plugins/stimGen.py
-sanpy/interface/plugins/summarizeResults.py
+sanpy/interface/plugins/stimGen2.py
 sanpy/scatterwidget/__init__.py
 sanpy/scatterwidget/bScatterPlotWidget2.py
 sanpy/scatterwidget/statlist.py
 sanpy/user_analysis/__init__.py
 sanpy/user_analysis/baseUserAnalysis.py
 sanpy_ephys.egg-info/PKG-INFO
 sanpy_ephys.egg-info/SOURCES.txt
```

### Comparing `sanpy-ephys-0.1.13/tests/test_analysis.py` & `sanpy-ephys-0.1.6/tests/test_analysis.py`

 * *Files identical despite different names*

### Comparing `sanpy-ephys-0.1.13/tests/test_analysisDir.py` & `sanpy-ephys-0.1.6/tests/test_analysisDir.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,17 +39,14 @@
 
     def testLoadDir(self):
 
         logger.info('')
         
         ad = sanpy.analysisDir(path=self.test_dir)
 
-        print('xxx')
-        print(ad._df)
-
         self.assertEqual(len(ad._df), 2)
 
         ad.saveHdf()
 
         ad.loadHdf()
         self.assertEqual(len(ad._df), 2)
```

### Comparing `sanpy-ephys-0.1.13/tests/test_fileLoader.py` & `sanpy-ephys-0.1.6/tests/test_fileLoader.py`

 * *Files identical despite different names*

