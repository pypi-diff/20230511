# Comparing `tmp/BitCash-0.6.7-py3-none-any.whl.zip` & `tmp/BitCash-0.6.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,43 +1,44 @@
-Zip file size: 46136 bytes, number of entries: 41
--rw-r--r--  2.0 unx      312 b- defN 22-Nov-19 01:06 bitcash/__init__.py
--rw-r--r--  2.0 unx     1822 b- defN 22-Nov-19 01:06 bitcash/base58.py
--rw-r--r--  2.0 unx     4927 b- defN 22-Nov-19 01:06 bitcash/cashaddress.py
--rw-r--r--  2.0 unx      309 b- defN 22-Nov-19 01:06 bitcash/cli.py
--rw-r--r--  2.0 unx      457 b- defN 22-Nov-19 01:06 bitcash/crypto.py
--rw-r--r--  2.0 unx      484 b- defN 22-Nov-19 01:06 bitcash/curve.py
--rw-r--r--  2.0 unx      189 b- defN 22-Nov-19 01:06 bitcash/exceptions.py
--rw-r--r--  2.0 unx     4864 b- defN 22-Nov-19 01:06 bitcash/format.py
--rw-r--r--  2.0 unx     2388 b- defN 22-Nov-19 01:06 bitcash/keygen.py
--rw-r--r--  2.0 unx    12526 b- defN 22-Nov-19 01:06 bitcash/transaction.py
--rw-r--r--  2.0 unx     1220 b- defN 22-Nov-19 01:06 bitcash/utils.py
--rw-r--r--  2.0 unx    21610 b- defN 22-Nov-19 01:06 bitcash/wallet.py
--rw-r--r--  2.0 unx      170 b- defN 22-Nov-19 01:06 bitcash/network/__init__.py
--rw-r--r--  2.0 unx     1166 b- defN 22-Nov-19 01:06 bitcash/network/meta.py
--rw-r--r--  2.0 unx    20868 b- defN 22-Nov-19 01:06 bitcash/network/rates.py
--rw-r--r--  2.0 unx     7301 b- defN 22-Nov-19 01:06 bitcash/network/services.py
--rw-r--r--  2.0 unx     2032 b- defN 22-Nov-19 01:06 bitcash/network/transaction.py
--rw-r--r--  2.0 unx     4939 b- defN 22-Nov-19 01:06 bitcash/network/APIs/BitcoinDotComAPI.py
--rw-r--r--  2.0 unx        0 b- defN 22-Nov-19 01:06 bitcash/network/APIs/__init__.py
--rw-r--r--  2.0 unx      241 b- defN 22-Nov-19 01:06 bitcash/network/http/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 22-Nov-19 01:06 tests/__init__.py
--rw-r--r--  2.0 unx     4713 b- defN 22-Nov-19 01:06 tests/samples.py
--rw-r--r--  2.0 unx     1036 b- defN 22-Nov-19 01:06 tests/test_base58.py
--rw-r--r--  2.0 unx     7618 b- defN 22-Nov-19 01:06 tests/test_cashaddress.py
--rw-r--r--  2.0 unx      900 b- defN 22-Nov-19 01:06 tests/test_curve.py
--rw-r--r--  2.0 unx     8269 b- defN 22-Nov-19 01:06 tests/test_format.py
--rw-r--r--  2.0 unx    14436 b- defN 22-Nov-19 01:06 tests/test_transaction.py
--rw-r--r--  2.0 unx     2690 b- defN 22-Nov-19 01:06 tests/test_utils.py
--rw-r--r--  2.0 unx    15886 b- defN 22-Nov-19 01:06 tests/test_wallet.py
--rw-r--r--  2.0 unx      672 b- defN 22-Nov-19 01:06 tests/utils.py
--rw-r--r--  2.0 unx        0 b- defN 22-Nov-19 01:06 tests/network/__init__.py
--rw-r--r--  2.0 unx     1012 b- defN 22-Nov-19 01:06 tests/network/test_meta.py
--rw-r--r--  2.0 unx     2614 b- defN 22-Nov-19 01:06 tests/network/test_rates.py
--rw-r--r--  2.0 unx    15409 b- defN 22-Nov-19 01:06 tests/network/test_services.py
--rw-r--r--  2.0 unx      428 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/AUTHORS.md
--rw-r--r--  2.0 unx     1052 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     4315 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/WHEEL
--rw-r--r--  2.0 unx       49 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3254 b- defN 22-Nov-19 01:07 BitCash-0.6.7.dist-info/RECORD
-41 files, 172284 bytes uncompressed, 41018 bytes compressed:  76.2%
+Zip file size: 49242 bytes, number of entries: 42
+-rw-r--r--  2.0 unx      312 b- defN 23-May-11 03:06 bitcash/__init__.py
+-rw-r--r--  2.0 unx     5199 b- defN 23-May-11 03:06 bitcash/_ripemd160.py
+-rw-r--r--  2.0 unx     1819 b- defN 23-May-11 03:06 bitcash/base58.py
+-rw-r--r--  2.0 unx     7517 b- defN 23-May-11 03:06 bitcash/cashaddress.py
+-rw-r--r--  2.0 unx      309 b- defN 23-May-11 03:06 bitcash/cli.py
+-rw-r--r--  2.0 unx      576 b- defN 23-May-11 03:06 bitcash/crypto.py
+-rw-r--r--  2.0 unx      483 b- defN 23-May-11 03:06 bitcash/curve.py
+-rw-r--r--  2.0 unx      189 b- defN 23-May-11 03:06 bitcash/exceptions.py
+-rw-r--r--  2.0 unx     4859 b- defN 23-May-11 03:06 bitcash/format.py
+-rw-r--r--  2.0 unx     2386 b- defN 23-May-11 03:06 bitcash/keygen.py
+-rw-r--r--  2.0 unx    12522 b- defN 23-May-11 03:06 bitcash/transaction.py
+-rw-r--r--  2.0 unx     1218 b- defN 23-May-11 03:06 bitcash/utils.py
+-rw-r--r--  2.0 unx    21610 b- defN 23-May-11 03:06 bitcash/wallet.py
+-rw-r--r--  2.0 unx      170 b- defN 23-May-11 03:06 bitcash/network/__init__.py
+-rw-r--r--  2.0 unx     1166 b- defN 23-May-11 03:06 bitcash/network/meta.py
+-rw-r--r--  2.0 unx    20839 b- defN 23-May-11 03:06 bitcash/network/rates.py
+-rw-r--r--  2.0 unx     7301 b- defN 23-May-11 03:06 bitcash/network/services.py
+-rw-r--r--  2.0 unx     2032 b- defN 23-May-11 03:06 bitcash/network/transaction.py
+-rw-r--r--  2.0 unx     4939 b- defN 23-May-11 03:06 bitcash/network/APIs/BitcoinDotComAPI.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 bitcash/network/APIs/__init__.py
+-rw-r--r--  2.0 unx      241 b- defN 23-May-11 03:06 bitcash/network/http/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 tests/__init__.py
+-rw-r--r--  2.0 unx     4713 b- defN 23-May-11 03:06 tests/samples.py
+-rw-r--r--  2.0 unx     1036 b- defN 23-May-11 03:06 tests/test_base58.py
+-rw-r--r--  2.0 unx     9509 b- defN 23-May-11 03:06 tests/test_cashaddress.py
+-rw-r--r--  2.0 unx      900 b- defN 23-May-11 03:06 tests/test_curve.py
+-rw-r--r--  2.0 unx    10596 b- defN 23-May-11 03:06 tests/test_format.py
+-rw-r--r--  2.0 unx    14436 b- defN 23-May-11 03:06 tests/test_transaction.py
+-rw-r--r--  2.0 unx     2690 b- defN 23-May-11 03:06 tests/test_utils.py
+-rw-r--r--  2.0 unx    15886 b- defN 23-May-11 03:06 tests/test_wallet.py
+-rw-r--r--  2.0 unx      672 b- defN 23-May-11 03:06 tests/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 23-May-11 03:06 tests/network/__init__.py
+-rw-r--r--  2.0 unx     1012 b- defN 23-May-11 03:06 tests/network/test_meta.py
+-rw-r--r--  2.0 unx     2614 b- defN 23-May-11 03:06 tests/network/test_rates.py
+-rw-r--r--  2.0 unx    15408 b- defN 23-May-11 03:06 tests/network/test_services.py
+-rw-r--r--  2.0 unx      428 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/AUTHORS.md
+-rw-r--r--  2.0 unx     1052 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     4294 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/WHEEL
+-rw-r--r--  2.0 unx       49 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3333 b- defN 23-May-11 03:08 BitCash-0.6.8.dist-info/RECORD
+42 files, 184421 bytes uncompressed, 44006 bytes compressed:  76.1%
```

## zipnote {}

```diff
@@ -1,10 +1,13 @@
 Filename: bitcash/__init__.py
 Comment: 
 
+Filename: bitcash/_ripemd160.py
+Comment: 
+
 Filename: bitcash/base58.py
 Comment: 
 
 Filename: bitcash/cashaddress.py
 Comment: 
 
 Filename: bitcash/cli.py
@@ -96,29 +99,29 @@
 
 Filename: tests/network/test_rates.py
 Comment: 
 
 Filename: tests/network/test_services.py
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/AUTHORS.md
+Filename: BitCash-0.6.8.dist-info/AUTHORS.md
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/LICENSE.txt
+Filename: BitCash-0.6.8.dist-info/LICENSE.txt
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/METADATA
+Filename: BitCash-0.6.8.dist-info/METADATA
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/WHEEL
+Filename: BitCash-0.6.8.dist-info/WHEEL
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/entry_points.txt
+Filename: BitCash-0.6.8.dist-info/entry_points.txt
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/top_level.txt
+Filename: BitCash-0.6.8.dist-info/top_level.txt
 Comment: 
 
-Filename: BitCash-0.6.7.dist-info/RECORD
+Filename: BitCash-0.6.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## bitcash/__init__.py

```diff
@@ -5,8 +5,8 @@
     Key,
     PrivateKey,
     PrivateKeyTestnet,
     PrivateKeyRegtest,
     wif_to_key,
 )
 
-__version__ = "0.6.7"
+__version__ = "0.6.8"
```

## bitcash/base58.py

```diff
@@ -5,15 +5,14 @@
 
 BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
 BASE58_ALPHABET_LIST = list(BASE58_ALPHABET)
 BASE58_ALPHABET_INDEX = {char: index for index, char in enumerate(BASE58_ALPHABET)}
 
 
 def b58encode(bytestr):
-
     alphabet = BASE58_ALPHABET_LIST
 
     encoded = deque()
     append = encoded.appendleft
     _divmod = divmod
 
     num = int.from_bytes(bytestr, "big")
@@ -35,15 +34,14 @@
 
 
 def b58encode_check(bytestr):
     return b58encode(bytestr + double_sha256_checksum(bytestr))
 
 
 def b58decode(string):
-
     alphabet_index = BASE58_ALPHABET_INDEX
 
     num = 0
 
     try:
         for char in string:
             num *= 58
@@ -62,15 +60,14 @@
         else:
             break
 
     return b"\x00" * pad + bytestr
 
 
 def b58decode_check(string):
-
     decoded = b58decode(string)
     shortened = decoded[:-4]
     decoded_checksum = decoded[-4:]
     hash_checksum = double_sha256_checksum(shortened)
 
     if decoded_checksum != hash_checksum:
         raise ValueError(
```

## bitcash/cashaddress.py

```diff
@@ -154,7 +154,101 @@
         except Exception:
             raise InvalidAddress("Could not determine address version")
 
         version += Address.VERSION_SUFFIXES[prefix]
 
         payload = converted[1:-6]
         return Address(version, payload)
+
+
+def parse_cashaddress(data):
+    """Parse CashAddress address URI, with params attached
+
+    :param data: Cashaddress uri to be parsed
+    :type data: `str`
+    :returns: cashaddress address, and parameters
+    :rtype: (`str`, `dict`)
+
+    >>> parse_cashaddress(
+            'bchtest:qzvsaasdvw6mt9j2rs3gyps673gj86flev3z0s40ln?'
+            'amount=0.1337&label=Satoshi-Nakamoto&message=Donation%20xyz'
+        )
+    (<bitcash.cashaddress.Address>,
+     {'amount': '0.1337',
+      'label': 'Satoshi-Nakamoto',
+      'message': 'Donation xyz'
+     }
+    )
+    >>> parse_cashaddress(
+            'bchtest:?label=Satoshi-Nakamoto&message=Donation%20xyz'
+        )
+    (None,
+     {'label': 'Satoshi-Nakamoto',
+      'message': 'Donation xyz'
+     }
+    )
+    """
+    import urllib
+
+    uri = urllib.parse.urlparse(data)
+    if uri.scheme not in Address.VERSION_SUFFIXES:
+        raise InvalidAddress("Invalid address scheme")
+
+    if uri.path == "":
+        address = None
+    else:
+        address = Address.from_string(f"{uri.scheme}:{uri.path}")
+    query = urllib.parse.parse_qs(uri.query)
+
+    for key, values in query.items():
+        if len(values) == 1:
+            query[key] = values[0]
+
+    return address, query
+
+
+def generate_cashaddress(address, params=None):
+    """Generates cashaddress uri from address and params
+
+    :param address: cashaddress
+    :type address: `str`
+    :param params: dictionary of parameters to be attached
+    :type params: `dict`
+    :returns: cashaddress uri
+    :rtype: str
+
+    >>> generate_cashaddress(
+            "bitcoincash:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqk5hhyaa6",
+            {
+                "amount": 0.1,
+            }
+    )
+    "bitcoincash:qzfyvx77v2pmgc0vulwlfkl3uzjgh5gnmqk5hhyaa6?amount=0.1"
+    >>> generate_cashaddress(
+            "bitcoincash:",
+            {"message": "Satoshi Nakamoto"}
+    )
+    "bitcoincash:?message=Satoshi%20Nakamoto"
+    """
+    import urllib
+
+    uri = urllib.parse.urlparse(address)
+    if uri.path != "":
+        # testing address
+        _ = Address.from_string(f"{uri.scheme}:{uri.path}")
+    elif uri.scheme not in Address.VERSION_SUFFIXES:
+        raise InvalidAddress("Invalid address scheme")
+
+    if params is None:
+        return uri.geturl()
+
+    param_list = []
+    for key, values in params.items():
+        if isinstance(values, str) or not hasattr(values, "__iter__"):
+            values = [values]
+        for value in values:
+            param_list.append((key, value))
+
+    query = urllib.parse.urlencode(param_list)
+    uri = uri._replace(query=query)
+
+    return uri.geturl()
```

## bitcash/crypto.py

```diff
@@ -1,8 +1,9 @@
 from hashlib import new, sha256 as _sha256
+from bitcash._ripemd160 import ripemd160
 
 from coincurve import PrivateKey as ECPrivateKey, PublicKey as ECPublicKey
 
 
 def sha256(bytestr):
     return _sha256(bytestr).digest()
 
@@ -12,11 +13,14 @@
 
 
 def double_sha256_checksum(bytestr):
     return double_sha256(bytestr)[:4]
 
 
 def ripemd160_sha256(bytestr):
-    return new("ripemd160", sha256(bytestr)).digest()
+    try:
+        return new("ripemd160", sha256(bytestr)).digest()
+    except ValueError:
+        return ripemd160(sha256(bytestr))
 
 
 hash160 = ripemd160_sha256
```

## bitcash/curve.py

```diff
@@ -9,14 +9,13 @@
 
 
 def parity(num):
     return num & 1
 
 
 def x_to_y(x, y_parity):
-
     y = pow(x**3 + 7, TONELLI_SHANKS_CONSTANT, FIELD_SIZE)
 
     if parity(y) != y_parity:
         y = FIELD_SIZE - y
 
     return y
```

## bitcash/format.py

```diff
@@ -52,15 +52,14 @@
         # others will raise ValueError
         raise ValueError("Bitcash currently only supports" " P2PKH/P2SH addresses")
 
     return bytes(address.payload)
 
 
 def bytes_to_wif(private_key, version="main", compressed=False):
-
     if version == "test":
         prefix = TEST_PRIVATE_KEY
     elif version == "regtest":
         prefix = REGTEST_PRIVATE_KEY
     else:
         prefix = MAIN_PRIVATE_KEY
 
@@ -71,15 +70,14 @@
 
     private_key = prefix + private_key + suffix
 
     return b58encode_check(private_key)
 
 
 def wif_to_bytes(wif, regtest=False):
-
     private_key = b58decode_check(wif)
 
     version = private_key[:1]
 
     if version == MAIN_PRIVATE_KEY:
         version = "main"
     elif version == TEST_PRIVATE_KEY:
@@ -101,15 +99,14 @@
     else:
         private_key, compressed = private_key[1:], False
 
     return private_key, compressed, version
 
 
 def wif_checksum_check(wif):
-
     try:
         decoded = b58decode_check(wif)
     except ValueError:
         return False
 
     if decoded[:1] in (MAIN_PRIVATE_KEY, TEST_PRIVATE_KEY, REGTEST_PRIVATE_KEY):
         return True
@@ -132,15 +129,14 @@
 
     payload = list(ripemd160_sha256(public_key))
     address = Address(payload=payload, version=version)
     return address.cash_address()
 
 
 def public_key_to_coords(public_key):
-
     length = len(public_key)
 
     if length == 33:
         flag, x = int.from_bytes(public_key[:1], "big"), int.from_bytes(
             public_key[1:], "big"
         )
         y = x_to_y(x, flag & 1)
@@ -151,15 +147,14 @@
     else:
         raise ValueError(f"{length} is an invalid length for a public key.")
 
     return x, y
 
 
 def coords_to_public_key(x, y, compressed=True):
-
     if compressed:
         y = PUBLIC_KEY_COMPRESSED_ODD_Y if y & 1 else PUBLIC_KEY_COMPRESSED_EVEN_Y
         return y + x.to_bytes(32, "big")
 
     return PUBLIC_KEY_UNCOMPRESSED + x.to_bytes(32, "big") + y.to_bytes(32, "big")
```

## bitcash/keygen.py

```diff
@@ -12,15 +12,14 @@
 def generate_key_address_pair():  # pragma: no cover
     private_key = ECPrivateKey()
     address = public_key_to_address(private_key.public_key.format())
     return bytes_to_wif(private_key.secret), address
 
 
 def generate_matching_address(prefix, cores="all"):  # pragma: no cover
-
     for char in prefix:
         if char not in BASE58_ALPHABET:
             raise ValueError(f"{char} is an invalid base58 encoded " f"character.")
 
     if not prefix:
         return generate_key_address_pair()
     elif not prefix.startswith("1"):
@@ -64,15 +63,14 @@
         sys.stdout.flush()
 
     private_key, address = queue.get()
     print(f"\n\n" f"WIF: {bytes_to_wif(private_key)}\n" f"Address: {address}")
 
 
 def generate_key_address_pairs(prefix, counter, match, queue):  # pragma: no cover
-
     context = Context()
 
     while True:
         if match.is_set():
             return
 
         with counter.get_lock():
```

## bitcash/transaction.py

```diff
@@ -77,15 +77,14 @@
 def calc_txid(tx_hex):
     return bytes_to_hex(double_sha256(hex_to_bytes(tx_hex))[::-1])
 
 
 def estimate_tx_fee(
     n_in, n_out_p2pkh, n_out_p2sh, satoshis, compressed, op_return_size=0
 ):
-
     if not satoshis:
         return 0
 
     n_out = n_out_p2sh + n_out_p2pkh
 
     estimated_size = (
         4
@@ -267,15 +266,14 @@
 
     outputs.extend(messages)
 
     return unspents, outputs
 
 
 def construct_output_block(outputs, custom_pushdata=False):
-
     output_block = b""
 
     for data in outputs:
         dest, amount = data
 
         # Real recipient
         if amount:
@@ -320,28 +318,26 @@
         output_block += int_to_unknown_bytes(len(script), byteorder="little")
         output_block += script
 
     return output_block
 
 
 def construct_input_block(inputs):
-
     input_block = b""
     sequence = SEQUENCE
 
     for txin in inputs:
         input_block += (
             txin.txid + txin.txindex + txin.script_len + txin.script + sequence
         )
 
     return input_block
 
 
 def create_p2pkh_transaction(private_key, unspents, outputs, custom_pushdata=False):
-
     public_key = private_key.public_key
     public_key_len = len(public_key).to_bytes(1, byteorder="little")
 
     scriptCode = private_key.scriptcode
     scriptCode_len = int_to_varint(len(scriptCode))
 
     version = VERSION_1
```

## bitcash/utils.py

```diff
@@ -18,15 +18,14 @@
 
 def bytes_to_hex(bytestr, upper=False):
     hexed = hexlify(bytestr).decode()
     return hexed.upper() if upper else hexed
 
 
 def hex_to_bytes(hexed):
-
     if len(hexed) & 1:
         hexed = "0" + hexed
 
     return bytes.fromhex(hexed)
 
 
 def int_to_hex(num, upper=False):
@@ -39,15 +38,14 @@
 
 
 def flip_hex_byte_order(string):
     return bytes_to_hex(hex_to_bytes(string)[::-1])
 
 
 def int_to_varint(val):
-
     if val < 253:
         return val.to_bytes(1, "little")
     elif val <= 65535:
         return b"\xfd" + val.to_bytes(2, "little")
     elif val <= 4294967295:
         return b"\xfe" + val.to_bytes(4, "little")
     else:
```

## bitcash/network/rates.py

```diff
@@ -308,322 +308,293 @@
     PEN_RATES = [BitpayRates.pen_to_satoshi]
     UYU_RATES = [BitpayRates.uyu_to_satoshi]
     BOB_RATES = [BitpayRates.bob_to_satoshi]
     DOP_RATES = [BitpayRates.dop_to_satoshi]
 
     @classmethod
     def usd_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.USD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def eur_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.EUR_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def gbp_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.GBP_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def jpy_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.JPY_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def cny_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.CNY_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def hkd_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.HKD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def cad_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.CAD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def aud_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.AUD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def nzd_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.NZD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def rub_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.RUB_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def brl_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.BRL_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def chf_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.CHF_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def sek_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.SEK_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def dkk_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.DKK_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def isk_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.ISK_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def pln_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.PLN_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def krw_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.KRW_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def clp_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.CLP_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def sgd_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.SGD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def thb_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.THB_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def twd_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.TWD_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def mxn_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.MXN_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def ars_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.ARS_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def cop_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.COP_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def cup_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.CUP_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def pen_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.PEN_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def uyu_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.UYU_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def dop_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.DOP_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
 
     @classmethod
     def bob_to_satoshi(cls):  # pragma: no cover
-
         for api_call in cls.BOB_RATES:
             try:
                 return api_call()
             except cls.IGNORED_ERRORS:
                 pass
 
         raise ConnectionError("All APIs are unreachable.")
```

## tests/test_cashaddress.py

```diff
@@ -1,10 +1,15 @@
 import pytest
 
-from bitcash.cashaddress import Address, convertbits
+from bitcash.cashaddress import (
+    Address,
+    convertbits,
+    generate_cashaddress,
+    parse_cashaddress,
+)
 from bitcash.exceptions import InvalidAddress
 
 from .samples import (
     PUBKEY_HASH,
     PUBKEY_HASH_COMPRESSED,
     BITCOIN_ADDRESS,
     BITCOIN_ADDRESS_COMPRESSED,
@@ -214,7 +219,60 @@
 
     def test_eq(self):
         address = Address.from_string(BITCOIN_CASHADDRESS)
         assert address == BITCOIN_CASHADDRESS
         assert address == address
         with pytest.raises(ValueError):
             address == 1
+
+
+def test_parse_cashaddress():
+    # good address
+    address, params = parse_cashaddress(
+        BITCOIN_CASHADDRESS + "?amount=0.1337&label=Satoshi"
+    )
+    assert address.cash_address() == BITCOIN_CASHADDRESS
+    assert params == {"amount": "0.1337", "label": "Satoshi"}
+
+    address, params = parse_cashaddress(
+        BITCOIN_CASHADDRESS + "?amount=0.1337&label=Satoshi%20a&label=Satoshi%20b"
+    )
+    assert address.cash_address() == BITCOIN_CASHADDRESS
+    assert params == {"amount": "0.1337", "label": ["Satoshi a", "Satoshi b"]}
+
+    address, params = parse_cashaddress(BITCOIN_CASHADDRESS + "")
+    assert address.cash_address() == BITCOIN_CASHADDRESS
+    assert params == {}
+
+    address, _ = parse_cashaddress("bchtest:")
+    assert address is None
+
+    # bad address
+    with pytest.raises(InvalidAddress):
+        address, params = parse_cashaddress(
+            "bchtest:abc" + "?amount=0.1337&label=Satoshi&label=Satoshi"
+        )
+
+    with pytest.raises(InvalidAddress):
+        address, params = parse_cashaddress(
+            "bch:" + "?amount=0.1337&label=Satoshi&label=Satoshi"
+        )
+
+
+def test_generate_cashaddress():
+    assert generate_cashaddress(BITCOIN_CASHADDRESS) == BITCOIN_CASHADDRESS
+
+    cashaddress = generate_cashaddress("bitcoincash:", {"message": "Satoshi Nakamoto"})
+    assert cashaddress == "bitcoincash:?message=Satoshi+Nakamoto"
+    cashaddress = generate_cashaddress(
+        BITCOIN_CASHADDRESS,
+        {"amount": 0.1337, "data": ["a", 1], "message": "Satoshi Nakamoto"},
+    )
+    assert cashaddress == (
+        BITCOIN_CASHADDRESS + "?amount=0.1337&data=a&data=1&message=Satoshi+Nakamoto"
+    )
+
+    with pytest.raises(InvalidAddress):
+        generate_cashaddress("bch:")
+
+    with pytest.raises(InvalidAddress):
+        generate_cashaddress(BITCOIN_CASHADDRESS[:-1])
```

## tests/test_format.py

```diff
@@ -1,8 +1,10 @@
 import pytest
+from bitcash import crypto
+from _pytest.monkeypatch import MonkeyPatch
 from bitcash.exceptions import InvalidAddress
 
 from bitcash.format import (
     Address,
     address_to_public_key_hash,
     bytes_to_wif,
     coords_to_public_key,
@@ -211,14 +213,73 @@
     def test_public_key_to_address_regtest_uncompressed(self):
         assert (
             public_key_to_address(PUBLIC_KEY_UNCOMPRESSED, version="regtest")
             == BITCOIN_CASHADDRESS_REGTEST
         )
 
 
+def mock_hashlib(name, data):
+    """Force ValueError from hashlib.new to fallback to pythonic ripemd160"""
+    raise ValueError()
+
+
+class TestPublicKeyToAddress_pythonic_ripemd:
+    def setup_method(self):
+        self.monkeypatch = MonkeyPatch()
+
+    def test_public_key_to_address_compressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert (
+            public_key_to_address(PUBLIC_KEY_COMPRESSED)
+            == BITCOIN_CASHADDRESS_COMPRESSED
+        )
+
+    def test_public_key_to_address_uncompressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert public_key_to_address(PUBLIC_KEY_UNCOMPRESSED) == BITCOIN_CASHADDRESS
+
+    def test_public_key_to_address_incorrect_length(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        with pytest.raises(ValueError):
+            public_key_to_address(PUBLIC_KEY_COMPRESSED[:-1])
+
+    def test_public_key_to_address_incorrect_version(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        with pytest.raises(ValueError):
+            public_key_to_address(PUBLIC_KEY_COMPRESSED, "incorrect-version")
+
+    def test_public_key_to_address_test_compressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert (
+            public_key_to_address(PUBLIC_KEY_COMPRESSED, version="test")
+            == BITCOIN_CASHADDRESS_TEST_COMPRESSED
+        )
+
+    def test_public_key_to_address_test_uncompressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert (
+            public_key_to_address(PUBLIC_KEY_UNCOMPRESSED, version="test")
+            == BITCOIN_CASHADDRESS_TEST
+        )
+
+    def test_public_key_to_address_regtest_compressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert (
+            public_key_to_address(PUBLIC_KEY_COMPRESSED, version="regtest")
+            == BITCOIN_CASHADDRESS_REGTEST_COMPRESSED
+        )
+
+    def test_public_key_to_address_regtest_uncompressed(self):
+        self.monkeypatch.setattr(crypto, "new", mock_hashlib)
+        assert (
+            public_key_to_address(PUBLIC_KEY_UNCOMPRESSED, version="regtest")
+            == BITCOIN_CASHADDRESS_REGTEST
+        )
+
+
 class TestCoordsToPublicKey:
     def test_coords_to_public_key_compressed(self):
         assert coords_to_public_key(PUBLIC_KEY_X, PUBLIC_KEY_Y) == PUBLIC_KEY_COMPRESSED
 
     def test_coords_to_public_key_uncompressed(self):
         assert (
             coords_to_public_key(PUBLIC_KEY_X, PUBLIC_KEY_Y, compressed=False)
```

## tests/network/test_services.py

```diff
@@ -161,15 +161,14 @@
     def test_get_unspent_testnet_failure(self):
         with pytest.raises(ConnectionError):
             MockBackend.get_unspent(TEST_ADDRESS_USED2, network="testnet")
 
 
 @decorate_methods(catch_errors_raise_warnings, NetworkAPI.IGNORED_ERRORS)
 class TestBitcoinDotComAPI:
-
     # Mainnet
     # Note: There are 1 second sleeps because the default mainnet API has
     # rate limiting and will return 503 if we query it too quickly.
 
     def test_invalid_endpoint_url_mainnet(self):
         for url in INVALID_ENDPOINT_URLS:
             with pytest.raises(InvalidEndpointURLProvided):
```

## Comparing `BitCash-0.6.7.dist-info/LICENSE.txt` & `BitCash-0.6.8.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `BitCash-0.6.7.dist-info/METADATA` & `BitCash-0.6.8.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 Metadata-Version: 2.1
 Name: BitCash
-Version: 0.6.7
+Version: 0.6.8
 Summary: Bitcoin Cash made easier.
 Home-page: https://github.com/pybitcash/bitcash
 Author: Teran McKinney
 Author-email: sega01@go-beyond.org
 Maintainer: Corentin Mercier
 Maintainer-email: corentin@mercier.link
 License: MIT
-Download-URL: https://github.com/pybitcash/bitcash/tarball/0.6.7
+Download-URL: https://github.com/pybitcash/bitcash/tarball/0.6.8
 Keywords: bitcoincash,cryptocurrency,payments,tools,wallet
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: End Users/Desktop
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Natural Language :: English
 Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 License-File: AUTHORS.md
 Requires-Dist: coincurve (>=4.3.0)
 Requires-Dist: requests
@@ -94,19 +94,19 @@
 - Standard P2PKH transactions
 
 If you are intrigued, continue reading. If not, continue all the same!
 
 ## Installation
 
 BitCash is distributed on `PyPI` as a universal wheel and is available on Linux/macOS
-and Windows and supports Python 3.6+ and PyPy3.6-v5.7.1+.
+and Windows and supports Python 3.7+.
 
 
 ```shell
-$ pip install bitcash  # pip3 if pip is Python 2 on your system.
+pip install bitcash  # pip3 if pip is Python 2 on your system.
 ```
 
 ## Documentation
 
 Docs are hosted by Github Pages and are automatically built and published after every successful commit to BitCash's ``master`` branch.
 
 [Read the documentation](https://bitcash.dev)
```

### html2text {}

```diff
@@ -1,20 +1,20 @@
-Metadata-Version: 2.1 Name: BitCash Version: 0.6.7 Summary: Bitcoin Cash made
+Metadata-Version: 2.1 Name: BitCash Version: 0.6.8 Summary: Bitcoin Cash made
 easier. Home-page: https://github.com/pybitcash/bitcash Author: Teran McKinney
 Author-email: sega01@go-beyond.org Maintainer: Corentin Mercier Maintainer-
 email: corentin@mercier.link License: MIT Download-URL: https://github.com/
-pybitcash/bitcash/tarball/0.6.7 Keywords:
+pybitcash/bitcash/tarball/0.6.8 Keywords:
 bitcoincash,cryptocurrency,payments,tools,wallet Platform: UNKNOWN Classifier:
 Development Status :: 4 - Beta Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: End Users/Desktop Classifier: License :: OSI
 Approved :: MIT License Classifier: Natural Language :: English Classifier:
 Operating System :: OS Independent Classifier: Programming Language :: Python
-:: 3.6 Classifier: Programming Language :: Python :: 3.7 Classifier:
-Programming Language :: Python :: 3.8 Classifier: Programming Language ::
-Python :: 3.9 Classifier: Programming Language :: Python :: Implementation ::
+:: 3.7 Classifier: Programming Language :: Python :: 3.8 Classifier:
+Programming Language :: Python :: 3.9 Classifier: Programming Language ::
+Python :: 3.10 Classifier: Programming Language :: Python :: Implementation ::
 CPython Classifier: Programming Language :: Python :: Implementation :: PyPy
 Description-Content-Type: text/markdown License-File: LICENSE.txt License-File:
 AUTHORS.md Requires-Dist: coincurve (>=4.3.0) Requires-Dist: requests Provides-
 Extra: cache Requires-Dist: lmdb ; extra == 'cache' Provides-Extra: cli
 Requires-Dist: appdirs ; extra == 'cli' Requires-Dist: click ; extra == 'cli'
 Requires-Dist: privy ; extra == 'cli' Requires-Dist: tinydb ; extra == 'cli'
                                **** BitCash ****
@@ -36,14 +36,13 @@
 storage - Fully supports 29 different currencies - First class support for
 storing data in the blockchain - Deterministic signatures via RFC 6979 - Access
 to the blockchain (and testnet chain) through multiple APIs for redundancy -
 Exchange rate API, with optional caching - Compressed public keys by default -
 Multiple representations of private keys; WIF, PEM, DER, etc. - Standard P2PKH
 transactions If you are intrigued, continue reading. If not, continue all the
 same! ## Installation BitCash is distributed on `PyPI` as a universal wheel and
-is available on Linux/macOS and Windows and supports Python 3.6+ and PyPy3.6-
-v5.7.1+. ```shell $ pip install bitcash # pip3 if pip is Python 2 on your
-system. ``` ## Documentation Docs are hosted by Github Pages and are
-automatically built and published after every successful commit to BitCash's
-``master`` branch. [Read the documentation](https://bitcash.dev) ## Credits -
-[ofek](https://github.com/ofek/bit) for the original bit codebase. -
-[Additional](AUTHORS.md)
+is available on Linux/macOS and Windows and supports Python 3.7+. ```shell pip
+install bitcash # pip3 if pip is Python 2 on your system. ``` ## Documentation
+Docs are hosted by Github Pages and are automatically built and published after
+every successful commit to BitCash's ``master`` branch. [Read the
+documentation](https://bitcash.dev) ## Credits - [ofek](https://github.com/
+ofek/bit) for the original bit codebase. - [Additional](AUTHORS.md)
```

## Comparing `BitCash-0.6.7.dist-info/RECORD` & `BitCash-0.6.8.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,41 +1,42 @@
-bitcash/__init__.py,sha256=Hj3zx2Ut0El3OzvZ9IzNsaYp2sp372pfNn5JT3K3zZA,312
-bitcash/base58.py,sha256=NoAA3eBbVgiQZwLHoc3zuZbaHdccCibD-T5-D3ffOoU,1822
-bitcash/cashaddress.py,sha256=UT9y9H8MaNLuO2XzvpZinui9vYMbsE4oZaJebrFKH1M,4927
+bitcash/__init__.py,sha256=mA-hDy10xxjpiLyy3APC-wlyn8qDC4Q4S_MW2lf9iqo,312
+bitcash/_ripemd160.py,sha256=924YTi37mkRBDGqjmj58CLRVfBjiSWYpoz-z4zE1sIw,5199
+bitcash/base58.py,sha256=a2M0HWqmo19FdE6vXupFZGlFFqg7WthoTiB-tBnC20Y,1819
+bitcash/cashaddress.py,sha256=IqcpYsadsnb03arT1pRtGvIkEkcVvEdYn9KcexlRarE,7517
 bitcash/cli.py,sha256=tEtnnWh2WLsaTe3DFFwh6eHH7bkFM8-XBy5X0K4Ro6k,309
-bitcash/crypto.py,sha256=U8rTjlZIEwFHVPLhzePj8QUR9B3AnSYdNotmjes8Pyw,457
-bitcash/curve.py,sha256=6D6ujoGckSjHc1TT8k5O_Gl6hiV2Ygsec5zGmn0xSkI,484
+bitcash/crypto.py,sha256=fGduLfHYqhyOrDdO5E6fUqDe99oARFJakZHWpcBq2bI,576
+bitcash/curve.py,sha256=m9lRzgUlONUnGWcOqMegHJ5ohwdCCNuYhDGsN_-_YbA,483
 bitcash/exceptions.py,sha256=sxiR15_1DnR7ffLO0q3sqsQorlHgkQWWWf5kJcXDc2I,189
-bitcash/format.py,sha256=6DBswJUp-Vjt_czDlIYPtsvXjWQbkB4g01X1XEjPH0E,4864
-bitcash/keygen.py,sha256=GUZ-0N4udwUhTaoOUox0pcUn7mRkbCnDBbHqmdhVCWk,2388
-bitcash/transaction.py,sha256=dWfy-_fIvrDmXvw0wnKc1bfA06D1qLJaQIAn6JgIaNU,12526
-bitcash/utils.py,sha256=OYiey0fsJxng9FhNH5VJdvVvxfaay18SdXyAG2hml9s,1220
+bitcash/format.py,sha256=z81MKg5G0OKp0qVso3QCGm0XkZBSua-ypcRXMCzohkY,4859
+bitcash/keygen.py,sha256=A04c1zZJq6rpSC1wiVAyAEAlQstMUeO-NbZDnskasdY,2386
+bitcash/transaction.py,sha256=K6G8tOJDanTJecyucxNLlEoRGrpoLnofP9I5BtfQE4Y,12522
+bitcash/utils.py,sha256=7alyuR0XBorjXOgGhs65XJVmRoblhh4cU1PXEeVsifA,1218
 bitcash/wallet.py,sha256=0ZwkBN1Vm-hnZXwO1qbkYj6gaJhCJLcXnT_ER3qYcOg,21610
 bitcash/network/__init__.py,sha256=4303d1zyJjxMmZz08H7S_o1P5JNVqHHQJtcPslL3t9Y,170
 bitcash/network/meta.py,sha256=sfEuplO8cumkjUgW9tT0bbCd-gNrva1tZA4wjB4b3Ko,1166
-bitcash/network/rates.py,sha256=dcm0y1kZfKnFadtrKgl7boEbtIzZUMcGjw_AxsOTMhI,20868
+bitcash/network/rates.py,sha256=J6tT3YJNF3hw-Y2arAcXhZkHWgj7psM0R9Hwqp0KknI,20839
 bitcash/network/services.py,sha256=hFmueELa45SEj4gAm0D77JqJmt11xi73D6Y6iYDRb-g,7301
 bitcash/network/transaction.py,sha256=fzKxipeQzR-exnns2elTWuIkOD58uXE8SYBAgKQk4Rw,2032
 bitcash/network/APIs/BitcoinDotComAPI.py,sha256=U0VIsUnGBF6tzWS5HYQBSaXa8ig0xSpSO9MfeumH4nk,4939
 bitcash/network/APIs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 bitcash/network/http/__init__.py,sha256=CsayB2zMuNYEAXv-zl35p3irhAyhk0DQyqpDGeccp_U,241
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/samples.py,sha256=jmIntNEc0dUTLerj6VAbiTsAnO2jgJzrNZ1cDPs6JG0,4713
 tests/test_base58.py,sha256=GP6sbY3E93C3e-xzN9Cd0aw5rngeVDrW2Z-j5YZmKRc,1036
-tests/test_cashaddress.py,sha256=LbabqdM8Itw22S5CHIXiTkrfHObeiNnMklTGIgAXl00,7618
+tests/test_cashaddress.py,sha256=vBFLwAiHNaho6Gpm0plKLN1nS8lOGoJwAah4GuUz3rE,9509
 tests/test_curve.py,sha256=-sBw9gJKOlgvi-rG-gQ68GZ0Lpsy9CoGtSwVdcGYYdc,900
-tests/test_format.py,sha256=6JWo_m3Na7V3f6coB2cucv26ks-3PtB_tulmD4I-FSk,8269
+tests/test_format.py,sha256=brvHToAcpNsHMFbVIBOT4tGgX-OJyH_JrH4oEQAz4wA,10596
 tests/test_transaction.py,sha256=GWSfAZaTo6pmP8IR5guUUVTWlcR-UZTCwnwkA7mj9pg,14436
 tests/test_utils.py,sha256=EHtKlqiVQRZy1QwylkGoYN-mXAvCyOMWiaaWvrHT5QY,2690
 tests/test_wallet.py,sha256=o4U0HHhDpozlaLIO-Uiv-hsPwFSJPW6Kqz58KbnU_M4,15886
 tests/utils.py,sha256=vQXhkt1v8VWFHpqFCw0mmdHenhRl9swr2VztZIkeMm4,672
 tests/network/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/network/test_meta.py,sha256=BvTS27SnVPjWr2B8W5VWEstJwgsKxwLM45Qlcz40h8Q,1012
 tests/network/test_rates.py,sha256=VB5TRxvo3KqOYeuzpbj5EVbMJgacatiRTjKgmJCzO-4,2614
-tests/network/test_services.py,sha256=FtOmYwTqskaqppkxBJG5Xe-MU-9I-XF9P5oRBa_4X4c,15409
-BitCash-0.6.7.dist-info/AUTHORS.md,sha256=h2-RtP3w62mtQNXtQ_sppCD5fQwV-oyDxy5ShMjVZBQ,428
-BitCash-0.6.7.dist-info/LICENSE.txt,sha256=b2KK82Uty2-WjWR0lVj-f6m37fA3GMe-Mzi3oQq2iL8,1052
-BitCash-0.6.7.dist-info/METADATA,sha256=sMKvokd3O3qAmSLuHPVxxV1eg7-E1yPrkXeXkh0nk4I,4315
-BitCash-0.6.7.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-BitCash-0.6.7.dist-info/entry_points.txt,sha256=V74SyZtAkGzTTvFy6v8OlNusDxQopsVy_Wdd5PKmyps,49
-BitCash-0.6.7.dist-info/top_level.txt,sha256=7A3uL54GMzX3TgkDgJqVc6Ya1maw4xOElrTI582mBT4,14
-BitCash-0.6.7.dist-info/RECORD,,
+tests/network/test_services.py,sha256=zsDSvGcAlgN5FBssHYx1SzaOjIhptXzAdtzPafIuwTA,15408
+BitCash-0.6.8.dist-info/AUTHORS.md,sha256=h2-RtP3w62mtQNXtQ_sppCD5fQwV-oyDxy5ShMjVZBQ,428
+BitCash-0.6.8.dist-info/LICENSE.txt,sha256=b2KK82Uty2-WjWR0lVj-f6m37fA3GMe-Mzi3oQq2iL8,1052
+BitCash-0.6.8.dist-info/METADATA,sha256=F-5HxM5GVrV2LtZteOCqk9hKMJ2DWs1QhXWmFvOQSQM,4294
+BitCash-0.6.8.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+BitCash-0.6.8.dist-info/entry_points.txt,sha256=V74SyZtAkGzTTvFy6v8OlNusDxQopsVy_Wdd5PKmyps,49
+BitCash-0.6.8.dist-info/top_level.txt,sha256=7A3uL54GMzX3TgkDgJqVc6Ya1maw4xOElrTI582mBT4,14
+BitCash-0.6.8.dist-info/RECORD,,
```

