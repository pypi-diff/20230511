# Comparing `tmp/tilmedia-3.13.0-cp39-cp39-win_amd64.whl.zip` & `tmp/tilmedia-3.14.0-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 3069778 bytes, number of entries: 21
--rw-rw-rw-  2.0 fat     2868 b- defN 22-Dec-05 16:23 tilmedia/__init__.py
--rw-rw-rw-  2.0 fat     6933 b- defN 22-Dec-05 16:23 tilmedia/_internals.py
--rw-rw-rw-  2.0 fat     4572 b- defN 22-Dec-05 16:23 tilmedia/batchcaller.py
--rw-rw-rw-  2.0 fat     6302 b- defN 22-Dec-05 16:23 tilmedia/convert.py
--rw-rw-rw-  2.0 fat  5869280 b- defN 22-Dec-05 16:30 tilmedia/core.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     4616 b- defN 22-Dec-05 16:30 tilmedia/core.pyi
--rw-rw-rw-  2.0 fat     3893 b- defN 22-Dec-05 16:23 tilmedia/datacontainer.py
--rw-rw-rw-  2.0 fat     1228 b- defN 22-Dec-05 16:23 tilmedia/exceptions.py
--rw-rw-rw-  2.0 fat    48399 b- defN 22-Dec-05 16:23 tilmedia/gas.py
--rw-rw-rw-  2.0 fat     2118 b- defN 22-Dec-05 16:23 tilmedia/general.py
--rw-rw-rw-  2.0 fat    29451 b- defN 22-Dec-05 16:23 tilmedia/liquid.py
--rw-rw-rw-  2.0 fat      894 b- defN 22-Dec-05 16:23 tilmedia/logger.py
--rw-rw-rw-  2.0 fat     4414 b- defN 22-Dec-05 16:23 tilmedia/moistair.py
--rw-rw-rw-  2.0 fat    18592 b- defN 22-Dec-05 16:23 tilmedia/properties.py
--rw-rw-rw-  2.0 fat    70809 b- defN 22-Dec-05 16:23 tilmedia/vlefluid.py
--rw-rw-rw-  2.0 fat     1475 b- defN 22-Dec-05 16:30 tilmedia-3.13.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     3030 b- defN 22-Dec-05 16:30 tilmedia-3.13.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat     8256 b- defN 22-Dec-05 16:30 tilmedia-3.13.0.dist-info/Third-Party-License.txt
--rw-rw-rw-  2.0 fat      100 b- defN 22-Dec-05 16:30 tilmedia-3.13.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        9 b- defN 22-Dec-05 16:28 tilmedia-3.13.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1679 b- defN 22-Dec-05 16:30 tilmedia-3.13.0.dist-info/RECORD
-21 files, 6088918 bytes uncompressed, 3067092 bytes compressed:  49.6%
+Zip file size: 3092170 bytes, number of entries: 21
+-rw-rw-rw-  2.0 fat     2982 b- defN 23-Apr-14 09:21 tilmedia/__init__.py
+-rw-rw-rw-  2.0 fat     6900 b- defN 23-Apr-14 09:21 tilmedia/_internals.py
+-rw-rw-rw-  2.0 fat     4680 b- defN 23-Apr-14 09:21 tilmedia/batchcaller.py
+-rw-rw-rw-  2.0 fat     6302 b- defN 23-Apr-14 09:21 tilmedia/convert.py
+-rw-rw-rw-  2.0 fat  6038240 b- defN 23-Apr-14 09:28 tilmedia/core.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat     4769 b- defN 23-Apr-14 09:28 tilmedia/core.pyi
+-rw-rw-rw-  2.0 fat     3905 b- defN 23-Apr-14 09:21 tilmedia/datacontainer.py
+-rw-rw-rw-  2.0 fat     1228 b- defN 23-Apr-14 09:21 tilmedia/exceptions.py
+-rw-rw-rw-  2.0 fat    51282 b- defN 23-Apr-14 09:21 tilmedia/gas.py
+-rw-rw-rw-  2.0 fat     4374 b- defN 23-Apr-14 09:21 tilmedia/general.py
+-rw-rw-rw-  2.0 fat    30312 b- defN 23-Apr-14 09:21 tilmedia/liquid.py
+-rw-rw-rw-  2.0 fat      894 b- defN 23-Apr-14 09:21 tilmedia/logger.py
+-rw-rw-rw-  2.0 fat     4607 b- defN 23-Apr-14 09:21 tilmedia/moistair.py
+-rw-rw-rw-  2.0 fat    18606 b- defN 23-Apr-14 09:21 tilmedia/properties.py
+-rw-rw-rw-  2.0 fat    79073 b- defN 23-Apr-14 09:21 tilmedia/vlefluid.py
+-rw-rw-rw-  2.0 fat     1475 b- defN 23-Apr-14 09:28 tilmedia-3.14.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     3030 b- defN 23-Apr-14 09:28 tilmedia-3.14.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat     8256 b- defN 23-Apr-14 09:28 tilmedia-3.14.0.dist-info/Third-Party-License.txt
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-14 09:28 tilmedia-3.14.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        9 b- defN 23-Apr-14 09:26 tilmedia-3.14.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1679 b- defN 23-Apr-14 09:28 tilmedia-3.14.0.dist-info/RECORD
+21 files, 6272703 bytes uncompressed, 3089484 bytes compressed:  50.8%
```

## zipnote {}

```diff
@@ -39,26 +39,26 @@
 
 Filename: tilmedia/properties.py
 Comment: 
 
 Filename: tilmedia/vlefluid.py
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/LICENSE.txt
+Filename: tilmedia-3.14.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/METADATA
+Filename: tilmedia-3.14.0.dist-info/METADATA
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/Third-Party-License.txt
+Filename: tilmedia-3.14.0.dist-info/Third-Party-License.txt
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/WHEEL
+Filename: tilmedia-3.14.0.dist-info/WHEEL
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/top_level.txt
+Filename: tilmedia-3.14.0.dist-info/top_level.txt
 Comment: 
 
-Filename: tilmedia-3.13.0.dist-info/RECORD
+Filename: tilmedia-3.14.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tilmedia/__init__.py

```diff
@@ -11,57 +11,67 @@
 .. _TILMedia Suite: https://www.tlk-thermo.com/index.php/en/tilmedia-suite
 """
 
 from re import search as re_search
 from ._internals import set_logger_exceptions, set_logger, _logger
 from .general import (
     get_all_liquid_names,
+    get_all_liquid_mixture_names,
     get_all_gas_names,
     get_all_vleFluid_names,
     get_all_condensing_gas_names,
     get_all_adsorption_and_absorption_names,
     get_data_path,
     set_data_path,
     clear_medium_name_cache,
     get_closest_vleFluid_dpT,
-    license_is_valid
+    license_is_valid,
 )
 from .exceptions import (
     TILMediaError,
     TILMediaErrorIncompatibleVectorLength,
     TILMediaErrorInvalidParameter,
     TILMediaErrorInvalidMedium,
-    TILMediaErrorInvalidLicense
+    TILMediaErrorInvalidLicense,
 )
 from .properties import property_information
 
 from .gas import Gas
 from .moistair import MoistAir
 from .liquid import Liquid
 from .vlefluid import VLEFluid
+
 _VLEProperties = VLEFluid._VLEProperties
 _SaturationProperties = VLEFluid._SaturationProperties
 _CriticalProperties = VLEFluid._CriticalProperties
 
-__version__ = "3.13.0"
-version_match = re_search(r'(\d+\.)+?((?P<final_release>\d+)|\d+(?P<pre_release>a|b|rc)(?P<pre_release_version>\d+)|(?P<dev_release>dev)(?P<dev_release_version>\d+))$', __version__)
+__version__ = "3.14.0"
+version_match = re_search(
+    r"(\d+\.)+?((?P<final_release>\d+)|\d+(?P<pre_release>a|b|rc)(?P<pre_release_version>\d+)|(?P<dev_release>dev)(?P<dev_release_version>\d+))$",
+    __version__,
+)
 if version_match:
     # pep 440
-    if version_match.group('dev_release'):
-        release = version_match.group('dev_release')
-        version_info = __version__.split('.')
-        version_info = tuple([int(i) for i in version_info[:-2]] + ['x', int(version_match.group('dev_release_version'))])
-    elif version_match.group('pre_release'):
-        release = version_match.group('pre_release')
-        version_info = __version__.split('.')
-        version_info = tuple([int(i) for i in version_info[:-1]] + ['y', version_match.group('pre_release'), int(version_match.group('pre_release_version'))])
-    elif version_match.group('final_release'):
-        release = version_match.group('final_release')
-        version_info = __version__.split('.')
-        version_info = tuple([int(i) for i in version_info[:-1]] + ['z', version_match.group('final_release')])
+    if version_match.group("dev_release"):
+        release = version_match.group("dev_release")
+        version_info = __version__.split(".")
+        version_info = tuple(
+            [int(i) for i in version_info[:-2]] + ["x", int(version_match.group("dev_release_version"))]
+        )
+    elif version_match.group("pre_release"):
+        release = version_match.group("pre_release")
+        version_info = __version__.split(".")
+        version_info = tuple(
+            [int(i) for i in version_info[:-1]]
+            + ["y", version_match.group("pre_release"), int(version_match.group("pre_release_version"))]
+        )
+    elif version_match.group("final_release"):
+        release = version_match.group("final_release")
+        version_info = __version__.split(".")
+        version_info = tuple([int(i) for i in version_info[:-1]] + ["z", version_match.group("final_release")])
 else:
     # TIL version number
-    version_info = __version__.split('.')
-    release = version_info[-1].split(' ')[-1] if len(version_info[-1].split(' ')) > 1 else 'release'
-    version_info = tuple([int(i) for i in version_info[:2]] + ['z'] + [int(version_info[-1].split(' ')[0])])
+    version_info = __version__.split(".")
+    release = version_info[-1].split(" ")[-1] if len(version_info[-1].split(" ")) > 1 else "release"
+    version_info = tuple([int(i) for i in version_info[:2]] + ["z"] + [int(version_info[-1].split(" ")[0])])
 
 del re_search
```

## tilmedia/_internals.py

```diff
@@ -4,48 +4,45 @@
 from ctypes import c_int, c_char_p, CFUNCTYPE
 from .exceptions import TILMediaErrorIncompatibleVectorLength, TILMediaError
 from .core import BatchFunctionCaller_abort
 from .properties import property_information
 
 _tilmedia_message_c_functions = []
 _tilmedia_error_c_functions = []
-_logger_exceptions = {
-    'fatal': True,
-    'info': True
-}
+_logger_exceptions = {"fatal": True, "info": True}
 
 _handler = logging.StreamHandler()
 _formatter = logging.Formatter()
-_logger = logging.getLogger('TILMedia')
+_logger = logging.getLogger("TILMedia")
 _logger.setLevel(logging.INFO)
 _logger.addHandler(_handler)
 
 
 CPRINTFUNCTION = CFUNCTYPE(c_int, c_char_p)
 """ The following statements define a callback c-function for interaction with the python callback compatibility dll"""
 
 
 def tilmedia_message_logger_function(exceptions: list, medium_wrapper: list, logger: logging.Logger, val):
-    val = val.decode('utf8', errors='ignore')
-    if val[-1] == '\n':
+    val = val.decode("utf8", errors="ignore")
+    if val[-1] == "\n":
         val = val[:-1]
     logger.info(val)
-    if exceptions is not None and _logger_exceptions['info']:
+    if exceptions is not None and _logger_exceptions["info"]:
         exceptions.append(TILMediaError(val))
         if medium_wrapper and medium_wrapper[0] != 0:
             BatchFunctionCaller_abort(medium_wrapper[0])
     return 0
 
 
 def tilmedia_error_logger_function(exceptions: list, medium_wrapper: list, logger: logging.Logger, val):
-    val = val.decode('utf8', errors='ignore')
-    if val[-1] == '\n':
+    val = val.decode("utf8", errors="ignore")
+    if val[-1] == "\n":
         val = val[:-1]
     logger.error(val)
-    if exceptions is not None and _logger_exceptions['fatal']:
+    if exceptions is not None and _logger_exceptions["fatal"]:
         exceptions.append(TILMediaError(val))
         if medium_wrapper and medium_wrapper[0] != 0:
             BatchFunctionCaller_abort(medium_wrapper[0])
     # raise TILMediaError(val) # not handled well, c code after this call is still executed.
     return 0
 
 
@@ -55,28 +52,28 @@
 
     Args:
         logger (logging.Logger): logger instance
     """
     global _tilmedia_message_c_functions
     global _tilmedia_error_c_functions
     if logger is None:
-        logger = logging.getLogger('TILMedia')
-    globals()['_logger'] = logger
+        logger = logging.getLogger("TILMedia")
+    globals()["_logger"] = logger
 
 
 def set_logger_exceptions(log_level, active: bool):
     """
     activate the exceptions of the global logger for a specific log level.
 
     Args:
         log_level (str): either "fatal" or "info"
         active (bool): activate exceptions
     """
 
-    globals()['_logger_exceptions'][log_level] = active
+    globals()["_logger_exceptions"][log_level] = active
 
 
 def var_normalize_inputs(*args) -> tuple:
     """
     align the sizes of all inputs. The last input is expected to be a concentration vector with one additional dimension.
 
     Raises:
@@ -101,39 +98,33 @@
     # vectorized arguments
     shapes = [v.shape for v in arrays]
     # remove concentration dimension
     shapes_wo_concentration = deepcopy(shapes)
     shapes_wo_concentration[-1] = shapes_wo_concentration[-1][:-1]
 
     # get the shape with the highest number of dimensions
-    highest_dim_shape = sorted(shapes_wo_concentration, key=lambda x:len(x))[-1]
+    highest_dim_shape = sorted(shapes_wo_concentration, key=lambda x: len(x))[-1]
     if highest_dim_shape == tuple():
         highest_dim_shape = (1,)
 
     # missing dimensions at the beginning are filled with highest_dim_shape
     vectorized_shapes_wo_concentration = [
-        tuple(
-            list(highest_dim_shape[:len(highest_dim_shape)-len(shape)])
-            + list(shape)
-        )
+        tuple(list(highest_dim_shape[: len(highest_dim_shape) - len(shape)]) + list(shape))
         for shape in shapes_wo_concentration
     ]
     vectorized_shapes = deepcopy(vectorized_shapes_wo_concentration)
     vectorized_shapes[-1] = tuple(list(vectorized_shapes[-1]) + [arrays[-1].shape[-1]])
 
     vectorizations = set(vectorized_shapes_wo_concentration)
     if len(vectorizations) > 1:
         raise TILMediaErrorIncompatibleVectorLength("incompatible vector lengths of inputs")
 
     # missing dimensions at the beginning are filled with highest_dim_shape
     tile_shapes = [
-        tuple(
-            list(highest_dim_shape[:len(highest_dim_shape)-len(shape)])
-            + [1]*len(shape)
-        )
+        tuple(list(highest_dim_shape[: len(highest_dim_shape) - len(shape)]) + [1] * len(shape))
         for shape in shapes_wo_concentration
     ]
     # add concentration dimension
     tile_shapes[-1] = tuple(list(tile_shapes[-1]) + [1])
 
     normalized_arrays = []
     for expected_shape, tile_shape, var in zip(vectorized_shapes, tile_shapes, arrays):
@@ -156,38 +147,37 @@
         expected (int): expected composition length
 
     Raises:
         TILMediaErrorIncompatibleVectorLength: length mismatch
     """
     if vector.shape[-1] != expected:
         raise TILMediaErrorIncompatibleVectorLength(
-            'The composition vector length is ' + str(vector.shape[-1]) + ' but should be ' + str(expected))
+            "The composition vector length is " + str(vector.shape[-1]) + " but should be " + str(expected)
+        )
 
 
 def _generate_code(property_list: list):
     code_a = []
     code_b = []
     for name, _, mixture_dim, _ in property_list:
         info = property_information.get(name, {})
         if mixture_dim is None:
-            template_a = (
-                '        self.{name} = np.{data_type}(0)\n'
-                "        '{escaped_description} [{unit}]'"
-            )
-            template_b = '        self._{name}_vector = np.zeros(1, dtype=np.{data_type})'
+            template_a = "        self.{name} = np.{data_type}(0)\n" "        '{escaped_description} [{unit}]'"
+            template_b = "        self._{name}_vector = np.zeros(1, dtype=np.{data_type})"
         else:
             template_a = (
-                '        self.{name} = np.zeros((1, {n}), dtype=np.{data_type})\n'
+                "        self.{name} = np.zeros((1, {n}), dtype=np.{data_type})\n"
                 "        '{escaped_description} [{unit}]'"
             )
-            template_b = '        self._{name}_vector = np.zeros((1, {n}), dtype=np.{data_type})'
+            template_b = "        self._{name}_vector = np.zeros((1, {n}), dtype=np.{data_type})"
 
         args = {
-            'name': name,
-            'data_type': info.get('numpy_type', ''),
-            'unit': info.get('unit', ''),
-            'description': info.get('description', ''),
-            'n': max(0, 1 + mixture_dim if mixture_dim is not None else 0)
+            "name": name,
+            "data_type": info.get("numpy_type", ""),
+            "unit": info.get("unit", ""),
+            "description": info.get("description", ""),
+            "escaped_description": info.get("description", "").replace("'", "\\'"),
+            "n": max(0, 1 + mixture_dim if mixture_dim is not None else 0),
         }
         code_a.append(template_a.format(**args))
         code_b.append(template_b.format(**args))
-    return code_a + [''] + code_b
+    return code_a + [""] + code_b
```

## tilmedia/batchcaller.py

```diff
@@ -1,60 +1,71 @@
 from typing import List
 from collections import defaultdict
 from .core import BatchFunctionCaller_execute, ExternalObject
 
 
-class BatchFunctionCaller():
+class BatchFunctionCaller:
     """
     Preparing and executing TILMedia function calls for an array of inputs
     """
 
     def __init__(self):
         self.current_point = None
-        'progress information in batch call'
+        "progress information in batch call"
 
         self._function_names = []
-        'functions to be called'
+        "functions to be called"
 
-        self._function_input_arguments = {'d': [], 'i': []}
-        'all input numpy arrays of the functions to be called'
+        self._function_input_arguments = {"d": [], "i": []}
+        "all input numpy arrays of the functions to be called"
 
         self._function_input_argument_index = []
-        'for each function in :attr:`_function_names` this contains the index of the input arguments in :attr:`_function_input_arguments`'
+        "for each function in :attr:`_function_names` this contains the index of the input arguments in :attr:`_function_input_arguments`"
 
         self._double_arguments = []
-        'all output numpy arrays of doubles'
+        "all output numpy arrays of doubles"
 
         self._int_arguments = []
-        'all output numpy arrays of ints'
+        "all output numpy arrays of ints"
 
         self._calculated_property_list = defaultdict(list)
-        'properties which are correct now'
+        "properties which are correct now"
 
-    def add_call(self, function_name, input_argument_instance, input_argument_names, output_argument_instance_name, output_argument_names):
+    def add_call(
+        self,
+        function_name,
+        input_argument_instance,
+        input_argument_names,
+        output_argument_instance_name,
+        output_argument_names,
+    ):
         """
         Add a function call to the sequence of calls per input value set.
 
         Args:
             function_name (str): name of the function to be called
             input_argument_instance (object): parent instance were the input ctypes property instances can be found
             input_argument_names (list): list of input argument property names (None means creating a new one which contains -1)
             output_argument_instance_name (object): member name of input parent instance were the ouput ctypes property instances can be found (None means self)
             output_argument_names (list): list of output argument property names
         """
         self._function_names.append(function_name)
-        self._calculated_property_list[None] += [n for n in input_argument_names if n not in self._calculated_property_list[None]]
-        self._calculated_property_list[output_argument_instance_name] += [n for n in output_argument_names if n not in self._calculated_property_list[output_argument_instance_name]]
+        self._calculated_property_list[None] += [
+            n for n in input_argument_names if n not in self._calculated_property_list[None]
+        ]
+        self._calculated_property_list[output_argument_instance_name] += [
+            n for n in output_argument_names if n not in self._calculated_property_list[output_argument_instance_name]
+        ]
         indices = []
 
         for arg_name in input_argument_names:
             if arg_name is None:
                 arg = None
             else:
-                arg = getattr(input_argument_instance, '_' + arg_name + '_vector')
+                arg = getattr(input_argument_instance, "_" + arg_name + "_vector")
             argument_type_letter = self.__get_argument_letter(arg)
 
             # use the same array if the input variable is reused
             array_is_identical = [arg is item for item in self._function_input_arguments[argument_type_letter]]
             if any(array_is_identical):
                 index = array_is_identical.index(True)
             else:
@@ -64,35 +75,35 @@
 
         self._function_input_argument_index.append(indices)
         for arg_name in output_argument_names:
             if output_argument_instance_name is None:
                 output_argument_instance = input_argument_instance
             else:
                 output_argument_instance = getattr(input_argument_instance, output_argument_instance_name)
-            arg = getattr(output_argument_instance, '_' + arg_name + '_vector')
+            arg = getattr(output_argument_instance, "_" + arg_name + "_vector")
             if self._is_double_argument(arg):
                 self._double_arguments.append(arg)
             elif self._is_integer_argument(arg):
                 self._int_arguments.append(arg)
             else:
                 raise RuntimeError("Argument type not recognized")
 
     @staticmethod
     def _is_integer_argument(input_argument):
-        return input_argument is not None and input_argument.dtype.name == 'int32'
+        return input_argument is not None and input_argument.dtype.name == "int32"
 
     @staticmethod
     def _is_double_argument(input_argument):
-        return input_argument is not None and input_argument.dtype.name == 'float64'
+        return input_argument is not None and input_argument.dtype.name == "float64"
 
     @staticmethod
     def __get_argument_letter(input_argument):
         if BatchFunctionCaller._is_double_argument(input_argument):
-            return 'd'
+            return "d"
         elif BatchFunctionCaller._is_integer_argument(input_argument):
-            return 'i'
+            return "i"
         elif input_argument is None:
-            return 'd'
+            return "d"
         raise RuntimeError("Unknown input argument type")
 
     def execute(self, eo: ExternalObject, length: int, *args) -> List[str]:
         return BatchFunctionCaller_execute(self, eo, length, *args)
```

## tilmedia/core.pyi

```diff
@@ -1,16 +1,17 @@
-from typing import Any, ClassVar, List, Union
+from typing import Any, ClassVar, Dict, List, Union
 
 import _cython_3_0_0a9
 import _thread
 import collections
 import typing
 BatchFunctionCaller_abort: _cython_3_0_0a9.cython_function_or_method
 BatchFunctionCaller_currentPoint: _cython_3_0_0a9.cython_function_or_method
 BatchFunctionCaller_execute: _cython_3_0_0a9.cython_function_or_method
+Dict: typing._SpecialGenericAlias
 GasObjectFunctions_freezingPoint: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificAbsoluteGasEntropy_pTn: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificAbsoluteLiquidEntropy_pTn: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificAbsoluteSolidEntropy_pTn: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificGasEnthalpy_refStateHf_Tn: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificLiquidEnthalpy_refStateHf_Tn: _cython_3_0_0a9.cython_function_or_method
 GasObjectFunctions_specificSolidEnthalpy_refStateHf_Tn: _cython_3_0_0a9.cython_function_or_method
@@ -25,27 +26,29 @@
 Union: typing._SpecialForm
 VLEFluidFunctions_density_pTxi: _cython_3_0_0a9.cython_function_or_method
 VLEFluid_Cached_molarMass: _cython_3_0_0a9.cython_function_or_method
 VLEFluid_isValid_getInfo_errorInterface: _cython_3_0_0a9.cython_function_or_method
 _cache_getAllAdsorptionAndAbsorptionNames: list
 _cache_getAllCondensingGasNames: list
 _cache_getAllGasNames: list
+_cache_getAllLiquidMixtureNames: list
 _cache_getAllLiquidNames: list
 _cache_getAllVLEFluidNames: list
 _destructor_queue: collections.deque
 _logger_wrapper_backup: None
 _tilmedia_lock: _thread.lock
 clear_medium_name_cache: _cython_3_0_0a9.cython_function_or_method
 deepcopy: function
 getGasInformation_pointer: _cython_3_0_0a9.cython_function_or_method
 getLiquidInformation_pointer: _cython_3_0_0a9.cython_function_or_method
 getVLEFluidInformation_pointer: _cython_3_0_0a9.cython_function_or_method
 get_all_adsorption_and_absorption_names: _cython_3_0_0a9.cython_function_or_method
 get_all_condensing_gas_names: _cython_3_0_0a9.cython_function_or_method
 get_all_gas_names: _cython_3_0_0a9.cython_function_or_method
+get_all_liquid_mixture_names: _cython_3_0_0a9.cython_function_or_method
 get_all_liquid_names: _cython_3_0_0a9.cython_function_or_method
 get_all_vleFluid_names: _cython_3_0_0a9.cython_function_or_method
 get_closest_vleFluid_dpT: _cython_3_0_0a9.cython_function_or_method
 get_data_path: _cython_3_0_0a9.cython_function_or_method
 get_fit_config: _cython_3_0_0a9.cython_function_or_method
 get_fit_config_eo: _cython_3_0_0a9.cython_function_or_method
 get_fit_data: _cython_3_0_0a9.cython_function_or_method
```

## tilmedia/datacontainer.py

```diff
@@ -1,84 +1,84 @@
 import numpy as np
 from .properties import property_information
 
 
 class DataContainer(object):
     def __init__(self, nc, shape_property):
         object.__init__(self)
-        if not hasattr(self, '_property_list'):
+        if not hasattr(self, "_property_list"):
             self._property_list = []
         self._nc = nc
-        self._shape_property = '_' + shape_property + '_vector'
+        self._shape_property = "_" + shape_property + "_vector"
 
         self._shape_property_mixture_dim = tuple()
         for name, dtype, mixture_dim, default_value in self._property_list:
             if name == shape_property:
                 if mixture_dim is None:
                     break
-                self._shape_property_mixture_dim = max(0, self._nc + mixture_dim),
+                self._shape_property_mixture_dim = (max(0, self._nc + mixture_dim),)
                 break
 
     def _resize_properties(self, shape):
         old_shape = getattr(self, self._shape_property).shape
         new_shape = shape + self._shape_property_mixture_dim
         if old_shape == new_shape:
             for name, dtype, _, default_value in self._property_list:
-                v = getattr(self, '_'+name+'_vector')
+                v = getattr(self, "_" + name + "_vector")
                 if default_value is not None:
                     v.fill(default_value)
                 else:
                     v.fill(0)
         else:
             for name, dtype, mixture_dim, default_value in self._property_list:
                 if mixture_dim is not None:
-                    additional_dimension = max(0, self._nc + mixture_dim),
+                    additional_dimension = (max(0, self._nc + mixture_dim),)
                 else:
                     additional_dimension = tuple()
                 if default_value:
                     value = default_value
                 else:
                     value = 0
                 v = np.full(shape + additional_dimension, value, dtype=dtype)
-                setattr(self, '_'+name+'_vector', v)
+                setattr(self, "_" + name + "_vector", v)
 
     def _make_properties_scalar(self, shape, calculated_properties):
         p = calculated_properties
         if shape == (1,):
             for name, dtype, mixture_dim, _ in self._property_list:
                 if name not in p:
                     setattr(self, name, None)
                 elif dtype == np.int32:
-                    setattr(self, name, int(getattr(self, '_' + name + '_vector')[0, ...]))
+                    setattr(self, name, int(getattr(self, "_" + name + "_vector")[0, ...]))
                 else:
                     if mixture_dim is None:
-                        setattr(self, name, getattr(self, '_' + name + '_vector')[0])
+                        setattr(self, name, getattr(self, "_" + name + "_vector")[0])
                     else:
-                        setattr(self, name, getattr(self, '_' + name + '_vector')[0, ...])
+                        setattr(self, name, getattr(self, "_" + name + "_vector")[0, ...])
         else:
             for name, _, _, _ in self._property_list:
                 if name not in p:
                     setattr(self, name, None)
                 else:
-                    setattr(self, name, getattr(self, '_' + name + '_vector'))
+                    setattr(self, name, getattr(self, "_" + name + "_vector"))
 
     def __str__(self):
         value = []
         for name, _, _, _ in self._property_list:
             v = getattr(self, name)
             if v is not None:
                 info = property_information.get(name, {})
                 left_part = name
-                description = info.get('description', '')
-                unit = info.get('unit', '')
+                description = info.get("description", "")
+                unit = info.get("unit", "")
                 if description:
-                    left_part += ' (' + description
+                    left_part += " (" + description
                     if unit:
-                        left_part += ' in ' + unit
-                    left_part += ')'
+                        left_part += " in " + unit
+                    left_part += ")"
                 value.append("{left_part}: {property_value}".format(left_part=left_part, property_value=v))
         return "\n".join(value)
 
     def keys(self):
         return [name for name, _, _, _ in self._property_list if getattr(self, name) is not None]
 
     def __len__(self):
```

## tilmedia/gas.py

```diff
@@ -1,56 +1,72 @@
 ï»¿import logging
 from typing import Union, Optional, List
 from copy import deepcopy
 import numpy as np
-from .exceptions import TILMediaErrorIncompatibleVectorLength, TILMediaErrorInvalidParameter, TILMediaErrorInvalidMedium, TILMediaErrorInvalidLicense
+from threading import Lock
+from .exceptions import (
+    TILMediaErrorIncompatibleVectorLength,
+    TILMediaErrorInvalidParameter,
+    TILMediaErrorInvalidMedium,
+    TILMediaErrorInvalidLicense,
+)
 from .batchcaller import BatchFunctionCaller
 from .datacontainer import DataContainer
-from .core import license_is_valid, Gas_isValid_getInfo_errorInterface, ExternalObject, getGasInformation_pointer, Gas_molarMass, GasObjectFunctions_freezingPoint
+from .core import (
+    license_is_valid,
+    Gas_isValid_getInfo_errorInterface,
+    ExternalObject,
+    getGasInformation_pointer,
+    Gas_molarMass,
+    GasObjectFunctions_freezingPoint,
+)
 from .logger import LoggerWrapper
 from . import _internals as internals
 
+_gas_lock = Lock()
+
 # _pureComponentProperties = ['p_s', 'delta_hv', 'delta_hd', 'h_i', 'T']
 # _additionalProperties = ['cp', 'beta', 'kappa', 's', 'T']
 # _transportProperties = ['Pr', 'lambda', 'eta']
 # _fullTransportProperties = [('Pr', np.float64, None, None), ('lamb', np.float64, None, None), ('eta', np.float64, None, None), ('sigma', np.float64, None, None)]
 _fullProperties = [
-    ('d', np.float64, None, None),
-    ('h', np.float64, None, None),
-    ('p', np.float64, None, None),
-    ('s', np.float64, None, None),
-    ('T', np.float64, None, None),
-    ('xi', np.float64, -1, None),
-    ('x', np.float64, -1, None),
-    ('xi_dryGas', np.float64, -2, None),
-    ('M', np.float64, None, None),
-    ('cp', np.float64, None, None),
-    ('cv', np.float64, None, None),
-    ('beta', np.float64, None, None),
-    ('kappa', np.float64, None, None),
-    ('w', np.float64, None, None),
-    ('drhodh_pxi', np.float64, None, None),
-    ('drhodp_hxi', np.float64, None, None),
-    ('drhodxi_ph', np.float64, -1, None),
-    ('p_i', np.float64, 0, None),
-    ('xi_gas', np.float64, None, None),
-    ('phi', np.float64, None, None),
-    ('p_s', np.float64, None, None),
-    ('xi_s', np.float64, None, None),
-    ('delta_hv', np.float64, None, None),
-    ('delta_hd', np.float64, None, None),
-    ('h_i', np.float64, 0, None),
-    ('humRatio', np.float64, None, None),
-    ('humRatio_s', np.float64, None, None),
-    ('h1px', np.float64, None, None),
-    ('Y', np.float64, None, None),
-    ('Pr', np.float64, None, None),
-    ('lamb', np.float64, None, None),
-    ('eta', np.float64, None, None),
-    ('sigma', np.float64, None, None)]
+    ("d", np.float64, None, None),
+    ("h", np.float64, None, None),
+    ("p", np.float64, None, None),
+    ("s", np.float64, None, None),
+    ("T", np.float64, None, None),
+    ("xi", np.float64, -1, None),
+    ("x", np.float64, -1, None),
+    ("xi_dryGas", np.float64, -2, None),
+    ("M", np.float64, None, None),
+    ("cp", np.float64, None, None),
+    ("cv", np.float64, None, None),
+    ("beta", np.float64, None, None),
+    ("kappa", np.float64, None, None),
+    ("w", np.float64, None, None),
+    ("drhodh_pxi", np.float64, None, None),
+    ("drhodp_hxi", np.float64, None, None),
+    ("drhodxi_ph", np.float64, -1, None),
+    ("p_i", np.float64, 0, None),
+    ("xi_gas", np.float64, None, None),
+    ("phi", np.float64, None, None),
+    ("p_s", np.float64, None, None),
+    ("xi_s", np.float64, None, None),
+    ("delta_hv", np.float64, None, None),
+    ("delta_hd", np.float64, None, None),
+    ("h_i", np.float64, 0, None),
+    ("humRatio", np.float64, None, None),
+    ("humRatio_s", np.float64, None, None),
+    ("h1px", np.float64, None, None),
+    ("Y", np.float64, None, None),
+    ("Pr", np.float64, None, None),
+    ("lamb", np.float64, None, None),
+    ("eta", np.float64, None, None),
+    ("sigma", np.float64, None, None),
+]
 
 
 class Gas(DataContainer):
     """
     This Gas class can calculate the thermopyhsical properties of a pure ideal gas or ideal gas vapor mixture.
 
     The following combinations of inputs can be used to calculate properties by calling a setState function:
@@ -90,31 +106,60 @@
         array([1004.990552, 1008.342171, 1013.626381])
 
     """
 
     # static function call list
     _batch_function_calls = {
         3: [
-            ("TILMedia_Gas_pureComponentProperties_T", lambda self: (self, ['T'], None, ['p_s', 'delta_hv', 'delta_hd', 'h_i'])),
-            ("TILMedia_Gas_simpleCondensingProperties_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['cp', 'cv', 'beta', 'w'])),
-            ("TILMedia_Gas_additionalProperties_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['d', 'kappa', 'drhodp_hxi', 'drhodh_pxi', 'drhodxi_ph', 'p_i', 'xi_gas'])),
-            ("TILMedia_Gas_specificEnthalpy_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['h'])),
-            ("TILMedia_GasObjectFunctions_saturationMassFraction_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['xi_s'])),
-            ("TILMedia_Gas_specificEntropy_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['s'])),
-            ("TILMedia_GasObjectFunctions_relativeHumidity_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['phi'])),
-            ("TILMedia_GasObjectFunctions_specificEnthalpy1px_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['h1px'])),
+            (
+                "TILMedia_Gas_pureComponentProperties_T",
+                lambda self: (self, ["T"], None, ["p_s", "delta_hv", "delta_hd", "h_i"]),
+            ),
+            (
+                "TILMedia_Gas_simpleCondensingProperties_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["cp", "cv", "beta", "w"]),
+            ),
+            (
+                "TILMedia_Gas_additionalProperties_pTxi",
+                lambda self: (
+                    self,
+                    ["p", "T", "xi"],
+                    None,
+                    ["d", "kappa", "drhodp_hxi", "drhodh_pxi", "drhodxi_ph", "p_i", "xi_gas"],
+                ),
+            ),
+            ("TILMedia_Gas_specificEnthalpy_pTxi", lambda self: (self, ["p", "T", "xi"], None, ["h"])),
+            (
+                "TILMedia_GasObjectFunctions_saturationMassFraction_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["xi_s"]),
+            ),
+            ("TILMedia_Gas_specificEntropy_pTxi", lambda self: (self, ["p", "T", "xi"], None, ["s"])),
+            ("TILMedia_GasObjectFunctions_relativeHumidity_pTxi", lambda self: (self, ["p", "T", "xi"], None, ["phi"])),
+            (
+                "TILMedia_GasObjectFunctions_specificEnthalpy1px_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["h1px"]),
+            ),
         ],
         2: [
-            ("TILMedia_Gas_pureComponentProperties_T", lambda self: (self, ['T'], None, ['p_s', 'delta_hv', 'delta_hd', 'h_i'])),
-            ("TILMedia_Gas_simpleCondensingProperties_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['cp', 'cv', 'beta', 'w'])),
-            ("TILMedia_Gas_specificEnthalpy_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['h'])),
+            (
+                "TILMedia_Gas_pureComponentProperties_T",
+                lambda self: (self, ["T"], None, ["p_s", "delta_hv", "delta_hd", "h_i"]),
+            ),
+            (
+                "TILMedia_Gas_simpleCondensingProperties_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["cp", "cv", "beta", "w"]),
+            ),
+            ("TILMedia_Gas_specificEnthalpy_pTxi", lambda self: (self, ["p", "T", "xi"], None, ["h"])),
         ],
         1: [
-            ("TILMedia_Gas_pureComponentProperties_T", lambda self: (self, ['T'], None, ['p_s', 'delta_hv', 'delta_hd', 'h_i'])),
-        ]
+            (
+                "TILMedia_Gas_pureComponentProperties_T",
+                lambda self: (self, ["T"], None, ["p_s", "delta_hv", "delta_hd", "h_i"]),
+            ),
+        ],
     }
 
     class _Info:
         _allowed = [
             "MediumName",
             "LibraryName",
             "LibraryLiteratureReference",
@@ -134,101 +179,132 @@
             self.LiteratureReference = None
             self.T_min = None
             self.T_max = None
             self.T_data_min = None
             self.T_data_max = None
 
         def __repr__(self):
-            return 'TILMedia.Gas.Info ' + self.LibraryName + ' ' + self.MediumName
+            return "TILMedia.Gas.Info " + self.LibraryName + " " + self.MediumName
 
         def keys(self):
             return [member for member in self._allowed if getattr(self, member) is not None]
 
         def __len__(self):
             return len(self._allowed)
 
         def __getitem__(self, key):
             if key in self._allowed:
                 return getattr(self, key)
             raise KeyError("Invalid parameter requested")
 
         def __str__(self):
             data = dict(self)
-            units = {
-                'T_min': ' K',
-                'T_max': ' K',
-                'T_data_min': ' K',
-                'T_data_max': ' K'
-            }
-            return "\n".join([key + ': ' + str(value) + units.get(key, '') for key, value in data.items()])
+            units = {"T_min": " K", "T_max": " K", "T_data_min": " K", "T_data_max": " K"}
+            return "\n".join([key + ": " + str(value) + units.get(key, "") for key, value in data.items()])
 
         def dump(self):
             s = str(self)
             if len(s) > 0:
                 print(s)
 
     _status = 0
     _property_list = []
 
     def __init__(
         self,
         gas_name: str,
-        xi: Optional[Union[np.ndarray, List[float]]] = None,
+        xi: Optional[Union[List[float], np.ndarray]] = None,
         condensingIndex=0,
         fixed_mixing_ratio=False,
         compute_transport_properties=True,
         instance_name="Gas_Python",
-        logger: Optional[logging.Logger] = None
+        logger: Optional[logging.Logger] = None,
     ):
+        global _gas_lock
         self._property_list = _fullProperties + self._property_list
         # properties of GasObject
+        # fmt: off
         #    [[[cog
         # import cog
-        # from TILMedia import Gas
+        # from tilmedia import Gas
         # import numpy as np
-        # from TILMedia.internals import _generate_code
+        # from tilmedia._internals import _generate_code
         # gas = Gas("DryAir")
         # v = gas._property_list + [("M_i",
         # np.float64, None, None)]
         # cog.outl("\n".join(_generate_code(v)))
         # ]]]
-        self.d = np.float64(0)  # : Density [kg/m^3]
-        self.h = np.float64(0)  # : Specific enthalpy [J/kg]
-        self.p = np.float64(0)  # : Pressure [Pa]
-        self.s = np.float64(0)  # : Specific entropy [J/(kg*K)]
-        self.T = np.float64(0)  # : Temperature [K]
-        self.xi = np.zeros((1, 0), dtype=np.float64)  # : Water Mass fraction [1]
-        self.x = np.zeros((1, 0), dtype=np.float64)  # : Mole fraction [1]
-        self.xi_dryGas = np.zeros((1, 0), dtype=np.float64)  # : Mass fraction of dry gas [1]
-        self.M = np.float64(0)  # : Average molar mass [kg/mol]
-        self.cp = np.float64(0)  # : Specific isobaric heat capacity cp [J/(kg*K)]
-        self.cv = np.float64(0)  # : Specific isochoric heat capacity cv [J/(kg*K)]
-        self.beta = np.float64(0)  # : Isobaric thermal expansion coefficient [1/K]
-        self.kappa = np.float64(0)  # : Isothermal compressibility [1/Pa]
-        self.w = np.float64(0)  # : Speed of sound [m/s]
-        self.drhodh_pxi = np.float64(0)  # : Derivative of density wrt specific enthalpy at constant pressure and mass fraction [kg^2/(m^3*J)]
-        self.drhodp_hxi = np.float64(0)  # : Derivative of density wrt pressure at specific enthalpy and mass fraction [kg/(N*m)]
-        self.drhodxi_ph = np.zeros((1, 0), dtype=np.float64)  # : Derivative of density wrt mass fraction of water at constant pressure and specific enthalpy [kg/m^3]
-        self.p_i = np.zeros((1, 1), dtype=np.float64)  # : Partial pressure [kg^2/(m^3*J)]
-        self.xi_gas = np.float64(0)  # : Mass fraction of gasoues condensing component [1]
-        self.phi = np.float64(0)  # : Relative humidity [%]
-        self.p_s = np.float64(0)  # : Saturation partial pressure of condensing component [Pa]
-        self.xi_s = np.float64(0)  # : Saturation mass fraction of condensing component [1]
-        self.delta_hv = np.float64(0)  # : Specific enthalpy of vaporisation of condensing component [J/kg]
-        self.delta_hd = np.float64(0)  # : Specific enthalpy of desublimation of condensing component [J/kg]
-        self.h_i = np.zeros((1, 1), dtype=np.float64)  # : Specific enthalpy of theoretical pure component [J/kg]
-        self.humRatio = np.float64(0)  # : Content of condensing component aka humidity ratio [1]
-        self.humRatio_s = np.float64(0)  # : Saturation content of condensing component aka saturation humidity ratio [1]
-        self.h1px = np.float64(0)  # : Specific enthalpy h related to the mass of components that cannot condense [J/kg]
-        self.Y = np.float64(0)  # : Transformed y axis in Mollier's hx chart [1]
-        self.Pr = np.float64(0)  # : Prandtl number [1]
-        self.lamb = np.float64(0)  # : Thermal conductivity [W/(m*K)]
-        self.eta = np.float64(0)  # : Dynamic viscosity [Pa*s]
-        self.sigma = np.float64(0)  # : Surface tension [J/m^2]
-        self.M_i = np.float64(0)  # : Molar mass of component i [kg/mol]
+        self.d = np.float64(0)
+        'Density [kg/m^3]'
+        self.h = np.float64(0)
+        'Specific enthalpy [J/kg]'
+        self.p = np.float64(0)
+        'Pressure [Pa]'
+        self.s = np.float64(0)
+        'Specific entropy [J/(kg*K)]'
+        self.T = np.float64(0)
+        'Temperature [K]'
+        self.xi = np.zeros((1, 0), dtype=np.float64)
+        'Water Mass fraction [1]'
+        self.x = np.zeros((1, 0), dtype=np.float64)
+        'Mole fraction [1]'
+        self.xi_dryGas = np.zeros((1, 0), dtype=np.float64)
+        'Mass fraction of dry gas [1]'
+        self.M = np.float64(0)
+        'Average molar mass [kg/mol]'
+        self.cp = np.float64(0)
+        'Specific isobaric heat capacity cp [J/(kg*K)]'
+        self.cv = np.float64(0)
+        'Specific isochoric heat capacity cv [J/(kg*K)]'
+        self.beta = np.float64(0)
+        'Isobaric thermal expansion coefficient [1/K]'
+        self.kappa = np.float64(0)
+        'Isothermal compressibility [1/Pa]'
+        self.w = np.float64(0)
+        'Speed of sound [m/s]'
+        self.drhodh_pxi = np.float64(0)
+        'Derivative of density wrt specific enthalpy at constant pressure and mass fraction [kg^2/(m^3*J)]'
+        self.drhodp_hxi = np.float64(0)
+        'Derivative of density wrt pressure at specific enthalpy and mass fraction [kg/(N*m)]'
+        self.drhodxi_ph = np.zeros((1, 0), dtype=np.float64)
+        'Derivative of density wrt mass fraction of water at constant pressure and specific enthalpy [kg/m^3]'
+        self.p_i = np.zeros((1, 1), dtype=np.float64)
+        'Partial pressure [kg^2/(m^3*J)]'
+        self.xi_gas = np.float64(0)
+        'Mass fraction of gasoues condensing component [1]'
+        self.phi = np.float64(0)
+        'Relative humidity [%]'
+        self.p_s = np.float64(0)
+        'Saturation partial pressure of condensing component [Pa]'
+        self.xi_s = np.float64(0)
+        'Saturation mass fraction of condensing component [1]'
+        self.delta_hv = np.float64(0)
+        'Specific enthalpy of vaporisation of condensing component [J/kg]'
+        self.delta_hd = np.float64(0)
+        'Specific enthalpy of desublimation of condensing component [J/kg]'
+        self.h_i = np.zeros((1, 1), dtype=np.float64)
+        'Specific enthalpy of theoretical pure component [J/kg]'
+        self.humRatio = np.float64(0)
+        'Content of condensing component aka humidity ratio [1]'
+        self.humRatio_s = np.float64(0)
+        'Saturation content of condensing component aka saturation humidity ratio [1]'
+        self.h1px = np.float64(0)
+        'Specific enthalpy h related to the mass of components that cannot condense [J/kg]'
+        self.Y = np.float64(0)
+        'Transformed y axis in Mollier\'s hx chart [1]'
+        self.Pr = np.float64(0)
+        'Prandtl number [1]'
+        self.lamb = np.float64(0)
+        'Thermal conductivity [W/(m*K)]'
+        self.eta = np.float64(0)
+        'Dynamic viscosity [Pa*s]'
+        self.sigma = np.float64(0)
+        'Surface tension [J/m^2]'
+        self.M_i = np.float64(0)
+        'Molar mass of component i [kg/mol]'
 
         self._d_vector = np.zeros(1, dtype=np.float64)
         self._h_vector = np.zeros(1, dtype=np.float64)
         self._p_vector = np.zeros(1, dtype=np.float64)
         self._s_vector = np.zeros(1, dtype=np.float64)
         self._T_vector = np.zeros(1, dtype=np.float64)
         self._xi_vector = np.zeros((1, 0), dtype=np.float64)
@@ -257,108 +333,124 @@
         self._Y_vector = np.zeros(1, dtype=np.float64)
         self._Pr_vector = np.zeros(1, dtype=np.float64)
         self._lamb_vector = np.zeros(1, dtype=np.float64)
         self._eta_vector = np.zeros(1, dtype=np.float64)
         self._sigma_vector = np.zeros(1, dtype=np.float64)
         self._M_i_vector = np.zeros(1, dtype=np.float64)
         # [[[end]]]
+        # fmt: on
 
         self._xiFixed_vector = np.zeros((1, 0), dtype=np.float64)
-        self.T_freeze = np.float64(0)  # : freezing temperature in [K]
+        self.T_freeze = np.float64(0)
+        "freezing temperature in [K]"
 
         self._medium = None
         self._medium_wrapper = []
 
         self._compute_transport_properties = compute_transport_properties
 
         if condensingIndex > 0 and fixed_mixing_ratio:
-            raise TILMediaErrorInvalidParameter("fixed_mixing_ratio cannot be combined with condensingIndex not equal to zero")
+            raise TILMediaErrorInvalidParameter(
+                "fixed_mixing_ratio cannot be combined with condensingIndex not equal to zero"
+            )
 
         valid_license = license_is_valid()
         if valid_license != 1:
             raise TILMediaErrorInvalidLicense("License not valid")
 
         # prepare error function pointer
         if logger is None:
             logger = internals._logger
         self._exceptions = []
         message_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_message_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_message_logger_function(
+                e, m, logger, x
+            )
         )
         error_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_error_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_error_logger_function(
+                e, m, logger, x
+            )
         )
 
         # Check if name is valid and calculate number of components
         self.fixed_mixing_ratio = fixed_mixing_ratio
         self._condensingIndex = condensingIndex
         self._gas_name = gas_name
         self._nc_internal: int = -1
         _xi_autodetect = np.zeros(20, dtype=np.float64)
         c_logger = LoggerWrapper(logger, self._medium_wrapper, message_function, error_function)
         self.__c_logger = c_logger
-        self._status, self._nc_internal = Gas_isValid_getInfo_errorInterface(
-            gas_name,
-            condensingIndex,
-            _xi_autodetect,
-            True,
-            c_logger
-        )
+        with _gas_lock as locked:
+            if locked:
+                self._status, self._nc_internal = Gas_isValid_getInfo_errorInterface(
+                    gas_name, condensingIndex, _xi_autodetect, True, c_logger
+                )
         if self._status == 0:
-            raise TILMediaErrorInvalidMedium('GasName "'+gas_name+'" not valid. Could not create TILMedia object.')
-        self._xi_autodetect = np.zeros(self._nc_internal-1)
+            raise TILMediaErrorInvalidMedium('GasName "' + gas_name + '" not valid. Could not create TILMedia object.')
+        self._xi_autodetect = np.zeros(self._nc_internal - 1)
 
         # forwarding information to other classes
         if fixed_mixing_ratio:
             self._nc = 1
         else:
             self._nc = self._nc_internal
-        DataContainer.__init__(self, self._nc, 'xi')
+        DataContainer.__init__(self, self._nc, "xi")
 
         # update to new nc
         self._resize_properties((1,))
         self._make_properties_scalar((1,), {None: []})
         self.M_i = np.zeros((self._nc), dtype=np.float64)
 
         # evaluate concentration
         if self._nc_internal > 1:
             # it is a mixture
             if fixed_mixing_ratio:
                 if xi is not None:
                     _, self._xiFixed_vector = internals.var_normalize_inputs(0, xi)
                     # xi is given
-                    if self._xiFixed_vector.shape[-1] != self._nc_internal-1:
+                    if self._xiFixed_vector.shape[-1] != self._nc_internal - 1:
                         # but has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("length of xi vector should be {nc} but is {length}".format(nc=self._nc_internal-1, length=self._xiFixed_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xiFixed_vector.shape[-1]
+                            )
+                        )
                 else:
                     # xi is not given
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
-                        raise TILMediaErrorInvalidParameter("xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                        raise TILMediaErrorInvalidParameter(
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
                     _, self._xiFixed_vector = internals.var_normalize_inputs(0, self._xi_autodetect)
             else:
                 # variable concentration
                 if xi is None:
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
-                        raise TILMediaErrorInvalidParameter("xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                        raise TILMediaErrorInvalidParameter(
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
                     _, self._xi_vector = internals.var_normalize_inputs(0, self._xi_autodetect)
                 else:
                     _, self._xi_vector = internals.var_normalize_inputs(0, xi)
-                    if self._xi_vector.shape[-1] != self._nc_internal-1:
+                    if self._xi_vector.shape[-1] != self._nc_internal - 1:
                         # but the concentration vector has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("Length of xi vector should be {nc} but is {length}".format(nc=self._nc_internal-1, length=self._xi_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "Length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xi_vector.shape[-1]
+                            )
+                        )
         else:
             if xi is not None:
                 _, xi = internals.var_normalize_inputs(0, xi)
                 internals.check_vector_size(xi, self._nc_internal - 1)
         if xi is None:
             xi = self._xi_autodetect
 
@@ -366,31 +458,29 @@
         flags = 0
         if self._compute_transport_properties:
             flags = 1
         if self.fixed_mixing_ratio:
             _xi_call = self._xiFixed_vector[0]
         else:
             _xi_call = self._xi_vector[0]
-        self._medium = ExternalObject(
-            "Gas",
-            gas_name,
-            flags,
-            _xi_call,
-            self._nc,
-            condensingIndex,
-            instance_name,
-            c_logger)
+        with _gas_lock as locked:
+            if locked:
+                self._medium = ExternalObject(
+                    "Gas", gas_name, flags, _xi_call, self._nc, condensingIndex, instance_name, c_logger
+                )
         if not self._medium:
             if self._exceptions:
                 exceptions = deepcopy(self._exceptions)
                 while self._exceptions:
                     self._exceptions.pop()
                 raise exceptions[0]
             else:
-                raise TILMediaErrorInvalidMedium('GasName "'+gas_name+'" not valid. Could not create TILMedia object.')
+                raise TILMediaErrorInvalidMedium(
+                    'GasName "' + gas_name + '" not valid. Could not create TILMedia object.'
+                )
         self._medium_wrapper.append(self._medium)
         self.xi = self._xi_vector[0]
 
         Gas_molarMass(self._medium, self.M_i)
         self.T_freeze = GasObjectFunctions_freezingPoint(self._medium)
 
         # initializing Info
@@ -404,19 +494,19 @@
             raise exceptions[0]
 
     def __del__(self):
         if self._status != 0:
             self._medium = 0
 
     def dump(self):
-        """ Prints the current thermophysical properties of the gas to stdout. """
+        """Prints the current thermophysical properties of the gas to stdout."""
         print(self.__str__())
 
     def __repr__(self):
-        return 'TILMedia.Gas "' + self._gas_name + '" (nc = '+str(self._nc)+')'
+        return 'TILMedia.Gas "' + self._gas_name + '" (nc = ' + str(self._nc) + ")"
 
     def __str__(self):
         value = []
         value += ["Medium: " + self._gas_name]
         value += [DataContainer.__str__(self)]
         return "\n".join([v for v in value if v])
 
@@ -445,269 +535,304 @@
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe error was caused by element %s: T=%s.'
-                    % (str(failure_index), str(T[failure_index])))
+                    + "\nThe error was caused by element %s: T=%s." % (str(failure_index), str(T[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
-                    self._exceptions[0].message
-                    + '\nThe inputs were T=%s.'
-                    % (str(T[failure_index])))
+                    self._exceptions[0].message + "\nThe inputs were T=%s." % (str(T[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_Txi(self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_Txi(
+        self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[List[float], np.ndarray]] = None
+    ) -> None:
         """
         Calculates temperature and mass fraction dependent properties.
 
         Args:
             T (float, list, or numpy.ndarray): temperature [K]
             xi (list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if self._condensingIndex > 0:
-            raise TILMediaErrorInvalidParameter('If condensingIndex is > 0, then this function must not be called, since some of the properties are pressure dependent')
+            raise TILMediaErrorInvalidParameter(
+                "If condensingIndex is > 0, then this function must not be called, since some of the properties are pressure dependent"
+            )
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         T, xi = internals.var_normalize_inputs(T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         if xi.shape[-1] != self._nc - 1:
-            raise TILMediaErrorIncompatibleVectorLength(
-                "xi vector length is should be " + str(self._nc - 1))
+            raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(self._nc - 1))
         shape = T.shape
         self._resize_properties(shape)
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
         for function_name, arguments in self._batch_function_calls[2]:
             batch_caller.add_call(function_name, *arguments(self))
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: T=%s, xi=%s.' %
-                                                          (str(failure_index), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: T=%s, xi=%s."
+                    % (str(failure_index), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were T=%s, xi=%s.'
-                    % (str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were T=%s, xi=%s." % (str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_pTxi(self, p: Union[float, np.ndarray, List[float]], T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_pTxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        T: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, temperature and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             T (float, list, or numpy.ndarray): temperature [K]
             xi (list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, T, xi = internals.var_normalize_inputs(p, T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         if xi.shape[-1] != self._nc - 1:
-            raise TILMediaErrorIncompatibleVectorLength(
-                "xi vector length is should be " + str(self._nc - 1))
+            raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(self._nc - 1))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, T=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, T=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, T=%s, xi=%s.'
-                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, T=%s, xi=%s."
+                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_phxi(self, p: Union[float, np.ndarray, List[float]], h: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_phxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        h: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, enthalpy and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             h (float, list, or numpy.ndarray): specific entphalpy [J/kg]
             xi (list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, h, xi = internals.var_normalize_inputs(p, h, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         if xi.shape[-1] != self._nc - 1:
             raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(self._nc - 1))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._h_vector[:] = h
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Gas_temperature_phxi", self, ['p', 'h', 'xi'], None, ['T'])
+        batch_caller.add_call("TILMedia_Gas_temperature_phxi", self, ["p", "h", "xi"], None, ["T"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, h=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, h=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, h=%s, xi=%s.'
-                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, h=%s, xi=%s."
+                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_psxi(self, p: Union[float, np.ndarray, List[float]], s: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_psxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        s: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, specific entropy and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             s (float, list, or numpy.ndarray): specific entropy [J/(kg*K)]
             xi (list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, s, xi = internals.var_normalize_inputs(p, s, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         if xi.shape[-1] != self._nc - 1:
             raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(self._nc - 1))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._s_vector[:] = s
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Gas_temperature_psxi", self, ['p', 's', 'xi'], None, ['T'])
+        batch_caller.add_call("TILMedia_Gas_temperature_psxi", self, ["p", "s", "xi"], None, ["T"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, s=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, s=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, s=%s, xi=%s.'
-                    % (str(p[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, s=%s, xi=%s."
+                    % (str(p[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_pThumRatioxidg(self, p, T, humRatio, xi_dryGas=None):
         """
@@ -717,62 +842,81 @@
             p (float, list, or numpy.ndarray): pressure [Pa]
             T (float, list, or numpy.ndarray): temperature [K]
             humRatio (float, list, or numpy.ndarray): humidity ratio [1]
             xi_dryGas (list, or numpy.ndarray): mass fraction of dry gas [1] (optional)
         """
 
         if self.fixed_mixing_ratio:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then this function must not be used")
         if self._condensingIndex <= 0:
-            raise TILMediaErrorInvalidParameter('If condensingIndex is = 0, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If condensingIndex is = 0, then this function must not be used")
         if xi_dryGas is None:
-            xi_dryGas = self._xi_dryGas_vector[tuple([0]*(self._xi_dryGas_vector.ndim-1))]
+            xi_dryGas = self._xi_dryGas_vector[tuple([0] * (self._xi_dryGas_vector.ndim - 1))]
 
         p, T, humRatio, xi_dryGas = internals.var_normalize_inputs(p, T, humRatio, xi_dryGas)
         internals.check_vector_size(xi_dryGas, self._nc - 2)
 
         if xi_dryGas.shape[-1] != max(0, self._nc - 2):
             raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(max(0, self._nc - 2)))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._T_vector[:] = T
         self._xi_dryGas_vector[:] = xi_dryGas
         self._humRatio_vector[:] = humRatio
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ['humRatio', 'xi_dryGas'], None, ['xi'])
+        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ["humRatio", "xi_dryGas"], None, ["xi"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, T=%s, humRatio=%s, xi_dryGas=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(humRatio[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, T=%s, humRatio=%s, xi_dryGas=%s."
+                    % (
+                        str(failure_index),
+                        str(p[failure_index]),
+                        str(T[failure_index]),
+                        str(humRatio[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             else:
                 failure_index = 0
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe inputs were p=%s, T=%s, humRatio=%s, xi_dryGas=%s.' %
-                                                          (str(p[failure_index]), str(T[failure_index]), str(humRatio[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe inputs were p=%s, T=%s, humRatio=%s, xi_dryGas=%s."
+                    % (
+                        str(p[failure_index]),
+                        str(T[failure_index]),
+                        str(humRatio[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_pTphixidg(self, p, T, phi, xi_dryGas=None):
         """
@@ -782,63 +926,84 @@
             p (float, list, or numpy.ndarray): pressure [Pa]
             T (float, list, or numpy.ndarray): temperature [K]
             phi (float, list, or numpy.ndarray): relative humidity [%]
             xi_dryGas (list, or numpy.ndarray): mass fraction of dry gas [1] (optional)
         """
 
         if self.fixed_mixing_ratio:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then this function must not be used")
         if self._condensingIndex <= 0:
-            raise TILMediaErrorInvalidParameter('If condensingIndex is = 0, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If condensingIndex is = 0, then this function must not be used")
         if xi_dryGas is None:
-            xi_dryGas = self._xi_dryGas_vector[tuple([0]*(self._xi_dryGas_vector.ndim-1))]
+            xi_dryGas = self._xi_dryGas_vector[tuple([0] * (self._xi_dryGas_vector.ndim - 1))]
 
         p, T, phi, xi_dryGas = internals.var_normalize_inputs(p, T, phi, xi_dryGas)
         internals.check_vector_size(xi_dryGas, self._nc - 2)
 
         if xi_dryGas.shape[-1] != max(0, self._nc - 2):
             raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(max(0, self._nc - 2)))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._T_vector[:] = T
         self._xi_dryGas_vector[:] = xi_dryGas
         self._phi_vector[:] = phi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_MoistAir_humRatio_pTphixidg", self, ['p', 'T', 'phi', 'xi_dryGas'], None, ['humRatio'])
-        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ['humRatio', 'xi_dryGas'], None, ['xi'])
+        batch_caller.add_call(
+            "TILMedia_MoistAir_humRatio_pTphixidg", self, ["p", "T", "phi", "xi_dryGas"], None, ["humRatio"]
+        )
+        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ["humRatio", "xi_dryGas"], None, ["xi"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, T=%s, phi=%s, xi_dryGas=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(phi[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, T=%s, phi=%s, xi_dryGas=%s."
+                    % (
+                        str(failure_index),
+                        str(p[failure_index]),
+                        str(T[failure_index]),
+                        str(phi[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             else:
                 failure_index = 0
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe inputs were p=%s, T=%s, phi=%s, xi_dryGas=%s.' %
-                                                          (str(p[failure_index]), str(T[failure_index]), str(phi[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe inputs were p=%s, T=%s, phi=%s, xi_dryGas=%s."
+                    % (
+                        str(p[failure_index]),
+                        str(T[failure_index]),
+                        str(phi[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_phumRatiophixidg(self, p, humRatio, phi, xi_dryGas=None):
         """
@@ -848,99 +1013,124 @@
             p (float, list, or numpy.ndarray): pressure [Pa]
             humRatio (float, list, or numpy.ndarray): humidity ratio [1]
             phi (float, list, or numpy.ndarray): relative humidity [%]
             xi_dryGas (list, or numpy.ndarray): mass fraction of dry gas [1] (optional)
         """
 
         if self.fixed_mixing_ratio:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then this function must not be used")
         if self._condensingIndex <= 0:
-            raise TILMediaErrorInvalidParameter('If condensingIndex is = 0, then this function must not be used')
+            raise TILMediaErrorInvalidParameter("If condensingIndex is = 0, then this function must not be used")
         if xi_dryGas is None:
-            xi_dryGas = self._xi_dryGas_vector[tuple([0]*(self._xi_dryGas_vector.ndim-1))]
+            xi_dryGas = self._xi_dryGas_vector[tuple([0] * (self._xi_dryGas_vector.ndim - 1))]
 
         p, humRatio, phi, xi_dryGas = internals.var_normalize_inputs(p, humRatio, phi, xi_dryGas)
         internals.check_vector_size(xi_dryGas, self._nc - 2)
 
         if xi_dryGas.shape[-1] != max(0, self._nc - 2):
             raise TILMediaErrorIncompatibleVectorLength("xi vector length is should be " + str(max(0, self._nc - 2)))
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._humRatio_vector[:] = humRatio
         self._xi_dryGas_vector[:] = xi_dryGas
         self._phi_vector[:] = phi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_MoistAir_properties_phumRatiophixidg", self, ['p', 'humRatio', 'phi', 'xi_dryGas'], None, ['d', 'h', 's', 'T', 'Y'])
-        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ['humRatio', 'xi_dryGas'], None, ['xi'])
+        batch_caller.add_call(
+            "TILMedia_MoistAir_properties_phumRatiophixidg",
+            self,
+            ["p", "humRatio", "phi", "xi_dryGas"],
+            None,
+            ["d", "h", "s", "T", "Y"],
+        )
+        batch_caller.add_call("TILMedia_Gas_xi_humRatioxidg_", self, ["humRatio", "xi_dryGas"], None, ["xi"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Gas_transportProperties_pTxi", self, ['p', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Gas_transportProperties_pTxi", self, ["p", "T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         if not self.fixed_mixing_ratio:
-            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ['xi'], None, ['humRatio', 'xi_dryGas'])
-            batch_caller.add_call("TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ['p', 'T', 'xi_dryGas'], None, ['humRatio_s'])
+            batch_caller.add_call("TILMedia_Gas_humRatioxidg_xi_", self, ["xi"], None, ["humRatio", "xi_dryGas"])
+            batch_caller.add_call(
+                "TILMedia_Gas_saturationHumidityRatio_pTxidg", self, ["p", "T", "xi_dryGas"], None, ["humRatio_s"]
+            )
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
-        self._M_vector[:], self._x_vector[:] = self._molarMass(
-            self._xi_vector,
-            self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        self._M_vector[:], self._x_vector[:] = self._molarMass(self._xi_vector, self.M_i)
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, humRatio=%s, phi=%s, xi_dryGas=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(humRatio[failure_index]), str(phi[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, humRatio=%s, phi=%s, xi_dryGas=%s."
+                    % (
+                        str(failure_index),
+                        str(p[failure_index]),
+                        str(humRatio[failure_index]),
+                        str(phi[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             else:
                 failure_index = 0
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe inputs were p=%s, humRatio=%s, phi=%s, xi_dryGas=%s.' %
-                                                          (str(p[failure_index]), str(humRatio[failure_index]), str(phi[failure_index]), str(xi_dryGas[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe inputs were p=%s, humRatio=%s, phi=%s, xi_dryGas=%s."
+                    % (
+                        str(p[failure_index]),
+                        str(humRatio[failure_index]),
+                        str(phi[failure_index]),
+                        str(xi_dryGas[failure_index]),
+                    )
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def _molarMass(self, xi, M_i):
         shape = xi.shape[:-1]
         M = np.zeros(shape)
         x = np.zeros(xi.shape)
         if isinstance(M_i, list):
             M_i = np.array(M_i)
 
-        mixingRatio = np.concatenate((xi, (np.ones(shape) - np.sum(xi, xi.ndim-1)).reshape(shape + (1,))), xi.ndim-1)
-        M = 1/np.sum(mixingRatio/M_i, xi.ndim-1)
-        x = M.reshape(shape + (1,)) * (xi/M_i[:-1])
+        mixingRatio = np.concatenate(
+            (xi, (np.ones(shape) - np.sum(xi, xi.ndim - 1)).reshape(shape + (1,))), xi.ndim - 1
+        )
+        M = 1 / np.sum(mixingRatio / M_i, xi.ndim - 1)
+        x = M.reshape(shape + (1,)) * (xi / M_i[:-1])
 
         return M, x
 
     def set(self, **kwargs):
         keys = frozenset(kwargs)
         mapping = {
-            frozenset({'p', 'h'}): self.set_phxi,
-            frozenset({'p', 'h', 'xi'}): self.set_phxi,
-            frozenset({'p', 'T'}): self.set_pTxi,
-            frozenset({'p', 'T', 'xi'}): self.set_pTxi,
-            frozenset({'p', 's'}): self.set_psxi,
-            frozenset({'p', 's', 'xi'}): self.set_psxi,
-            frozenset({'T'}): self.set_T,
-            frozenset({'T', 'xi'}): self.set_Txi,
-            frozenset({'p', 'T', 'phi'}): self.set_pTphixidg,
-            frozenset({'p', 'T', 'phi', 'xi_dryGas'}): self.set_pTphixidg,
-            frozenset({'p', 'T', 'humRatio'}): self.set_pThumRatioxidg,
-            frozenset({'p', 'T', 'humRatio', 'xi_dryGas'}): self.set_pThumRatioxidg,
-            frozenset({'p', 'humRatio', 'phi'}): self.set_phumRatiophixidg,
-            frozenset({'p', 'humRatio', 'phi', 'xi_dryGas'}): self.set_phumRatiophixidg,
+            frozenset({"p", "h"}): self.set_phxi,
+            frozenset({"p", "h", "xi"}): self.set_phxi,
+            frozenset({"p", "T"}): self.set_pTxi,
+            frozenset({"p", "T", "xi"}): self.set_pTxi,
+            frozenset({"p", "s"}): self.set_psxi,
+            frozenset({"p", "s", "xi"}): self.set_psxi,
+            frozenset({"T"}): self.set_T,
+            frozenset({"T", "xi"}): self.set_Txi,
+            frozenset({"p", "T", "phi"}): self.set_pTphixidg,
+            frozenset({"p", "T", "phi", "xi_dryGas"}): self.set_pTphixidg,
+            frozenset({"p", "T", "humRatio"}): self.set_pThumRatioxidg,
+            frozenset({"p", "T", "humRatio", "xi_dryGas"}): self.set_pThumRatioxidg,
+            frozenset({"p", "humRatio", "phi"}): self.set_phumRatiophixidg,
+            frozenset({"p", "humRatio", "phi", "xi_dryGas"}): self.set_phumRatiophixidg,
         }
         function = mapping.get(keys)
         if function:
             function(**kwargs)
         else:
-            raise TILMediaErrorInvalidParameter(
-                f'Properties cannot be computed from the arguments {keys}'
-            )
+            raise TILMediaErrorInvalidParameter(f"Properties cannot be computed from the arguments {keys}")
```

## tilmedia/general.py

```diff
@@ -1,11 +1,53 @@
-from typing import List, Union
+from typing import List, Union, Dict
 from . import core
 
 
+class LiquidMixtureInformation:
+    def __init__(
+        self,
+        supports_mass_fraction: bool = None,
+        supports_volume_fraction: bool = None,
+        minimum_mass_fraction: float = None,
+        maximum_mass_fraction: float = None,
+        minimum_volume_fraction: float = None,
+        maximum_volume_fraction: float = None,
+    ):
+        self.supports_mass_fraction: bool = supports_mass_fraction
+        "This medium supports setting the composition as mass fraction, and therefore all xi based function can be used."
+        self.supports_volume_fraction: bool = supports_volume_fraction
+        "This medium supports setting the composition as volume fraction."
+        self.minimum_mass_fraction: float = minimum_mass_fraction if minimum_mass_fraction >= 0 else None
+        self.maximum_mass_fraction: float = maximum_mass_fraction if maximum_mass_fraction >= 0 else None
+        self.minimum_volume_fraction: float = minimum_volume_fraction if minimum_volume_fraction >= 0 else None
+        self.maximum_volume_fraction: float = maximum_volume_fraction if maximum_volume_fraction >= 0 else None
+        self._property_list = [
+            "supports_mass_fraction",
+            "supports_volume_fraction",
+            "minimum_mass_fraction",
+            "maximum_mass_fraction",
+            "minimum_volume_fraction",
+            "maximum_volume_fraction",
+        ]
+
+    def __str__(self):
+        return "\n".join(
+            f"{name} = {round(getattr(self, name),5) if name.startswith('m') else getattr(self, name)}"
+            for name in self._property_list
+            if getattr(self, name) is not None
+        )
+
+    def __repr__(self):
+        return ", ".join(
+            f"{name} = {round(getattr(self, name),5) if name.startswith('m') else getattr(self, name)}"
+            for name in self._property_list
+            if getattr(self, name) is not None
+        )
+
+
 def clear_medium_name_cache():
     """
     Clear the name cache. This might be required if the data path has been changed.
     """
     core.clear_medium_name_cache()
 
 
@@ -15,14 +57,24 @@
 
     Returns:
         list: list of Liquid names
     """
     return core.get_all_liquid_names()
 
 
+def get_all_liquid_mixture_names() -> Dict[str, LiquidMixtureInformation]:
+    """
+    Get the list of Liquid names
+
+    Returns:
+        list: list of Liquid names
+    """
+    return dict((key, LiquidMixtureInformation(**value)) for key, value in core.get_all_liquid_mixture_names().items())
+
+
 def get_all_gas_names() -> List[str]:
     """
     Get the list of Gas names
 
     Returns:
         list: list of Gas names
     """
```

## tilmedia/liquid.py

```diff
@@ -1,33 +1,49 @@
 import logging
 from typing import Union, Optional, List
 from copy import deepcopy
 import numpy as np
-from .exceptions import TILMediaErrorIncompatibleVectorLength, TILMediaErrorInvalidParameter, TILMediaErrorInvalidMedium, TILMediaErrorInvalidLicense
+from threading import Lock
+from .exceptions import (
+    TILMediaErrorIncompatibleVectorLength,
+    TILMediaErrorInvalidParameter,
+    TILMediaErrorInvalidMedium,
+    TILMediaErrorInvalidLicense,
+)
 from .batchcaller import BatchFunctionCaller
 from .datacontainer import DataContainer
-from .core import license_is_valid, ExternalObject, Liquid_isValid_getInfo_errorInterface, getLiquidInformation_pointer, Liquid_minimalTemperature_xi_, Liquid_maximalTemperature_xi_
+from .core import (
+    license_is_valid,
+    ExternalObject,
+    Liquid_isValid_getInfo_errorInterface,
+    getLiquidInformation_pointer,
+    Liquid_minimalTemperature_xi_,
+    Liquid_maximalTemperature_xi_,
+)
 from .logger import LoggerWrapper
 from . import _internals as internals
 
+_liq_lock = Lock()
+
 _fullProperties = [
-    ('d', np.float64, None, None),
-    ('h', np.float64, None, None),
-    ('p', np.float64, None, None),
-    ('s', np.float64, None, None),
-    ('T', np.float64, None, None),
-    ('xi', np.float64, -1, None),
-    ('cp', np.float64, None, None),
-    ('beta', np.float64, None, None),
-    ('Pr', np.float64, None, None),
-    ('lamb', np.float64, None, None),
-    ('eta', np.float64, None, None),
-    ('sigma', np.float64, None, None),
-    ('current_T_min', np.float64, None, None),
-    ('current_T_max', np.float64, None, None)]
+    ("d", np.float64, None, None),
+    ("h", np.float64, None, None),
+    ("p", np.float64, None, None),
+    ("s", np.float64, None, None),
+    ("T", np.float64, None, None),
+    ("xi", np.float64, -1, None),
+    ("cp", np.float64, None, None),
+    ("beta", np.float64, None, None),
+    ("Pr", np.float64, None, None),
+    ("lamb", np.float64, None, None),
+    ("eta", np.float64, None, None),
+    ("sigma", np.float64, None, None),
+    ("current_T_min", np.float64, None, None),
+    ("current_T_max", np.float64, None, None),
+]
 
 
 class Liquid(DataContainer):
     """
     This Liquid class can calculate the thermopyhsical properties of a pure or mixture of incompressible liquids.
 
     The following combinations of inputs can be used to calculate properties by calling a setState function:
@@ -63,25 +79,25 @@
         array([4180.308149, 4177.312533, 4177.805418])
 
     """
 
     # static function call list
     _batch_function_calls = {
         1: [
-            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_min'])),
-            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_max'])),
+            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_min"])),
+            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_max"])),
         ],
         2: [
-            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_min'])),
-            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_max'])),
+            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_min"])),
+            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_max"])),
         ],
         3: [
-            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_min'])),
-            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ['xi'], None, ['current_T_max'])),
-            ("TILMedia_Liquid_specificEntropy_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['s'])),
+            ("TILMedia_Liquid_minimalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_min"])),
+            ("TILMedia_Liquid_maximalTemperature_xi_", lambda self: (self, ["xi"], None, ["current_T_max"])),
+            ("TILMedia_Liquid_specificEntropy_pTxi", lambda self: (self, ["p", "T", "xi"], None, ["s"])),
         ],
     }
 
     class _Info:
         _allowed = [
             "MediumName",
             "LibraryName",
@@ -106,15 +122,15 @@
             self.T_max = None
             self.T_data_min = None
             self.T_data_max = None
             self.xi_min = None
             self.xi_max = None
 
         def __repr__(self):
-            return 'TILMedia.Liquid.Info ' + self.LibraryName + ' ' + self.MediumName
+            return "TILMedia.Liquid.Info " + self.LibraryName + " " + self.MediumName
 
         def keys(self):
             return [member for member in self._allowed if getattr(self, member) is not None]
 
         def __len__(self):
             return len(self._allowed)
 
@@ -126,59 +142,70 @@
         def dump(self):
             s = str(self)
             if len(s) > 0:
                 print(s)
 
         def __str__(self):
             data = dict(self)
-            units = {
-                'T_min': ' K',
-                'T_max': ' K',
-                'T_data_min': ' K',
-                'T_data_max': ' K'
-            }
-            return "\n".join([key + ': ' + str(value) + units.get(key, '') for key, value in data.items()])
+            units = {"T_min": " K", "T_max": " K", "T_data_min": " K", "T_data_max": " K"}
+            return "\n".join([key + ": " + str(value) + units.get(key, "") for key, value in data.items()])
 
     _status = 0
     _property_list = []
 
     def __init__(
         self,
         liquid_name,
-        xi: Optional[Union[np.ndarray, List[float]]] = None,
+        xi: Optional[Union[List[float], np.ndarray]] = None,
         fixed_mixing_ratio=False,
         compute_transport_properties=True,
-        instance_name='Liquid_Python',
-        logger: Optional[logging.Logger] = None
+        instance_name="Liquid_Python",
+        logger: Optional[logging.Logger] = None,
     ):
+        global _liq_lock
         self._property_list = _fullProperties + self._property_list
         # properties of liquidObject
+        # fmt: off
         #    [[[cog
         # import cog
-        # from TILMedia import Liquid
+        # from tilmedia import Liquid
         # import numpy as np
-        # from TILMedia.internals import _generate_code
+        # from tilmedia._internals import _generate_code
         # gas = Liquid("Water")
         # v = gas._property_list
         # cog.outl("\n".join(_generate_code(v)))
         # ]]]
-        self.d = np.float64(0)  # : Density [kg/m^3]
-        self.h = np.float64(0)  # : Specific enthalpy [J/kg]
-        self.p = np.float64(0)  # : Pressure [Pa]
-        self.s = np.float64(0)  # : Specific entropy [J/(kg*K)]
-        self.T = np.float64(0)  # : Temperature [K]
-        self.xi = np.zeros((1, 0), dtype=np.float64)  # : Water Mass fraction [1]
-        self.cp = np.float64(0)  # : Specific isobaric heat capacity cp [J/(kg*K)]
-        self.beta = np.float64(0)  # : Isobaric thermal expansion coefficient [1/K]
-        self.Pr = np.float64(0)  # : Prandtl number [1]
-        self.lamb = np.float64(0)  # : Thermal conductivity [W/(m*K)]
-        self.eta = np.float64(0)  # : Dynamic viscosity [Pa*s]
-        self.sigma = np.float64(0)  # : Surface tension [J/m^2]
-        self.current_T_min = np.float64(0)  # : Minimal temperature of the valid region [K]
-        self.current_T_max = np.float64(0)  # : Maximal temperature of the valid region [K]
+        self.d = np.float64(0)
+        'Density [kg/m^3]'
+        self.h = np.float64(0)
+        'Specific enthalpy [J/kg]'
+        self.p = np.float64(0)
+        'Pressure [Pa]'
+        self.s = np.float64(0)
+        'Specific entropy [J/(kg*K)]'
+        self.T = np.float64(0)
+        'Temperature [K]'
+        self.xi = np.zeros((1, 0), dtype=np.float64)
+        'Water Mass fraction [1]'
+        self.cp = np.float64(0)
+        'Specific isobaric heat capacity cp [J/(kg*K)]'
+        self.beta = np.float64(0)
+        'Isobaric thermal expansion coefficient [1/K]'
+        self.Pr = np.float64(0)
+        'Prandtl number [1]'
+        self.lamb = np.float64(0)
+        'Thermal conductivity [W/(m*K)]'
+        self.eta = np.float64(0)
+        'Dynamic viscosity [Pa*s]'
+        self.sigma = np.float64(0)
+        'Surface tension [J/m^2]'
+        self.current_T_min = np.float64(0)
+        'Minimal temperature of the valid region [K]'
+        self.current_T_max = np.float64(0)
+        'Maximal temperature of the valid region [K]'
 
         self._d_vector = np.zeros(1, dtype=np.float64)
         self._h_vector = np.zeros(1, dtype=np.float64)
         self._p_vector = np.zeros(1, dtype=np.float64)
         self._s_vector = np.zeros(1, dtype=np.float64)
         self._T_vector = np.zeros(1, dtype=np.float64)
         self._xi_vector = np.zeros((1, 0), dtype=np.float64)
@@ -187,14 +214,15 @@
         self._Pr_vector = np.zeros(1, dtype=np.float64)
         self._lamb_vector = np.zeros(1, dtype=np.float64)
         self._eta_vector = np.zeros(1, dtype=np.float64)
         self._sigma_vector = np.zeros(1, dtype=np.float64)
         self._current_T_min_vector = np.zeros(1, dtype=np.float64)
         self._current_T_max_vector = np.zeros(1, dtype=np.float64)
         # [[[end]]]
+        # fmt: on
         self._xiFixed_vector = np.zeros((1, 0), dtype=np.float64)
 
         self._medium = None
         self._medium_wrapper = []
 
         self._compute_transport_properties = compute_transport_properties
 
@@ -203,86 +231,97 @@
             raise TILMediaErrorInvalidLicense("License not valid")
 
         # prepare error function pointer
         if logger is None:
             logger = internals._logger
         self._exceptions = []
         message_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_message_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_message_logger_function(
+                e, m, logger, x
+            )
         )
         error_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_error_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_error_logger_function(
+                e, m, logger, x
+            )
         )
 
         # Check if name is valid and calculate number of components
         self.fixed_mixing_ratio = fixed_mixing_ratio
         self._liquid_name = liquid_name
         self._nc_internal: int = -1
         _xi_autodetect = np.zeros(20, dtype=np.float64)
         c_logger = LoggerWrapper(logger, self._medium_wrapper, message_function, error_function)
         self.__c_logger = c_logger
-        self._status, self._nc_internal = Liquid_isValid_getInfo_errorInterface(
-            liquid_name+'',
-            _xi_autodetect,
-            True,
-            c_logger)
+        with _liq_lock as locked:
+            if locked:
+                self._status, self._nc_internal = Liquid_isValid_getInfo_errorInterface(
+                    liquid_name + "", _xi_autodetect, True, c_logger
+                )
         if self._status == 0:
-            raise TILMediaErrorInvalidMedium('LiquidName "'+liquid_name +
-                                             '" not valid. Could not create TILMedia object.')
-        self._xi_autodetect = np.zeros(self._nc_internal-1)
+            raise TILMediaErrorInvalidMedium(
+                'LiquidName "' + liquid_name + '" not valid. Could not create TILMedia object.'
+            )
+        self._xi_autodetect = np.zeros(self._nc_internal - 1)
 
         # forwarding information to other classes
         if fixed_mixing_ratio:
             self._nc = 1
         else:
             self._nc = self._nc_internal
-        DataContainer.__init__(self, self._nc, 'xi')
+        DataContainer.__init__(self, self._nc, "xi")
 
         # update to new nc
         self._resize_properties((1,))
         self._make_properties_scalar((1,), {None: []})
 
         # evaluate concentration
         if self._nc_internal > 1:
             # it is a mixture
             if fixed_mixing_ratio:
                 if xi is not None:
                     _, self._xiFixed_vector = internals.var_normalize_inputs(0, xi)
                     # xi is given
-                    if self._xiFixed_vector.shape[-1] != self._nc_internal-1:
+                    if self._xiFixed_vector.shape[-1] != self._nc_internal - 1:
                         # but has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("length of xi vector should be {nc} but is {length}".format(
-                            nc=self._nc_internal-1, length=self._xiFixed_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xiFixed_vector.shape[-1]
+                            )
+                        )
                 else:
                     # xi is not given
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
                         raise TILMediaErrorInvalidParameter(
-                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
             else:
                 # variable concentration
                 if xi is None:
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
                         raise TILMediaErrorInvalidParameter(
-                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
                 else:
                     _, self._xi_vector = internals.var_normalize_inputs(0, xi)
-                    if self._xi_vector.shape[-1] != self._nc_internal-1:
+                    if self._xi_vector.shape[-1] != self._nc_internal - 1:
                         # but the concentration vector has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("Length of xi vector should be {nc} but is {length}".format(
-                            nc=self._nc_internal-1, length=self._xi_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "Length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xi_vector.shape[-1]
+                            )
+                        )
         else:
             if xi is not None:
                 _, xi = internals.var_normalize_inputs(0, xi)
                 internals.check_vector_size(xi, self._nc_internal - 1)
         if xi is None:
             xi = self._xi_autodetect
 
@@ -290,36 +329,39 @@
         flags = 0
         if self._compute_transport_properties:
             flags = 1
         if self.fixed_mixing_ratio:
             _xi_call = self._xiFixed_vector[0]
         else:
             _xi_call = self._xi_vector[0]
-        self._medium = ExternalObject(
-            "Liquid",
-            liquid_name,
-            flags,
-            _xi_call,
-            self._nc,
-            -1,
-            instance_name,
-            c_logger
-            # self._messageFunction,
-            # self._errorFunction,
-            # c_void_p(0)
-        )
+        with _liq_lock as locked:
+            if locked:
+                self._medium = ExternalObject(
+                    "Liquid",
+                    liquid_name,
+                    flags,
+                    _xi_call,
+                    self._nc,
+                    -1,
+                    instance_name,
+                    c_logger
+                    # self._messageFunction,
+                    # self._errorFunction,
+                    # c_void_p(0)
+                )
         if not self._medium.ptr:
             if self._exceptions:
                 exceptions = deepcopy(self._exceptions)
                 while self._exceptions:
                     self._exceptions.pop()
                 raise exceptions[0]
             else:
-                raise TILMediaErrorInvalidMedium('LiquidName "'+liquid_name +
-                                                 '" not valid. Could not create TILMedia object.')
+                raise TILMediaErrorInvalidMedium(
+                    'LiquidName "' + liquid_name + '" not valid. Could not create TILMedia object.'
+                )
         self._medium_wrapper.append(self._medium)
         self.xi = self._xi_vector[0]
 
         # initializing Info
         self.info = self._Info()
         getLiquidInformation_pointer(self.info, self._medium)
 
@@ -334,44 +376,44 @@
             raise exceptions[0]
 
     def __del__(self):
         if self._status != 0:
             self._medium = 0
 
     def dump(self):
-        """ Prints the current thermophysical properties of the liquid to stdout. """
+        """Prints the current thermophysical properties of the liquid to stdout."""
 
         s = "---------------------------------"
         s += str(self)
         s += "---------------------------------"
         print(s)
 
     def __str__(self):
         value = []
         value += ["Medium: " + self._liquid_name]
         value += [DataContainer.__str__(self)]
         return "\n".join([v for v in value if v])
 
     def __repr__(self):
-        return 'TILMedia.Liquid "' + self._liquid_name + '" (nc = '+str(self._nc)+')'
+        return 'TILMedia.Liquid "' + self._liquid_name + '" (nc = ' + str(self._nc) + ")"
 
-    def set_xi(self, xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_xi(self, xi: Optional[Union[List[float], np.ndarray]] = None) -> None:
         """
         Calculates all thermophysical properties depending on the concentration.
 
         Args:
             xi (list, numpy.ndarray): mass fraction [1]
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
-        xi, = internals.var_normalize_inputs(xi)
+        (xi,) = internals.var_normalize_inputs(xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = xi.shape[:-1]
         self._resize_properties(shape)
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
@@ -386,263 +428,292 @@
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe error was caused by element %s: xi=%s.'
-                    % (str(failure_index), str(xi[failure_index])))
+                    + "\nThe error was caused by element %s: xi=%s." % (str(failure_index), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
-                    self._exceptions[0].message
-                    + '\nThe inputs were xi=%s.'
-                    % (str(xi[failure_index])))
+                    self._exceptions[0].message + "\nThe inputs were xi=%s." % (str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_Txi(self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_Txi(
+        self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[List[float], np.ndarray]] = None
+    ) -> None:
         """
         Calculates all thermophysical properties depending on temperature and independent mass fractions (always one less than the number of components in mixtures).
         Pressure and specific entropy are set to 0.
 
         Args:
             T (float, list, numpy.ndarray): temperature [K]
             xi (list, numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         T, xi = internals.var_normalize_inputs(T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = T.shape
         self._resize_properties(shape)
         self._p_vector[:] = 0
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Liquid_properties_Txi", self, ['T', 'xi'], None, ['d', 'cp', 'beta'])
-        batch_caller.add_call("TILMedia_LiquidObjectFunctions_specificEnthalpy_Txi", self, ['T', 'xi'], None, ['h'])
+        batch_caller.add_call("TILMedia_Liquid_properties_Txi", self, ["T", "xi"], None, ["d", "cp", "beta"])
+        batch_caller.add_call("TILMedia_LiquidObjectFunctions_specificEnthalpy_Txi", self, ["T", "xi"], None, ["h"])
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Liquid_transportProperties_Txi", self, [
-                                  'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Liquid_transportProperties_Txi", self, ["T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         for function_name, arguments in self._batch_function_calls[2]:
             batch_caller.add_call(function_name, *arguments(self))
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
         self._s_vector[:] = 0
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: T=%s, xi=%s.' %
-                                                          (str(failure_index), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: T=%s, xi=%s."
+                    % (str(failure_index), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were T=%s, xi=%s.'
-                    % (str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were T=%s, xi=%s." % (str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_hxi(self, h: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_hxi(
+        self, h: Union[float, np.ndarray, List[float]], xi: Optional[Union[List[float], np.ndarray]] = None
+    ) -> None:
         """
         Calculates all thermophysical properties depending on specific enthalpy and independent mass fractions (always one less than the number of components in mixtures).
         Pressure and specific entropy are set to 0.
 
         Args:
             h (float, list, numpy.ndarray): specific entphalpy [J/kg]
             xi (list, numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         h, xi = internals.var_normalize_inputs(h, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = h.shape
         self._resize_properties(shape)
         self._p_vector[:] = 0
         self._h_vector[:] = h
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Liquid_properties_hxi", self, ['h', 'xi'], None, ['d', 'cp', 'beta'])
-        batch_caller.add_call("TILMedia_LiquidObjectFunctions_temperature_hxi", self, ['h', 'xi'], None, ['T'])
+        batch_caller.add_call("TILMedia_Liquid_properties_hxi", self, ["h", "xi"], None, ["d", "cp", "beta"])
+        batch_caller.add_call("TILMedia_LiquidObjectFunctions_temperature_hxi", self, ["h", "xi"], None, ["T"])
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Liquid_transportProperties_Txi", self, [
-                                  'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Liquid_transportProperties_Txi", self, ["T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         for function_name, arguments in self._batch_function_calls[2]:
             batch_caller.add_call(function_name, *arguments(self))
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
         self._s_vector[:] = 0
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: h=%s, xi=%s.' %
-                                                          (str(failure_index), str(h[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: h=%s, xi=%s."
+                    % (str(failure_index), str(h[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were h=%s, xi=%s.'
-                    % (str(h[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were h=%s, xi=%s." % (str(h[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_pTxi(self, p: Union[float, np.ndarray, List[float]], T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_pTxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        T: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, temperature and independent mass fractions
         (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, numpy.ndarray): pressure [Pa]
             T (float, list, numpy.ndarray): temperature [K]
             xi (list, numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, T, xi = internals.var_normalize_inputs(p, T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Liquid_properties_Txi", self, ['T', 'xi'], None, ['d', 'cp', 'beta'])
-        batch_caller.add_call("TILMedia_LiquidObjectFunctions_specificEnthalpy_Txi", self, ['T', 'xi'], None, ['h'])
+        batch_caller.add_call("TILMedia_Liquid_properties_Txi", self, ["T", "xi"], None, ["d", "cp", "beta"])
+        batch_caller.add_call("TILMedia_LiquidObjectFunctions_specificEnthalpy_Txi", self, ["T", "xi"], None, ["h"])
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Liquid_transportProperties_Txi", self, [
-                                  'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Liquid_transportProperties_Txi", self, ["T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, T=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, T=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, T=%s, xi=%s.'
-                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, T=%s, xi=%s."
+                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_phxi(self, p: Union[float, np.ndarray, List[float]], h: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_phxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        h: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, specific enthalpy and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, numpy.ndarray): pressure [Pa]
             h (float, list, numpy.ndarray): specific entphalpy [J/kg]
             xi (list, numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, h, xi = internals.var_normalize_inputs(p, h, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._h_vector[:] = h
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_Liquid_properties_hxi", self, ['h', 'xi'], None, ['d', 'cp', 'beta'])
-        batch_caller.add_call("TILMedia_LiquidObjectFunctions_temperature_hxi", self, ['h', 'xi'], None, ['T'])
+        batch_caller.add_call("TILMedia_Liquid_properties_hxi", self, ["h", "xi"], None, ["d", "cp", "beta"])
+        batch_caller.add_call("TILMedia_LiquidObjectFunctions_temperature_hxi", self, ["h", "xi"], None, ["T"])
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_Liquid_transportProperties_Txi", self, [
-                                  'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_Liquid_transportProperties_Txi", self, ["T", "xi"], None, ["Pr", "lamb", "eta", "sigma"]
+            )
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
 
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._make_properties_scalar(shape, calculated_properties[None])
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, h=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, h=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, h=%s, xi=%s.'
-                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, h=%s, xi=%s."
+                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set(self, **kwargs):
         keys = frozenset(kwargs)
         mapping = {
-            frozenset({'p', 'h'}): self.set_phxi,
-            frozenset({'p', 'h', 'xi'}): self.set_phxi,
-            frozenset({'p', 'T'}): self.set_pTxi,
-            frozenset({'p', 'T', 'xi'}): self.set_pTxi,
-            frozenset({'h'}): self.set_hxi,
-            frozenset({'h', 'xi'}): self.set_hxi,
-            frozenset({'T'}): self.set_Txi,
-            frozenset({'T', 'xi'}): self.set_Txi,
-            frozenset({'xi'}): self.set_xi,
+            frozenset({"p", "h"}): self.set_phxi,
+            frozenset({"p", "h", "xi"}): self.set_phxi,
+            frozenset({"p", "T"}): self.set_pTxi,
+            frozenset({"p", "T", "xi"}): self.set_pTxi,
+            frozenset({"h"}): self.set_hxi,
+            frozenset({"h", "xi"}): self.set_hxi,
+            frozenset({"T"}): self.set_Txi,
+            frozenset({"T", "xi"}): self.set_Txi,
+            frozenset({"xi"}): self.set_xi,
         }
         function = mapping.get(keys)
         if function:
             function(**kwargs)
         else:
-            raise TILMediaErrorInvalidParameter(
-                f'Properties cannot be computed from the arguments {keys}'
-            )
+            raise TILMediaErrorInvalidParameter(f"Properties cannot be computed from the arguments {keys}")
```

## tilmedia/logger.py

```diff
@@ -1,14 +1,15 @@
 from logging import Logger
 from .core import CLoggerWrapper
+
 _logger_id = 0
 c_logger = {}
 
 
-class LoggerWrapper():
+class LoggerWrapper:
     """
     Wrapper class for the logger. It holds the exceptions, the C wrapper, and the message functions.
     """
 
     def __init__(self, logger: Logger, message_container: list, format_message, format_error):
         global _logger_id
         _logger_id = _logger_id + 1
```

## tilmedia/moistair.py

```diff
@@ -1,15 +1,15 @@
 import logging
 from copy import deepcopy
 from typing import Union, Optional, List
 import numpy as np
 from .gas import Gas
 from .exceptions import TILMediaErrorInvalidParameter
 
-_moistAirProperties = ['T_wetBulb', 'T_iceBulb', 'T_dew']
+_moistAirProperties = ["T_wetBulb", "T_iceBulb", "T_dew"]
 
 
 class MoistAir(Gas):
     """
     This MoistAir class can calculate the thermopyhsical properties of a pure ideal gas or ideal gas vapor mixture. It provides additional variables for wet/ice bulb temperature and dew temperature.
 
     The following combinations of inputs can be used to calculate properties by calling a setState function:
@@ -43,44 +43,58 @@
         1.150191
 
     """
 
     def __init__(
         self,
         gas_name,
-        xi: Optional[Union[np.ndarray, List[float]]] = None,
+        xi: Optional[Union[List[float], np.ndarray]] = None,
         condensingIndex=1,
         fixed_mixing_ratio=False,
         compute_transport_properties=True,
         instance_name="MoistAir_Python",
-        logger: Optional[logging.Logger] = None
+        logger: Optional[logging.Logger] = None,
     ):
-        self.T_wetBulb = 0  # : wet bulb temperature [K]
-        self.T_iceBulb = 0  # : ice bulb temperature [K]
-        self.T_dew = 0  # : dew temperature [K]
+        self.T_wetBulb = 0
+        "wet bulb temperature [K]"
+        self.T_iceBulb = 0
+        "ice bulb temperature [K]"
+        self.T_dew = 0
+        "dew temperature [K]"
 
         self._T_wetBulb_vector = np.zeros((1), dtype=np.float64)
         self._T_iceBulb_vector = np.zeros((1), dtype=np.float64)
         self._T_dew_vector = np.zeros((1), dtype=np.float64)
 
         self._T_wetBulb = np.ctypeslib.as_ctypes(self._T_wetBulb_vector)
         self._T_iceBulb = np.ctypeslib.as_ctypes(self._T_iceBulb_vector)
         self._T_dew = np.ctypeslib.as_ctypes(self._T_dew_vector)
 
         self._batch_function_calls = deepcopy(self._batch_function_calls)
         self._batch_function_calls[3] += [
-            ("TILMedia_GasObjectFunctions_wetBulbTemperature_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['T_wetBulb'])),
-            ("TILMedia_GasObjectFunctions_iceBulbTemperature_pTxi", lambda self: (self, ['p', 'T', 'xi'], None, ['T_iceBulb'])),
-            ("TILMedia_GasObjectFunctions_dewTemperature_pTphixidg", lambda self: (self, ['p', 'T', 'phi', 'xi_dryGas'], None, ['T_dew'])),
+            (
+                "TILMedia_GasObjectFunctions_wetBulbTemperature_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["T_wetBulb"]),
+            ),
+            (
+                "TILMedia_GasObjectFunctions_iceBulbTemperature_pTxi",
+                lambda self: (self, ["p", "T", "xi"], None, ["T_iceBulb"]),
+            ),
+            (
+                "TILMedia_GasObjectFunctions_dewTemperature_pTphixidg",
+                lambda self: (self, ["p", "T", "phi", "xi_dryGas"], None, ["T_dew"]),
+            ),
         ]
         self._property_list = [
-            ('T_wetBulb', np.float64, None, None),
-            ('T_iceBulb', np.float64, None, None),
-            ('T_dew', np.float64, None, None),
+            ("T_wetBulb", np.float64, None, None),
+            ("T_iceBulb", np.float64, None, None),
+            ("T_dew", np.float64, None, None),
         ]
 
-        Gas.__init__(self, gas_name, xi, condensingIndex, fixed_mixing_ratio, compute_transport_properties, instance_name, logger)
+        Gas.__init__(
+            self, gas_name, xi, condensingIndex, fixed_mixing_ratio, compute_transport_properties, instance_name, logger
+        )
         if self._nc == 1:
             raise TILMediaErrorInvalidParameter("The MoistAir class should not be used for pure substances.")
 
     set_pThumRatio = Gas.set_pThumRatioxidg
     set_pTphi = Gas.set_pTphixidg
```

## tilmedia/properties.py

```diff
@@ -1,8 +1,9 @@
-ï»¿
+ï»¿# fmt: off
+
 property_information = {
     'd': {
         'description': 'Density',
         'unit': 'kg/m^3',
         'numpy_type': 'float64',
         'is_vector': False,
     },
@@ -639,7 +640,8 @@
     'current_T_max': {
         'description': 'Maximal temperature of the valid region',
         'unit': 'K',
         'numpy_type': 'float64',
         'is_vector': False,
     },
 }
+
```

## tilmedia/vlefluid.py

```diff
@@ -1,73 +1,91 @@
 import logging
 from typing import Union, Optional, List
 from copy import deepcopy
 import numpy as np
-from .exceptions import TILMediaErrorIncompatibleVectorLength, TILMediaErrorInvalidParameter, TILMediaErrorInvalidMedium, TILMediaErrorInvalidLicense
+from threading import Lock
+from .exceptions import (
+    TILMediaErrorIncompatibleVectorLength,
+    TILMediaErrorInvalidParameter,
+    TILMediaErrorInvalidMedium,
+    TILMediaErrorInvalidLicense,
+)
 from .batchcaller import BatchFunctionCaller
 from .datacontainer import DataContainer
-from .core import license_is_valid, VLEFluid_isValid_getInfo_errorInterface, ExternalObject, getVLEFluidInformation_pointer, VLEFluid_Cached_molarMass
+from .core import (
+    license_is_valid,
+    VLEFluid_isValid_getInfo_errorInterface,
+    ExternalObject,
+    getVLEFluidInformation_pointer,
+    VLEFluid_Cached_molarMass,
+)
 from .logger import LoggerWrapper
 from . import _internals as internals
 
+_vle_lock = Lock()
+
 _properties = [
-    ('d', np.float64, None, None),
-    ('h', np.float64, None, None),
-    ('p', np.float64, None, None),
-    ('s', np.float64, None, None),
-    ('T', np.float64, None, None)]
+    ("d", np.float64, None, None),
+    ("h", np.float64, None, None),
+    ("p", np.float64, None, None),
+    ("s", np.float64, None, None),
+    ("T", np.float64, None, None),
+]
 _additionalProperties = [
-    ('cp', np.float64, None, None),
-    ('beta', np.float64, None, None),
-    ('kappa', np.float64, None, None)]
+    ("cp", np.float64, None, None),
+    ("beta", np.float64, None, None),
+    ("kappa", np.float64, None, None),
+]
 _transportProperties = [
-    ('Pr', np.float64, None, None),
-    ('lambda', np.float64, None, None),
-    ('eta', np.float64, None, None)]
+    ("Pr", np.float64, None, None),
+    ("lambda", np.float64, None, None),
+    ("eta", np.float64, None, None),
+]
 _fullProperties = [
-    ('p', np.float64, None, None),
-    ('h', np.float64, None, None),
-    ('d', np.float64, None, None),
-    ('s', np.float64, None, None),
-    ('T', np.float64, None, None),
-    ('xi', np.float64, -1, None),
-    ('x', np.float64, -1, None),
-    ('M', np.float64, None, None),
-    ('phase', np.int32, None, None),
-    ('q', np.float64, None, None),
-    ('cp', np.float64, None, None),
-    ('cv', np.float64, None, None),
-    ('beta', np.float64, None, None),
-    ('kappa', np.float64, None, None),
-    ('w', np.float64, None, None),
-    ('drhodh_pxi', np.float64, None, None),
-    ('drhodp_hxi', np.float64, None, None),
-    ('drhodxi_ph', np.float64, -1, None),
-    ('gamma', np.float64, None, None)]
+    ("p", np.float64, None, None),
+    ("h", np.float64, None, None),
+    ("d", np.float64, None, None),
+    ("s", np.float64, None, None),
+    ("T", np.float64, None, None),
+    ("xi", np.float64, -1, None),
+    ("x", np.float64, -1, None),
+    ("M", np.float64, None, None),
+    ("phase", np.int32, None, None),
+    ("q", np.float64, None, None),
+    ("cp", np.float64, None, None),
+    ("cv", np.float64, None, None),
+    ("beta", np.float64, None, None),
+    ("kappa", np.float64, None, None),
+    ("w", np.float64, None, None),
+    ("drhodh_pxi", np.float64, None, None),
+    ("drhodp_hxi", np.float64, None, None),
+    ("drhodxi_ph", np.float64, -1, None),
+    ("gamma", np.float64, None, None),
+]
 _fullTransportProperties = [
-    ('Pr', np.float64, None, None),
-    ('lamb', np.float64, None, None),
-    ('eta', np.float64, None, None),
-    ('sigma', np.float64, None, None)]
+    ("Pr", np.float64, None, None),
+    ("lamb", np.float64, None, None),
+    ("eta", np.float64, None, None),
+    ("sigma", np.float64, None, None),
+]
 _saturationProperties = [
-    ('T_bubble', np.float64, None, None),
-    ('T_dew', np.float64, None, None),
-    ('p_bubble', np.float64, None, None),
-    ('p_dew', np.float64, None, None),
-    ('dl_bubble', np.float64, None, None),
-    ('dv_dew', np.float64, None, None),
-    ('dv_bubble', np.float64, None, None),
-    ('dl_dew', np.float64, None, None),
-    ('hl_bubble', np.float64, None, None),
-    ('hv_dew', np.float64, None, None),
-    ('sl_bubble', np.float64, None, None),
-    ('sv_dew', np.float64, None, None)]
-_saturationMixtureProperties = [
-    ('xiv_bubble', np.float64, -1, None),
-    ('xil_dew', np.float64, -1, None)]
+    ("T_bubble", np.float64, None, None),
+    ("T_dew", np.float64, None, None),
+    ("p_bubble", np.float64, None, None),
+    ("p_dew", np.float64, None, None),
+    ("dl_bubble", np.float64, None, None),
+    ("dv_dew", np.float64, None, None),
+    ("dv_bubble", np.float64, None, None),
+    ("dl_dew", np.float64, None, None),
+    ("hl_bubble", np.float64, None, None),
+    ("hv_dew", np.float64, None, None),
+    ("sl_bubble", np.float64, None, None),
+    ("sv_dew", np.float64, None, None),
+]
+_saturationMixtureProperties = [("xiv_bubble", np.float64, -1, None), ("xil_dew", np.float64, -1, None)]
 
 
 class VLEFluid(DataContainer):
     """
     This VLEFluid class can calculate the thermopyhsical properties of a pure real fluid or real fluid mixture.
 
         1. xi: mass fraction
@@ -115,73 +133,139 @@
         array([6.106462, 5.79392 , 5.511813])
 
     """
 
     # static function call list
     _batch_function_calls = {
         4: [
-            ("TILMedia_VLEFluid_criticalDataRecord_xi", lambda self: (self, ['xi'], 'crit', ['dc', 'hc', 'pc', 'sc', 'Tc'])),
-            ("TILMedia_VLEFluid_Cached_phase_dTxi", lambda self: (self, ['d', 'T', 'xi'], None, ['phase'])),
-            ("TILMedia_VLEFluid_additionalProperties_dTxi", lambda self: (self, ['d', 'T', 'xi'], None, ['q', 'cp', 'cv', 'beta', 'kappa', 'drhodp_hxi', 'drhodh_pxi', 'drhodxi_ph', 'w', 'gamma'])),
-            ("TILMedia_VLEFluid_VLEProperties_dTxi", lambda self: (self, ['d', 'T', 'xi'], 'vle', ['d_l', 'h_l', 'p_l', 's_l', 'T_l', 'xi_l', 'd_v', 'h_v', 'p_v', 's_v', 'T_v', 'xi_v'])),
+            (
+                "TILMedia_VLEFluid_criticalDataRecord_xi",
+                lambda self: (self, ["xi"], "crit", ["dc", "hc", "pc", "sc", "Tc"]),
+            ),
+            ("TILMedia_VLEFluid_Cached_phase_dTxi", lambda self: (self, ["d", "T", "xi"], None, ["phase"])),
+            (
+                "TILMedia_VLEFluid_additionalProperties_dTxi",
+                lambda self: (
+                    self,
+                    ["d", "T", "xi"],
+                    None,
+                    ["q", "cp", "cv", "beta", "kappa", "drhodp_hxi", "drhodh_pxi", "drhodxi_ph", "w", "gamma"],
+                ),
+            ),
+            (
+                "TILMedia_VLEFluid_VLEProperties_dTxi",
+                lambda self: (
+                    self,
+                    ["d", "T", "xi"],
+                    "vle",
+                    ["d_l", "h_l", "p_l", "s_l", "T_l", "xi_l", "d_v", "h_v", "p_v", "s_v", "T_v", "xi_v"],
+                ),
+            ),
         ],
         3: [
-            ("TILMedia_VLEFluid_criticalDataRecord_xi", lambda self: (self, ['xi'], 'crit', ['dc', 'hc', 'pc', 'sc', 'Tc'])),
-            ("TILMedia_VLEFluid_Cached_phase_phxi", lambda self: (self, ['p', 'h', 'xi'], None, ['phase'])),
-            ("TILMedia_VLEFluid_additionalProperties_phxi", lambda self: (self, ['p', 'h', 'xi'], None, ['q', 'cp', 'cv', 'beta', 'kappa', 'drhodp_hxi', 'drhodh_pxi', 'drhodxi_ph', 'w', 'gamma'])),
-            ("TILMedia_VLEFluid_VLEProperties_phxi", lambda self: (self, ['p', 'h', 'xi'], 'vle', ['d_l', 'h_l', 'p_l', 's_l', 'T_l', 'xi_l', 'd_v', 'h_v', 'p_v', 's_v', 'T_v', 'xi_v'])),
+            (
+                "TILMedia_VLEFluid_criticalDataRecord_xi",
+                lambda self: (self, ["xi"], "crit", ["dc", "hc", "pc", "sc", "Tc"]),
+            ),
+            ("TILMedia_VLEFluid_Cached_phase_phxi", lambda self: (self, ["p", "h", "xi"], None, ["phase"])),
+            (
+                "TILMedia_VLEFluid_additionalProperties_phxi",
+                lambda self: (
+                    self,
+                    ["p", "h", "xi"],
+                    None,
+                    ["q", "cp", "cv", "beta", "kappa", "drhodp_hxi", "drhodh_pxi", "drhodxi_ph", "w", "gamma"],
+                ),
+            ),
+            (
+                "TILMedia_VLEFluid_VLEProperties_phxi",
+                lambda self: (
+                    self,
+                    ["p", "h", "xi"],
+                    "vle",
+                    ["d_l", "h_l", "p_l", "s_l", "T_l", "xi_l", "d_v", "h_v", "p_v", "s_v", "T_v", "xi_v"],
+                ),
+            ),
         ],
         2: [],
         1: [
-            ("TILMedia_VLEFluid_criticalDataRecord_xi", lambda self: (self, ['xi'], 'crit', ['dc', 'hc', 'pc', 'sc', 'Tc']))
-        ]
+            (
+                "TILMedia_VLEFluid_criticalDataRecord_xi",
+                lambda self: (self, ["xi"], "crit", ["dc", "hc", "pc", "sc", "Tc"]),
+            )
+        ],
     }
 
     class _VLEProperties(DataContainer):
         """Vapour Liquid Equilibrium Properties"""
 
         def __init__(self, nc=1):
             self._property_list = []
-            for p in _properties + [('xi', np.float64, -1, None)] + _additionalProperties + _transportProperties:
-                self._property_list.append((p[0] + '_l',) + p[1:])
-                self._property_list.append((p[0] + '_v',) + p[1:])
+            for p in _properties + [("xi", np.float64, -1, None)] + _additionalProperties + _transportProperties:
+                self._property_list.append((p[0] + "_l",) + p[1:])
+                self._property_list.append((p[0] + "_v",) + p[1:])
 
+            # fmt: off
             #    [[[cog
             # import cog
-            # from TILMedia import VLEFluid
+            # from tilmedia import VLEFluid
             # import numpy as np
-            # from TILMedia.internals import _generate_code
+            # from tilmedia._internals import _generate_code
             # vle = VLEFluid("Refprop.R410A.mix")
             # v = vle.vle._property_list
             # cog.outl("\n".join(_generate_code(v)))
             # ]]]
-            self.d_l = np.float64(0)  # : Density of liquid phase [kg/m^3]
-            self.d_v = np.float64(0)  # : Density of vapour phase [kg/m^3]
-            self.h_l = np.float64(0)  # : Specific enthalpy of liquid phase [J/kg]
-            self.h_v = np.float64(0)  # : Specific enthalpy of vapour phase [J/kg]
-            self.p_l = np.float64(0)  # : Pressure of liquid phase [Pa]
-            self.p_v = np.float64(0)  # : Pressure of vapour phase [Pa]
-            self.s_l = np.float64(0)  # : Specific entropy of liquid phase [J/(kg*K)]
-            self.s_v = np.float64(0)  # : Specific entropy of vapour phase [J/(kg*K)]
-            self.T_l = np.float64(0)  # : Temperature of liquid phase [K]
-            self.T_v = np.float64(0)  # : Temperature of vapour phase [K]
-            self.xi_l = np.zeros((1, 0), dtype=np.float64)  # : Mass fraction of liquid phase [1]
-            self.xi_v = np.zeros((1, 0), dtype=np.float64)  # : Mass fraction of vapour phase [1]
-            self.cp_l = np.float64(0)  # : Specific heat capacity cp of liquid phase [J/(kg*K)]
-            self.cp_v = np.float64(0)  # : Specific heat capacity cp of vapour phase [J/(kg*K)]
-            self.beta_l = np.float64(0)  # : Isobaric expansion coefficient of liquid phase [1/K]
-            self.beta_v = np.float64(0)  # : Isobaric expansion coefficient of vapour phase [1/K]
-            self.kappa_l = np.float64(0)  # : Isothermal compressibility of liquid phase [1/Pa]
-            self.kappa_v = np.float64(0)  # : Isothermal compressibility of vapour phase [1/Pa]
-            self.Pr_l = np.float64(0)  # : Prandtl number of liquid phase [1]
-            self.Pr_v = np.float64(0)  # : Prandtl number of vapour phase [1]
-            self.lambda_l = np.float64(0)  # : Thermal conductivity of liquid phase [W/(m*K)]
-            self.lambda_v = np.float64(0)  # : Thermal conductivity of vapour phase [W/(m*K)]
-            self.eta_l = np.float64(0)  # : Dynamic viscosity of liquid phase [Pa*s]
-            self.eta_v = np.float64(0)  # : Dynamic viscosity of vapour phase [Pa*s]
+            self.d_l = np.float64(0)
+            'Density of liquid phase [kg/m^3]'
+            self.d_v = np.float64(0)
+            'Density of vapour phase [kg/m^3]'
+            self.h_l = np.float64(0)
+            'Specific enthalpy of liquid phase [J/kg]'
+            self.h_v = np.float64(0)
+            'Specific enthalpy of vapour phase [J/kg]'
+            self.p_l = np.float64(0)
+            'Pressure of liquid phase [Pa]'
+            self.p_v = np.float64(0)
+            'Pressure of vapour phase [Pa]'
+            self.s_l = np.float64(0)
+            'Specific entropy of liquid phase [J/(kg*K)]'
+            self.s_v = np.float64(0)
+            'Specific entropy of vapour phase [J/(kg*K)]'
+            self.T_l = np.float64(0)
+            'Temperature of liquid phase [K]'
+            self.T_v = np.float64(0)
+            'Temperature of vapour phase [K]'
+            self.xi_l = np.zeros((1, 0), dtype=np.float64)
+            'Mass fraction of liquid phase [1]'
+            self.xi_v = np.zeros((1, 0), dtype=np.float64)
+            'Mass fraction of vapour phase [1]'
+            self.cp_l = np.float64(0)
+            'Specific heat capacity cp of liquid phase [J/(kg*K)]'
+            self.cp_v = np.float64(0)
+            'Specific heat capacity cp of vapour phase [J/(kg*K)]'
+            self.beta_l = np.float64(0)
+            'Isobaric expansion coefficient of liquid phase [1/K]'
+            self.beta_v = np.float64(0)
+            'Isobaric expansion coefficient of vapour phase [1/K]'
+            self.kappa_l = np.float64(0)
+            'Isothermal compressibility of liquid phase [1/Pa]'
+            self.kappa_v = np.float64(0)
+            'Isothermal compressibility of vapour phase [1/Pa]'
+            self.Pr_l = np.float64(0)
+            'Prandtl number of liquid phase [1]'
+            self.Pr_v = np.float64(0)
+            'Prandtl number of vapour phase [1]'
+            self.lambda_l = np.float64(0)
+            'Thermal conductivity of liquid phase [W/(m*K)]'
+            self.lambda_v = np.float64(0)
+            'Thermal conductivity of vapour phase [W/(m*K)]'
+            self.eta_l = np.float64(0)
+            'Dynamic viscosity of liquid phase [Pa*s]'
+            self.eta_v = np.float64(0)
+            'Dynamic viscosity of vapour phase [Pa*s]'
 
             self._d_l_vector = np.zeros(1, dtype=np.float64)
             self._d_v_vector = np.zeros(1, dtype=np.float64)
             self._h_l_vector = np.zeros(1, dtype=np.float64)
             self._h_v_vector = np.zeros(1, dtype=np.float64)
             self._p_l_vector = np.zeros(1, dtype=np.float64)
             self._p_v_vector = np.zeros(1, dtype=np.float64)
@@ -200,52 +284,68 @@
             self._Pr_l_vector = np.zeros(1, dtype=np.float64)
             self._Pr_v_vector = np.zeros(1, dtype=np.float64)
             self._lambda_l_vector = np.zeros(1, dtype=np.float64)
             self._lambda_v_vector = np.zeros(1, dtype=np.float64)
             self._eta_l_vector = np.zeros(1, dtype=np.float64)
             self._eta_v_vector = np.zeros(1, dtype=np.float64)
             # [[[end]]]
+            # fmt: on
 
-            DataContainer.__init__(self, nc, 'xi_l')
+            DataContainer.__init__(self, nc, "xi_l")
 
         def resize_properties(self, shape):
             return self._resize_properties(shape)
 
         def __repr__(self):
             return "VLEProperties()"
 
     class _SaturationProperties(DataContainer):
         """Dew and Bubble Point Properties"""
 
         def __init__(self, nc=1):
             self._property_list = _saturationProperties + _saturationMixtureProperties
 
+            # fmt: off
             #    [[[cog
             # import cog
-            # from TILMedia import VLEFluid
+            # from tilmedia import VLEFluid
             # import numpy as np
-            # from TILMedia.internals import _generate_code
+            # from tilmedia._internals import _generate_code
             # vle = VLEFluid("Refprop.R410A.mix")
             # v = vle.sat._property_list
             # cog.outl("\n".join(_generate_code(v)))
             # ]]]
-            self.T_bubble = np.float64(0)  # : bubble point temperature [K]
-            self.T_dew = np.float64(0)  # : dew point temperature [K]
-            self.p_bubble = np.float64(0)  # : bubble point pressure [Pa]
-            self.p_dew = np.float64(0)  # : dew point pressure [Pa]
-            self.dl_bubble = np.float64(0)  # : bubble point liquid denstiy [kg/m^3]
-            self.dv_dew = np.float64(0)  # : dew point vapour denstiy [kg/m^3]
-            self.dv_bubble = np.float64(0)  # : bubble point vapour denstiy [kg/m^3]
-            self.dl_dew = np.float64(0)  # : dew point liquid denstiy [kg/m^3]
-            self.hl_bubble = np.float64(0)  # : bubble point liquid specific enthalpy [J/kg]
-            self.hv_dew = np.float64(0)  # : dew point vapour specific enthalpy [J/kg]
-            self.sl_bubble = np.float64(0)  # : bubble point liquid specific entropy [J/(kg*K)]
-            self.sv_dew = np.float64(0)  # : dew point vapour specific entropy [J/(kg*K)]
-            self.xiv_bubble = np.zeros((1, 0), dtype=np.float64)  # : bubble point vapour mass fraction [1]
-            self.xil_dew = np.zeros((1, 0), dtype=np.float64)  # : dew point liquid mass fraction [1]
+            self.T_bubble = np.float64(0)
+            'bubble point temperature [K]'
+            self.T_dew = np.float64(0)
+            'dew point temperature [K]'
+            self.p_bubble = np.float64(0)
+            'bubble point pressure [Pa]'
+            self.p_dew = np.float64(0)
+            'dew point pressure [Pa]'
+            self.dl_bubble = np.float64(0)
+            'bubble point liquid denstiy [kg/m^3]'
+            self.dv_dew = np.float64(0)
+            'dew point vapour denstiy [kg/m^3]'
+            self.dv_bubble = np.float64(0)
+            'bubble point vapour denstiy [kg/m^3]'
+            self.dl_dew = np.float64(0)
+            'dew point liquid denstiy [kg/m^3]'
+            self.hl_bubble = np.float64(0)
+            'bubble point liquid specific enthalpy [J/kg]'
+            self.hv_dew = np.float64(0)
+            'dew point vapour specific enthalpy [J/kg]'
+            self.sl_bubble = np.float64(0)
+            'bubble point liquid specific entropy [J/(kg*K)]'
+            self.sv_dew = np.float64(0)
+            'dew point vapour specific entropy [J/(kg*K)]'
+            self.xiv_bubble = np.zeros((1, 0), dtype=np.float64)
+            'bubble point vapour mass fraction [1]'
+            self.xil_dew = np.zeros((1, 0), dtype=np.float64)
+            'dew point liquid mass fraction [1]'
 
             self._T_bubble_vector = np.zeros(1, dtype=np.float64)
             self._T_dew_vector = np.zeros(1, dtype=np.float64)
             self._p_bubble_vector = np.zeros(1, dtype=np.float64)
             self._p_dew_vector = np.zeros(1, dtype=np.float64)
             self._dl_bubble_vector = np.zeros(1, dtype=np.float64)
             self._dv_dew_vector = np.zeros(1, dtype=np.float64)
@@ -254,50 +354,58 @@
             self._hl_bubble_vector = np.zeros(1, dtype=np.float64)
             self._hv_dew_vector = np.zeros(1, dtype=np.float64)
             self._sl_bubble_vector = np.zeros(1, dtype=np.float64)
             self._sv_dew_vector = np.zeros(1, dtype=np.float64)
             self._xiv_bubble_vector = np.zeros((1, 0), dtype=np.float64)
             self._xil_dew_vector = np.zeros((1, 0), dtype=np.float64)
             # [[[end]]]
+            # fmt: on
 
-            DataContainer.__init__(self, nc, 'xil_dew')
+            DataContainer.__init__(self, nc, "xil_dew")
 
         def resize_properties(self, shape):
             return self._resize_properties(shape)
 
         def __repr__(self):
             return "SaturationProperties()"
 
     class _CriticalProperties(DataContainer):
         """Critical Properties"""
 
         def __init__(self, nc=1):
-            self._property_list = [(n[0] + 'c',) + n[1:] for n in _properties]
-            DataContainer.__init__(self, nc, 'Tc')
+            self._property_list = [(n[0] + "c",) + n[1:] for n in _properties]
+            DataContainer.__init__(self, nc, "Tc")
+            # fmt: off
             #    [[[cog
             # import cog
-            # from TILMedia import VLEFluid
+            # from tilmedia import VLEFluid
             # import numpy as np
-            # from TILMedia.internals import _generate_code
+            # from tilmedia._internals import _generate_code
             # vle = VLEFluid("Refprop.R410A.mix")
             # v = vle.crit._property_list
             # cog.outl("\n".join(_generate_code(v)))
             # ]]]
-            self.dc = np.float64(0)  # : Critical density [kg/m^3]
-            self.hc = np.float64(0)  # : Critical specific enthalpy [J/kg]
-            self.pc = np.float64(0)  # : Critical pressure [Pa]
-            self.sc = np.float64(0)  # : Critical specific entropy [J/(kg*K)]
-            self.Tc = np.float64(0)  # : Critical temperature [K]
+            self.dc = np.float64(0)
+            'Critical density [kg/m^3]'
+            self.hc = np.float64(0)
+            'Critical specific enthalpy [J/kg]'
+            self.pc = np.float64(0)
+            'Critical pressure [Pa]'
+            self.sc = np.float64(0)
+            'Critical specific entropy [J/(kg*K)]'
+            self.Tc = np.float64(0)
+            'Critical temperature [K]'
 
             self._dc_vector = np.zeros(1, dtype=np.float64)
             self._hc_vector = np.zeros(1, dtype=np.float64)
             self._pc_vector = np.zeros(1, dtype=np.float64)
             self._sc_vector = np.zeros(1, dtype=np.float64)
             self._Tc_vector = np.zeros(1, dtype=np.float64)
             # [[[end]]]
+            # fmt: on
 
         def resize_properties(self, shape):
             return self._resize_properties(shape)
 
         def __repr__(self):
             return "CriticalProperties()"
 
@@ -412,15 +520,15 @@
             self.Viscosity_precisionComment = None
             self.Viscosity_Tmin = None
             self.Viscosity_Tmax = None
             self.Viscosity_pmax = None
             self.Viscosity_rhomax = None
 
         def __repr__(self):
-            return 'TILMedia.VLEFluid.Info ' + self.LibraryName + ' ' + self.MediumName
+            return "TILMedia.VLEFluid.Info " + self.LibraryName + " " + self.MediumName
 
         def keys(self):
             return [member for member in self._allowed if getattr(self, member) is not None]
 
         def __len__(self):
             return len(self._allowed)
 
@@ -428,86 +536,112 @@
             if key in self._allowed:
                 return getattr(self, key)
             raise KeyError("Invalid parameter requested")
 
         def __str__(self):
             data = dict(self)
             units = {
-                'MolarMass': ' kg/mol',
-                'IdealPart_Tmin': ' K',
-                'IdealPart_Tmax': ' K',
-                'RealPart_Tmin': ' K',
-                'RealPart_Tmax': ' K',
-                'Viscosity_Tmin': ' K',
-                'Viscosity_Tmax': ' K',
-                'ThermalConductivity_Tmin': ' K',
-                'ThermalConductivity_Tmax': ' K',
-                'TripleTemperature': ' K',
-                'NormalBoilingPoint': ' K',
-                'criticalTemperature': ' K',
-                'criticalPressure': ' Pa',
-                'criticalDensity': ' kg/m^3',
-                'RealPart_pmax': ' Pa',
-                'RealPart_rhomax': ' kg/m^3',
+                "MolarMass": " kg/mol",
+                "IdealPart_Tmin": " K",
+                "IdealPart_Tmax": " K",
+                "RealPart_Tmin": " K",
+                "RealPart_Tmax": " K",
+                "Viscosity_Tmin": " K",
+                "Viscosity_Tmax": " K",
+                "ThermalConductivity_Tmin": " K",
+                "ThermalConductivity_Tmax": " K",
+                "TripleTemperature": " K",
+                "NormalBoilingPoint": " K",
+                "criticalTemperature": " K",
+                "criticalPressure": " Pa",
+                "criticalDensity": " kg/m^3",
+                "RealPart_pmax": " Pa",
+                "RealPart_rhomax": " kg/m^3",
             }
-            return "\n".join([key + ': ' + str(value) + units.get(key, '') for key, value in data.items()])
+            return "\n".join([key + ": " + str(value) + units.get(key, "") for key, value in data.items()])
 
         def dump(self):
             print(self)
 
     _status = 0
     _property_list = []
 
     def __init__(
         self,
         vleFluid_name: str,
-        xi: Optional[Union[np.ndarray, List[float]]] = None,
+        xi: Optional[Union[List[float], np.ndarray]] = None,
         fixed_mixing_ratio=False,
         compute_transport_properties=False,
         compute_vle_transport_properties=False,
         compute_vle_additional_properties=False,
         deactivate_density_derivatives=False,
         deactivate_two_phase_region=False,
-        instance_name='VLEFluid_Python',
-        logger: Optional[logging.Logger] = None
+        instance_name="VLEFluid_Python",
+        logger: Optional[logging.Logger] = None,
     ):
+        global _vle_lock
         self._property_list = _fullProperties + _fullTransportProperties + self._property_list
+        # fmt: off
         #    [[[cog
         # import cog
-        # from TILMedia import VLEFluid
+        # from tilmedia import VLEFluid
         # import numpy as np
-        # from TILMedia.internals import _generate_code
+        # from tilmedia._internals import _generate_code
         # vle = VLEFluid("Refprop.R410A.mix")
         # v = vle._property_list + [("M_i", np.float64, 0, None)]
         # cog.outl("\n".join(_generate_code(v)))
         # ]]]
-        self.p = np.float64(0)  # : Pressure [Pa]
-        self.h = np.float64(0)  # : Specific enthalpy [J/kg]
-        self.d = np.float64(0)  # : Density [kg/m^3]
-        self.s = np.float64(0)  # : Specific entropy [J/(kg*K)]
-        self.T = np.float64(0)  # : Temperature [K]
-        self.xi = np.zeros((1, 0), dtype=np.float64)  # : Water Mass fraction [1]
-        self.x = np.zeros((1, 0), dtype=np.float64)  # : Mole fraction [1]
-        self.M = np.float64(0)  # : Average molar mass [kg/mol]
-        self.phase = np.int32(0)  # : 0=subcooled, 1=two phase, 2=superheated [1]
-        self.q = np.float64(0)  # : Vapor quality (steam mass fraction) [1]
-        self.cp = np.float64(0)  # : Specific isobaric heat capacity cp [J/(kg*K)]
-        self.cv = np.float64(0)  # : Specific isochoric heat capacity cv [J/(kg*K)]
-        self.beta = np.float64(0)  # : Isobaric thermal expansion coefficient [1/K]
-        self.kappa = np.float64(0)  # : Isothermal compressibility [1/Pa]
-        self.w = np.float64(0)  # : Speed of sound [m/s]
-        self.drhodh_pxi = np.float64(0)  # : Derivative of density wrt specific enthalpy at constant pressure and mass fraction [kg^2/(m^3*J)]
-        self.drhodp_hxi = np.float64(0)  # : Derivative of density wrt pressure at specific enthalpy and mass fraction [kg/(N*m)]
-        self.drhodxi_ph = np.zeros((1, 0), dtype=np.float64)  # : Derivative of density wrt mass fraction of water at constant pressure and specific enthalpy [kg/m^3]
-        self.gamma = np.float64(0)  # : Heat capacity ratio aka isentropic expansion factor [1]
-        self.Pr = np.float64(0)  # : Prandtl number [1]
-        self.lamb = np.float64(0)  # : Thermal conductivity [W/(m*K)]
-        self.eta = np.float64(0)  # : Dynamic viscosity [Pa*s]
-        self.sigma = np.float64(0)  # : Surface tension [J/m^2]
-        self.M_i = np.zeros((1, 1), dtype=np.float64)  # : Molar mass of component i [kg/mol]
+        self.p = np.float64(0)
+        'Pressure [Pa]'
+        self.h = np.float64(0)
+        'Specific enthalpy [J/kg]'
+        self.d = np.float64(0)
+        'Density [kg/m^3]'
+        self.s = np.float64(0)
+        'Specific entropy [J/(kg*K)]'
+        self.T = np.float64(0)
+        'Temperature [K]'
+        self.xi = np.zeros((1, 0), dtype=np.float64)
+        'Water Mass fraction [1]'
+        self.x = np.zeros((1, 0), dtype=np.float64)
+        'Mole fraction [1]'
+        self.M = np.float64(0)
+        'Average molar mass [kg/mol]'
+        self.phase = np.int32(0)
+        '0=subcooled, 1=two phase, 2=superheated [1]'
+        self.q = np.float64(0)
+        'Vapor quality (steam mass fraction) [1]'
+        self.cp = np.float64(0)
+        'Specific isobaric heat capacity cp [J/(kg*K)]'
+        self.cv = np.float64(0)
+        'Specific isochoric heat capacity cv [J/(kg*K)]'
+        self.beta = np.float64(0)
+        'Isobaric thermal expansion coefficient [1/K]'
+        self.kappa = np.float64(0)
+        'Isothermal compressibility [1/Pa]'
+        self.w = np.float64(0)
+        'Speed of sound [m/s]'
+        self.drhodh_pxi = np.float64(0)
+        'Derivative of density wrt specific enthalpy at constant pressure and mass fraction [kg^2/(m^3*J)]'
+        self.drhodp_hxi = np.float64(0)
+        'Derivative of density wrt pressure at specific enthalpy and mass fraction [kg/(N*m)]'
+        self.drhodxi_ph = np.zeros((1, 0), dtype=np.float64)
+        'Derivative of density wrt mass fraction of water at constant pressure and specific enthalpy [kg/m^3]'
+        self.gamma = np.float64(0)
+        'Heat capacity ratio aka isentropic expansion factor [1]'
+        self.Pr = np.float64(0)
+        'Prandtl number [1]'
+        self.lamb = np.float64(0)
+        'Thermal conductivity [W/(m*K)]'
+        self.eta = np.float64(0)
+        'Dynamic viscosity [Pa*s]'
+        self.sigma = np.float64(0)
+        'Surface tension [J/m^2]'
+        self.M_i = np.zeros((1, 1), dtype=np.float64)
+        'Molar mass of component i [kg/mol]'
 
         self._p_vector = np.zeros(1, dtype=np.float64)
         self._h_vector = np.zeros(1, dtype=np.float64)
         self._d_vector = np.zeros(1, dtype=np.float64)
         self._s_vector = np.zeros(1, dtype=np.float64)
         self._T_vector = np.zeros(1, dtype=np.float64)
         self._xi_vector = np.zeros((1, 0), dtype=np.float64)
@@ -526,14 +660,15 @@
         self._gamma_vector = np.zeros(1, dtype=np.float64)
         self._Pr_vector = np.zeros(1, dtype=np.float64)
         self._lamb_vector = np.zeros(1, dtype=np.float64)
         self._eta_vector = np.zeros(1, dtype=np.float64)
         self._sigma_vector = np.zeros(1, dtype=np.float64)
         self._M_i_vector = np.zeros((1, 1), dtype=np.float64)
         # [[[end]]]
+        # fmt: on
 
         self._xiFixed_vector = np.zeros((1, 0), dtype=np.float64)
         self._medium = None
         self._medium_wrapper = []
 
         # Library functions
 
@@ -548,88 +683,103 @@
             raise TILMediaErrorInvalidLicense("License not valid")
 
         # prepare error function pointer
         if logger is None:
             logger = internals._logger
         self._exceptions = []
         message_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_message_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_message_logger_function(
+                e, m, logger, x
+            )
         )
         error_function = internals.CPRINTFUNCTION(
-            lambda x, e=self._exceptions, m=self._medium_wrapper:
-            internals.tilmedia_error_logger_function(e, m, logger, x)
+            lambda x, e=self._exceptions, m=self._medium_wrapper: internals.tilmedia_error_logger_function(
+                e, m, logger, x
+            )
         )
 
         # Check if name is valid and calculate number of components
         self.fixed_mixing_ratio = fixed_mixing_ratio
         self._vleFluid_name = vleFluid_name
         self._nc_internal: int = 0
         _xi_autodetect = np.zeros(20, dtype=np.float64)
         c_logger = LoggerWrapper(logger, self._medium_wrapper, message_function, error_function)
         self.__c_logger = c_logger
-        self._status, self._nc_internal = VLEFluid_isValid_getInfo_errorInterface(
-            vleFluid_name,
-            _xi_autodetect,
-            True,
-            c_logger
-        )
+        with _vle_lock as locked:
+            if locked:
+                self._status, self._nc_internal = VLEFluid_isValid_getInfo_errorInterface(
+                    vleFluid_name, _xi_autodetect, True, c_logger
+                )
         if self._status == 0:
-            raise TILMediaErrorInvalidMedium('VLEFluidName "'+vleFluid_name+'" not valid. Could not create TILMedia object.')
-        self._xi_autodetect = np.zeros(self._nc_internal-1)
+            raise TILMediaErrorInvalidMedium(
+                'VLEFluidName "' + vleFluid_name + '" not valid. Could not create TILMedia object.'
+            )
+        self._xi_autodetect = np.zeros(self._nc_internal - 1)
 
         # forwarding information to other classes
         if fixed_mixing_ratio:
             self._nc = 1
         else:
             self._nc = self._nc_internal
-        DataContainer.__init__(self, self._nc, 'drhodxi_ph')
+        DataContainer.__init__(self, self._nc, "drhodxi_ph")
         self.vle = self._VLEProperties(self._nc)
         self.sat = self._SaturationProperties(self._nc)
         self.crit = self._CriticalProperties(self._nc)
 
         # update to new nc
         self._resize_properties((1,))
-        self._make_properties_scalar((1,), {None: [], 'sat': [], 'vle': [], 'crit': []})
+        self._make_properties_scalar((1,), {None: [], "sat": [], "vle": [], "crit": []})
         self.M_i = np.zeros((self._nc), dtype=np.float64)
 
         # evaluate concentration
         if self._nc_internal > 1:
             # it is a mixture
             if fixed_mixing_ratio:
                 if xi is not None:
                     _, self._xiFixed_vector = internals.var_normalize_inputs(0, xi)
                     # xi is given
-                    if self._xiFixed_vector.shape[-1] != self._nc_internal-1:
+                    if self._xiFixed_vector.shape[-1] != self._nc_internal - 1:
                         # but has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("length of xi vector should be {nc} but is {length}".format(nc=self._nc_internal-1, length=self._xiFixed_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xiFixed_vector.shape[-1]
+                            )
+                        )
                 else:
                     # xi is not given
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
-                        raise TILMediaErrorInvalidParameter("xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                        raise TILMediaErrorInvalidParameter(
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
                     _, self._xiFixed_vector = internals.var_normalize_inputs(0, self._xi_autodetect)
             else:
                 # variable concentration
                 if xi is None:
                     if _xi_autodetect[0] < -1e200:
                         # and autodetection failed (should work for e.g. Refprop.R407c.mix)
-                        raise TILMediaErrorInvalidParameter("xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal-1))
+                        raise TILMediaErrorInvalidParameter(
+                            "xi vector with length {nc} expected, but none was given".format(nc=self._nc_internal - 1)
+                        )
                     # and autodetection was successful
-                    for i in range(self._nc_internal-1):
+                    for i in range(self._nc_internal - 1):
                         self._xi_autodetect[i] = _xi_autodetect[i]
                     _, self._xi_vector = internals.var_normalize_inputs(0, self._xi_autodetect)
                 else:
                     _, self._xi_vector = internals.var_normalize_inputs(0, xi)
-                    if self._xi_vector.shape[-1] != self._nc_internal-1:
+                    if self._xi_vector.shape[-1] != self._nc_internal - 1:
                         # but the concentration vector has the wrong length
-                        raise TILMediaErrorIncompatibleVectorLength("Length of xi vector should be {nc} but is {length}".format(nc=self._nc_internal-1, length=self._xi_vector.shape[-1]))
+                        raise TILMediaErrorIncompatibleVectorLength(
+                            "Length of xi vector should be {nc} but is {length}".format(
+                                nc=self._nc_internal - 1, length=self._xi_vector.shape[-1]
+                            )
+                        )
         else:
             if xi is not None:
                 _, xi = internals.var_normalize_inputs(0, xi)
                 internals.check_vector_size(xi, self._nc_internal - 1)
         if xi is None:
             xi = self._xi_autodetect
 
@@ -641,31 +791,29 @@
             flags = flags | 16
         if self._deactivate_two_phase_region:
             flags = flags | 8
         if self.fixed_mixing_ratio:
             _xi_call = self._xiFixed_vector[0]
         else:
             _xi_call = self._xi_vector[0]
-        self._medium = ExternalObject(
-            "VLEFluid",
-            vleFluid_name,
-            flags,
-            _xi_call,
-            self._nc,
-            -1,
-            instance_name,
-            c_logger)
+        with _vle_lock as locked:
+            if locked:
+                self._medium = ExternalObject(
+                    "VLEFluid", vleFluid_name, flags, _xi_call, self._nc, -1, instance_name, c_logger
+                )
         if not self._medium:
             if self._exceptions:
                 exceptions = deepcopy(self._exceptions)
                 while self._exceptions:
                     self._exceptions.pop()
                 raise exceptions[0]
             else:
-                raise TILMediaErrorInvalidMedium('VLEFluidName "'+vleFluid_name+'" not valid. Could not create TILMedia object.')
+                raise TILMediaErrorInvalidMedium(
+                    'VLEFluidName "' + vleFluid_name + '" not valid. Could not create TILMedia object.'
+                )
         self._medium_wrapper.append(self._medium)
         self.xi = self._xi_vector[0]
 
         VLEFluid_Cached_molarMass(self._medium, self.M_i)
         if fixed_mixing_ratio:
             self.set_xi()
         else:
@@ -682,386 +830,606 @@
             raise exceptions[0]
 
     def __del__(self):
         if self._status != 0:
             self._medium = 0
 
     def dump(self):
-        """ Prints the current thermophysical properties of the VLEFluid to stdout. """
+        """Prints the current thermophysical properties of the VLEFluid to stdout."""
         print(self)
 
     def __str__(self):
         value = []
         value += ["Medium: " + self._vleFluid_name]
         value += [DataContainer.__str__(self)]
         value += [str(self.crit)]
         value += [str(self.vle)]
         value += [str(self.sat)]
         return "\n".join([v for v in value if v])
 
     def __repr__(self):
-        return 'TILMedia.VLEFluid "' + self._vleFluid_name + '" (nc = '+str(self._nc)+')'
+        return 'TILMedia.VLEFluid "' + self._vleFluid_name + '" (nc = ' + str(self._nc) + ")"
 
-    def set_pxi(self, p: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_pxi(
+        self, p: Union[float, np.ndarray, List[float]], xi: Optional[Union[List[float], np.ndarray]] = None
+    ) -> None:
         """
         Calculates the saturated properties depending on pressure and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             xi (float, list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, xi = internals.var_normalize_inputs(p, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_criticalDataRecord_xi", self, ['xi'], 'crit', ['dc', 'hc', 'pc', 'sc', 'Tc'])
+        batch_caller.add_call(
+            "TILMedia_VLEFluid_criticalDataRecord_xi", self, ["xi"], "crit", ["dc", "hc", "pc", "sc", "Tc"]
+        )
         if self._nc == 1:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEProperties_phxi", self, ['p', None, 'xi'], 'vle', ['d_l', 'h_l', 'p_l', 's_l', 'T_l', 'xi_l', 'd_v', 'h_v', 'p_v', 's_v', 'T_v', 'xi_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEProperties_phxi",
+                self,
+                ["p", None, "xi"],
+                "vle",
+                ["d_l", "h_l", "p_l", "s_l", "T_l", "xi_l", "d_v", "h_v", "p_v", "s_v", "T_v", "xi_v"],
+            )
             if self._compute_vle_transport_properties:
-                batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_phxi", self, ['p', None, 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+                batch_caller.add_call(
+                    "TILMedia_VLEFluid_VLETransportProperties_phxi",
+                    self,
+                    ["p", None, "xi"],
+                    "vle",
+                    ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+                )
             if self._compute_vle_additional_properties:
-                batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_phxi", self, ['p', None, 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_pxi", self, ['p', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+                batch_caller.add_call(
+                    "TILMedia_VLEFluid_VLEAdditionalProperties_phxi",
+                    self,
+                    ["p", None, "xi"],
+                    "vle",
+                    ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+                )
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_pxi",
+            self,
+            ["p", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         for function_name, arguments in self._batch_function_calls[2]:
             batch_caller.add_call(function_name, *arguments(self))
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, xi=%s.'
-                    % (str(p[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, xi=%s." % (str(p[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_Txi(self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None) -> None:
+    def set_Txi(
+        self, T: Union[float, np.ndarray, List[float]], xi: Optional[Union[List[float], np.ndarray]] = None
+    ) -> None:
         """
         Calculates the saturated properties depending on temperature and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             T (float, list, or numpy.ndarray): temperature [K]
             xi (float, list, or numpy.ndarray): mass fraction [1] (optional)
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         T, xi = internals.var_normalize_inputs(T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = T.shape
         self._resize_properties(shape)
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_criticalDataRecord_xi", self, ['xi'], 'crit', ['dc', 'hc', 'pc', 'sc', 'Tc'])
+        batch_caller.add_call(
+            "TILMedia_VLEFluid_criticalDataRecord_xi", self, ["xi"], "crit", ["dc", "hc", "pc", "sc", "Tc"]
+        )
         if self._nc == 1:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEProperties_dTxi", self, [None, 'T', 'xi'], 'vle', ['d_l', 'h_l', 'p_l', 's_l', 'T_l', 'xi_l', 'd_v', 'h_v', 'p_v', 's_v', 'T_v', 'xi_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEProperties_dTxi",
+                self,
+                [None, "T", "xi"],
+                "vle",
+                ["d_l", "h_l", "p_l", "s_l", "T_l", "xi_l", "d_v", "h_v", "p_v", "s_v", "T_v", "xi_v"],
+            )
             if self._compute_vle_transport_properties:
-                batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_dTxi", self, [None, 'T', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+                batch_caller.add_call(
+                    "TILMedia_VLEFluid_VLETransportProperties_dTxi",
+                    self,
+                    [None, "T", "xi"],
+                    "vle",
+                    ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+                )
             if self._compute_vle_additional_properties:
-                batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_dTxi", self, [None, 'T', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_Txi", self, ['T', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+                batch_caller.add_call(
+                    "TILMedia_VLEFluid_VLEAdditionalProperties_dTxi",
+                    self,
+                    [None, "T", "xi"],
+                    "vle",
+                    ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+                )
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_Txi",
+            self,
+            ["T", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         for function_name, arguments in self._batch_function_calls[2]:
             batch_caller.add_call(function_name, *arguments(self))
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: T=%s, xi=%s.' %
-                                                          (str(failure_index), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: T=%s, xi=%s."
+                    % (str(failure_index), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were T=%s, xi=%s.'
-                    % (str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were T=%s, xi=%s." % (str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_xi(self, xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_xi(self, xi: Optional[Union[List[float], np.ndarray]] = None):
         """
         Calculates critical properties depending on independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
-        xi, = internals.var_normalize_inputs(xi)
+        (xi,) = internals.var_normalize_inputs(xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = xi.shape[:-1]
         self._resize_properties(shape)
         self._xi_vector[:] = xi
 
         self.crit.resize_properties(shape)
         batch_caller = BatchFunctionCaller()
         for function_name, arguments in self._batch_function_calls[1]:
             batch_caller.add_call(function_name, *arguments(self))
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe error was caused by element %s: xi=%s.'
-                    % (str(failure_index), str(xi[failure_index])))
+                    + "\nThe error was caused by element %s: xi=%s." % (str(failure_index), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
-                    self._exceptions[0].message
-                    + '\nThe inputs were xi=%s.'
-                    % (str(xi[failure_index])))
+                    self._exceptions[0].message + "\nThe inputs were xi=%s." % (str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_pTxi(self, p: Union[float, np.ndarray, List[float]], T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_pTxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        T: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, temperature and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             T (float, list, or numpy.ndarray): temperature [K]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, T, xi = internals.var_normalize_inputs(p, T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = T.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_pTxi", self, ['p', 'T', 'xi'], None, ['d', 'h', 's'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_pTxi", self, ["p", "T", "xi"], None, ["d", "h", "s"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_pxi", self, ['p', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_pxi",
+            self,
+            ["p", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_phxi", self, ['p', 'h', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, T=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, T=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, T=%s, xi=%s.'
-                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, T=%s, xi=%s."
+                    % (str(p[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_phxi(self, p: Union[float, np.ndarray, List[float]], h: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_phxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        h: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, specific enthalpy and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             h (float, list, or numpy.ndarray): specific enthalpy [J/kg]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, h, xi = internals.var_normalize_inputs(p, h, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = h.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._h_vector[:] = h
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_phxi", self, ['p', 'h', 'xi'], None, ['d', 's', 'T'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_phxi", self, ["p", "h", "xi"], None, ["d", "s", "T"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_pxi", self, ['p', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_pxi",
+            self,
+            ["p", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_phxi", self, ['p', 'h', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, h=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, h=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, h=%s, xi=%s.'
-                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, h=%s, xi=%s."
+                    % (str(p[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_psxi(self, p: Union[float, np.ndarray, List[float]], s: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_psxi(
+        self,
+        p: Union[float, np.ndarray, List[float]],
+        s: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on pressure, specific entropy and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             s (float, list, or numpy.ndarray): specific entropy [J/(kg*K)]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, s, xi = internals.var_normalize_inputs(p, s, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = s.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._s_vector[:] = s
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_psxi", self, ['p', 's', 'xi'], None, ['d', 'h', 'T'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_psxi", self, ["p", "s", "xi"], None, ["d", "h", "T"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_pxi", self, ['p', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_pxi",
+            self,
+            ["p", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_phxi", self, ['p', 'h', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, s=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, s=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, s=%s, xi=%s.'
-                    % (str(p[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, s=%s, xi=%s."
+                    % (str(p[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_pdxi(self, p, d, xi=None):
         """
@@ -1070,61 +1438,101 @@
         Args:
             p (float, list, or numpy.ndarray): pressure [Pa]
             d (float, list, or numpy.ndarray): density [kg/m3]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         p, d, xi = internals.var_normalize_inputs(p, d, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = p.shape
         self._resize_properties(shape)
         self._p_vector[:] = p
         self._d_vector[:] = d
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_pdxi", self, ['p', 'd', 'xi'], None, ['h', 's', 'T'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_pdxi", self, ["p", "d", "xi"], None, ["h", "s", "T"])
         for function_name, arguments in self._batch_function_calls[3]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_pxi", self, ['p', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_pxi",
+            self,
+            ["p", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_phxi", self, ['p', 'h', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_phxi", self, ['p', 'h', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_phxi",
+                self,
+                ["p", "h", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: p=%s, d=%s, xi=%s.' %
-                                                          (str(failure_index), str(p[failure_index]), str(d[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: p=%s, d=%s, xi=%s."
+                    % (str(failure_index), str(p[failure_index]), str(d[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were p=%s, d=%s, xi=%s.'
-                    % (str(p[failure_index]), str(d[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were p=%s, d=%s, xi=%s."
+                    % (str(p[failure_index]), str(d[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_Thxi(self, T, h, xi=None):
         """
@@ -1133,61 +1541,101 @@
         Args:
             T (float, list, or numpy.ndarray): pressure [K]
             h (float, list, or numpy.ndarray): specific enthalpy [J/kg]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         T, h, xi = internals.var_normalize_inputs(T, h, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = T.shape
         self._resize_properties(shape)
         self._T_vector[:] = T
         self._h_vector[:] = h
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_Thxi", self, ['T', 'h', 'xi'], None, ['d', 'p', 's'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_Thxi", self, ["T", "h", "xi"], None, ["d", "p", "s"])
         for function_name, arguments in self._batch_function_calls[4]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_Txi", self, ['T', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_Txi",
+            self,
+            ["T", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_dTxi", self, ['d', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: T=%s, h=%s, xi=%s.' %
-                                                          (str(failure_index), str(T[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: T=%s, h=%s, xi=%s."
+                    % (str(failure_index), str(T[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were T=%s, h=%s, xi=%s.'
-                    % (str(T[failure_index]), str(h[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were T=%s, h=%s, xi=%s."
+                    % (str(T[failure_index]), str(h[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def set_Tsxi(self, T, s, xi=None):
         """
@@ -1196,177 +1644,262 @@
         Args:
             T (float, list, or numpy.ndarray): pressure [K]
             s (float, list, or numpy.ndarray): specific entropy [J/(kg*K)]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         T, s, xi = internals.var_normalize_inputs(T, s, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = T.shape
         self._resize_properties(shape)
         self._T_vector[:] = T
         self._s_vector[:] = s
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_Tsxi", self, ['T', 's', 'xi'], None, ['d', 'h', 'p'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_Tsxi", self, ["T", "s", "xi"], None, ["d", "h", "p"])
         for function_name, arguments in self._batch_function_calls[4]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_Txi", self, ['T', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_Txi",
+            self,
+            ["T", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_dTxi", self, ['d', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: T=%s, s=%s, xi=%s.' %
-                                                          (str(failure_index), str(T[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: T=%s, s=%s, xi=%s."
+                    % (str(failure_index), str(T[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were T=%s, s=%s, xi=%s.'
-                    % (str(T[failure_index]), str(s[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were T=%s, s=%s, xi=%s."
+                    % (str(T[failure_index]), str(s[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
-    def set_dTxi(self, d: Union[float, np.ndarray, List[float]], T: Union[float, np.ndarray, List[float]], xi: Optional[Union[np.ndarray, List[float]]] = None):
+    def set_dTxi(
+        self,
+        d: Union[float, np.ndarray, List[float]],
+        T: Union[float, np.ndarray, List[float]],
+        xi: Optional[Union[List[float], np.ndarray]] = None,
+    ):
         """
         Calculates all thermophysical properties depending on density, temperature and independent mass fractions (always one less than the number of components in mixtures).
 
         Args:
             d (float, list, or numpy.ndarray): density [kg/m^3]
             T (float, list, or numpy.ndarray): temperature [K]
             xi (list or numpy.ndarray, optional): mass fraction [1]. Defaults to None.
         """
 
         if self.fixed_mixing_ratio and xi is not None:
-            raise TILMediaErrorInvalidParameter('If fixed_mixing_ratio is True, then xi input must not be used')
+            raise TILMediaErrorInvalidParameter("If fixed_mixing_ratio is True, then xi input must not be used")
         if xi is None:
-            xi = self._xi_vector[tuple([0]*(self._xi_vector.ndim-1))]
+            xi = self._xi_vector[tuple([0] * (self._xi_vector.ndim - 1))]
 
         d, T, xi = internals.var_normalize_inputs(d, T, xi)
         internals.check_vector_size(xi, self._nc - 1)
 
         shape = d.shape
         self._resize_properties(shape)
         self._d_vector[:] = d
         self._T_vector[:] = T
         self._xi_vector[:] = xi
 
         batch_caller = BatchFunctionCaller()
-        batch_caller.add_call("TILMedia_VLEFluid_properties_dTxi", self, ['d', 'T', 'xi'], None, ['h', 'p', 's'])
+        batch_caller.add_call("TILMedia_VLEFluid_properties_dTxi", self, ["d", "T", "xi"], None, ["h", "p", "s"])
         for function_name, arguments in self._batch_function_calls[4]:
             batch_caller.add_call(function_name, *arguments(self))
-        batch_caller.add_call("_TILMedia_VLEFluid_saturationProperties_Txi", self, ['T', 'xi'], 'sat', [
-            'dl_bubble', 'dv_bubble', 'xiv_bubble', 'hl_bubble', 'p_bubble', 'sl_bubble', 'T_bubble',
-            'dv_dew', 'dl_dew', 'xil_dew', 'hv_dew', 'p_dew', 'sv_dew', 'T_dew',
-        ])
+        batch_caller.add_call(
+            "_TILMedia_VLEFluid_saturationProperties_Txi",
+            self,
+            ["T", "xi"],
+            "sat",
+            [
+                "dl_bubble",
+                "dv_bubble",
+                "xiv_bubble",
+                "hl_bubble",
+                "p_bubble",
+                "sl_bubble",
+                "T_bubble",
+                "dv_dew",
+                "dl_dew",
+                "xil_dew",
+                "hv_dew",
+                "p_dew",
+                "sv_dew",
+                "T_dew",
+            ],
+        )
         if self._compute_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_transportProperties_dTxi", self, ['d', 'T', 'xi'], None, ['Pr', 'lamb', 'eta', 'sigma'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_transportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                None,
+                ["Pr", "lamb", "eta", "sigma"],
+            )
         if self._compute_vle_transport_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLETransportProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['Pr_l', 'Pr_v', 'lambda_l', 'lambda_v', 'eta_l', 'eta_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLETransportProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["Pr_l", "Pr_v", "lambda_l", "lambda_v", "eta_l", "eta_v"],
+            )
         if self._compute_vle_additional_properties:
-            batch_caller.add_call("TILMedia_VLEFluid_VLEAdditionalProperties_dTxi", self, ['d', 'T', 'xi'], 'vle', ['cp_l', 'beta_l', 'kappa_l', 'cp_v', 'beta_v', 'kappa_v'])
+            batch_caller.add_call(
+                "TILMedia_VLEFluid_VLEAdditionalProperties_dTxi",
+                self,
+                ["d", "T", "xi"],
+                "vle",
+                ["cp_l", "beta_l", "kappa_l", "cp_v", "beta_v", "kappa_v"],
+            )
         calculated_properties = batch_caller.execute(self._medium, np.prod(shape))
 
         self._M_vector[:], self._x_vector[:] = self._molarMass(xi, self.M_i)
-        calculated_properties[None] += ['x', 'M']
+        calculated_properties[None] += ["x", "M"]
 
         self._make_properties_scalar(shape, calculated_properties)
 
         if self._exceptions:
             if len(shape) > 1 or max(shape) > 1:
                 failure_index = np.unravel_index(batch_caller.current_point, shape)
                 if len(failure_index) == 1:
                     failure_index = failure_index[0]
-                exception = self._exceptions[0].__class__(self._exceptions[0].message + '\nThe error was caused by element %s: d=%s, T=%s, xi=%s.' %
-                                                          (str(failure_index), str(d[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                exception = self._exceptions[0].__class__(
+                    self._exceptions[0].message
+                    + "\nThe error was caused by element %s: d=%s, T=%s, xi=%s."
+                    % (str(failure_index), str(d[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             else:
                 failure_index = 0
                 exception = self._exceptions[0].__class__(
                     self._exceptions[0].message
-                    + '\nThe inputs were d=%s, T=%s, xi=%s.'
-                    % (str(d[failure_index]), str(T[failure_index]), str(xi[failure_index])))
+                    + "\nThe inputs were d=%s, T=%s, xi=%s."
+                    % (str(d[failure_index]), str(T[failure_index]), str(xi[failure_index]))
+                )
             while self._exceptions:
                 self._exceptions.pop()
 
             raise exception
 
     def _molarMass(self, xi, M_i):
         shape = xi.shape[:-1]
         M = np.zeros(shape)
         x = np.zeros(xi.shape)
         if isinstance(M_i, list):
             M_i = np.array(M_i)
 
-        mixingRatio = np.concatenate((xi, (np.ones(shape) - np.sum(xi, xi.ndim-1)).reshape(shape + (1,))), xi.ndim-1)
-        M = 1/np.sum(mixingRatio/M_i, xi.ndim-1)
-        x = M.reshape(shape + (1,)) * (xi/M_i[:-1])
+        mixingRatio = np.concatenate(
+            (xi, (np.ones(shape) - np.sum(xi, xi.ndim - 1)).reshape(shape + (1,))), xi.ndim - 1
+        )
+        M = 1 / np.sum(mixingRatio / M_i, xi.ndim - 1)
+        x = M.reshape(shape + (1,)) * (xi / M_i[:-1])
 
         return M, x
 
     def _make_properties_scalar(self, shape, calculated_properties):
         DataContainer._make_properties_scalar(self, shape, calculated_properties[None])
-        self.vle._make_properties_scalar(shape, calculated_properties.get('vle', []))
-        self.sat._make_properties_scalar(shape, calculated_properties.get('sat', []))
-        self.crit._make_properties_scalar(shape, calculated_properties.get('crit', []))
+        self.vle._make_properties_scalar(shape, calculated_properties.get("vle", []))
+        self.sat._make_properties_scalar(shape, calculated_properties.get("sat", []))
+        self.crit._make_properties_scalar(shape, calculated_properties.get("crit", []))
 
     def _resize_properties(self, shape):
         DataContainer._resize_properties(self, shape)
         self.vle.resize_properties(shape)
         self.sat.resize_properties(shape)
         self.crit.resize_properties(shape)
 
     def set(self, **kwargs):
         keys = frozenset(kwargs)
         mapping = {
-            frozenset({'p', 'h'}): self.set_phxi,
-            frozenset({'p', 'h', 'xi'}): self.set_phxi,
-            frozenset({'p', 'T'}): self.set_pTxi,
-            frozenset({'p', 'T', 'xi'}): self.set_pTxi,
-            frozenset({'p', 's'}): self.set_psxi,
-            frozenset({'p', 's', 'xi'}): self.set_psxi,
-            frozenset({'d', 'T'}): self.set_dTxi,
-            frozenset({'d', 'T', 'xi'}): self.set_dTxi,
-            frozenset({'xi'}): self.set_xi,
-            frozenset({'p'}): self.set_pxi,
-            frozenset({'p', 'xi'}): self.set_pxi,
-            frozenset({'T'}): self.set_Txi,
-            frozenset({'T', 'xi'}): self.set_Txi,
-            frozenset({'p', 'd'}): self.set_pdxi,
-            frozenset({'p', 'd', 'xi'}): self.set_pdxi,
-            frozenset({'T', 'h'}): self.set_Thxi,
-            frozenset({'T', 'h', 'xi'}): self.set_Thxi,
-            frozenset({'T', 's'}): self.set_Tsxi,
-            frozenset({'T', 's', 'xi'}): self.set_Tsxi,
+            frozenset({"p", "h"}): self.set_phxi,
+            frozenset({"p", "h", "xi"}): self.set_phxi,
+            frozenset({"p", "T"}): self.set_pTxi,
+            frozenset({"p", "T", "xi"}): self.set_pTxi,
+            frozenset({"p", "s"}): self.set_psxi,
+            frozenset({"p", "s", "xi"}): self.set_psxi,
+            frozenset({"d", "T"}): self.set_dTxi,
+            frozenset({"d", "T", "xi"}): self.set_dTxi,
+            frozenset({"xi"}): self.set_xi,
+            frozenset({"p"}): self.set_pxi,
+            frozenset({"p", "xi"}): self.set_pxi,
+            frozenset({"T"}): self.set_Txi,
+            frozenset({"T", "xi"}): self.set_Txi,
+            frozenset({"p", "d"}): self.set_pdxi,
+            frozenset({"p", "d", "xi"}): self.set_pdxi,
+            frozenset({"T", "h"}): self.set_Thxi,
+            frozenset({"T", "h", "xi"}): self.set_Thxi,
+            frozenset({"T", "s"}): self.set_Tsxi,
+            frozenset({"T", "s", "xi"}): self.set_Tsxi,
         }
         function = mapping.get(keys)
         if function:
             function(**kwargs)
         else:
-            raise TILMediaErrorInvalidParameter(
-                f'Properties cannot be computed from the arguments {keys}'
-            )
+            raise TILMediaErrorInvalidParameter(f"Properties cannot be computed from the arguments {keys}")
```

## Comparing `tilmedia-3.13.0.dist-info/LICENSE.txt` & `tilmedia-3.14.0.dist-info/LICENSE.txt`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-Copyright Â© 2022, TLK Thermo GmbH
+Copyright Â© 2023, TLK Thermo GmbH
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 
 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 
 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
```

## Comparing `tilmedia-3.13.0.dist-info/METADATA` & `tilmedia-3.14.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tilmedia
-Version: 3.13.0
+Version: 3.14.0
 Summary: Substance properties for incompressible liquids, ideal gases, real fluids and mixtures
 Home-page: https://www.tlk-thermo.com/index.php/en/tilmedia-suite
 Author: TLK Thermo GmbH
 Author-email: tilmedia@tlk-thermo.com
 License: BSD
 Keywords: thermophysical thermodynamic fluid properties gas liquid mixtures substances media
 Platform: UNKNOWN
```

## Comparing `tilmedia-3.13.0.dist-info/Third-Party-License.txt` & `tilmedia-3.14.0.dist-info/Third-Party-License.txt`

 * *Files identical despite different names*

