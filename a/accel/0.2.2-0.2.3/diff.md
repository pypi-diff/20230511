# Comparing `tmp/accel-0.2.2-py3-none-any.whl.zip` & `tmp/accel-0.2.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,16 @@
-Zip file size: 62095 bytes, number of entries: 35
--rw-rw-rw-  2.0 fat      199 b- defN 23-Apr-25 06:55 accel/__init__.py
+Zip file size: 64820 bytes, number of entries: 35
+-rw-rw-rw-  2.0 fat      199 b- defN 23-May-10 13:49 accel/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 21-Jul-01 06:20 accel/__main__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 22-Apr-24 06:17 accel/base/__init__.py
--rw-rw-rw-  2.0 fat    14361 b- defN 22-Sep-14 09:56 accel/base/atoms.py
+-rw-rw-rw-  2.0 fat    14485 b- defN 23-May-10 10:31 accel/base/atoms.py
 -rw-rw-rw-  2.0 fat     2514 b- defN 22-Aug-23 04:00 accel/base/box.py
--rw-rw-rw-  2.0 fat    22595 b- defN 23-Feb-01 02:23 accel/base/boxcore.py
+-rw-rw-rw-  2.0 fat    22882 b- defN 23-May-10 09:09 accel/base/boxcore.py
 -rw-rw-rw-  2.0 fat    10265 b- defN 22-Dec-13 04:06 accel/base/formats.py
--rw-rw-rw-  2.0 fat    62554 b- defN 23-Apr-24 14:07 accel/base/modeler.py
+-rw-rw-rw-  2.0 fat    78055 b- defN 23-May-10 10:41 accel/base/modeler.py
 -rw-rw-rw-  2.0 fat      830 b- defN 22-Aug-23 04:00 accel/base/selector.py
 -rw-rw-rw-  2.0 fat    13436 b- defN 23-Feb-05 06:09 accel/base/systems.py
 -rw-rw-rw-  2.0 fat     1290 b- defN 22-Aug-23 04:00 accel/base/tools.py
 -rw-rw-rw-  2.0 fat    17216 b- defN 22-Aug-23 04:00 accel/base/topology.py
 -rw-rw-rw-  2.0 fat      755 b- defN 22-May-11 09:47 accel/plugin/__init__.py
 -rw-rw-rw-  2.0 fat    31834 b- defN 23-Feb-05 05:59 accel/plugin/gaulib.py
 -rw-rw-rw-  2.0 fat    10488 b- defN 23-Feb-05 06:02 accel/plugin/maelib.py
@@ -25,13 +25,13 @@
 -rw-rw-rw-  2.0 fat     1519 b- defN 23-Feb-05 07:21 accel/util/dialogue.py
 -rw-rw-rw-  2.0 fat     7662 b- defN 22-Apr-24 05:35 accel/util/elements.pkl
 -rw-rw-rw-  2.0 fat      546 b- defN 22-Aug-23 04:00 accel/util/execmd.py
 -rw-rw-rw-  2.0 fat      687 b- defN 22-Aug-23 04:00 accel/util/filetype.py
 -rw-rw-rw-  2.0 fat     4073 b- defN 23-Feb-05 07:59 accel/util/log.py
 -rw-rw-rw-  2.0 fat     7508 b- defN 22-Nov-24 03:42 accel/util/logo32.png
 -rw-rw-rw-  2.0 fat     2978 b- defN 22-Aug-23 04:00 accel/util/matrix.py
--rw-rw-rw-  2.0 fat     1059 b- defN 23-Apr-25 06:55 accel-0.2.2.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      515 b- defN 23-Apr-25 06:55 accel-0.2.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-25 06:55 accel-0.2.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 23-Apr-25 06:55 accel-0.2.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2706 b- defN 23-Apr-25 06:55 accel-0.2.2.dist-info/RECORD
-35 files, 237865 bytes uncompressed, 57861 bytes compressed:  75.7%
+-rw-rw-rw-  2.0 fat     1059 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      515 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2706 b- defN 23-May-10 13:49 accel-0.2.3.dist-info/RECORD
+35 files, 253777 bytes uncompressed, 60586 bytes compressed:  76.1%
```

## zipnote {}

```diff
@@ -84,23 +84,23 @@
 
 Filename: accel/util/logo32.png
 Comment: 
 
 Filename: accel/util/matrix.py
 Comment: 
 
-Filename: accel-0.2.2.dist-info/LICENSE
+Filename: accel-0.2.3.dist-info/LICENSE
 Comment: 
 
-Filename: accel-0.2.2.dist-info/METADATA
+Filename: accel-0.2.3.dist-info/METADATA
 Comment: 
 
-Filename: accel-0.2.2.dist-info/WHEEL
+Filename: accel-0.2.3.dist-info/WHEEL
 Comment: 
 
-Filename: accel-0.2.2.dist-info/top_level.txt
+Filename: accel-0.2.3.dist-info/top_level.txt
 Comment: 
 
-Filename: accel-0.2.2.dist-info/RECORD
+Filename: accel-0.2.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## accel/__init__.py

```diff
@@ -1,7 +1,7 @@
-__version__ = "0.2.2"
+__version__ = "0.2.3"
 
 from accel.base.atoms import Atom, Atoms
 from accel.base.box import Box
 from accel.base.systems import System, Systems
 
 __all__ = ["Box", "System", "Atom", "Systems", "Atoms"]
```

## accel/base/atoms.py

```diff
@@ -1,13 +1,14 @@
 import copy
 import math
 from collections.abc import MutableSequence
 from typing import Iterable, Iterator, MutableMapping, Sequence, Set, Tuple
 
 import numpy as np
+
 from accel.util.constants import Elements
 from accel.util.datadict import Data
 from accel.util.log import logger
 
 
 class BondType:
     undefined = -1
@@ -41,28 +42,30 @@
         "_symbol",
         "x",
         "y",
         "z",
         "data",
         "cache",
         "charge",
+        "stereo",
         "parent",
     ]
 
     def __init__(self, symbol: str = None, x: float = 0.0, y: float = 0.0, z: float = 0.0, parent: "Atoms" = None):
         if symbol is None:
             self._symbol: str = ""
         else:
             self._symbol: str = Elements.canonicalize(symbol)
         self.x: float = float(x)
         self.y: float = float(y)
         self.z: float = float(z)
         self.data = Data(self)
         self.cache = {}
         self.charge: int = None
+        self.stereo: set = None
         self.parent: Atoms = parent
 
     def __str__(self):
         if self.parent is None:
             return f"{self.symbol}({self.x}, {self.y}, {self.z})"
         else:
             return f"{self.number}{self.symbol}"
@@ -155,24 +158,26 @@
         n._symbol = self._symbol
         n.x = self.x
         n.y = self.y
         n.z = self.z
         n.data = self.data.duplicate(n)
         n.cache = copy.deepcopy(self.cache)
         n.charge = self.charge
+        n.stereo = self.stereo
         return n
 
     def show(self):
         data_dict = {}
         data_dict["symbol"] = self.symbol
         data_dict["number"] = self.number
         data_dict["x"] = self.x
         data_dict["y"] = self.y
         data_dict["z"] = self.y
         data_dict["charge"] = self.charge
+        data_dict["stereo"] = self.stereo
         data_dict["bonds"] = [str(_a) for _a in self.bonds]
         data_dict["single"] = [str(_a) for _a in self.single]
         data_dict["double"] = [str(_a) for _a in self.double]
         data_dict["triple"] = [str(_a) for _a in self.triple]
         data_dict["aromatic"] = [str(_a) for _a in self.aromatic]
         data_dict["contacts"] = [str(_a) for _a in self.contacts]
         for _key, _val in self.data._data.items():
```

## accel/base/boxcore.py

```diff
@@ -348,14 +348,21 @@
             if aromatize:
                 c.modeler.aromatize()
             else:
                 logger.debug(f"{c.name}: skipped aromatic bonds detection")
         logger.debug(f"done: {str(self)}")
         return self
 
+    def calc_stereo(self, with_num_chirality: bool = True):
+        for c in self.get():
+            logger.debug(f"{c.name}: calculating chirality")
+            c.modeler.calc_stereo(with_num_chirality=with_num_chirality)
+        logger.debug(f"done: {str(self)}")
+        return self
+
     def calc_symm(self, calc_all: bool = True):
         if not calc_all:
             cfs = []
             if len(self.get()) != len(self.get().has_label()):
                 logger.info("Breaking Change: Automatic labeling has been eliminated: version 0.2.0")
             for _confs in self.get().labels.values():
                 cfs.append(_confs.get())
```

## accel/base/modeler.py

```diff
@@ -1,9 +1,10 @@
 import math
 from collections import defaultdict, deque
+from collections.abc import MutableSequence
 from statistics import mean
 from typing import Iterable, Sequence
 
 import numpy as np
 
 from accel.base.atoms import Atom, Atoms, BondType
 from accel.base.tools import float_to_str
@@ -196,14 +197,155 @@
                 for index_b in range(len(a_list)):
                     if index_a >= index_b:
                         continue
                     if _mat[index_a, index_b]:
                         self.atoms.bonds[index_a + 1, index_b + 1] = _tyep
         return self
 
+    def calc_stereo(self, with_num_chirality=True):
+        logger.info("calc_stereo is under developement, might be wrong assignment")
+
+        def set_stereo(a: Atom, stereo: str):
+            logger.debug(f"{a}: {stereo}")
+            a.stereo.add(stereo)
+
+        def get_ez(a: Atom, b: Atom, c: Atom, d: Atom) -> str:
+            vab = np.array(a.xyz) - np.array(b.xyz)
+            vcb = np.array(c.xyz) - np.array(b.xyz)
+            vdc = np.array(d.xyz) - np.array(c.xyz)
+            pvac = np.cross(vab, vcb)
+            pvbd = np.cross(vdc, vcb)
+            angle = np.arccos(np.sum(pvac * pvbd) / (np.linalg.norm(pvac) * np.linalg.norm(pvbd)))
+            if np.sum(pvac * np.cross(pvbd, vcb)) < 0:
+                angle = -angle
+            angle = float(np.rad2deg(angle))
+            if angle > 90 or angle < -90:
+                return "E"
+            return "Z"
+
+        def get_rs(a: Atom, b: Atom, c: Atom, d: Atom) -> str:
+            neighbors_xyz = np.array([atom_.xyz for atom_ in [a, b, c]]) - np.array(d.xyz)
+            if np.linalg.det(neighbors_xyz) > 0:
+                return "S"
+            return "R"
+
+        def det_allene_chirality(a: Atom, b: Atom, c: Atom):
+            if len(b.single) >= 1 or len(b.double) != 2:
+                return None
+            a_singles = a.single
+            c_singles = c.single
+            if len(a_singles) != 2 or len(c_singles) != 2:
+                return None
+            a_subs = Chains.get_ordered_substituents([Chains([(a, a_single)]) for a_single in a_singles])
+            c_subs = Chains.get_ordered_substituents([Chains([(a, c_single)]) for c_single in c_singles])
+            if None in [a_subs, c_subs]:
+                return None
+            chirality = get_rs(*[chain[0][1] for chain in a_subs + c_subs])
+            if chirality is None:
+                return None
+            else:
+                return chirality + "a"
+
+        def det_allene_num_chirality(a: Atom, b: Atom, c: Atom):
+            if len(b.single) >= 1 or len(b.double) != 2:
+                return None
+            a_singles = a.single
+            c_singles = c.single
+            if len(a_singles) != 2 or len(c_singles) != 2:
+                return None
+            ordered_atoms: list[Atom] = sorted(a_singles, key=lambda a: a.number)
+            ordered_atoms.extend(sorted(c_singles, key=lambda a: a.number))
+            chirality = get_rs(*ordered_atoms)
+            if chirality is None:
+                return None
+            else:
+                return "n" + chirality + "a"
+
+        for root_atom in self.atoms:
+            root_atom.stereo = set()
+        for root_atom in self.atoms:
+            root_atom_bonds = root_atom.bonds
+            if len(root_atom_bonds) == 2:
+                db_bond = root_atom.double
+                if len(db_bond) == 2:
+                    allene_chirality = det_allene_chirality(db_bond[0], root_atom, db_bond[1])
+                    if allene_chirality is not None:
+                        set_stereo(db_bond[0], allene_chirality)
+                        set_stereo(root_atom, allene_chirality)
+                        set_stereo(db_bond[1], allene_chirality)
+                if len(db_bond) == 2 and with_num_chirality:
+                    allene_chirality = det_allene_num_chirality(db_bond[0], root_atom, db_bond[1])
+                    if allene_chirality is not None:
+                        set_stereo(db_bond[0], allene_chirality)
+                        set_stereo(root_atom, allene_chirality)
+                        set_stereo(db_bond[1], allene_chirality)
+                if len(db_bond) != 1:
+                    continue
+                if len(root_atom.single) != 1:
+                    continue
+                if len(db_bond[0].single) not in (2, 1):
+                    continue
+                if with_num_chirality:
+                    db_next = sorted(db_bond[0].single, key=lambda a: a.number, reverse=True)[0]
+                    chiral = "n" + get_ez(root_atom.single[0], root_atom, db_bond[0], db_next) + "i"
+                    set_stereo(root_atom, chiral)
+                ba_singles = Chains.get_ordered_substituents([Chains([(db_bond[0], a)]) for a in db_bond[0].single])
+                if ba_singles is None:
+                    continue
+                elif len(ba_singles) in (2, 1):
+                    orderd_atoms = [root_atom.single[0], root_atom, db_bond[0], ba_singles[0][0][1]]
+                    chiral = get_ez(*orderd_atoms) + "i"
+                    set_stereo(root_atom, chiral)
+                else:
+                    logger.error(f"error chiral handling of ez {root_atom}")
+                    root_atom.stereo.add("error")
+            if len(root_atom_bonds) == 3:
+                # aromatic handling
+                db_bond = root_atom.double
+                if len(db_bond) != 1:
+                    continue
+                if len(db_bond[0].single) not in (2, 1):
+                    continue
+                if with_num_chirality:
+                    root_next = sorted(root_atom.single, key=lambda a: a.number, reverse=True)[0]
+                    db_next = sorted(db_bond[0].single, key=lambda a: a.number, reverse=True)[0]
+                    chiral = "n" + get_ez(root_next, root_atom, db_bond[0], db_next)
+                    if len(db_bond[0].single) == 1:
+                        chiral += "i"
+                    set_stereo(root_atom, chiral)
+                ra_singles = Chains.get_ordered_substituents([Chains([(root_atom, a)]) for a in root_atom.single])
+                ba_singles = Chains.get_ordered_substituents([Chains([(db_bond[0], a)]) for a in db_bond[0].single])
+                if None in [ra_singles, ba_singles]:
+                    continue
+                if len(ra_singles) == 2 and len(ba_singles) == 2:
+                    orderd_atoms = [ra_singles[0][0][1], root_atom, db_bond[0], ba_singles[0][0][1]]
+                    chiral = get_ez(*orderd_atoms)
+                    set_stereo(root_atom, chiral)
+                elif len(ra_singles) == 2 and len(ba_singles) == 1:
+                    orderd_atoms = [ra_singles[0][0][1], root_atom, db_bond[0], ba_singles[0][0][1]]
+                    chiral = get_ez(*orderd_atoms) + "i"
+                    set_stereo(root_atom, chiral)
+                else:
+                    logger.error(f"error chiral handling of ez {root_atom}")
+                    root_atom.stereo.add("error")
+            if len(root_atom_bonds) == 4:
+                if with_num_chirality:
+                    chiral = "n" + get_rs(*sorted(root_atom_bonds, key=lambda a: a.number, reverse=True))
+                    set_stereo(root_atom, chiral)
+                ordered_subs = Chains.get_ordered_substituents([Chains([(root_atom, a)]) for a in root_atom_bonds])
+                if ordered_subs is None:
+                    continue
+                if len(ordered_subs) == 4:
+                    orderd_atoms: list[Atom] = [sub[0][1] for sub in ordered_subs]
+                    chiral = get_rs(*orderd_atoms)
+                    set_stereo(root_atom, chiral)
+                else:
+                    logger.error(f"error chiral handling of rs {root_atom}")
+                    root_atom.stereo.add("error")
+
     def merge(self, atoms: Atoms):
         p_len = len(self.atoms)
         for a in atoms:
             self.atoms.append(a)
         for b_ft, b_val in atoms.bonds.to_dict().items():
             self.atoms.bonds[b_ft[0] + p_len, b_ft[1] + p_len] = b_val
         logger.debug(f"merged {len(atoms)} atoms")
@@ -597,15 +739,14 @@
 def _get_maps(
     atoms_a: "Atoms",
     atoms_b: "Atoms",
     known_pairs: list[tuple[int]] = [],
     exclude_known: bool = False,
     terminal_first: bool = False,
 ) -> list[list[tuple[Atom]]]:
-
     if len(known_pairs) == 0:
         known_check = False
         given_known_as = []
         given_known_bs = []
     else:
         known_check = True
         given_known_as = [atoms_a.get(pr[0]) for pr in known_pairs]
@@ -1355,11 +1496,216 @@
         np.identity(xyz_length),
         np_ref_xyzs,
         np_tar_xyzs,
     )
     return min_rmsd
 
 
-def _order_by_cip(substitutions: list[Atom], roots: list[Atom]):
-    for sub in substitutions:
+def _is_heavy(atom_heavy: Atom, atom_light: Atom):
+    heavy_idx = Elements.symbols.index(atom_heavy.symbol)
+    light_idx = Elements.symbols.index(atom_light.symbol)
+    if heavy_idx > light_idx:
+        return True
+    elif heavy_idx < light_idx:
+        return False
+    return None
+
+
+class Chains(MutableSequence):
+    def __init__(self, chains: list[tuple[Atom]] = []) -> None:
+        self._chains: list[tuple[Atom]] = chains[:]
+
+    def __getitem__(self, idx: int) -> tuple[Atom]:
+        return self._chains[idx]
+
+    def __setitem__(self, idx: int, chain: tuple[Atom]):
+        self._chains[idx] = chain
+
+    def __delitem__(self, idx: int):
+        del self._chains[idx]
+
+    def __len__(self):
+        return len(self._chains)
+
+    def insert(self, idx: int, chain: tuple[Atom]):
+        self._chains.insert(idx, chain)
+
+    def __add__(self, other: "Chains"):
+        if not isinstance(other, Chains):
+            raise TypeError
+        return Chains(self._chains + other._chains)
+
+    def __iter__(self):
+        return self._chains.__iter__()
+
+    @staticmethod
+    def is_same_substituent(chain_a: tuple[Atom], chain_b: tuple[Atom]):
+        return (chain_a[0] is chain_b[0]) and (chain_a[1] is chain_b[1])
+
+    @staticmethod
+    def is_higher(chain_high: tuple[Atom], chain_low: tuple[Atom]):
+        zipped = list(zip(chain_high, chain_low))
+        for ha, la in zipped:
+            is_heavy = _is_heavy(ha, la)
+            if is_heavy is None:
+                continue
+            if is_heavy:
+                return True
+            else:
+                return False
+        if len(chain_high) > len(chain_low):
+            return True
+        elif len(chain_high) < len(chain_low):
+            return False
+        symb_dict_high: dict[str, float] = defaultdict(float)
+        symb_dict_low: dict[str, float] = defaultdict(float)
+        for chain, symb_dict in [(chain_high, symb_dict_high), (chain_low, symb_dict_low)]:
+            for a in chain[-1].single:
+                symb_dict[a.symbol] += 1
+            for a in chain[-1].double:
+                symb_dict[a.symbol] += 2
+            for a in chain[-1].triple:
+                symb_dict[a.symbol] += 3
+            for a in chain[-1].aromatic:
+                symb_dict[a.symbol] += 1.5
+            if len(chain) >= 2:
+                symb_dict[chain[-2].symbol] -= 1
+        symbidx_dict_high: dict[int, float] = {Elements.symbols.index(s): v for s, v in dict(symb_dict_high).items()}
+        symbidx_dict_low: dict[int, float] = {Elements.symbols.index(s): v for s, v in dict(symb_dict_low).items()}
+        symbidxs: list[int] = sorted(list(set(symbidx_dict_high.keys()) | set(symbidx_dict_low.keys())), reverse=True)
+        for idx in symbidxs:
+            order_high = symbidx_dict_high.get(idx, 0)
+            order_low = symbidx_dict_low.get(idx, 0)
+            if order_high > order_low:
+                return True
+            elif order_high < order_low:
+                return False
+        return None
+
+    @property
+    def max_distance(self):
+        return max([len(chain) - 1 for chain in self._chains])
+
+    def elongated(self, accept_loop: bool = False) -> "Chains":
+        new_chains = Chains()
+        for chain in self._chains:
+            for a in chain[-1].bonds:
+                if a is chain[-2]:
+                    continue
+                if not accept_loop:
+                    if a in chain:
+                        continue
+                new_chains.append(chain + (a,))
+        return new_chains
+
+    def expanded(self, accept_loop=False, max_elongation=128) -> "Chains":
+        new_chains = Chains(self._chains)
+        for _ in range(max_elongation):
+            terminal_chains = self.elongated(accept_loop=accept_loop)
+            if len(terminal_chains) == 0:
+                break
+            new_chains.extend(terminal_chains)
+        return new_chains
+
+    def longest(self) -> "Chains":
+        max_len = self.max_distance() + 1
+        return Chains([chain for chain in self._chains if len(chain) == max_len])
+
+    def heavily_terminated(self) -> "Chains":
+        symbs = set([chain[-1].symbol for chain in self._chains])
+        max_symbol = Elements.canonicalize(max([Elements.symbols.index(s) for s in symbs]))
+        return Chains([chain for chain in self._chains if chain[-1].symbol == max_symbol])
+
+    @property
+    def terminals(self) -> list[Atom]:
+        return [chain[-1] for chain in self._chains]
+
+    @property
+    def terminal_neighbors(self) -> list[list[Atom]]:
+        return [chain[-1].bonds for chain in self._chains]
+
+    @property
+    def length_of_substituent(self) -> int:
         pass
-    return []
+
+    def sort(self):
+        for i in range(1, len(self._chains)):
+            for j in range(0, len(self._chains) - i):
+                if Chains.is_higher(self._chains[j], self._chains[j + 1]) is False:
+                    self._chains[j], self._chains[j + 1] = self._chains[j + 1], self._chains[j]
+
+    @staticmethod
+    def get_ordered_substituents(initial_chains_list: list["Chains"]) -> list["Chains"]:
+        sorted_chains_list: list[Chains] = []
+        if len(initial_chains_list) == 0:
+            return sorted_chains_list
+        if len(initial_chains_list) == 1:
+            sorted_chains_list.append(initial_chains_list[0])
+            return sorted_chains_list
+        max_distance = max([chains.max_distance for chains in initial_chains_list])
+        if max_distance > 64:
+            logger.error("exceeded max recursive iteration")
+            return None
+
+        t_chains_list = [Chains(initial_chains._chains[:]) for initial_chains in initial_chains_list]
+        for t_chains in t_chains_list:
+            t_chains.sort()
+        for _ in range(len(t_chains_list)):
+            if len(t_chains_list) in [0, 1]:
+                break
+            higher_chains = [t_chains[0] for t_chains in t_chains_list]
+            max_chains = [higher_chains[0]]
+            for chain in higher_chains[1:]:
+                for mxchain in max_chains[:]:
+                    flag = Chains.is_higher(chain, mxchain)
+                    if flag is True:
+                        max_chains = [chain]
+                        break
+                    elif flag is None:
+                        max_chains.append(chain)
+            if len(max_chains) == 1:
+                sorted_chains_list.extend(
+                    [chains for chains in initial_chains_list if chains[0][1] == max_chains[0][1]]
+                )
+                for t_chains in t_chains_list[:]:
+                    if t_chains[0][1] == max_chains[0][1]:
+                        t_chains_list.remove(t_chains)
+            elif len(max_chains) >= 2:
+                pass
+            else:
+                break
+            for max_chain in max_chains:
+                for t_chains in t_chains_list:
+                    if max_chain in t_chains._chains:
+                        t_chains._chains.remove(max_chain)
+            t_chains_list = [t_chains for t_chains in t_chains_list if len(t_chains) != 0]
+
+        next_chains_list: list[Chains] = []
+        elongated_flag = False
+        for chains in initial_chains_list:
+            for sorted_chains in sorted_chains_list:
+                if chains[0][1] == sorted_chains[0][1]:
+                    break
+            else:
+                elongated_chains = chains.elongated()
+                for chain in chains:
+                    if chain in elongated_chains:
+                        elongated_chains.remove(chain)
+                if len(elongated_chains) != 0:
+                    elongated_flag = True
+                    next_chains_list.append(chains + elongated_chains)
+                else:
+                    next_chains_list.append(chains)
+        if len(next_chains_list) == 1:
+            sorted_chains_list.extend(next_chains_list)
+            return sorted_chains_list
+        if len(next_chains_list) == 0 or elongated_flag is False:
+            return None
+        ordered_chains_list = Chains.get_ordered_substituents(next_chains_list)
+        if ordered_chains_list is None:
+            return None
+        for chains in ordered_chains_list:
+            for initial_chains in initial_chains_list:
+                if chains[0][1] == initial_chains[0][1]:
+                    sorted_chains_list.append(initial_chains)
+                    break
+        return sorted_chains_list
```

## Comparing `accel-0.2.2.dist-info/LICENSE` & `accel-0.2.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `accel-0.2.2.dist-info/RECORD` & `accel-0.2.3.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-accel/__init__.py,sha256=Vn_QNfk2fY06KKAU_THqfARle2grfesNpTRb0eB705g,199
+accel/__init__.py,sha256=uz_XgERy2lWGCYMVxsG65BlCCi63ZAM8fHBOd2OwcjA,199
 accel/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 accel/base/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-accel/base/atoms.py,sha256=x9l25TMqLlpOf4Nhjjt6580CfqiOw1JTjd71Y3pmxbI,14361
+accel/base/atoms.py,sha256=IuFFP7l7n8_FVDUI4Fx9mdsJHAXoVB9Aa_X-WwEQP0w,14485
 accel/base/box.py,sha256=5pka1-hA7-SeIG9HUI07V-xRFCWESShdcnziElCrv_E,2514
-accel/base/boxcore.py,sha256=tm5XwgY4xh966UOI2meelPzlnl0UmXgsc4cyWn6z_vk,22595
+accel/base/boxcore.py,sha256=b8Y9TNF4UWWFVtMDa3jxnp0J4KBGGK-YhprUTFYTjyE,22882
 accel/base/formats.py,sha256=xCzSv5_jRxCAoZYQLmXZDYKk-MajT4EQW_rkEK_ywE0,10265
-accel/base/modeler.py,sha256=RwTbHMGFR6Mr-hEk-kTBALXDeK_4a9uS-zzw6HXm46I,62554
+accel/base/modeler.py,sha256=jztsRl4mfGoQ4Xa2bsQhgDSLu7RJvTHUBXrzHVmhy3g,78055
 accel/base/selector.py,sha256=BZERAbMyb1KoqfBW1c1EC4WTBsKgsfFGQnEh105oQKg,830
 accel/base/systems.py,sha256=08px0f8bFeMwnpf9tOS6P7gYBecjToqmZNNFtMGPfus,13436
 accel/base/tools.py,sha256=O40JDiua5a0RzBBEl13BN_QvfJ_WdhDcuQsz96PLUV8,1290
 accel/base/topology.py,sha256=BNgDRvmcsZorU2l08eqq9tfd7yyMvvaeAyr-M_V9FHA,17216
 accel/plugin/__init__.py,sha256=vIESlj9VGQnUMOVXn6UZHBfGKz54JtsDgJoLUeWMP6M,755
 accel/plugin/gaulib.py,sha256=NRf41yAweIgZd4Rj1qmoOReR_YDrk96OuniqQKy7-qs,31834
 accel/plugin/maelib.py,sha256=wS2AvjW0rMZTquxlB8sdLODjg9-KSMFLf9dS3hOgT4I,10488
@@ -24,12 +24,12 @@
 accel/util/dialogue.py,sha256=-s65zXRnEOohyH7N1ZEhDG9Z9p8e1b_Inog_oPkiK4s,1519
 accel/util/elements.pkl,sha256=JsxWQoKC4IovYUqReMqkHIuU9ykIiWK_Jl7Lgl1lDOg,7662
 accel/util/execmd.py,sha256=kyqgnB2etvU7de3gXlWKmv7H-_GIVRih-Jkl50jK1-o,546
 accel/util/filetype.py,sha256=JKpyowreNB3_lch7fJVBTDwJnHt7XC2LTPpAykZwW-o,687
 accel/util/log.py,sha256=N0eJUOkKU1TiZWAFC9BTEbh7AqPbBTsD08Tufu-l_6M,4073
 accel/util/logo32.png,sha256=fX2pmSs70rTbXTuGlTvy6hqSHjZ4VejSxtZ7F2o6_Wk,7508
 accel/util/matrix.py,sha256=ln-YsbzuTBrGJh4R3YZekFDEV__pcZYyLc9enD0g3dY,2978
-accel-0.2.2.dist-info/LICENSE,sha256=6kVvPMd5fpiLN44G42XCWHb0Q_nDhLOMW1K4py7EY1I,1059
-accel-0.2.2.dist-info/METADATA,sha256=rJEitfmCt2lCoyu068CgxkobHpoZ8ljAqs_S6PytVRI,515
-accel-0.2.2.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-accel-0.2.2.dist-info/top_level.txt,sha256=rvhggDW-aRtU4KyyeMQ0SKa754UarbjRb4izBDCNj6g,6
-accel-0.2.2.dist-info/RECORD,,
+accel-0.2.3.dist-info/LICENSE,sha256=6kVvPMd5fpiLN44G42XCWHb0Q_nDhLOMW1K4py7EY1I,1059
+accel-0.2.3.dist-info/METADATA,sha256=-tkIrXM3z1ciSCVddxGdgSneZZ8juIZ22HXXVXkQV8o,515
+accel-0.2.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+accel-0.2.3.dist-info/top_level.txt,sha256=rvhggDW-aRtU4KyyeMQ0SKa754UarbjRb4izBDCNj6g,6
+accel-0.2.3.dist-info/RECORD,,
```

